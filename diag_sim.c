/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(int a1);
void __cdecl sub_10001550(int a1, int a2, char *a3, size_t a4, int a5);
const char *__cdecl sub_100017A0(const char *a1);
int __cdecl sub_10001840(int a1, int a2);
char __cdecl sub_10001870(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_10001A10(int a1);
bool __cdecl sub_10001AE0(int a1, int a2);
char __cdecl sub_10001B10(int a1, int a2);
int __cdecl sub_10001DA0(int a1, int a2);
// int unknown_libname_1(void); weak
int sub_10001E90();
void sub_10001F40();
int __cdecl sub_100022A0(int a1, int a2);
int __cdecl sub_10002450(int a1, int a2);
int __cdecl sub_10002480(int a1);
void sub_100024D0();
int __cdecl sub_100024F0(int a1, int a2, int a3, int a4);
char __cdecl sub_100025A0(int a1, int a2, __int16 a3);
char __cdecl sub_100025D0(int a1, int a2, __int16 a3);
char __cdecl sub_10002600(int a1, int a2, int a3);
char __cdecl sub_10002670(int a1, int a2, int a3);
int sub_100026E0();
_DWORD *__cdecl sub_10002700(int a1);
int __cdecl sub_10002720(int a1, int a2, int a3);
int __cdecl sub_100027A0(int a1);
int __cdecl sub_100027E0(unsigned int a1);
char __cdecl sub_100028A0(unsigned int a1);
char __cdecl sub_10002DA0(int a1);
int __cdecl sub_10002EE0(int a1, int a2);
char __cdecl sub_100031D0(int a1, int a2);
unsigned int *__cdecl sub_10003300(int a1, int a2);
char __cdecl sub_100033E0(int a1);
int __cdecl sub_10003420(int a1, int a2);
char __cdecl sub_10003450(int a1, unsigned int a2);
char __cdecl sub_100034B0(int a1);
int __cdecl sub_100034E0(int a1, int a2);
int __cdecl sub_100035A0(int a1, __int16 a2, __int16 a3);
int sub_100035D0();
char __cdecl sub_10003600(int a1);
void *__cdecl sub_100037E0(int a1, unsigned int a2);
bool __cdecl sub_10003A30(unsigned int a1, char a2);
bool __cdecl sub_10003B90(unsigned int a1, char a2);
char __cdecl sub_10003D00(unsigned __int8 a1);
__int16 __cdecl sub_10003D20(unsigned __int8 a1);
char __cdecl sub_10003D40(int (__cdecl *a1)(int));
char __cdecl sub_10003D90(int (__cdecl *a1)(int));
char *__cdecl sub_10003DC0(int a1, __int16 *a2, _BYTE *a3);
char __cdecl sub_10003E90(unsigned int a1);
char __thiscall sub_10004090(void *this);
void sub_100040D0();
_WORD *__cdecl sub_100040E0(int a1);
void __cdecl sub_10004180(int a1);
void __cdecl sub_100042B0(int a1);
void __cdecl sub_10004310(int a1);
int __cdecl sub_10004650(int a1);
bool __cdecl sub_10004690(int a1);
char __cdecl sub_10004720(int a1);
char __cdecl sub_10004780(int a1);
int __cdecl sub_100047B0(int a1);
int __cdecl sub_100047D0(int a1);
void __cdecl sub_100048C0(unsigned int a1);
int __cdecl sub_100049D0(int a1);
void __cdecl sub_10004A50(unsigned int a1);
__int16 __cdecl sub_10004DF0(int a1, _WORD *a2, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, __int16 a7, _WORD *a8, unsigned __int8 *a9, char a10, char a11);
int __cdecl sub_10004EF0(int a1);
_WORD *__cdecl sub_10005010(int a1, int a2, int a3, _WORD *a4, _WORD *a5, _WORD *a6, _BYTE *a7, unsigned __int8 a8, char a9);
int __cdecl sub_100051F0(int a1);
int __cdecl sub_10005300(int a1, int a2, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, char a10);
int __cdecl sub_10005590(int a1, int a2, unsigned __int16 a3, unsigned __int16 a4, __int16 a5);
int __cdecl sub_10005660(int a1, char *a2, __int16 a3);
char __cdecl sub_10005700(int a1, int a2, unsigned __int16 a3);
void __cdecl sub_10005830(unsigned int a1);
void __cdecl sub_10005A20(unsigned int a1);
int __cdecl sub_10005B60(int a1);
void __cdecl sub_10005BE0(unsigned int a1);
void __cdecl sub_10005D70(unsigned int a1);
__int16 __cdecl sub_100060C0(int a1, _WORD *a2, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, __int16 a7, _WORD *a8, unsigned __int8 *a9, char a10, char a11, int a12, int a13);
int __cdecl sub_100061F0(int a1);
_WORD *__cdecl sub_10006350(int a1, int a2, int a3, _WORD *a4, _WORD *a5, _WORD *a6, _BYTE *a7, unsigned __int8 a8, char a9);
int __cdecl sub_10006560(int a1);
int __cdecl sub_100066D0(int a1, int a2, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, char a10);
int __cdecl sub_100068D0(int a1, int a2, unsigned __int16 a3);
bool __cdecl sub_10006940(int a1, int a2, unsigned __int16 a3);
void sub_100069C0();
void sub_10006A30();
int sub_10006A40();
bool sub_10006A60();
int __cdecl sub_10006B00(int a1, int a2, int a3);
void __cdecl sub_10006BC0(int a1);
char *sub_10006BE0();
int __cdecl sub_10006C30(int a1);
int __cdecl sub_10006CA0(int a1);
int __cdecl sub_100071C0(void *, int); // idb
int __cdecl sub_10007270(int a1, int a2, _WORD *a3, unsigned __int8 a4);
char __cdecl sub_100074B0(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_100074D0(int a1, _WORD *a2);
int __cdecl sub_10007560(int a1, int a2);
char __cdecl sub_100075B0(int a1, int a2, int a3);
__int16 __cdecl sub_100076F0(int a1, void *a2);
signed int __cdecl sub_100078A0(int *a1, int a2);
int __cdecl sub_10007930(int a1, int a2, int a3);
int __cdecl sub_10007AD0(int a1, int a2);
_DWORD *__cdecl sub_10007D30(_DWORD *a1, int a2);
__int16 __cdecl sub_10007DB0(int a1, int a2);
int __cdecl sub_10007ED0(int a1);
signed int __cdecl sub_10007F40(int a1, int a2);
signed int __cdecl sub_10008F80(int a1, int a2);
signed int __cdecl sub_10009080(int a1, int a2);
int __cdecl sub_100096A0(int a1);
unsigned int __cdecl sub_10009720(int a1);
int __cdecl sub_10009770(int a1);
void *__cdecl sub_10009860(int a1, int a2, int a3);
char __cdecl sub_10009940(int a1, int a2);
int __cdecl sub_100099A0(signed int a1, int a2);
char __cdecl sub_10009A20(int a1);
char __cdecl sub_10009A80(int a1, int a2, signed int a3);
int sub_10009D20();
signed int __cdecl sub_10009D40(int a1, int a2);
int *__cdecl sub_10009DE0(int a1, unsigned int a2);
unsigned int __cdecl sub_10009E30(int a1, char *a2, char a3);
signed int __cdecl sub_10009FB0(int a1, unsigned int a2, void *a3, int a4);
int *__cdecl sub_10009FE0(int a1, unsigned int a2);
int __cdecl sub_1000A000(int a1, unsigned int a2);
void *__cdecl sub_1000A020(int a1, void *a2, unsigned int a3);
int __cdecl sub_1000A040(int, char *, va_list); // idb
char sub_1000A090();
// int unknown_libname_2(void); weak
char __cdecl sub_1000A0C0(char a1);
unsigned int sub_1000A0E0();
int __cdecl sub_1000A110(int a1, int a2, char a3);
void *sub_1000A1A0();
int __cdecl sub_1000A1F0(int a1, int a2, char a3);
signed int __cdecl sub_1000A260(int a1);
int __cdecl sub_1000A2B0(int a1, unsigned int a2, unsigned int a3, unsigned int a4);
char __cdecl sub_1000A4A0(int a1, void *a2);
int __cdecl sub_1000A4F0(int a1);
unsigned int sub_1000A720();
int sub_1000A770();
BOOL sub_1000A780();
char __cdecl sub_1000A7A0(_QWORD *a1);
// int unknown_libname_3(void); weak
signed int __cdecl sub_1000A810(int a1, unsigned int a2);
int sub_1000A830();
signed int __cdecl sub_1000A850(int a1, unsigned int a2);
int __cdecl sub_1000A8A0(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_1000A930(int a1, int a2, int a3, signed int *a4, _DWORD *a5);
int __cdecl sub_1000AAE0(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000AC90(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000ADA0(int a1, int a2, int a3, int a4, _DWORD *a5);
signed int __cdecl sub_1000AEF0(const char *a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_1000B040(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_1000B100(int a1, int a2, int a3, signed int *a4, int *a5);
signed int __cdecl sub_1000B1C0(int a1, int a2, int a3, int a4, int *a5);
signed int __cdecl sub_1000B530(int a1, int a2, int a3, int a4, _DWORD *a5);
signed int __cdecl sub_1000B600(int a1, int a2, int a3, int a4, _DWORD *a5);
signed int __cdecl sub_1000B630(int a1, int a2, int a3, signed int *a4, _DWORD *a5);
int __cdecl sub_1000B6C0(int a1, int a2, int a3, int a4, int *a5);
signed int __cdecl sub_1000B7C0(int a1, int a2, _DWORD *a3, int a4);
int __cdecl sub_1000C3A0(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_1000C460(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000C540(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000C620(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_1000C6F0(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_1000C7B0(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000C890(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000C9A0(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000CAE0(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000CBF0(int a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_1000CD30(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_1000CDC0(int a1, int a2, int a3, int a4, int a5);
signed int __cdecl sub_1000CDF0(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_1000CF80(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1000D040(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1000D100(int a1, int a2, int a3, signed int *a4, _DWORD *a5);
int __cdecl sub_1000D1C0(int a1);
char __cdecl sub_1000D1E0(unsigned int a1);
char __cdecl sub_1000D5C0(int a1);
void sub_1000D680();
// bool __cdecl std::uncaught_exception(); idb
void __cdecl sub_1000D6A0(unsigned int a1);
char __cdecl sub_1000D6F0(int a1);
void __cdecl sub_1000D760(int a1, char a2);
int __cdecl sub_1000D7B0(int a1);
void sub_1000D7E0();
void __cdecl sub_1000D800(unsigned int a1);
// int unknown_libname_4(void); weak
char __cdecl sub_1000D830(int a1);
int __cdecl sub_1000DAE0(int a1);
int __cdecl sub_1000DC30(int a1, unsigned __int8 a2);
int __cdecl sub_1000DC50(int a1, unsigned __int8 a2);
bool __cdecl sub_1000DDE0(int a1, char a2);
char __cdecl sub_1000DE50(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1000DF10(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_1000DF40(int a1, int a2, unsigned __int8 a3);
char __cdecl sub_1000E030(int a1, unsigned __int8 a2);
void sub_1000E110();
void sub_1000E120();
void sub_1000E130();
int sub_1000E1A0();
int __thiscall sub_1000E270(void *this);
int sub_1000E320();
signed int __cdecl sub_1000E520(int a1, int a2, int a3, int a4);
signed int __cdecl sub_1000E5E0(int a1, int a2, unsigned int a3, int a4);
int __cdecl sub_1000E6F0(FILE *, int, int, int, int); // idb
int sub_1000E760();
unsigned int __cdecl sub_1000E790(int a1, char *a2, int a3);
unsigned int __cdecl sub_1000E810(int a1, int a2, unsigned int *a3, unsigned int a4);
unsigned int __cdecl sub_1000EA00(int a1, int a2, int a3, unsigned int a4);
unsigned int sub_1000EAA0(int arg0, int arg4, char *arg8, ...);
int __fastcall sub_1000EB10(void *a1);
signed int sub_1000EBA0();
int __cdecl sub_1000EC50(int a1);
int __cdecl sub_1000EC80(int, void *); // idb
int __cdecl sub_1000ECC0(int a1);
int __cdecl sub_1000ECF0(int, void *); // idb
int __cdecl sub_1000ED30(int a1);
int __cdecl sub_1000ED60(int, void *); // idb
int __cdecl sub_1000EDA0(int a1);
int __cdecl sub_1000EDD0(int a1, int a2, int a3);
int __cdecl sub_1000EE70(int a1, int a2, int a3);
signed int __cdecl sub_1000EEE0(int a1, int a2, signed int a3, int *a4);
// signed int __usercall sub_1000EFA0@<eax>(char a1@<bpl>, int a2, int a3, signed int a4, signed int *a5);
int __cdecl sub_1000F180(int a1);
int __cdecl sub_1000F1B0(int, void *); // idb
__int32 __cdecl sub_1000F1F0(char *a1);
int __cdecl sub_1000F220(int a1, int a2);
int __cdecl sub_1000F2A0(int a1);
int __cdecl sub_1000F2D0(int, void *); // idb
int __cdecl sub_1000F310(int a1);
int __cdecl sub_1000F340(int, void *); // idb
int __cdecl sub_1000F380(int a1);
int __cdecl sub_1000F3B0(int, void *); // idb
int __cdecl sub_1000F3F0(int a1);
int __cdecl sub_1000F420(int, void *, int); // idb
int __cdecl sub_1000F480(int a1);
char *__cdecl sub_1000F4A0(int a1, int a2, int a3);
signed int __cdecl sub_1000F500(int a1, int a2, signed int a3, _DWORD *a4);
// signed int __usercall sub_1000F5D0@<eax>(char a1@<dil>, int a2, int a3, signed int a4, signed int *a5);
int __cdecl nullsub_8(_DWORD); // weak
int __fastcall sub_1000F8A0(int a1, int a2);
// unsigned int __usercall sub_1000F8D0@<eax>(const char *a1@<eax>);
void __cdecl sub_1000F8F0(int a1, char a2);
int __cdecl sub_1000FA20(int a1, int a2);
int __cdecl sub_1000FA50(int a1, int a2);
signed int __cdecl sub_1000FAD0(int a1, int a2);
int __cdecl sub_1000FB20(int a1, char *a2, int a3);
int __cdecl sub_1000FB90(int a1);
void __cdecl sub_1000FBA0(int a1, int a2);
int __cdecl sub_1000FC70(int a1);
int __cdecl sub_1000FD30(int a1);
// signed int __usercall sub_1000FF40@<eax>(int a1@<edi>, char *a2);
signed int __cdecl sub_10010030(int a1, int a2);
int sub_10010110(void); // weak
// void *__cdecl malloc(size_t);
void *__cdecl sub_10010140(void *a1, unsigned int a2);
int __cdecl sub_10010160(int a1);
int __cdecl sub_10010180(int a1);
unsigned int __cdecl sub_100101A0(int a1, char a2);
_DWORD __cdecl sub_100101C0(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_100101D0(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_100101E0(int a1, int a2);
char *__cdecl sub_10010260(int a1, unsigned int a2);
int *__cdecl sub_10010280(unsigned int a1);
int sub_100102B0();
_DWORD __cdecl sub_100102C0(_DWORD, _DWORD); // weak
// int __cdecl iswlower(wint_t);
int __cdecl sub_100102E0(int a1);
int __cdecl sub_100102F0(int a1, int a2);
// int __cdecl _fileno(FILE *);
int __cdecl sub_10010310(int a1, int a2);
int *__cdecl sub_10010340(int a1, unsigned int a2);
double *__cdecl sub_10010360(int a1, double a2);
int __cdecl sub_10010380(int, double, int); // idb
int __cdecl sub_100103A0(int, double, int); // idb
signed int __cdecl sub_100103C0(int a1, int a2);
void __cdecl sub_100103D0(int a1, unsigned int a2);
_DWORD *__cdecl sub_100103F0(int a1);
_DWORD *__cdecl sub_10010430(int a1);
int __cdecl sub_10010470(int a1, int a2);
_DWORD __cdecl sub_10010480(_DWORD, _DWORD); // weak
int __cdecl sub_10010490(int a1, signed int a2, int *a3);
signed int sub_100104C0();
signed int sub_100104E0();
signed int sub_10010500();
signed int __cdecl sub_10010520(int a1, int a2, int a3, _DWORD *a4);
void sub_10010540();
unsigned int __cdecl sub_10010550(int a1, int a2);
signed int __cdecl sub_10010570(int a1, int a2, int a3);
_DWORD *__cdecl sub_10010590(int a1, int a2);
int __cdecl sub_100105B0(int a1, char **a2, int a3, unsigned int a4);
// char *__usercall sub_100105D0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>, unsigned int a4@<esi>, int a5, signed int (*a6)(), signed int (*a7)(), int a8, int a9);
// int __usercall sub_10010680@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>, unsigned int a4@<esi>, _WORD *a5, int a6, signed int (*a7)(), signed int (*a8)(), int a9, int a10);
int __cdecl sub_10010720(int a1, unsigned int a2, int a3, char **a4, int a5, int a6);
char *__cdecl sub_10010780(int a1, unsigned int a2, int a3);
char *__cdecl sub_10010800(int a1, unsigned int a2, int *a3);
char *__cdecl sub_10010860(int a1, unsigned int a2, int a3, int a4, signed int (*a5)(), signed int (*a6)(), int a7);
// char *__usercall sub_10010890@<eax>(const char *a1@<edx>, int a2@<ebx>, int a3@<edi>, int a4, int a5);
char *__cdecl sub_100108D0(int a1, int a2, const char *a3, int a4);
char *__cdecl sub_10010920(int a1, int a2, const char *a3, int a4);
char *__cdecl sub_10010970(int a1, int a2, const char *a3, int a4);
int __cdecl sub_100109C0(int a1, unsigned int a2, _WORD *a3, int a4, int a5, signed int (*a6)(), signed int (*a7)(), int a8);
_DWORD __cdecl sub_10010A00(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10010A10(int a1, int a2, int a3);
int __cdecl sub_10010A30(int a1, int a2, int a3);
int *__cdecl sub_10010A50(int a1, int a2);
unsigned int __cdecl sub_10010B60(int a1);
char *__cdecl sub_10010B80(int a1, unsigned int a2, const char *a3, int a4, __int16 a5, int a6);
// unsigned int __usercall sub_10010BE0@<eax>(int a1@<esi>, int a2, int a3, int a4, int *a5);
int __cdecl sub_10010CF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
_DWORD __cdecl sub_10010D60(_DWORD, _DWORD); // weak
int __cdecl sub_10010D70(int a1, int a2, int a3, unsigned int a4);
signed int __cdecl sub_10010DE0(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_10010E20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8);
int __cdecl sub_10010EB0(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_10010F20(int a1, const char *a2);
char *__cdecl sub_10010F90(int a1, const char *a2);
int __cdecl sub_10010FD0(int a1, int a2, unsigned int a3);
void *__cdecl sub_10010FF0(unsigned int a1);
void *__cdecl sub_10011010(unsigned int a1);
int __cdecl sub_10011070(int *a1);
void *__cdecl sub_100110A0(int a1, unsigned int a2);
signed int __cdecl sub_100110D0(int a1, char *a2, char a3);
signed int __cdecl sub_100110F0(int a1, int a2, int a3, int a4, char a5);
signed int __cdecl sub_10011120(int a1, char *a2, char a3);
int __cdecl sub_10011140(int a1, int a2, int a3, int a4, int a5, char a6);
int __cdecl sub_10011170(int a1);
int __cdecl sub_10011190(int a1, int a2);
int __cdecl sub_100111B0(int a1);
int __cdecl sub_10011230(int a1);
signed int __cdecl sub_10011240(int a1, _DWORD *a2);
int __cdecl sub_10011270(int a1, int a2);
int __cdecl sub_10011290(int a1);
void __cdecl sub_100112B0(int a1, unsigned int a2);
int sub_100112F0();
// int __usercall sub_10011310@<eax>(int a1@<ebx>, const char **a2, int a3, int a4, int a5);
_WORD *__cdecl sub_10011380(int a1, signed int a2, int a3, signed int *a4);
signed int __cdecl sub_10011590(int a1);
char *__cdecl sub_10011630(int a1, unsigned int a2);
BOOL __cdecl sub_10011740(int a1, unsigned int a2);
int __cdecl sub_10011830(int a1, unsigned int a2);
void *__cdecl sub_10011870(int a1, void *a2, unsigned int a3);
void *__cdecl sub_100118A0(int a1, void *a2);
unsigned int __cdecl sub_100118F0(int a1, int a2);
int __cdecl sub_10011970(int a1, int a2, const char *a3, const char *a4);
char *__cdecl sub_10011AB0(int a1, int a2, const char *a3);
_DWORD __cdecl sub_10011AD0(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10011B50(int a1, int a2, unsigned int a3, int a4);
const char *__cdecl sub_10011BC0(int a1);
signed int __cdecl sub_10011BE0(int a1, unsigned int a2, const char **a3);
int __cdecl sub_10011C40(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10011C70@<eax>(char a1@<bpl>, int a2, int a3, unsigned int a4);
int __cdecl sub_10011CF0(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7);
signed int *__cdecl sub_10011D20(int a1);
void __cdecl sub_10011D70(int a1, int a2);
signed int __cdecl sub_10011DB0(int a1, int a2, signed int *a3, unsigned __int8 *a4, int a5);
char *__cdecl sub_10012240(int a1, unsigned int a2, int a3, int *a4, int a5, __int16 a6, int *a7, const char **a8, int *a9, const char **a10);
signed int __cdecl sub_100123C0(int a1, int a2, int *a3, int a4);
unsigned int __cdecl sub_10012430(int a1, int a2, int *a3, int a4);
int __cdecl sub_10012470(int a1, int a2, int a3, unsigned int a4, int a5, int a6);
signed int __cdecl sub_100124C0(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_100125C0(int a1, int a2, int a3, unsigned int a4, int a5, int a6, _DWORD *a7);
signed int __cdecl sub_10012620(int a1, int a2, signed int *a3, unsigned __int8 *a4, char a5);
int __cdecl sub_10012650(int, char *, int, char, char *, size_t); // idb
signed int __cdecl sub_10012A00(int a1);
char *__cdecl sub_10012DA0(int a1, unsigned int a2, int a3, int a4);
// signed int __usercall sub_10012E10@<eax>(char a1@<sil>, int a2, int a3, int a4);
// int __usercall sub_10012E70@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_10012EB0(int a1, int a2, signed int a3, int *a4);
int __fastcall sub_10012F10(const char *a1, const char *a2);
char __cdecl sub_10012F50(int a1);
int __cdecl sub_10012FC0(int a1, int a2);
signed int __cdecl sub_100130E0(int a1, int a2, signed int a3, int *a4);
// signed int __usercall sub_100131B0@<eax>(char a1@<bpl>, int a2, int a3, signed int a4, _DWORD *a5);
// signed int __usercall sub_100133A0@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5, int *a6);
// int __usercall sub_100134C0@<eax>(char a1@<dil>, int a2, int a3, int a4, int a5);
signed int __cdecl sub_100135C0(int a1, int a2, int a3, _DWORD *a4);
signed int __cdecl sub_10013610(int a1, int a2, signed int a3, _DWORD *a4);
char *__cdecl sub_100136A0(int a1);
signed int __cdecl sub_10013700(int a1, int a2, signed int a3, int *a4);
int __cdecl sub_10013840(int a1, int a2, signed int a3);
bool __cdecl sub_100138C0(int a1);
// int __usercall sub_10013940@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5, int *a6);
// int __usercall sub_10013A50@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5, int *a6);
int __fastcall sub_10013B20(int a1, int a2);
char __cdecl sub_10013B50(int a1);
int __cdecl sub_10013C60(int a1);
// signed int __usercall sub_10013CC0@<eax>(char a1@<dil>, int a2, int a3, int a4, signed int *a5);
// signed int __usercall sub_10013D30@<eax>(char a1@<bl>, int a2, int a3, int a4, int a5, int *a6);
signed int __cdecl sub_10013EF0(int a1, int a2, signed int a3, int *a4);
signed int __cdecl sub_10013F80(int a1, int a2);
signed int __cdecl sub_10013FB0(int a1, int a2, signed int a3, int *a4);
signed int __cdecl sub_10014050(int a1, int a2, int a3, _DWORD *a4);
// int __usercall sub_10014130@<eax>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10014160(int a1, int a2, signed int a3, _DWORD *a4);
int __cdecl sub_100141F0(int a1, _DWORD *a2, int a3, _DWORD *a4);
unsigned int __cdecl sub_10014290(unsigned int a1);
int __cdecl sub_100142A0(int a1, unsigned int a2, _DWORD *a3);
int __cdecl sub_100144E0(int a1, int a2, int a3, unsigned int *a4);
int __cdecl sub_10014720(int a1, int *a2);
int __cdecl sub_10014780(int a1, int a2, int a3, int *a4, int *a5);
int __cdecl sub_10014F50(int a1, int a2, int a3, int *a4, int *a5);
signed int __cdecl sub_10015040(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_10015050(int a1, int a2);
int __cdecl sub_10015060(int a1, int a2);
BOOL __cdecl sub_10015070(int a1, int a2, int a3);
// signed int __usercall sub_10015090@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, unsigned int **a4);
// unsigned int *__usercall sub_10015110@<eax>(unsigned int *result@<eax>, int a2@<ecx>, int a3@<ebx>, int a4, int a5);
signed int __cdecl sub_10015170(int a1, int a2, int a3, int a4, int *a5, int a6);
_DWORD *__cdecl sub_10015220(int a1, _DWORD *a2, int a3, int a4);
_DWORD *__cdecl sub_100152F0(int a1, int a2, int a3, int *a4);
int __cdecl sub_10015310(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_10015400(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_10015520(int a1, int a2, int a3, int a4);
int __cdecl sub_100155F0(int a1, int a2, int a3, int a4);
signed int __cdecl sub_100156C0(int a1, int a2, int a3, signed int *a4, _DWORD *a5);
signed int __cdecl sub_10015750(int a1, int a2, int a3, signed int *a4, _DWORD *a5);
unsigned int __cdecl sub_100157E0(int a1, unsigned int a2);
int (__cdecl **sub_10015810())(int, int, int, int, int);
int __cdecl sub_10015820(int a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_10015880(int a1, _DWORD *a2);
_DWORD *__cdecl sub_10015890(int a1, int a2, int a3);
// signed int __usercall sub_100158E0@<eax>(unsigned int a1@<eax>, const char *a2@<edx>, int a3@<ebx>, _DWORD *a4);
void __cdecl sub_100159B0(int a1, int a2);
unsigned int *__cdecl sub_10015A30(int a1, int a2, _DWORD *a3);
unsigned int __cdecl sub_10015AB0(int a1, int a2, int a3);
// int __usercall sub_10015B30@<eax>(_WORD *a1@<eax>, int a2, int a3);
_DWORD *__cdecl sub_10015BB0(int a1, int a2, int a3, signed int (*a4)(), signed int (*a5)(), signed int a6, int a7, int a8, int a9);
_DWORD *__cdecl sub_10015C70(int a1, unsigned int a2, int a3, int a4, char a5, signed int (*a6)(), signed int (*a7)());
int __cdecl sub_10015D00(int a1, unsigned int a2, int a3, _DWORD *a4, unsigned int *a5);
signed int __cdecl sub_10016010(int a1, int a2, unsigned int *a3, unsigned int *a4, _DWORD *a5);
int __cdecl sub_10016170(int a1, int a2);
int __cdecl sub_10016210(int a1, unsigned int a2, int a3, _DWORD *a4);
int __cdecl sub_10016530(int a1, unsigned int a2, int a3, _DWORD *a4);
int __cdecl sub_100169C0(int a1, unsigned int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_10016AA0(int a1, unsigned int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_10016BA0(int a1, unsigned int a2, int a3, signed int *a4);
int *__cdecl sub_10016E50(int a1, int a2);
_DWORD *__cdecl sub_10016E80(int a1, void *a2, int a3);
int __cdecl sub_10016EB0(int a1, int a2, int a3, int *a4, int *a5);
int __cdecl sub_10017090(int a1, unsigned int a2, int a3, int a4, signed int *a5, int *a6);
// _BYTE *__usercall sub_10017200@<eax>(char a1@<dl>, int a2@<edi>, int *a3);
int __cdecl sub_10017250(int a1, int a2, int a3, int a4);
int __cdecl sub_10017290(int a1, int a2, int a3, int a4);
int __cdecl sub_100172D0(int a1, int a2, int a3, _DWORD *a4);
signed int __cdecl sub_10017300(int a1, int a2, int a3, _DWORD *a4);
// signed int __usercall sub_10017350@<eax>(int a1@<eax>, const char *a2@<edx>, unsigned int a3, unsigned int *a4);
int __cdecl sub_100173E0(int a1, int a2, int a3, int a4);
signed int __cdecl sub_10017450(int a1, signed int a2, unsigned int *a3);
_BYTE *__cdecl sub_10017540(int a1, signed int a2);
signed int __cdecl sub_100175A0(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
unsigned int __cdecl sub_10017630(int a1, int a2, int a3);
void __cdecl sub_10017710(int a1, unsigned int a2);
signed int __cdecl sub_100177F0(int a1, int a2, unsigned int a3);
unsigned int *__cdecl sub_10017810(int a1, int a2, unsigned int a3, int a4);
_DWORD *__cdecl sub_100178B0(int a1, int a2, int a3, _DWORD **a4);
signed int __cdecl sub_100179C0(int a1, int a2, int a3, int *a4, int *a5);
int __cdecl sub_10017A00(int a1, unsigned int a2, int a3, int *a4, unsigned int *a5);
int __cdecl sub_10017AF0(int a1, unsigned int a2, int a3, _DWORD *a4);
int __cdecl sub_10017B20(int a1, unsigned int a2, int a3, _DWORD *a4);
int __cdecl sub_10017B50(int a1, unsigned int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_10017B80(int a1, unsigned int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_10017BB0(int a1, unsigned int a2, int a3, signed int *a4);
int __cdecl sub_10017BE0(int a1, int a2, int a3, int *a4, int *a5);
int __cdecl sub_10017C10(int a1, unsigned int a2, int a3, int a4, signed int *a5, int *a6);
int __cdecl sub_10017C40(int a1, int a2, int a3, unsigned int a4);
unsigned int __cdecl sub_10017DE0(int a1, const char **a2, int a3, unsigned int a4, int a5, int a6);
signed int __cdecl sub_10017EF0(int a1, unsigned int a2, int a3, int a4, signed int (*a5)(), signed int (*a6)(), int a7, int a8, int a9, unsigned int **a10);
char *__cdecl sub_10018130(int a1, int a2, int a3, int *a4);
signed int __cdecl sub_10018350(int a1, const char *a2, unsigned int *a3);
signed int __cdecl sub_10018370(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_100183B0(int a1, int a2);
_DWORD *__cdecl sub_10018570(int a1, int a2, signed int a3, _DWORD *a4);
signed int __cdecl sub_10018600(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
signed int __cdecl sub_10018870(int a1, int a2, int a3, signed int *a4, int *a5);
char *__cdecl sub_100188D0(int a1, int a2, int a3, int *a4);
_DWORD *__cdecl sub_10018900(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
unsigned int __cdecl sub_10018A00(int a1, unsigned int a2);
signed int __cdecl sub_10018AC0(int a1, unsigned int a2, int a3, int a4, signed int (*a5)(), signed int (*a6)(), int a7, unsigned int **a8);
// void __usercall sub_10018B00(int a1@<edi>, unsigned int *a2);
unsigned int *__cdecl sub_10018B90(int a1, int a2);
void __cdecl sub_10018DA0(int a1, int a2);
int __cdecl sub_10018DD0(int a1, int a2);
// char *__usercall sub_10018E10@<eax>(unsigned int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
int __cdecl sub_10019530(int a1, unsigned int a2, unsigned int a3, int a4, int *a5);
int *__cdecl sub_10019680(int a1, signed int a2, int a3, int a4, int *a5);
int __cdecl sub_10019890(int a1, signed int a2, int a3, int a4, int *a5);
unsigned int __cdecl sub_10019CE0(int a1, unsigned int a2);
char *__cdecl sub_10019EA0(int a1, const char *a2, int a3);
signed int __cdecl sub_10019FD0(int a1);
unsigned int __cdecl sub_1001A130(int a1, signed int a2, _DWORD *a3);
unsigned int __cdecl sub_1001A200(int a1);
void *__cdecl sub_1001A220(int a1, int a2);
signed int __cdecl sub_1001A2D0(int a1, int a2, int a3, int *a4, int *a5);
signed int __cdecl sub_1001A330(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_1001A370(int a1, int a2, int a3, int a4, int a5);
int *__cdecl sub_1001A470(int a1, unsigned int a2, int a3, int *a4);
unsigned int __cdecl sub_1001A770(int a1, int a2, int a3, unsigned int *a4, int a5);
signed int sub_1001AAB0();
signed int __cdecl sub_1001AAE0(int a1);
int __cdecl sub_1001AB10(int a1, int a2, unsigned int a3, char a4);
char *__cdecl sub_1001AB60(int a1, void *a2, int a3, int a4);
unsigned int __cdecl sub_1001ABD0(unsigned int a1);
void __cdecl sub_1001ABE0(unsigned int a1);
void __cdecl sub_1001AC30(int a1, unsigned int a2);
int __cdecl sub_1001AC80(int a1, int a2);
int __cdecl sub_1001ACB0(int a1, signed int a2);
char *__cdecl sub_1001AD70(int a1, signed int a2);
unsigned int __cdecl sub_1001AE10(int a1);
int __cdecl sub_1001AEA0(int a1, int a2);
int __cdecl sub_1001AFC0(_WORD *a1);
_WORD *__cdecl sub_1001AFE0(_WORD *a1, __int16 a2);
_WORD *__cdecl sub_1001B010(_WORD *a1, __int16 a2, unsigned int a3);
_WORD *__cdecl sub_1001B030(_WORD *a1);
unsigned int __cdecl sub_1001B0A0(_WORD *a1, int a2, unsigned int a3);
int __cdecl sub_1001B0E0(int a1, int a2, unsigned int a3);
int __cdecl sub_1001B130(int a1, int a2, unsigned int a3);
int sub_1001B190();
int __cdecl sub_1001B1C0(unsigned int a1, int a2);
int __cdecl sub_1001B200(unsigned int a1);
// void *__usercall sub_1001B2F0@<eax>(int a1@<edi>, int a2@<esi>, int a3, void *a4);
// signed int __usercall sub_1001B360@<eax>(unsigned int a1@<edx>, _BYTE *a2@<edi>);
// unsigned int __usercall sub_1001B3B0@<eax>(int a1@<eax>, _BYTE *a2@<edx>);
void *__cdecl sub_1001B420(unsigned int a1);
void *__cdecl sub_1001B450(int a1, int a2, void *a3);
int __cdecl sub_1001B690(int a1, int a2, unsigned int a3, int a4, int *a5);
int __cdecl sub_1001B9E0(int a1, int a2, int a3, signed int *a4, int *a5);
signed int __cdecl sub_1001BDE0(int a1, int a2, int a3, signed int *a4, int *a5);
int *__cdecl sub_1001BE10(int a1, signed int a2, int a3, int *a4);
signed int __cdecl sub_1001BE80(int a1, signed int a2, int a3, int a4, int *a5);
unsigned int __cdecl sub_1001BEC0(int a1, int a2, int a3, int *a4, int *a5);
int *__cdecl sub_1001C0B0(int a1, signed int a2, int a3, int a4, int *a5);
int *__cdecl sub_1001C210(int a1, signed int a2, int a3, int a4, int *a5);
int *__cdecl sub_1001C270(int a1, signed int a2, int a3, int a4, int *a5);
int *__cdecl sub_1001C3D0(int a1, signed int a2, int a3, int a4, int *a5);
int __cdecl sub_1001C430(int a1, signed int a2, int a3, signed int *a4, int *a5);
signed int __cdecl sub_1001C4D0(__int64 a1, int a2, signed int *a3, int *a4);
int __cdecl sub_1001C630(int a1, signed int a2, unsigned int a3, int a4, int *a5);
int __cdecl sub_1001C870(int a1, signed int a2, unsigned int a3, int a4, int *a5);
// int __usercall sub_1001CA80@<eax>(signed int a1@<eax>, signed int *a2@<ecx>, int a3@<edi>, unsigned int a4, int (__cdecl *a5)(int, int, int), int a6, int *a7);
int __cdecl sub_1001CDC0(int a1, int a2, int a3);
int __cdecl sub_1001CE40(int a1, signed int a2, unsigned int a3, signed int *a4, int *a5);
int __cdecl sub_1001CEA0(int a1, signed int a2, unsigned int a3, signed int *a4, int *a5);
// int __usercall sub_1001CEE0@<eax>(int a1@<ebx>, int a2, int *a3);
void *__cdecl sub_1001D170(int a1, int a2, void *a3);
signed int __cdecl sub_1001D290(int a1, int a2, int a3);
_WORD *__cdecl sub_1001D3F0(int a1, signed int a2, unsigned int a3, int a4, int *a5);
int __cdecl sub_1001D6D0(int a1, signed int a2, unsigned int a3, int a4, int *a5);
// unsigned int __usercall sub_1001D750@<eax>(signed int a1@<eax>, int a2, int a3, int a4, void *a5, int a6, int a7);
// int __usercall sub_1001D9B0@<eax>(int a1@<edi>, signed int *a2@<esi>, signed int a3, int a4, int a5, int a6);
unsigned int __cdecl sub_1001DA30(int a1, signed int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_1001DA60(int a1, signed int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_1001DA90(int a1, signed int a2, int a3, int a4, int a5);
int __cdecl sub_1001DAC0(int a1, signed int a2, int a3, signed int *a4, int a5);
int __cdecl sub_1001DAF0(int a1, signed int a2, int a3, signed int *a4, int a5);
int __cdecl sub_1001DB20(int a1, signed int a2, int a3, signed int *a4, int a5);
int __cdecl sub_1001DB50(int a1, signed int a2, int a3, signed int *a4, int a5);
unsigned int __cdecl sub_1001DB80(int a1, signed int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_1001DBB0(int a1, signed int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_1001DBE0(int a1, signed int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_1001DC10(int a1, signed int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_1001DC40(int a1, signed int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_1001DC70(int a1, signed int a2, int a3, int a4, int a5);
int __cdecl sub_1001DCA0(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_1001DD00(int a1, int a2, unsigned int a3, int a4, int *a5);
signed int __cdecl sub_1001DDA0(int a1);
char *__cdecl sub_1001DDF0(int a1, unsigned int a2);
_DWORD *__cdecl sub_1001DE60(int a1, int a2, unsigned int a3, unsigned int a4, int a5);
void *__cdecl sub_1001DF40(int a1, void *a2, int a3);
void __cdecl sub_1001DFA0(int a1, unsigned int a2);
// void *__usercall sub_1001DFB0@<eax>(_WORD *a1@<edx>, _WORD *a2@<ecx>, int a3, int a4, int *a5);
// int __usercall sub_1001E2B0@<eax>(int a1@<edx>, int *a2@<ecx>, char a3@<bpl>, int a4, _WORD *a5);
// int __usercall sub_1001E710@<eax>(char a1@<bpl>, int a2, int a3, int a4, signed int *a5, int *a6);
// int __usercall sub_1001E750@<eax>(char a1@<bpl>, int a2, int a3, int a4, signed int *a5, int *a6);
void *__cdecl sub_1001E790(int a1, int a2, int a3, signed int *a4, int *a5);
void *__cdecl sub_1001E7D0(int a1, int a2, int a3, signed int *a4, int *a5);
unsigned int *__cdecl sub_1001E810(int a1, signed int a2);
unsigned int *__cdecl sub_1001E8C0(int a1, signed int a2, signed int a3);
signed int __cdecl sub_1001E980(__int64 a1, int a2, int a3, int *a4);
signed int __cdecl sub_1001EB40(__int64 a1, int a2, signed int *a3, _DWORD *a4);
int __cdecl sub_1001EC60(int a1, signed int a2, unsigned int a3, int a4, int *a5);
signed int __cdecl sub_1001F050(__int64 a1, int a2, int a3, int *a4);
signed int __cdecl sub_1001F210(__int64 a1, int a2, int a3, int *a4);
signed int __cdecl sub_1001F400(int a1, int a2, int a3, int a4, int *a5);
// _BYTE *__usercall sub_1001F4E0@<eax>(int a1@<eax>, int a2@<edx>, signed int a3@<edi>);
signed int __cdecl sub_1001F520(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_1001F560(int a1);
double *__cdecl sub_1001F5B0(int a1, double a2);
int __cdecl sub_1001F5D0(int, double, int); // idb
int __cdecl sub_1001F600(int, double, int); // idb
int __cdecl sub_1001F680(int, double); // idb
int __cdecl sub_1001F6E0(int, double); // idb
signed int __cdecl sub_1001F7A0(int a1, long double a2, _DWORD *a3);
signed int __cdecl sub_1001F840(int a1, double a2, _DWORD *a3);
double __cdecl sub_1001F900(double a1);
char *__cdecl sub_1001F970(int a1, _WORD *a2, int a3, double *a4);
signed int __thiscall sub_1001FB60(int this);
signed int __cdecl sub_1001FBC0(int a1, _WORD *a2, int *a3, signed int a4, double *a5);
int __cdecl sub_1001FE70(int a1, int a2, int a3, signed int *a4, int *a5);
signed int __cdecl sub_1001FF10(int a1);
_WORD *__cdecl sub_10020030(int a1, signed int a2, double *a3);
_WORD *__cdecl sub_10020180(__int64 a1, _DWORD *a2);
_WORD *__cdecl sub_100201D0(__int64 a1, _DWORD *a2);
signed int __cdecl sub_10020220(int a1, signed int a2, signed int *a3);
_WORD *__cdecl sub_10020310(__int64 a1, _WORD *a2);
_WORD *__cdecl sub_10020450(int a1, int a2, int a3, signed int *a4, int *a5);
_WORD *__cdecl sub_100204C0(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_10020510(int a1, int a2, unsigned int a3, int a4, int *a5);
signed int __cdecl sub_10020600(int a1, int a2, int a3, signed int *a4, int *a5);
signed int __cdecl sub_10020680(int a1, int a2, int a3, _DWORD *a4, int *a5);
signed int __cdecl sub_100207E0(int a1, int a2, int a3, _DWORD *a4, int *a5);
// signed int __usercall sub_100207F0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int *a4, int a5, int a6, signed int a7, signed int a8, int a9);
signed int __cdecl sub_10020970(int a1, int a2, int a3, int a4, int *a5);
signed int __cdecl sub_100209A0(int a1, int a2, int a3, int a4, int *a5);
signed int __cdecl sub_100209D0(int a1, int a2, int a3, int a4, int *a5);
char *__cdecl sub_10020A00(int a1, unsigned int a2);
unsigned int __cdecl sub_10020AF0(int a1, int a2, int a3, _DWORD *a4, int *a5);
signed int __cdecl sub_10020D00(int a1, int a2, int a3, _DWORD *a4, int *a5);
signed int __cdecl sub_10020DB0(int a1, int a2, int a3, signed int *a4, _DWORD *a5);
// int __usercall sub_10020E90@<eax>(int a1@<edi>, int a2@<esi>);
int __cdecl sub_10020F00(int a1, int a2);
signed int __cdecl sub_100210A0(int a1, int a2, int a3, signed int *a4, _DWORD *a5);
BOOL __cdecl sub_100210C0(const char *a1, const char *a2);
int __cdecl sub_10021100(int a1, const char *a2);
int *__cdecl sub_10021140(int a1, unsigned int a2, int a3);
int __cdecl sub_10021160(int a1);
int __cdecl sub_10021190(int a1, char *a2);
int __cdecl sub_10021210(int a1);
signed int __cdecl sub_10021220(int a1);
int __cdecl sub_10021240(int a1);
_DWORD *__cdecl sub_10021260(int a1, int a2, int a3, int a4);
int __cdecl sub_100212D0(int a1, int a2, int a3);
int *__cdecl sub_10021340(int a1, unsigned int a2);
int __cdecl sub_100213B0(int a1, int a2);
unsigned __int8 *__cdecl sub_10021400(int a1, int a2);
int __cdecl sub_10021490(int a1, int a2, int a3);
signed int __cdecl sub_10021580(int a1, int a2, unsigned int a3, int a4, int *a5);
signed int __cdecl sub_10021730(int a1, _DWORD **a2, _DWORD *a3);
unsigned int __cdecl sub_10021D40(int a1, int a2);
int __cdecl sub_10021D70(int a1, int a2);
int __cdecl sub_10021DA0(int a1, int a2, unsigned int a3, int a4, int *a5);
char *__cdecl sub_10021DF0(int a1, unsigned int a2);
signed int __cdecl sub_10021E20(int a1);
unsigned int __cdecl sub_10021E70(int a1, int a2, int a3);
// unsigned __int16 __usercall sub_10022040@<ax>(unsigned __int16 a1@<si>);
// unsigned __int16 __usercall sub_10022090@<ax>(unsigned __int16 a1@<si>);
// int __usercall sub_100220E0@<eax>(int *a1@<eax>, int a2);
// signed int __usercall sub_10022130@<eax>(unsigned int a1@<eax>, _DWORD *a2@<ecx>);
// signed int __usercall sub_10022170@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>, int a4);
// signed int __usercall sub_10022310@<eax>(char bp0@<bpl>, int a1);
// unsigned int __usercall sub_10022390@<eax>(int a1@<edi>, unsigned __int16 a2, unsigned int a3, int (__cdecl *a4)(int));
// signed int __usercall sub_10022430@<eax>(_WORD *a1@<eax>, char a2@<sil>, int a3, int a4, _WORD *a5);
// signed int __usercall sub_10022770@<eax>(int a1@<eax>);
// _BYTE *__usercall sub_10022A00@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, int *a4, int a5);
// int __usercall sub_10022E00@<eax>(int a1@<eax>, char a2, int a3, int a4, int a5, int a6, int a7);
// unsigned int *__usercall sub_10022F50@<eax>(unsigned __int16 *a1@<eax>, int a2, unsigned int *a3, int a4);
// unsigned __int16 **__usercall sub_10022FE0@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int16 **a3);
_BYTE *__fastcall sub_100230B0(unsigned __int16 a1, int a2);
// _BYTE *__usercall sub_100230D0@<eax>(unsigned __int16 a1@<cx>, int a2@<edi>, unsigned __int16 a3);
void *__cdecl sub_10023150(int a1, int a2);
void __cdecl sub_100236A0(int a1, unsigned int a2);
// signed int __usercall sub_10023720@<eax>(int a1@<esi>);
// void *__usercall sub_100237B0@<eax>(int a1@<eax>, unsigned __int16 **a2, int a3, _BYTE **a4, int a5);
// int __usercall sub_10023ED0@<eax>(int a1@<eax>, unsigned __int16 **a2);
// int __usercall sub_10024A70@<eax>(unsigned __int16 **a1@<ebx>, int a2@<esi>);
// int __usercall sub_10024AF0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
unsigned __int16 **__cdecl sub_10024C00(int a1, int a2, int a3, int *a4, int a5, int *a6);
signed int __cdecl sub_100251E0(int a1, int a2, signed int a3, int *a4);
signed int __cdecl sub_100252D0(int a1, int a2, int a3, int *a4);
signed int __cdecl sub_10025370(int a1, int a2);
signed int __cdecl sub_10025390(int a1, int a2);
signed int __cdecl sub_100253D0(int a1, int a2, signed int a3, int *a4);
signed int __cdecl sub_100254C0(int a1, int a2, signed int a3, signed int *a4);
void __cdecl sub_10025560(int a1, int a2);
int __cdecl sub_10025590(int a1, int a2);
signed int __cdecl sub_100255D0(int a1, int a2, int a3, int a4, int *a5);
BOOL __cdecl sub_10025780(int a1, int a2, double *a3);
int __cdecl sub_100257D0(int, int, double); // idb
// int __usercall sub_10025820@<eax>(int a1@<eax>);
// unsigned __int16 **__usercall sub_10025E30@<eax>(int a1@<ebx>, int a2@<edi>, int a3, signed int *a4, int a5, int *a6);
unsigned __int16 **__cdecl sub_10026070(int a1, int a2, int a3, signed int *a4, int *a5);
unsigned __int16 **__cdecl sub_100260A0(int a1, int a2, int a3, signed int *a4, int *a5);
// signed int __usercall sub_100260E0@<eax>(char a1@<bpl>, int a2);
int __cdecl sub_100265F0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10026830(int a1, int a2, int a3, int a4, int a5);
unsigned __int16 **__cdecl sub_10026930(int a1, int a2, int a3, signed int *a4, int *a5);
signed int __cdecl sub_10026950(unsigned int a1, int *a2);
// signed int __usercall sub_10026A40@<eax>(char a1@<dil>, __int64 a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl sub_10026BC0(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
char *__cdecl sub_10026C50(int a1, unsigned int a2);
char *__cdecl sub_10026D70(int a1, int a2, void *a3, int a4, int a5);
// int *__usercall sub_10026E10@<eax>(int a1@<eax>, int a2@<ebx>, unsigned int a3);
// int __usercall sub_10026F00@<eax>(unsigned int a1@<eax>, int a2@<edx>, int a3@<ecx>);
int __cdecl sub_10026F80(int a1, signed int a2, signed int a3, unsigned int *a4, int *a5);
int __cdecl sub_100270E0(int a1, int a2);
int *__cdecl sub_10027130(int a1, int a2, signed int a3);
signed int __cdecl sub_100271C0(int a1, int a2, signed int a3, int *a4);
signed int __cdecl sub_100272B0(int a1, int a2, signed int a3, _DWORD *a4);
signed int __cdecl sub_10027370(int a1, unsigned int a2, int a3, int a4, unsigned int *a5);
signed int __cdecl sub_100274F0(int a1, unsigned int a2);
int __cdecl sub_10027630(int a1, int a2, unsigned int a3);
int __cdecl sub_100276B0(int a1, int a2, signed int a3, int *a4);
signed int __cdecl sub_10027780(int a1, int a2, signed int a3, _DWORD *a4);
signed int __cdecl sub_10027800(int a1, int a2, signed int a3, _DWORD *a4);
signed int __cdecl sub_10027840(int a1, int a2, signed int a3, _DWORD *a4);
signed int __cdecl sub_10027880(int a1, int a2);
signed int __cdecl sub_10027950(int a1, unsigned int a2, int a3, int a4, unsigned int *a5);
signed int __cdecl sub_10027AD0(int a1, int a2, int a3, _DWORD *a4);
signed int __cdecl sub_10027B20(int a1, int a2, int a3, char a4, int *a5);
signed int __cdecl sub_10027C20(int a1, int a2, int a3, int *a4);
unsigned int __cdecl sub_10027C50(int a1, int a2);
signed int __cdecl sub_10027CA0(int a1, signed int a2, int a3, _DWORD *a4);
int __cdecl sub_10027E00(int a1, int a2);
// signed int __usercall sub_10027E60@<eax>(char a1@<bpl>, int a2, int a3, unsigned int a4, int a5, int a6, int *a7);
// signed int __usercall sub_10027F70@<eax>(char a1@<bpl>, int a2, int a3, int a4, int a5, int *a6);
// signed int __usercall sub_10027FA0@<eax>(char a1@<bpl>, int a2, int a3, int a4, int a5, int *a6);
int __cdecl sub_10027FD0(int a1, unsigned int a2, unsigned int a3, int a4, _DWORD *a5);
// int __usercall sub_10028110@<eax>(char a1@<dil>, int a2, unsigned int a3, unsigned int a4, int a5, _DWORD *a6);
signed int __cdecl sub_10028320(int a1);
char *__cdecl sub_10028440(int a1, unsigned int a2);
signed int __cdecl sub_10028470(int a1, int a2, int a3);
_BYTE *__cdecl sub_100284B0(int a1, int *a2, char a3);
int __cdecl sub_10028530(int a1, _DWORD *a2, int *a3);
int __cdecl sub_10028590(int a1, int a2);
int __cdecl sub_10028680(int a1, unsigned int *a2);
signed int __cdecl sub_10028710(int a1, int a2, signed int a3, int *a4);
int __cdecl sub_10028940(int a1, int a2, int a3, __int16 a4, char a5, unsigned int a6, int a7);
int __cdecl sub_100289F0(int a1, int a2, unsigned int a3);
int __cdecl sub_10028A40(int a1, unsigned int a2, int a3, int a4, __int16 a5, int a6);
unsigned int __cdecl sub_10028AB0(int a1, int *a2, char a3);
signed int __cdecl sub_10028B40(unsigned int a1, int *a2);
signed int __cdecl sub_10028FD0(int a1, unsigned int a2, int a3, int a4, int *a5);
char *__cdecl sub_100295A0(int a1, unsigned int a2);
_WORD *__cdecl sub_10029650(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_100296A0(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_100296F0(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_10029740(int a1, int a2, int a3, signed int *a4, int a5);
int __cdecl sub_10029790(int a1, int a2, int a3, int a4, int a5);
_WORD *__cdecl sub_10029810(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_10029870(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_100298C0(int a1, int a2, int a3, signed int *a4, unsigned int *a5);
_WORD *__cdecl sub_10029980(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_100299E0(int a1, int a2, int a3, signed int *a4, int a5);
int __cdecl sub_10029A30(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl sub_10029B70(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl sub_10029CB0(int a1, int a2, int a3, int a4, int a5);
// int __usercall sub_10029D30@<eax>(int a1@<esi>, signed __int64 a2);
// int __usercall sub_10029D70@<eax>(int a1@<eax>);
// unsigned __int64 __usercall sub_10029DF0@<edx:eax>(int a1@<esi>, char a2);
// double __usercall sub_10029E50@<st0>(int a1@<eax>);
int __cdecl sub_10029EA0(int a1, int a2, int a3, int a4, int a5);
_WORD *__cdecl sub_10029ED0(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_10029F40(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_10029F90(int a1, int a2, int a3, signed int *a4, int a5);
_WORD *__cdecl sub_10029FE0(int a1, int a2, int a3, signed int *a4, int a5);
signed int __cdecl sub_1002A030(int a1, int a2, int a3, int a4, _DWORD *a5);
unsigned int __cdecl sub_1002A050(int a1, unsigned int a2);
double __cdecl sub_1002A0B0(double a1);
int __cdecl sub_1002A0E0(double); // idb
int __cdecl sub_1002A230(double); // idb
int __cdecl sub_1002A400(double); // idb
int __cdecl sub_1002A580(double); // idb
double __cdecl sub_1002A5D0(double a1);
long double __cdecl sub_1002A660(double a1);
int __cdecl sub_1002A690(double); // idb
int __cdecl sub_1002A6C0(double); // idb
int __cdecl sub_1002A6F0(double); // idb
int __cdecl sub_1002A720(double); // idb
double __cdecl sub_1002A750(double a1, double a2, double a3);
// BOOL __usercall sub_1002A890@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5, int a6);
double __cdecl sub_1002A9C0(double a1, double a2, double a3, double a4, double a5, double a6, double a7);
int __cdecl sub_1002AA10(int a1, int a2, unsigned int a3, int a4, int a5);
// signed int __usercall sub_1002AB80@<eax>(unsigned int *a1@<eax>, long double *a2);
unsigned int *__cdecl sub_1002B0A0(int a1, int a2, int a3, signed int *a4, int *a5);
int __cdecl sub_1002B160(int a1, int a2, int a3, int a4, int a5);
// unsigned int __usercall sub_1002B1A0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>);
double *__cdecl sub_1002B1C0(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B200(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B2D0(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B370(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B3E0(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B480(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B4F0(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B590(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B600(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B6A0(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B710(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B7B0(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B820(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B8C0(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B930(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002B9A0(int a1, int a2, int a3, int a4, int a5);
double *__cdecl sub_1002BA10(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1002BA80(int a1, int a2, int a3, signed int *a4, int a5);
// int __usercall sub_1002BB40@<eax>(unsigned int a1@<eax>, int a2@<ecx>, int a3, int a4, unsigned int a5, int a6, int a7);
int __cdecl sub_1002BE10(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002BE40(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002BE70(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002BEA0(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002BED0(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002BF00(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002BF30(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002BF60(int a1, int a2, unsigned int a3, int a4, int a5);
// int __usercall sub_1002BF90@<eax>(unsigned int a1@<eax>, int a2@<ecx>, int a3, int a4, unsigned int a5, int a6, int a7);
int __cdecl sub_1002C230(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002C260(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002C290(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002C2C0(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002C2F0(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002C320(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1002C350(int a1, int a2, int a3, signed int *a4, int a5);
signed int __cdecl sub_1002C530(int a1, int a2, int a3, int a4, int *a5);
// int __usercall sub_1002C690@<eax>(int a1@<edi>, double a2, int a3);
// int __usercall sub_1002C860@<eax>(int a1@<ebx>, double a2, int a3, int *a4);
double *__cdecl sub_1002CB30(int a1, int a2, int a3, int a4, int *a5);
double *__cdecl sub_1002CB70(int a1, int a2, int a3, int a4, int *a5);
signed int __cdecl sub_1002CBB0(int a1, int a2, int a3, int a4, int *a5);
double *__cdecl sub_1002CC90(int a1, int a2, int a3, int a4, int *a5);
double *__cdecl sub_1002CCD0(int a1, int a2, int a3, signed int *a4, int *a5);
// double *__usercall sub_1002CD60@<eax>(int a1@<eax>, int a2);
int __cdecl sub_1002CD90(int a1, int a2, unsigned int a3, signed int *a4, int *a5);
int __cdecl sub_1002D100(int a1, unsigned int a2);
int __cdecl sub_1002D1A0(int a1, int a2, int a3, int *a4, int *a5);
int __cdecl sub_1002D280(int a1, int a2, int a3, int *a4, int *a5);
signed int __cdecl sub_1002D300(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_1002D340(int a1, int a2);
unsigned int __cdecl sub_1002D370(int a1, int a2);
int __cdecl sub_1002D390(int a1, signed int a2, signed int *a3);
int __cdecl sub_1002D4E0(int a1, int a2, int a3, signed int *a4, int *a5);
char *__cdecl sub_1002D550(int a1, unsigned int a2);
// signed int __usercall sub_1002D590@<eax>(signed int a1@<eax>, int *a2);
// signed int __usercall sub_1002D6C0@<eax>(signed int a1@<eax>, unsigned int *a2@<edi>, int a3@<esi>);
_WORD *__cdecl sub_1002D770(signed int a1, int a2, signed int *a3);
// int __usercall sub_1002D7D0@<eax>(int a1@<ecx>, unsigned int a2@<eax>, int a3);
// signed int __usercall sub_1002D810@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edi>, int a3@<esi>);
int __cdecl sub_1002D870(int a1, int a2, unsigned int a3);
int __cdecl sub_1002D8C0(int a1, int a2);
_WORD *__cdecl sub_1002D8E0(int a1, int a2, int a3, signed int *a4);
_WORD *__cdecl sub_1002D990(signed int a1, int a2, signed int a3);
_WORD *__cdecl sub_1002DA10(unsigned int a1, int a2, int a3, int *a4);
_WORD *__cdecl sub_1002DA90(signed int a1, int a2, int a3, int a4, int *a5, int a6);
_WORD *__cdecl sub_1002DF60(signed int a1, int a2, int a3, int a4, int *a5);
_WORD *__cdecl sub_1002DF90(signed int a1, int a2, int a3, int a4, int *a5);
_WORD *__cdecl sub_1002DFD0(signed int a1, int a2, int a3, int a4, int *a5);
// signed int __usercall sub_1002E000@<eax>(int a1@<eax>, int a2, unsigned int a3, int a4);
// signed int __usercall sub_1002E060@<eax>(unsigned int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
int __cdecl sub_1002E0D0(signed int a1, int a2, int a3, signed int *a4, int *a5);
_WORD *__cdecl sub_1002E140(signed int a1, int a2, int a3, int a4, int *a5);
// _DWORD *__usercall sub_1002E250@<eax>(int a1@<eax>, int a2, signed int a3, unsigned int a4);
signed int __cdecl sub_1002E420(signed int *a1, signed int *a2, int a3);
int __cdecl sub_1002E5A0(_DWORD *a1, _DWORD *a2);
_WORD *__cdecl sub_1002E5C0(int a1, int a2, unsigned int a3, int a4, signed int *a5);
_WORD *__cdecl sub_1002E6A0(signed int a1, int a2, int a3, int a4, int a5);
_WORD *__cdecl sub_1002E740(signed int a1, int a2, int a3, int a4, int a5);
_WORD *__cdecl sub_1002E850(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1002E990(signed int a1, int a2, unsigned int a3, signed int *a4, int *a5);
char *__cdecl sub_1002EA60(int a1, unsigned int a2);
int __cdecl sub_1002EAB0(int a1, unsigned int a2, int a3);
int __cdecl sub_1002EB00(int a1, unsigned int a2, unsigned int a3, signed int (__cdecl *a4)(signed int *a1, signed int *a2, int a3), int a5);
signed int __cdecl sub_1002EBD0(int a1, int a2, int a3, int *a4, int *a5);
_WORD *__cdecl sub_1002EDC0(__int64 a1, int a2, signed int *a3, int *a4);
signed int __cdecl sub_1002F270(int a1, int a2, unsigned int a3, int a4, int *a5);
signed int __cdecl sub_1002F420(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
int sub_1002F6A0();
__int64 sub_1002F6B0();
__int64 sub_1002F6D0();
void *__cdecl sub_1002F6E0(int a1);
int __cdecl sub_1002F720(int a1);
int __cdecl sub_1002F740(int a1);
int __cdecl sub_1002F760(int a1, int a2);
int __cdecl sub_1002F7C0(int a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_1002F840(int a1, int a2);
int __cdecl sub_1002F880(int a1, int a2, _DWORD *a3);
void __cdecl sub_1002F930(int a1, int a2);
// int __usercall sub_1002F9A0@<eax>(signed int a1@<eax>, unsigned int a2@<edx>, signed int (*a3)()@<ecx>, int a4, int a5);
signed int sub_1002FB00();
int __cdecl sub_1002FB20(int a1, unsigned int a2, signed int a3, int *a4);
int __cdecl sub_1002FB50(int a1, unsigned int a2, signed int a3, int *a4);
signed int sub_1002FB80();
// unsigned int __usercall sub_1002FBA0@<eax>(unsigned int result@<eax>, int a2@<edx>, int a3@<esi>);
int __cdecl sub_1002FC40(int a1, unsigned int a2, int a3);
int __cdecl sub_100302A0(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7);
int __cdecl sub_10030390(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl sub_10030430(int a1, int a2, int a3, unsigned __int8 a4, _DWORD *a5);
int __cdecl sub_100305F0(int a1, _DWORD *a2);
int __cdecl sub_10038170(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_10038330(int a1, int a2);
unsigned int __cdecl sub_10038370(signed int a1);
signed int __cdecl sub_100383C0(int a1, int a2);
signed int sub_10038490();
int __cdecl sub_100384A0(int a1, unsigned int a2);
int *__cdecl sub_100384C0(int a1, unsigned int a2);
int __cdecl sub_100384E0(int a1, int a2);
int *__cdecl sub_10038520(int a1, unsigned int a2, int a3);
void *__cdecl sub_10038540(int a1, void *a2);
int __cdecl sub_10038570(int a1, int a2, int a3);
void *__cdecl sub_100385B0(void *a1);
int __cdecl sub_100385F0(int a1, int a2, int a3);
int __cdecl sub_10038630(int a1, int a2, int a3, int a4);
signed int __cdecl sub_10038670(int a1, int a2, int a3);
int __cdecl sub_100386A0(int a1);
int __cdecl sub_100386D0(int a1);
int __cdecl sub_100386E0(int a1);
// int __usercall sub_10038700@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4);
int __cdecl sub_10038750(int a1, unsigned int a2, int a3);
int __cdecl sub_10038770(int a1, int a2, int a3);
int __cdecl sub_100387A0(int a1, int a2, int a3);
int __cdecl sub_100387D0(int, double, int); // idb
int __cdecl sub_10038890(int a1, int a2, char a3);
char *__cdecl sub_10038950(int a1, int a2, unsigned int a3, char a4);
int __cdecl sub_10038A10(int a1, int a2, int a3, char a4);
int __cdecl sub_10038A60(int a1, int a2, int a3);
int __cdecl sub_10038B20(int a1, signed int a2);
int __cdecl sub_10038B50(int a1);
int __cdecl sub_10038B60(int a1, int a2);
int __cdecl sub_10038BC0(int a1);
int __cdecl sub_10038C10(int a1, int a2, int a3);
int *__cdecl sub_10038D40(int a1, int a2, unsigned int a3);
int __cdecl sub_10038DE0(int a1, int a2, int a3);
// int __usercall sub_10038E00@<eax>(char a1@<bpl>, int a2, int a3, int a4);
int *__cdecl sub_10038EB0(int a1, int a2);
signed int __cdecl sub_10038EE0(int a1, int a2);
int __cdecl sub_10039470(int, void *); // idb
// int __usercall sub_100394E0@<eax>(int result@<eax>);
int __cdecl sub_10039500(int a1, int a2, int a3, int a4, int a5);
int *__cdecl sub_10039550(int a1, unsigned int a2);
unsigned int *__cdecl sub_10039580(int a1, signed int a2, int a3);
// signed int __usercall sub_100396D0@<eax>(__int16 a1@<dx>, int a2@<edi>, int a3);
unsigned int __cdecl sub_10039780(int a1, int a2);
BOOL __cdecl sub_10039800(int a1, int a2, int a3);
// int __usercall sub_10039860@<eax>(int a1@<eax>);
void *sub_100398C0();
int *__thiscall sub_100398E0(void *this);
// signed int __usercall sub_100398F0@<eax>(int a1@<eax>, int a2, int a3);
// unsigned int __usercall sub_100399B0@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall sub_10039AA0@<eax>(int a1@<esi>, int a2, int a3);
// int __usercall sub_10039C40@<eax>(int a1@<edi>, int a2@<esi>);
int __cdecl sub_10039C90(int a1, int a2);
unsigned int __cdecl sub_10039CC0(int a1);
void *__cdecl sub_10039E40(int a1);
_DWORD *__cdecl sub_10039E90(int a1);
_DWORD *__cdecl sub_10039ED0(int a1, int a2);
// void *__usercall sub_10039F30@<eax>(int a1@<edi>);
unsigned int __cdecl sub_10039FC0(int a1, int a2, signed int a3, signed int (*a4)(), signed int (*a5)(), signed int a6, int a7, int a8, int a9);
unsigned int *__cdecl sub_1003A470(int a1, int a2, int a3, int a4, char a5, signed int (*a6)(), signed int (*a7)());
signed int __cdecl sub_1003A590(int a1, int a2, signed int a3);
// int __usercall sub_1003A6D0@<eax>(int a1@<eax>);
unsigned int __cdecl sub_1003A730(unsigned int a1);
void *__cdecl sub_1003A750(int a1, int a2);
int *__cdecl sub_1003A7D0(int a1);
signed int __cdecl sub_1003A820(int a1, int a2, unsigned int a3);
signed int __cdecl sub_1003A860(int a1, int a2);
signed int __cdecl sub_1003A890(int a1, unsigned int a2);
signed int __cdecl sub_1003A950(int a1, unsigned int a2);
void __cdecl sub_1003A9D0(int a1, unsigned int a2, int a3);
int __cdecl sub_1003AA80(int a1, int a2, int a3, int a4);
int __cdecl sub_1003AAC0(int a1, int a2, int a3, int a4);
int sub_1003AAE0();
signed int __cdecl sub_1003AB10(int a1, int a2, unsigned int a3);
signed int __cdecl sub_1003AB40(int a1, unsigned int a2);
void __cdecl sub_1003AB70(unsigned int a1, int a2);
void __cdecl sub_1003AB90(int a1, int a2);
void __cdecl sub_1003ABD0(int a1, int a2);
int __cdecl sub_1003B230(int a1, char a2);
_DWORD *__cdecl sub_1003B310(int a1, int a2);
// int __usercall sub_1003B350@<eax>(int a1@<edi>);
// int __usercall sub_1003B3C0@<eax>(int result@<eax>);
int __cdecl sub_1003B3E0(int a1, int a2, unsigned int a3);
// int __usercall sub_1003B4B0@<eax>(int a1@<eax>, signed int a2@<ebx>, signed int a3, int a4);
signed int __fastcall sub_1003B560(int a1);
// signed int __usercall sub_1003B5C0@<eax>(unsigned int *a1@<esi>);
int __cdecl sub_1003B640(int a1);
// int __usercall sub_1003B660@<eax>(int a1@<eax>, int a2);
// int __usercall sub_1003B790@<eax>(signed int a1@<eax>, int a2);
int __cdecl sub_1003B860(int a1, signed int a2);
// signed int __usercall sub_1003B940@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall sub_1003B990@<eax>(int a1@<eax>, int a2@<ecx>);
double __cdecl sub_1003BAA0(double a1);
// double __usercall sub_1003BB20@<st0>(int a1@<eax>, _DWORD *a2);
int __cdecl sub_1003BC20(int a1, int a2, _DWORD *a3, int *a4);
// double __usercall sub_1003BD30@<st0>(int a1@<edi>, int a2@<esi>);
int *sub_1003BDA0();
double __cdecl sub_1003BE10(_BYTE *a1, _DWORD *a2, _DWORD *a3);
// int __usercall sub_1003CAD0@<eax>(signed int a1@<eax>, int a2);
unsigned int __cdecl sub_1003CB60(int a1, int a2);
// int __usercall sub_1003CCD0@<eax>(_DWORD *a1@<eax>, double a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl sub_1003DB50(int, int, int, int, double); // idb
// unsigned int __usercall sub_1003DD40@<eax>(unsigned int a1@<ebx>, int a2);
_BYTE *__cdecl sub_1003DDC0(int a1, double a2);
void *sub_1003E260();
int __cdecl sub_1003E280(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_1003E2D0(int a1, unsigned int a2);
int *__cdecl sub_1003E400(int a1, int a2, size_t a3, int a4);
int *__cdecl sub_1003E510(int a1, void *a2, size_t a3, int a4);
// _DWORD *__usercall sub_1003E580@<eax>(_DWORD **a1@<esi>, int a2, int a3);
_DWORD *__cdecl sub_1003E5E0(int a1, int a2);
int *__cdecl sub_1003E630(int a1, int a2, unsigned int a3);
_DWORD *__cdecl sub_1003E6B0(_DWORD **a1);
_DWORD *__cdecl sub_1003E6D0(_DWORD **a1);
_DWORD *sub_1003E6F0();
int nullsub_9(void); // weak
void sub_1003E730();
int *__cdecl sub_1003E740(int a1, int a2);
_DWORD *__cdecl sub_1003E8A0(int a1, int a2, _DWORD **a3);
int __cdecl sub_1003E8D0(int a1, int (__cdecl *a2)(_DWORD, _DWORD, signed int));
signed int __cdecl sub_1003E9B0(int a1, int (__cdecl *a2)(int, _DWORD, int), int a3, int a4, unsigned int *a5, int a6, int *a7, int a8, int a9);
void __cdecl sub_1003ECD0(int a1, void *a2, int a3);
char **__cdecl sub_1003ED50(int a1, int a2, int a3);
_DWORD *__cdecl sub_1003ED70(int a1, int a2);
// void __usercall sub_1003EEC0(void *a1@<ebx>, int a2@<edi>, int a3@<esi>);
signed int __cdecl sub_1003EF20(int a1, int a2, char *a3, int a4);
signed int __cdecl sub_1003F020(int a1, int a2, int (__cdecl *a3)(int, _DWORD, int), int a4, int a5, int a6, int a7);
int __cdecl sub_1003F160(int a1, char a2);
int __cdecl sub_1003F180(int a1, unsigned int a2);
int *__cdecl sub_1003F1A0(int a1, unsigned int a2);
int __cdecl sub_1003F1C0(int a1, int a2);
unsigned int __cdecl sub_1003F1D0(int a1, unsigned int a2);
BOOL __cdecl sub_1003F1E0(int a1, int a2, int a3);
void *__cdecl sub_1003F200(int a1, void *a2, void *a3);
void *__cdecl sub_1003F220(int a1, void *a2);
int (__cdecl **sub_1003F250())(int, int);
void *__cdecl sub_1003F260(int a1, int (__cdecl **a2)(_DWORD, _DWORD), int a3, int a4, unsigned int a5);
int __cdecl sub_1003F300(int a1);
// _DWORD *__usercall sub_1003F360@<eax>(int a1@<edi>, int a2, unsigned int a3, int a4);
// void *__usercall sub_1003F480@<eax>(int a1@<eax>, __int16 a2@<dx>);
int __cdecl sub_1003F580(int a1, int *a2);
int __cdecl sub_1003F5C0(int a1, int (__cdecl *a2)(int, int *, int, int), int a3);
int __cdecl sub_1003F6B0(int (__cdecl **a1)(_DWORD, _DWORD), int a2, int a3, unsigned int a4);
int *__cdecl sub_1003F700(unsigned int a1);
unsigned int *__cdecl sub_1003F720(int a1, int a2, int a3);
int __cdecl sub_1003F880(int, void *, int, int, int, int, int); // idb
_DWORD *__cdecl sub_1003F940(int a1, int a2);
// signed int __usercall sub_1003F9F0@<eax>(int a1@<edx>, int a2, int a3);
// unsigned int __usercall sub_1003FB00@<eax>(int a1@<edx>, int a2@<edi>, int a3);
int __cdecl sub_1003FBB0(int a1, int a2, char a3);
signed int __cdecl sub_1003FC00(int a1, int a2, char a3, char a4, char a5);
int __cdecl sub_1003FC60(int, int, char, size_t); // idb
// const char *__usercall sub_1003FCC0@<eax>(int a1@<eax>);
// signed int __usercall sub_1003FCE0@<eax>(int a1@<eax>, int a2);
// signed int __usercall sub_1003FD00@<eax>(_DWORD *a1@<eax>);
int __cdecl sub_1003FDF0(int a1, int *a2);
// signed int __usercall sub_1003FEF0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>);
// signed int __usercall sub_1003FF50@<eax>(int a1@<edi>, int a2, _BYTE *a3, int a4, int a5);
signed int __cdecl sub_100400D0(int a1, int a2);
int __fastcall sub_10040270(int a1, int a2);
// signed int __usercall sub_100402E0@<eax>(signed int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4@<esi>);
int __cdecl sub_10040350(int a1, int a2, int a3);
// int __usercall sub_10040390@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4);
int __cdecl sub_10040400(int a1, int a2);
// signed int __usercall sub_10040440@<eax>(int a1@<eax>, signed int a2@<esi>, int a3, char a4);
int __fastcall sub_100404C0(int a1, int a2);
signed int __cdecl sub_10040510(int a1, int a2, int a3, int a4);
signed int __cdecl sub_10040580(int a1);
signed int __cdecl sub_100405B0(int a1, int a2);
int __cdecl sub_100405E0(int a1, int a2, int a3, int a4);
// signed int __usercall sub_10040620@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, char a5);
int __cdecl sub_10040680(int a1);
signed int __cdecl sub_10040690(int a1, int a2);
signed int __cdecl sub_100406F0(int a1, int a2, int a3, int a4);
signed int __cdecl sub_100407C0(int a1, int a2, int a3, _DWORD *a4);
// int __usercall sub_10040960@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, char a4);
// int __usercall sub_100409A0@<eax>(int a1@<edi>, int a2, _BYTE *a3);
signed int __cdecl sub_10040C90(int a1, _BYTE *a2, int a3, _DWORD *a4);
// int __usercall sub_10040F00@<eax>(int a1@<edi>, int a2@<esi>, double a3);
// signed int __usercall sub_10041010@<eax>(int a1@<esi>, int a2);
signed int __cdecl sub_10041100(int a1, int a2, int a3);
// signed int __usercall sub_100411C0@<eax>(int a1@<eax>, int a2);
void *__cdecl sub_10041260(int a1, int a2, void *a3, int a4);
int __cdecl sub_10041320(_BYTE *a1);
int __cdecl sub_10041370(int a1, int a2);
signed int __cdecl sub_100413C0(int a1, int a2, int a3, int a4, signed int a5);
signed int __cdecl sub_100414A0(int a1, int a2);
int __cdecl sub_100415D0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10041600(int, int, void *); // idb
int __cdecl sub_10041660(int a1, int a2);
// signed int __usercall sub_10041D80@<eax>(_DWORD *a1@<eax>, int a2@<edi>, int a3, int a4);
// signed int __usercall sub_10041EC0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, _DWORD *a4, int a5);
signed int __cdecl sub_10041F50(int a1, _BYTE *a2, int a3, int a4);
signed int __cdecl sub_10042010(int a1, int a2, int a3, signed int a4);
signed int __cdecl sub_10042060(int a1, int a2, int a3, signed int a4, signed int a5);
int __cdecl sub_100420C0(int, int, void *); // idb
int __cdecl sub_100421D0(int a1, int a2, int a3, int a4);
// int __usercall sub_100423C0@<eax>(int a1@<ebx>, int a2@<esi>, int a3, int a4);
// signed int __usercall sub_10042620@<eax>(int a1@<eax>, __int64 a2, int a3);
// signed int __usercall sub_10042F50@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>);
// signed int __usercall sub_10042FB0@<eax>(char a1@<dil>, signed int a2, int a3, int a4);
signed int __cdecl sub_100455A0(int a1);
int __cdecl sub_10045600(int a1, int a2, int a3);
BOOL __cdecl sub_100456B0(int a1, int a2);
// signed int __usercall sub_100456F0@<eax>(int a1@<esi>);
// int __usercall sub_10045980@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_100459A0@<eax>(int a1@<eax>);
// BOOL __usercall sub_100459C0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10045A10@<eax>(signed int result@<eax>, int a2@<ecx>);
// signed int __usercall sub_10045A30@<eax>(int a1@<eax>, int a2);
signed int __cdecl sub_10045A60(int a1, int a2, int a3, int a4, int a5, char a6);
signed int __cdecl sub_10045D00(int a1, int a2);
// signed int __usercall sub_10045DD0@<eax>(int a1@<ecx>, int a2@<esi>, __int16 a3);
int __cdecl sub_10045E00(int a1);
// signed int __usercall sub_10045FA0@<eax>(char a1@<sil>, int a2, int a3);
int __cdecl sub_10047550(int a1);
signed int __cdecl sub_10047570(int a1, int a2, int a3);
int __cdecl sub_100475A0(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_100475E0(int a1, int a2);
signed int __cdecl sub_10047620(int a1, int a2);
// int __usercall sub_10047640@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10047650@<eax>(int a1@<ecx>, int a2@<edi>);
// int __usercall sub_10047720@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4);
// int __usercall sub_10047750@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>, int a4, int a5, int a6);
// signed int __usercall sub_100478A0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
int __cdecl sub_10047960(unsigned int *a1);
int sub_10047AD0(void); // weak
// int __usercall sub_10047B10@<eax>(unsigned int *a1@<eax>);
// int __usercall sub_10047B30@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4@<bl>);
// signed int __usercall sub_10047B40@<eax>(int a1@<eax>, int a2@<edi>, int a3);
// int __usercall sub_10047B90@<eax>(int a1@<eax>, char a2@<sil>, int a3, int *a4);
// int __usercall sub_10047C50@<eax>(int result@<eax>, int a2, int a3, int a4, char a5);
// int __usercall sub_10047CB0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int a4@<edi>, _DWORD *a5, int a6, int a7);
// signed int __usercall sub_10047DC0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
// int __usercall sub_10047E40@<eax>(int a1@<esi>, int a2, int a3, int *a4, int a5);
signed int __cdecl sub_100481E0(int a1);
// signed int __usercall sub_100482B0@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>);
// signed int __usercall sub_10048350@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>, int a4, int a5, int a6);
signed int __cdecl sub_100485B0(signed int a1, int a2, int a3);
_DWORD __cdecl sub_10048CA0(_DWORD); // weak
// int __usercall sub_10048DA0@<eax>(char a1@<sil>, int a2, int a3, int *a4);
// int __usercall sub_10048FE0@<eax>(int a1@<ebx>, int a2@<edi>, char a3@<sil>, int *a4);
// int __usercall sub_10049060@<eax>(int a1@<eax>, int a2@<ecx>, char a3@<sil>, int *a4);
// int __usercall sub_100490E0@<eax>(int a1@<ebx>, int a2@<edi>, char a3@<sil>, int *a4);
// int __usercall sub_10049150@<eax>(int a1@<eax>, int a2@<ecx>, char a3@<sil>, int *a4);
// int __usercall sub_10049230@<eax>(int a1@<ebx>, int a2@<edi>, char a3@<sil>, int *a4);
// int __usercall sub_100492A0@<eax>(int a1@<eax>, int a2@<ecx>, char a3@<sil>, int *a4);
// int __usercall sub_10049300@<eax>(int *a1@<ebx>, int a2@<edi>, char a3@<sil>, int a4);
// int __usercall sub_10049360@<eax>(int *a1@<eax>, int a2@<ecx>, char a3@<sil>, int a4);
// int __usercall sub_100493C0@<eax>(char a1@<sil>, int a2, int a3, int *a4);
// int __usercall sub_10049420@<eax>(char a1@<sil>, int a2, int a3, int *a4);
// int __usercall sub_10049480@<eax>(int a1@<eax>, int *a2@<ebx>, char a3@<sil>, int a4);
// int __usercall sub_10049560@<eax>(char a1@<sil>, int a2, int a3, int *a4);
// int __usercall sub_100496B0@<eax>(int a1@<eax>, char a2@<bl>, int a3, int a4);
// int __usercall sub_10049BF0@<eax>(char a1@<sil>, int a2, int a3, int a4);
int __cdecl sub_1004AC90(int a1, int a2, int a3);
_DWORD *__cdecl sub_1004AE20(int a1, int a2, int a3);
signed int __cdecl sub_1004AF40(int a1, int a2, int a3, int a4);
// unsigned int *__usercall sub_1004B030@<eax>(int a1@<eax>, int a2, int a3, unsigned int *a4);
int __cdecl sub_1004B0E0(int a1, int a2, int a3);
// int __usercall sub_1004B250@<eax>(char a1@<bl>, int a2, int a3, int a4, int a5);
// int __usercall sub_1004B7E0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4@<bl>);
int __cdecl sub_1004B7F0(int a1, int a2, int *a3);
// int __usercall sub_1004BF50@<eax>(_BYTE *a1@<eax>, int a2@<ecx>);
// signed int __usercall sub_1004BFA0@<eax>(int a1@<esi>, int a2);
// signed int __usercall sub_1004C040@<eax>(int a1@<eax>, size_t a2@<ebx>, void *a3);
// signed int __usercall sub_1004C090@<eax>(_DWORD *a1@<eax>, char *a2, char a3);
// int __usercall sub_1004C0F0@<eax>(int a1@<eax>, int a2, __int16 a3);
int __cdecl sub_1004C310(int a1, int a2, __int16 a3);
int __cdecl sub_1004C3A0(int a1, int a2, unsigned int a3, char a4);
int *__cdecl sub_1004C450(unsigned int a1);
int __cdecl sub_1004C470(int a1);
size_t __cdecl sub_1004C4D0(int a1, void *a2, char a3);
BOOL __cdecl sub_1004C5E0(int a1, const char *a2);
// signed int __usercall sub_1004C620@<eax>(int a1@<eax>, int a2@<ebx>, int a3);
// signed int __usercall sub_1004C690@<eax>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_1004C700(int a1, int a2);
// signed int __usercall sub_1004C720@<eax>(int a1@<ebx>, int a2, unsigned int a3, int a4, int a5, int a6, int a7);
// int __usercall sub_1004C950@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// void *__usercall sub_1004C9A0@<eax>(unsigned __int8 *a1@<eax>);
int __cdecl sub_1004CA00(int a1, int a2);
// int __usercall sub_1004CA20@<eax>(char a1@<bpl>, int a2, int a3);
signed int __cdecl sub_1004CCA0(int a1, unsigned int a2, int a3);
signed int __cdecl sub_1004F7C0(int *a1, int a2, unsigned int a3, int a4);
_BYTE *__cdecl sub_1004F8E0(int a1, int a2, signed int a3, _BYTE *a4);
// int __usercall sub_1004FBA0@<eax>(int a1@<eax>, int (__cdecl **a2)(_DWORD, _DWORD, _DWORD)@<esi>, int a3, int a4, char a5);
// int __usercall sub_1004FC30@<eax>(int a1@<edx>, int a2@<ecx>, int (__cdecl **a3)(_DWORD, _DWORD, _DWORD)@<esi>, int a4, int a5, char a6, char a7);
// unsigned int __usercall sub_1004FDA0@<eax>(unsigned int a1@<edx>, int (__cdecl **a2)(_DWORD, _DWORD, _DWORD)@<ecx>, int a3@<ebx>, unsigned int a4, int a5, char a6, char a7, int a8);
int __cdecl sub_1004FE50(int (__cdecl **a1)(_DWORD, _DWORD, _DWORD), __int64 a2, int a3, int a4, unsigned int a5, char a6, char a7, int a8);
// int __usercall sub_1004FF50@<eax>(void *a1@<ecx>, int (__cdecl **a2)(_DWORD, _DWORD, _DWORD)@<edi>, double a3, int a4);
// int __usercall sub_10050000@<eax>(int a1@<edx>, const char *a2@<edi>, int (__cdecl **a3)(_DWORD, _DWORD, _DWORD), int a4, char a5);
// int __usercall sub_10050060@<eax>(int a1@<eax>, char *a2@<edi>, _DWORD *a3, int a4);
// int __usercall sub_10050380@<eax>(int a1@<edx>, char *a2@<ecx>, int a3);
signed int __cdecl sub_10050930(int a1, _BYTE *a2, unsigned int a3);
unsigned int __cdecl sub_100509D0(char *a1, int a2);
int __cdecl sub_10050A30(int a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_10050A70(int a1, int a2, char *a3, int a4);
unsigned int __cdecl sub_10050AE0(char *a1, char a2);
int __cdecl sub_10050B00(int a1, int a2, char *a3, char a4);
int __cdecl sub_10050B30(int a1, int a2, int a3);
// signed int __usercall sub_10050BB0@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5);
void __cdecl sub_10050C60(int a1, int a2);
signed int __cdecl sub_10050CA0(int a1, int a2, signed int a3, int *a4);
signed int __cdecl sub_10050D30(int a1, int a2);
// signed int __usercall sub_10050D60@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
char *__cdecl sub_10050E30(int a1, int a2, int a3);
signed int __cdecl sub_10050E90(int a1, int a2, int a3, __int32 *a4);
// signed int __usercall sub_10050F10@<eax>(char a1@<bl>, int a2, int a3, int a4, _DWORD *a5);
signed int __cdecl sub_10050FD0(int a1, int a2, int a3);
// int __usercall sub_10051030@<eax>(char a1@<sil>, int a2, int a3, int a4, signed int *a5, int *a6);
int __cdecl sub_10051170(int a1, unsigned int a2);
int *__cdecl sub_10051190(int a1, unsigned int a2);
int sub_100511B0();
int *__cdecl sub_100511D0(int a1, unsigned int a2, int a3);
int __cdecl sub_100511F0(unsigned int a1, int a2, int a3, int a4, int (__cdecl **a5)(int, int), int a6);
int __cdecl sub_100512D0(int a1);
_DWORD *__cdecl sub_10051360(int a1, int a2, int a3);
int __cdecl sub_100513D0(int a1, _DWORD *a2, int a3, int a4, int a5);
void *__cdecl sub_100514E0(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_100515D0(int a1, int (__cdecl *a2)(_DWORD *, int, int), int a3);
unsigned int __cdecl sub_10051690(_BYTE *a1);
BOOL __cdecl sub_100516C0(int a1, int a2);
// int __usercall sub_100516D0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>);
signed int __cdecl sub_10051700(int a1, int a2, int a3);
// int *__usercall sub_10051730@<eax>(int a1@<edi>, unsigned int a2@<esi>);
int *__cdecl sub_10051760(int a1, int *a2);
int *__cdecl sub_100517A0(int a1);
int __cdecl sub_100517E0(int a1, int a2, int a3, int *a4);
int __cdecl sub_10051830(int a1);
// int __usercall sub_10051860@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>);
int __cdecl sub_10051890(int a1, int a2, int a3);
int __cdecl sub_100518B0(int a1, int a2, int a3);
int __cdecl sub_10051900(int a1, int a2);
int __cdecl sub_10051930(int a1, int a2);
int __cdecl sub_10051980(int a1, int a2, int a3);
// _DWORD *__usercall sub_100519C0@<eax>(int a1@<ebx>, unsigned int a2@<esi>);
_DWORD *__cdecl sub_10051A40(int a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_10051BC0(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
_DWORD *(__cdecl *__cdecl sub_10051C00(int a1, signed int a2, char a3, int a4))(int a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_10051C70(int a1, _DWORD *a2, signed int a3, int a4, int a5);
_DWORD *__cdecl sub_10051F80(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
signed int __cdecl sub_10052020(int a1, int a2);
signed int __cdecl sub_10052070(int a1);
signed int __cdecl sub_10052100(int a1, _DWORD *a2);
int __cdecl sub_10052190(int, void *, size_t); // idb
int __cdecl sub_100521F0(int, void *, size_t); // idb
int __cdecl sub_10052290(int a1, int a2);
signed int __cdecl sub_10052320(int a1, int a2, int a3);
int __cdecl sub_100524F0(int a1);
int *__cdecl sub_10052500(int a1);
int __cdecl sub_10052520(int a1, int *a2);
signed int __cdecl sub_10052560(int a1, int a2, int a3);
signed int __cdecl sub_100525F0(char *a1, unsigned int *a2);
int __cdecl sub_100526B0(char *a1, unsigned int *a2);
int __cdecl sub_10052700(unsigned int a1, int *a2);
int __cdecl sub_100528A0(unsigned int a1, int *a2);
int __cdecl sub_100528F0(int a1, double **a2);
signed int __cdecl sub_10052970(_DWORD *a1, signed int *a2);
signed int __cdecl sub_10052B60(int a1, int *a2, _DWORD *a3);
unsigned int __cdecl sub_10052C00(int a1, const char *a2);
int __cdecl sub_10052CE0(int a1, int a2);
int __cdecl sub_10052D00(int a1, _BYTE *a2);
int __cdecl sub_10052D40(int a1, _WORD *a2);
signed int __cdecl sub_10052D80(unsigned int a1);
void __cdecl sub_10052DD0(double a1, double a2);
double __cdecl sub_10052DF0(double a1, double a2);
void __cdecl sub_10052E20(double a1, double a2);
double __cdecl sub_10052E40(double a1, double a2);
double __cdecl sub_100530E0(double a1, double a2);
double __cdecl sub_100537F0(double a1);
double __cdecl sub_10053810(double a1);
double __cdecl sub_100539B0(double a1, int a2);
void __cdecl sub_10053AC0(double a1);
double __cdecl sub_10053AE0(double a1);
int __cdecl sub_10053CF0(unsigned int a1, unsigned int a2);
void *__cdecl sub_10053DA0(unsigned int a1, unsigned int a2, unsigned int a3);
int *__cdecl sub_10053E10(unsigned int a1, unsigned int a2);
int __cdecl sub_10053EA0(int, void *); // idb
void *__cdecl sub_10053FC0(void *a1, unsigned int a2, unsigned int a3);
unsigned int __cdecl sub_100540D0(int a1);
__int16 *sub_10054250();
int __cdecl sub_100542D0(unsigned int a1, unsigned int a2);
int *__cdecl sub_10054490(unsigned int a1, unsigned int a2);
int __cdecl sub_10054560(int a1, unsigned int a2, unsigned int a3);
void *__cdecl sub_100546E0(void *a1, unsigned int a2, unsigned int a3);
int __cdecl sub_10054920(int a1, int a2, unsigned int a3);
unsigned int __cdecl sub_100549D0(unsigned int a1, int a2, unsigned int a3);
// char __usercall sub_10054B20@<al>(int a1@<ebx>, int a2@<esi>, int a3, _WORD *a4);
// char __usercall sub_10054CD0@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5);
// char __usercall sub_10054EA0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
// char __usercall sub_10054F30@<al>(int a1@<edx>, const void *a2@<ecx>, int a3, int a4, int a5);
// int __usercall sub_10055130@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
// int __usercall sub_100552F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, float a4);
// int __usercall sub_10055350@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// char __usercall sub_100556E0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4);
char __cdecl sub_10055B70(int a1, int a2, _WORD *a3, int a4, _WORD *a5);
// char __usercall sub_10055D20@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5);
// char __usercall sub_10055EF0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// char __usercall sub_10056070@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, const void *a5);
// __int16 __usercall sub_10056200@<ax>(int a1@<edi>, int a2, int a3);
// int __usercall sub_10056330@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>, _BYTE *a4);
// int __usercall sub_100563C0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, float a4);
void __cdecl sub_10056420(int a1, int a2, int a3, int a4, float a5, float a6);
// signed int __usercall sub_100566F0@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// int __usercall sub_100569B0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, __int16 *a4);
// void __usercall sub_10056D50(int a1@<esi>, int a2, int a3, int a4);
char __cdecl sub_10056E50(int a1, int a2, __int16 *a3, int a4, _WORD *a5);
// char __usercall sub_10057020@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// unsigned __int8 __usercall sub_100573C0@<al>(int a1@<eax>, int a2@<ecx>, int a3, _BYTE *a4, _WORD *a5);
// unsigned __int8 __usercall sub_10057450@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
char __cdecl sub_10057750(int a1, int a2, int a3, int a4, _WORD *a5);
// int __usercall sub_100578B0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// char __usercall sub_10057B70@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5);
// char __usercall sub_10057DF0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, int a5);
// int __usercall sub_10057EB0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// int __usercall sub_10058160@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
// int __usercall sub_10058240@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>, float a4);
// int __usercall sub_10058350@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4);
// signed int __usercall sub_100588B0@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4);
// signed int __usercall sub_10059450@<eax>(int a1@<eax>, int a2@<esi>, int a3, __int16 *a4);
char __cdecl sub_1005A000(int a1, int a2, int *a3, int a4, _WORD *a5);
// int __usercall sub_1005A230@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4, int a5);
// char __usercall sub_1005A780@<al>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5);
// int __usercall sub_1005A8F0@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4);
char __cdecl sub_1005A9F0(int a1, int a2, int a3, int a4, _WORD *a5);
// __int16 __usercall sub_1005AB70@<ax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4);
// signed __int16 __usercall sub_1005ABC0@<ax>(int a1@<edx>, int a2, int a3, __int16 a4, __int16 a5);
// int __usercall sub_1005AD20@<eax>(int a1@<edx>, int a2, int a3, __int16 a4, __int16 a5);
// signed __int16 __usercall sub_1005AF30@<ax>(int a1@<eax>, int a2, int a3);
// char __usercall sub_1005AF80@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5);
// char __usercall sub_1005B160@<al>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4, int a5);
// char __usercall sub_1005B230@<al>(int a1@<edx>, int a2@<ecx>, int a3, const void *a4, int a5);
// int __usercall sub_1005B3B0@<eax>(int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1005B400@<eax>(int *a1@<eax>, int a2@<ecx>, int a3);
double __cdecl sub_1005B440(float a1);
signed int __cdecl sub_1005B4B0(int a1, int a2, int a3, int a4);
// signed int __usercall sub_1005B7A0@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4);
char __cdecl sub_1005BAE0(int a1, int a2, int *a3, int a4, _WORD *a5);
int __cdecl sub_1005BCC0(int a1, __int16 a2, __int16 a3, int a4);
char *__cdecl sub_1005BD10(int a1, int a2, _BYTE *a3);
int __cdecl sub_1005C100(unsigned __int8 a1, int a2, int a3);
char __cdecl sub_1005C160(int a1, const void *a2, int a3);
int __cdecl sub_1005C440(unsigned __int8 a1, int a2);
char *__cdecl sub_1005C490(unsigned __int8 a1, _BYTE *a2);
// _WORD *__usercall sub_1005C6E0@<eax>(_WORD *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, __int16 a5);
// __int16 __usercall sub_1005C720@<ax>(int a1@<eax>, _WORD *a2@<ecx>, int a3, int a4);
// int __usercall sub_1005C840@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
// __int16 __usercall sub_1005C870@<ax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, int a5, __int16 a6, __int16 a7);
// char __usercall sub_1005C900@<al>(__int16 a1@<ax>, int a2@<edx>, int a3, int a4);
// signed int __usercall sub_1005C930@<eax>(__int16 a1@<ax>, int a2@<ecx>, int a3@<edi>, char a4, char a5);
// BOOL __usercall sub_1005C9A0@<eax>(int a1@<eax>, int a2@<ecx>);
// __int16 __usercall sub_1005C9D0@<ax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, int a5, int a6, __int16 a7);
// unsigned int __usercall sub_1005CC40@<eax>(_WORD *a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
__int16 __cdecl sub_1005CED0(int a1, int a2, int a3, __int16 a4);
// __int16 __usercall sub_1005CFD0@<ax>(int a1@<eax>, int a2, int a3, __int16 a4);
char __cdecl sub_1005D0F0(int a1, int a2, int a3, __int16 a4);
// __int16 __usercall sub_1005D1D0@<ax>(__int16 a1@<bx>, int a2@<edi>, int a3@<esi>, int a4);
int __cdecl sub_1005D210(int a1, int a2, int a3, int a4, int a5, int a6, char a7);
char __cdecl sub_1005D5D0(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_1005D800(int a1, int a2, int a3, int a4, __int16 *a5);
// char __usercall sub_1005DCD0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, const char *a4, char a5);
// char __usercall sub_1005DD70@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
char __cdecl sub_1005E1B0(int a1, int a2, int a3, __int16 *a4, int a5);
char __cdecl sub_1005E1F0(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_1005E210(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// char __usercall sub_1005E6F0@<al>(int a1@<eax>, char *a2@<ecx>);
// char __usercall sub_1005E750@<al>(int a1@<esi>, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1005E8A0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1005EBB0(unsigned int a1, char a2);
char __cdecl sub_1005EC10(signed __int16 *a1, _BYTE *a2);
// __int16 __usercall sub_1005EC80@<ax>(int a1@<eax>, int a2@<esi>, unsigned int a3);
// char *__usercall sub_1005ECE0@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4);
// int __usercall sub_1005EDA0@<eax>(unsigned int a1@<eax>, char a2@<cl>);
// char __usercall sub_1005EE10@<al>(int *a1@<ebx>, int a2@<edi>, _DWORD *a3);
// char __usercall sub_1005EE80@<al>(signed int *a1@<ecx>, int a2@<ebx>, int a3, int a4);
char __cdecl sub_1005F070(signed __int16 *a1, _BYTE *a2);
// char __usercall sub_1005F0F0@<al>(int a1@<eax>, int a2@<ecx>, signed int *a3, int a4);
// char __usercall sub_1005F8E0@<al>(char *a1@<eax>, signed int *a2@<edx>, int a3, _BYTE *a4);
// char __usercall sub_1005FDE0@<al>(signed int *a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>);
char __cdecl sub_1005FEA0(int a1, int a2, int *a3, signed int *a4, int a5);
// char __usercall sub_100609A0@<al>(signed int *a1@<eax>, int a2@<edi>, int a3@<esi>);
char __cdecl sub_100609F0(int a1);
// char __usercall sub_10060A50@<al>(float *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// char __usercall sub_10060A70@<al>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
char __cdecl sub_10060D00(int a1, int a2, int a3, float *a4, int a5);
double __cdecl sub_10061190(float a1, float a2);
double __cdecl sub_100611B0(float a1, float a2);
signed int __fastcall sub_100611D0(int a1);
// char __usercall sub_100611F0@<al>(int a1@<eax>, float *a2@<edi>, int a3);
char __cdecl sub_10061300(int a1);
// char __usercall sub_10061360@<al>(int a1@<ecx>, float *a2@<edi>, int a3@<esi>, int a4);
int __cdecl sub_100613D0(float); // idb
// char __usercall sub_10061410@<al>(int a1@<eax>, int a2, int a3);
char __cdecl sub_100618E0(int a1, int a2, int *a3, float *a4, int a5);
// int __usercall sub_10061F30@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
char __cdecl sub_10062310(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_10062350@<al>(unsigned __int8 a1@<al>, unsigned __int8 a2, int a3);
// char *__usercall sub_100623D0@<eax>(int a1@<ecx>, int a2@<esi>, int a3);
// char __usercall sub_10062450@<al>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_100628B0@<eax>(char a1@<dl>, int a2@<esi>, const char *a3, int *a4);
// int __usercall sub_10062A50@<eax>(int a1@<edx>, char *a2@<ecx>, char *a3, unsigned int a4, __int16 a5);
// int __usercall sub_10062DA0@<eax>(int a1@<eax>, int a2, void *a3, int a4, int a5);
// int __usercall sub_10063100@<eax>(void *a1@<ecx>, char *a2@<ebx>, int a3);
// int __usercall sub_10063130@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, char *a5, char *a6);
// char __usercall sub_100631D0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// char __usercall sub_10063AD0@<al>(_WORD *a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
char __cdecl sub_10063EF0(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10063F20(int a1, int a2, int a3);
char __cdecl sub_10063FF0(int a1, int a2, int a3, float *a4);
// char __usercall sub_100641E0@<al>(_DWORD *a1@<eax>, int a2@<ebx>, int a3@<esi>);
// char __usercall sub_10064250@<al>(int a1@<eax>, int a2@<ecx>, int a3);
char __cdecl sub_10064510(int a1, int a2);
char __cdecl sub_10064570(int a1, int a2, int *a3, float *a4, int a5);
// char __usercall sub_10064A20@<al>(_WORD *a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, _WORD *a5);
char __cdecl sub_10064B50(int a1, int a2, int a3, _WORD *a4, int a5);
char __cdecl sub_10064DE0(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_10064F30@<al>(int a1@<edx>, int a2@<esi>, int a3, int *a4, int a5);
char __cdecl sub_10064FE0(unsigned int a1, int a2, int *a3, int a4, int a5);
int __cdecl sub_100651F0(unsigned int a1, unsigned __int8 a2);
int __cdecl sub_10065250(int, char *, char); // idb
// int __usercall sub_100652B0@<eax>(int a1@<eax>, int a2);
// char *__usercall sub_10065300@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4);
// char *__usercall sub_100653A0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_10065480@<al>(int a1@<eax>, int a2@<edi>, int a3);
// char __usercall sub_10065790@<al>(int a1@<edi>, int a2@<esi>, int a3);
// char __usercall sub_100659A0@<al>(int a1@<edi>, int a2@<esi>, int a3, unsigned int *a4);
char __cdecl sub_10065B00(int a1, int a2, int a3, unsigned int *a4, int a5);
// char __usercall sub_100663E0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, _WORD *a5);
char __cdecl sub_10066540(int a1, int a2, int *a3, int a4, int a5);
char __cdecl sub_100666E0(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10066790(int a1, int a2, int a3, _WORD *a4, _WORD *a5);
char __cdecl sub_10066810(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_10066940@<al>(unsigned __int16 *a1@<eax>, int a2@<ebx>, int a3@<edi>, unsigned int a4@<esi>, int a5);
char __cdecl sub_100669D0(int a1, int a2, int *a3, int a4, _WORD *a5);
char __cdecl sub_10066B70(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
// int __usercall sub_10066DF0@<eax>(int a1@<eax>, int a2@<ecx>);
// char *__usercall sub_10066E30@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
int __fastcall sub_10066FA0(int a1, int a2);
// char __usercall sub_10066FF0@<al>(int a1@<eax>, int a2@<ecx>);
// char __usercall sub_10067050@<al>(int a1@<esi>, int a2, int a3);
char __thiscall sub_100671E0(int this);
// int __usercall sub_10067200@<eax>(int a1@<ecx>, int *a2@<ebx>, int a3@<edi>, int *a4@<esi>, _BYTE *a5, char a6);
// int __usercall sub_10067270@<eax>(_WORD *a1@<edx>, int a2@<ecx>, int a3, char a4, char *a5, int a6, int a7, int a8);
// char __usercall sub_100676A0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
char __cdecl sub_10067720(int a1, int a2, _WORD *a3, int *a4, int a5);
int __cdecl sub_10068190(int a1, int a2);
// int __usercall sub_10068230@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>);
char __cdecl sub_100682F0(int a1, int a2, int a3);
void __cdecl sub_100683C0(int a1, int a2, unsigned __int8 a3);
void __cdecl sub_10068420(char *a1, char *a2, int a3, char a4, char a5, char a6, char a7);
// void __usercall sub_10068A10(double *a1@<eax>, char a2@<dl>, double *a3@<ecx>, char a4);
void __cdecl sub_10068A70(int a1, int a2, int a3, char a4, char a5, char a6, char a7);
char sub_10068E60();
char __cdecl sub_10068E70(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
void *__cdecl sub_10068FA0(int a1, __int16 a2);
char __cdecl sub_10068FD0(int a1, int a2, char *a3);
int __cdecl sub_10069030(int a1, int a2, int a3, signed int a4, int a5);
// char __usercall sub_10069180@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// char __usercall sub_10069240@<al>(unsigned __int16 a1@<di>, int a2);
// signed int __usercall sub_100692A0@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3);
signed int __cdecl sub_10069400(int a1, int a2, signed int a3);
char __cdecl sub_10069460(int a1, int a2, int a3, char *a4);
char __cdecl sub_100696C0(int a1, int a2, int a3, char *a4);
char __cdecl sub_100698B0(int a1, int a2, int a3, char *a4, int a5);
char __cdecl sub_10069B10(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10069D40(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
int __cdecl sub_10069E20(unsigned int a1, char a2, int a3, int a4);
char __cdecl sub_10069E80(int a1, int a2, int a3, double *a4);
// char __usercall sub_1006A380@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_1006A460@<al>(int a1@<eax>, int a2, int a3, int a4);
// char __usercall sub_1006AF30@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5);
// char __usercall sub_1006AFF0@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4);
char __cdecl sub_1006B030(int a1, int a2, int *a3, float *a4, int a5);
// void *__usercall sub_1006B920@<eax>(int a1@<ecx>, int a2@<esi>, unsigned int *a3);
// int __usercall sub_1006B9F0@<eax>(unsigned int a1@<eax>, int a2@<esi>, char a3, int a4);
// signed int __usercall sub_1006BA40@<eax>(int a1@<eax>, void *a2@<ecx>, unsigned int *a3, int a4);
// unsigned int __usercall sub_1006BBC0@<eax>(int a1@<ebx>, int a2, unsigned int *a3);
// char __usercall sub_1006BD10@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>);
// char __usercall sub_1006BD70@<al>(int a1@<ebx>, int a2@<edi>, int a3, unsigned int *a4);
// char __usercall sub_1006BE10@<al>(unsigned int *a1@<edx>, int a2@<ecx>, int a3@<edi>);
// int __usercall sub_1006BEA0@<eax>(int a1@<eax>, void *a2@<ecx>, int a3, int a4);
char __cdecl sub_1006C060(int a1, int a2, __int64 a3, int a4);
char __cdecl sub_1006C4E0(int a1, int a2, int *a3, int a4, int a5);
// int __usercall sub_1006C550@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_1006C630(int a1, int a2, int a3, int a4, _WORD *a5);
// unsigned int *__usercall sub_1006CBE0@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3);
char __cdecl sub_1006CC90(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
_DWORD *__cdecl sub_1006CD30(int a1, char *a2, int a3, _DWORD *a4);
char __cdecl sub_1006CDB0(int a1, _WORD *a2, char **a3, int a4, int a5, int a6);
bool __cdecl sub_1006CED0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
int __cdecl sub_1006CFD0(unsigned int a1);
int *__cdecl sub_1006D000(unsigned int a1);
int __cdecl sub_1006D020(unsigned int a1);
signed int __cdecl sub_1006D040(__int16 a1);
signed int __cdecl sub_1006D070(int a1);
void *sub_1006D0A0();
// _BYTE *__usercall sub_1006D0B0@<eax>(_BYTE *a1@<eax>);
// char __usercall sub_1006D0E0@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
// char __usercall sub_1006D130@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7);
__int16 __cdecl sub_1006D630(_BYTE *a1, unsigned int a2);
int __cdecl sub_1006D690(unsigned int a1, unsigned int a2, float *a3);
int sub_1006D6C0();
int __cdecl sub_1006D760(int a1, int a2, int a3, unsigned __int8 a4);
char __cdecl sub_1006D8E0(int a1, const char *a2, int *a3);
int __cdecl sub_1006D920(unsigned int a1, char a2);
char __cdecl sub_1006D980(int a1, const char *a2, int *a3, int a4);
int __cdecl sub_1006DB90(int a1, int a2, unsigned int a3, int a4);
__int16 __cdecl sub_1006DC60(char *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_1006DCF0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7);
void __cdecl sub_1006DF10(int a1, int (__cdecl *a2)(int));
void sub_1006DF50();
// unsigned int __usercall sub_1006DF60@<eax>(unsigned int result@<eax>);
// int __usercall sub_1006DFA0@<eax>(int result@<eax>);
void __cdecl sub_1006DFD0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5);
void __cdecl sub_1006E380(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4);
char __cdecl sub_1006E3A0(char a1, char a2, char a3);
int __cdecl sub_1006E3E0(unsigned __int16 a1, char a2, int a3);
int sub_1006E4B0();
void sub_1006E510();
int sub_1006E520();
void *__cdecl sub_1006E530(void *a1);
int __cdecl sub_1006E570(double *a1, int a2);
void __cdecl sub_1006E6F0(long double *a1, int a2, float *a3, float *a4, float *a5);
int __cdecl sub_1006E9E0(int a1, int a2);
int __cdecl sub_1006EB10(int a1, int a2);
void __cdecl sub_1006EC20(int a1, int a2);
char __cdecl sub_1006ED30(int a1, int a2);
void __cdecl sub_1006EE10(int a1, int a2, float *a3, float *a4, float *a5);
char __cdecl sub_1006F0F0(int a1, int a2);
unsigned int __cdecl sub_1006F1A0(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_1006F210(int, int, int, int, int, char, char *); // idb
int __cdecl sub_1006F7A0(int a1);
double __cdecl sub_1006F830(double *a1, double *a2, double *a3, float *a4, float *a5);
int __cdecl sub_1006F8D0(_BYTE *a1);
int __cdecl sub_1006F8F0(char a1);
char __cdecl sub_1006F920(__int16 a1);
int __cdecl sub_1006F960(char a1);
char __cdecl sub_1006F990(__int16 a1);
int __cdecl sub_1006F9D0(int a1, int a2, double *a3);
char __cdecl sub_1006FAD0(const void *a1);
void __cdecl sub_1006FB40(const char *a1, unsigned int a2, int a3);
void __cdecl sub_1006FB90(const char *a1, char a2, char a3);
int __cdecl sub_1006FBE0(int a1, _BYTE *a2, int a3);
signed int __cdecl sub_1006FC30(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_1006FCA0(void *, size_t); // idb
int __cdecl sub_1006FCD0(int, char *, int); // idb
int __cdecl sub_1006FD30(char *, size_t, char *, va_list); // idb
int sub_1006FD70(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1006FDA0(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_1006FDE0(int a1, int a2);
char __cdecl sub_1006FE00(_BYTE *a1);
char __thiscall sub_1006FF40(void *this);
char __thiscall sub_1006FF70(void *this);
char __fastcall sub_1006FFA0(int a1);
char __thiscall sub_10070010(void *this);
char __fastcall sub_10070040(int a1);
char sub_10070090();
char __thiscall sub_100700A0(void *this);
BOOL __thiscall sub_10070100(void *this);
char __fastcall sub_10070120(int a1);
char __thiscall sub_10070170(void *this);
char __thiscall sub_100701A0(void *this);
char __fastcall sub_100701D0(int a1);
bool __thiscall sub_10070220(void *this);
char __thiscall sub_100702F0(void *this);
char __thiscall sub_10070320(void *this);
int sub_10070350();
char __thiscall sub_10070380(void *this);
char __fastcall sub_100703B0(int a1);
char __cdecl sub_10070400(int a1);
int __cdecl sub_10070420(int a1, char *a2);
char __thiscall sub_10070480(void *this);
char __thiscall sub_100704A0(void *this);
char __thiscall sub_100704C0(void *this);
char __thiscall sub_100704E0(void *this);
bool sub_10070500();
char __thiscall sub_10070580(void *this);
char sub_100705A0();
void *__thiscall sub_100705C0(void *this);
char __cdecl sub_100705E0(int a1, int a2, int a3);
char __cdecl sub_10070610(int a1, _WORD *a2, int a3);
__int16 __cdecl sub_10070640(unsigned int a1);
bool __cdecl sub_10070660(char *a1, int *a2, _DWORD *a3);
char __cdecl sub_100706B0(int a1, char *a2);
int __cdecl sub_10070710(int a1, int a2, char *a3, int a4);
char __cdecl sub_10070780(int a1, char *a2, _WORD *a3);
int __cdecl sub_10070830(unsigned __int16 a1);
char *__cdecl sub_10070850(unsigned __int16 a1);
char *__cdecl sub_10070890(int a1, char *a2, int a3, char *a4, int a5);
char sub_100709C0();
char __cdecl sub_100709D0(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10070AD0(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10070B40(int a1);
int __cdecl sub_10070BC0(int *a1);
// char __usercall sub_10070BF0@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10070CA0(const char *a1);
char __cdecl sub_10070CE0(void *a1);
signed int __cdecl sub_10070D30(unsigned int a1, int a2);
char **sub_100710D0();
int __cdecl sub_100710E0(_DWORD); // weak
int sub_100710F0(void); // weak
int __cdecl sub_10071100(int a1);
int __cdecl sub_10071110(int a1);
char sub_10071120();
_DWORD *__cdecl sub_10071150(_DWORD *a1);
int *__cdecl sub_10071160(int *a1, int a2);
_DWORD *__cdecl sub_10071190(_DWORD *a1, int a2);
char __cdecl sub_100711A0(char a1);
char __cdecl sub_100711E0(char a1);
signed int __cdecl sub_10071250(char a1);
char __cdecl sub_100712D0(char a1);
char __cdecl sub_10071340(char a1);
char __cdecl sub_100713F0(int a1);
char __thiscall sub_100714F0(void *this);
char __cdecl sub_10071500(char a1, unsigned __int16 a2, char a3);
signed int __cdecl sub_10071530(int (__cdecl *a1)(int));
char *__cdecl sub_10071560(unsigned __int8 a1);
int __cdecl sub_10071590(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10071720(_DWORD *a1, unsigned int a2, int a3, int a4, int a5);
signed int __cdecl sub_10071840(unsigned int a1);
bool __cdecl sub_10071860(unsigned int a1, _DWORD *a2);
signed int __cdecl sub_100718C0(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10071920(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_10071940(int a1, unsigned int a2, unsigned int a3);
signed int __cdecl sub_10071AB0(int a1);
unsigned int __cdecl sub_10071AF0(unsigned int a1);
int __cdecl sub_10071B10(int a1);
bool __cdecl sub_10071B20(int a1);
int __cdecl sub_10071BF0(int a1);
int __cdecl sub_10071C10(int a1, int a2);
bool __cdecl sub_10071C50(int a1);
signed int __cdecl sub_10071CB0(int a1, void *a2, unsigned __int16 a3, __int16 a4);
signed int __cdecl sub_10071D70(int a1, int a2, int a3);
int __cdecl sub_10071E20(int a1);
signed int __cdecl sub_10071E40(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall sub_10071EA0@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_10071FB0@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10072060@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10072230@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10072240@<eax>(int result@<eax>);
// char __usercall sub_10072260@<al>(int a1@<eax>);
// unsigned int __usercall sub_10072280@<eax>(int a1@<esi>, unsigned __int8 a2);
int __cdecl sub_100722C0(unsigned int a1);
int __fastcall sub_10072470(int a1, int a2);
// int __usercall sub_10072490@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_100724A0@<eax>(int a1@<esi>);
// signed int __usercall sub_100724E0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_100726F0(void *); // idb
int __cdecl sub_10072750(int, int, void *, int); // idb
signed int __cdecl sub_10072850(int a1, unsigned __int64 a2);
signed int __cdecl sub_10072A50(int a1, int a2);
int __cdecl sub_10072A70(int a1);
signed int __cdecl sub_10072CE0(int a1, unsigned int a2, unsigned int *a3);
int __cdecl sub_10072D70(void *, int, char); // idb
signed int __cdecl sub_10072E40(unsigned int a1, int a2, int a3);
// unsigned int __usercall sub_10072EE0@<eax>(int a1@<eax>);
// unsigned int __usercall sub_10072F00@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10072F30@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl sub_10072FA0(int, char *, int); // idb
// void __cdecl __noreturn exit(int);
signed int __cdecl sub_10073110(int a1);
// char __usercall sub_10073170@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_100731A0@<eax>(int a1@<eax>);
// BOOL __usercall sub_100731D0@<eax>(int a1@<ebx>, int a2);
signed int __cdecl sub_10073210(unsigned int a1);
signed int __cdecl sub_10073260(int a1, int a2);
// bool __usercall sub_10073450@<al>(int a1@<eax>);
int __cdecl sub_10073480(int, int, char, void *, int); // idb
signed int __cdecl sub_10073590(unsigned int a1, int a2, int a3);
signed int __cdecl sub_100735F0(unsigned int a1, int a2, int a3);
int __cdecl sub_10073780(int a1, char *a2, int a3, void *a4, int a5);
bool __cdecl sub_10073970(unsigned int a1, _DWORD *a2);
int __cdecl sub_100739C0(char a1);
signed int sub_100739E0();
// signed int __usercall sub_10073A30@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10073AD0@<eax>(char a1@<al>);
// int __usercall sub_10073AF0@<eax>(char a1@<al>);
// unsigned __int16 __usercall sub_10073B10@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10073D50(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10073ED0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10074030(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10074170(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10074250(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_100744D0(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10074500(char a1, int a2, void *a3);
char __cdecl sub_10074530(char a1, int a2, void *a3, int a4);
int __cdecl sub_10074560(_BYTE *a1);
unsigned int __cdecl sub_10074580(char *a1);
int __cdecl sub_100745A0(unsigned __int8 *a1);
int __cdecl sub_100745C0(_BYTE *a1);
int __cdecl sub_100745E0(unsigned __int8 *a1);
unsigned int __cdecl sub_10074600(int a1, int a2);
unsigned int __cdecl sub_10074930(int a1, int a2);
unsigned int __cdecl sub_10074D70(_BYTE *a1);
int __cdecl sub_10074D90(unsigned __int8 *a1);
int __cdecl sub_10074DB0(unsigned __int8 *a1);
int __cdecl sub_10074DD0(_BYTE *a1);
int __cdecl sub_10074DF0(int a1);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10074E40(unsigned __int8 *a1);
int __cdecl sub_10074E60(int a1);
unsigned int __cdecl sub_10074EF0(int a1);
unsigned int __cdecl sub_10074F10(int a1);
signed int __cdecl sub_10074F30(int a1);
unsigned int __cdecl sub_10074F80(int a1);
int __cdecl sub_10074FE0(_BYTE *a1);
unsigned int __cdecl sub_10075000(_BYTE *a1);
int __cdecl sub_10075020(unsigned __int8 *a1);
int __cdecl sub_10075040(_BYTE *a1);
signed int __cdecl sub_10075060(_BYTE *a1, int a2);
int __cdecl sub_10075090(_BYTE *a1, int a2);
signed int __cdecl sub_100750D0(_BYTE *a1, int a2);
int __cdecl sub_10075100(int a1, int a2);
int __cdecl sub_10075190(unsigned __int8 *a1);
int __cdecl sub_100751B0(int a1);
int __cdecl sub_100751E0(unsigned __int8 *a1);
unsigned int __cdecl sub_10075200(int a1);
int __cdecl sub_10075230(int a1);
int __cdecl sub_10075320(int a1);
signed int __cdecl sub_10075430(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10075460(_BYTE *a1, int a2);
signed int __cdecl sub_10075490(unsigned __int8 *a1, int a2);
int __cdecl sub_100754C0(unsigned __int8 *a1);
int __cdecl sub_10075520(int a1);
signed int __cdecl sub_10075530(_BYTE *a1, int a2);
int __cdecl sub_10075560(int a1, int a2);
unsigned int __cdecl sub_100755E0(int a1);
unsigned int __cdecl sub_10075620(int a1);
int __cdecl sub_10075670(int a1);
int __cdecl sub_100756A0(int a1);
unsigned int __cdecl sub_100756D0(int a1);
unsigned int __cdecl sub_10075700(int a1);
unsigned int __cdecl sub_10075720(int a1);
void __cdecl __noreturn sub_10075760(int a1);
signed int __cdecl sub_100758D0(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_10075930@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_10075A00(int a1);
int __cdecl sub_10075A10(int a1, unsigned int a2);
int __cdecl sub_10075B00(int a1, int a2, int a3);
int __cdecl sub_10075B40(int *a1, unsigned int a2);
__int16 __cdecl sub_10075C30(int a1, unsigned int a2);
int __cdecl sub_10075C80(int *a1, unsigned int a2);
__int16 __cdecl sub_10075CB0(unsigned int *a1, _WORD *a2, _WORD *a3);
char __cdecl sub_10075D30(char *a1);
char __cdecl sub_10075D60(int a1);
bool __cdecl sub_10075DB0(int a1, void *a2, int a3);
char __cdecl sub_10075E30(unsigned __int16 a1, char a2);
bool __cdecl sub_10075EA0(int a1, void *a2);
char __cdecl sub_10075ED0(unsigned __int16 a1, float *a2);
signed int __cdecl sub_10075FF0(_BYTE *a1, char a2, int a3);
int __cdecl sub_10076040(int, float, float, int, int); // idb
unsigned int __cdecl sub_10076130(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10076180(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5);
unsigned int __cdecl sub_10076220(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
signed int __cdecl sub_100762E0(void *a1, size_t a2, int a3);
int __cdecl sub_10076340(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10076390(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10076430(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int sub_100764E0();
int __cdecl sub_10076520(__int16 a1);
int __cdecl sub_10076570(char, __int16, char *); // idb
// int __usercall sub_100765E0@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
char __cdecl sub_10076690(int a1, char a2, __int16 a3, void *a4);
char __cdecl sub_10076700(char a1, void *a2);
char __cdecl sub_10076760(char a1, __int16 a2, void *a3);
char __cdecl sub_100767D0(char a1, __int16 a2, int a3, int a4);
char __cdecl sub_10076840(char a1, int a2, int a3);
char __cdecl sub_100768B0(char a1, void *a2);
char __cdecl sub_10076910(char a1, __int16 a2, void *a3);
char __cdecl sub_10076980(char a1, _WORD *a2);
char __cdecl sub_100769F0(char a1, __int16 a2, _WORD *a3);
char __cdecl sub_10076A70(char a1, _WORD *a2);
char __cdecl sub_10076AE0(char a1, __int16 a2, _WORD *a3);
__int16 __cdecl sub_10076B60(char a1);
char __cdecl sub_10076BB0(int a1, int a2);
char __thiscall sub_10076C30(void *this);
char __cdecl sub_10076CC0(int a1, char a2);
char __cdecl sub_10076D80(char a1, char a2);
char __cdecl sub_10076DD0(char a1);
char __cdecl sub_10076E00(char a1);
bool __cdecl sub_10076E40(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10076EB0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10076F10(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10076F80(char a1, _BYTE *a2);
char __thiscall sub_10076FC0(void *this);
char __cdecl sub_10077030(char a1, int a2);
char __cdecl sub_10077060(char a1, int a2);
char __cdecl sub_10077090(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl sub_10077260(char *, char *); // idb
// void *__usercall sub_100772A0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_100772F0();
_DWORD *sub_100790F0();
int sub_10079100();
signed int sub_10079120();
signed int sub_10079130();
signed int sub_10079140();
char __cdecl sub_10079150(char a1, int a2, void *a3);
void sub_10079200();
void sub_10079210();
int sub_10079220();
char sub_10079250();
int sub_100792F0();
signed int sub_10079300();
signed int sub_10079320();
int sub_10079340();
int nullsub_1(void); // weak
bool __thiscall sub_10079360(void *this);
bool __cdecl sub_10079370(char a1);
char *__cdecl sub_100793A0(unsigned __int8 a1);
char *__cdecl sub_100793B0(unsigned int a1, float *a2);
char *__cdecl sub_100793E0(unsigned int a1, float *a2);
char __cdecl sub_10079400(char a1);
char __cdecl sub_10079420(unsigned int a1, float *a2);
double __cdecl sub_10079840(int a1, unsigned int a2);
double __cdecl sub_10079E70(int a1, unsigned int a2);
char __thiscall sub_1007A560(void *this);
char __cdecl sub_1007A590(char a1);
int __cdecl sub_1007A5C0(int *a1, int a2);
void __cdecl sub_1007A5E0(int a1, float a2);
void __cdecl sub_1007A610(int a1, float a2);
int __cdecl sub_1007A640(int a1, signed int a2, signed int a3);
int __cdecl sub_1007A660(int, double, double); // idb
void __cdecl sub_1007A740(int a1);
char __cdecl sub_1007A840(int a1, int a2);
char __cdecl sub_1007A960(int a1);
char __cdecl sub_1007A970(int a1);
int __cdecl sub_1007A980(int a1);
char __cdecl sub_1007A9C0(char a1);
char __thiscall sub_1007A9F0(void *this);
int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_1007AA10(char **a1);
int sub_1007AA60();
int __cdecl sub_1007AAA0(_BYTE *a1, int a2);
signed int __cdecl sub_1007AB10(_BYTE *a1, int a2);
// int __usercall sub_1007ABB0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_1007ABE0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_1007ADB0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// unsigned int __usercall sub_1007AE10@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_1007AEA0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_1007AEF0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_1007AF50@<eax>(int a1@<eax>);
// int __usercall sub_1007AF70@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_1007AFB0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_1007B040@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_1007B190@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_1007B230@<eax>(int result@<eax>);
char *__cdecl sub_1007B270(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_1007B420@<eax>(int a1@<eax>);
// int __usercall sub_1007B450@<eax>(int a1@<esi>);
void __cdecl sub_1007B480(int (**a1)(void), char **a2, _DWORD *a3);
int sub_1007B8F0();
void *sub_1007B940();
char *sub_1007B9A0();
char sub_1007B9C0();
char __cdecl sub_1007B9D0(int a1, int a2, unsigned int a3);
// int *__usercall sub_1007BA10@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_1007BA60();
int __cdecl sub_1007BA70(_DWORD *a1, int a2, int a3);
int __cdecl sub_1007BB20(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_1007BD30@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_1007BDF0(char a1);
int *__cdecl sub_1007BE90(_BYTE *a1);
// int __usercall sub_1007BF50@<eax>(int a1@<eax>);
// signed int __usercall sub_1007C0B0@<eax>(int a1@<esi>);
int __cdecl sub_1007C120(int, int); // weak
char **sub_1007C400();
// int __usercall sub_1007C410@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_1007C500(char *a1);
int sub_1007C740();
int __cdecl sub_1007C820(int a1, int a2, char a3);
int __cdecl sub_1007C870(int a1);
int __cdecl sub_1007C880(void *); // idb
int __cdecl sub_1007C900(int a1, int a2);
signed int __cdecl sub_1007C930(int a1, int a2, int a3);
char __cdecl sub_1007C950(_DWORD *a1);
char __cdecl sub_1007CA60(int a1, unsigned int a2);
bool __cdecl sub_1007CA90(const void **a1, int a2);
bool __cdecl sub_1007CAC0(const void **a1, int a2);
bool __cdecl sub_1007CAF0(const void **a1, int a2);
bool __cdecl sub_1007CB20(const void **a1, int a2);
bool __cdecl sub_1007CB50(const void **a1, int a2);
bool __cdecl sub_1007CB80(int a1, int a2);
bool __cdecl sub_1007CBC0(int a1, int a2);
bool __cdecl sub_1007CC00(const void **a1, int a2);
bool __cdecl sub_1007CC30(const void **a1, int a2);
char __cdecl sub_1007CC60(int a1, unsigned int a2);
bool __cdecl sub_1007CC90(const void **a1, int a2);
bool __cdecl sub_1007CCC0(const void **a1, int a2);
bool __cdecl sub_1007CCF0(const void **a1, int a2);
bool __cdecl sub_1007CD20(const void **a1, int a2);
bool __cdecl sub_1007CD50(const void **a1, int a2);
bool __cdecl sub_1007CD80(const void **a1, int a2);
bool __cdecl sub_1007CDB0(const void **a1, int a2);
bool __cdecl sub_1007CDE0(const void **a1, int a2);
bool __cdecl sub_1007CE10(const void **a1, int a2);
bool __cdecl sub_1007CE40(const void **a1, int a2);
int __cdecl sub_1007CE70(int a1, int a2, int a3);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_1007CEE0(int a1, char a2);
int __cdecl sub_1007CF00(int a1, int a2, int a3);
int __cdecl sub_1007CF30(int a1, int a2, int a3, int a4);
int __cdecl sub_1007CF60(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1007CFA0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1007CFE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1007D030(int a1);
char __cdecl sub_1007D060(int a1);
char __cdecl sub_1007D070(int a1, int a2);
signed int __cdecl sub_1007D1F0(int a1);
signed int __cdecl sub_1007D230(int a1, int a2, int a3);
char __cdecl sub_1007D2D0(int a1);
char __cdecl sub_1007D330(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1007D3A0(char *a1);
int __cdecl sub_1007D440(int a1, int a2, int a3);
bool __cdecl sub_1007D4B0(int a1, unsigned int a2, int a3);
char __cdecl sub_1007D540(int a1, int a2, char a3, char a4);
char __cdecl sub_1007D5F0(int a1);
char __cdecl sub_1007D600(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1007D680(int a1, const char *a2))(const char *);
signed int __cdecl sub_1007D6D0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1007D720(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1007D8A0();
const char *__cdecl sub_1007D8B0(unsigned int a1);
int __cdecl sub_1007D8D0(int a1, int a2, int a3, int a4);
int __cdecl sub_1007D980(int a1);
int __cdecl sub_1007D9A0(int a1);
char *sub_1007D9C0(char *a1, ...);
// char *__usercall sub_1007DA00@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1007DA20@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1007DC00();
int sub_1007DC20();
int __cdecl sub_1007DC40(int a1, int a2);
int __cdecl sub_1007DCA0(int a1);
int __cdecl sub_1007DCB0(int a1, int a2);
int __cdecl sub_1007DD10(int a1);
bool __cdecl sub_1007DD20(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1007DE60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1007E210(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1007E660(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1007EB20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1007EEE0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1007F2E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1007F6A0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1007FBE0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1007FFC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10080380(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10080720(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_10080B20(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10080EC0(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_100814A0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_10081890(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_10081C30();
// BOOL __usercall sub_10081C60@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_10081DD0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10082040(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_10082340(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_100823F0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_10082430(int a1, int a2);
char __cdecl sub_10082470(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_10083220(int a1, int a2);
char **__cdecl sub_100832A0(int a1);
int (**sub_100832E0())();
int (__cdecl *__cdecl sub_100832F0(const char *a1))(const char *);
const char *sub_10083310();
__int64 sub_10083320();
const char *sub_10083330();
// int __usercall sub_10083340@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_10083390(int a1, int a2);
int (__cdecl *__cdecl sub_100833C0(_DWORD *a1))(int);
// int __usercall sub_100834E0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10083860(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10084680(int a1);
int sub_100846F0();
char __thiscall sub_10084720(void *this);
// char __usercall sub_10084790@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_100847D0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10084870(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_100848B0(char a1, char a2, void *a3);
char __cdecl sub_10084910(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10084950(char a1, char a2, void *a3);
char __cdecl sub_10084980(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100849C0(char a1, char a2, void *a3);
char __cdecl sub_10084A00(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10084A40(char a1, char a2, void *a3);
char __cdecl sub_10084A90(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10084AD0(char a1, char a2, void *a3);
char __cdecl sub_10084B10(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10084B50(char a1, char a2, void *a3);
char __cdecl sub_10084B90(char a1, void *a2);
char __cdecl sub_10084BC0(char a1, void *a2);
char __cdecl sub_10084BF0(char a1, void *a2);
char __cdecl sub_10084C20(char a1, void *a2);
char __cdecl sub_10084C50(char a1, void *a2);
char __cdecl sub_10084C80(char a1, void *a2);
char __cdecl sub_10084CB0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10084CF0(char a1, char a2, void *a3);
char __cdecl sub_10084D40(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10084D80(char a1, char a2, void *a3);
char __cdecl sub_10084DB0(char a1, void *a2);
char __cdecl sub_10084DE0(char a1, void *a2);
char __cdecl sub_10084E10(char a1, void *a2);
char __cdecl sub_10084E40(int a1, char a2, char a3, int a4, void *a5);
signed int __fastcall sub_100851E0(unsigned __int8 a1);
char __cdecl sub_100851F0(unsigned __int8 a1);
__int16 __cdecl sub_10085210(unsigned __int8 a1);
// signed int __usercall sub_10085230@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100862E0@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10086340@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_100870C0@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_100870E0(int a1, unsigned int a2);
// int __usercall sub_10087140@<eax>(int result@<eax>);
// int __usercall sub_10087180@<eax>(int result@<eax>);
// unsigned int __usercall sub_100888A0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_100889A0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10088A20@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10088AC0@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10088B80@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10088BE0@<eax>(char *a1@<edi>);
// int __usercall sub_10088CA0@<eax>(int a1@<ebx>);
char __cdecl sub_10088D60(char *a1, size_t a2, int a3);
char __cdecl sub_10088DB0(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10088E00(int a1, int a2);
// unsigned int __usercall sub_10088E30@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10089040@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_10089090(int a1, int a2);
signed int __cdecl sub_10089120(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_10089250(void *a1, int a2);
// BOOL __usercall sub_100892D0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10089370@<eax>(int result@<eax>);
unsigned int __fastcall sub_10089400(unsigned int a1, int a2);
// int __usercall sub_10089420@<eax>(int result@<eax>);
// int __usercall sub_100894B0@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10089930@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_100899E0@<eax>(int a1@<edi>);
// int __usercall sub_10089A40@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10089C10@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10089C90(int a1, int a2);
// signed int __usercall sub_10089D00@<eax>(int a1@<esi>);
// unsigned int __usercall sub_10089DC0@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10089F70@<eax>(int a1@<esi>, int a2);
// int __usercall sub_1008A040@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1008A0F0@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_1008A130@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_1008A190@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1008A270@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
_WORD *__fastcall sub_1008A810(int a1, int a2);
signed int __cdecl sub_1008A870(int a1);
// int __usercall sub_1008A900@<eax>(int a1@<eax>);
// int __usercall sub_1008AB40@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_1008ABE0@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_1008ADC0@<eax>(int a1@<edi>);
// int __usercall sub_1008AF00@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_1008B1B0(int a1, int a2);
signed int __cdecl sub_1008B470(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
// signed int __usercall sub_1008B620@<eax>(int a1@<eax>);
// _WORD *__usercall sub_1008B6F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_1008B910(int a1, int a2);
signed int __cdecl sub_1008BC20(int a1, int a2);
signed int __cdecl sub_1008C030(int a1, int a2);
_BYTE *__cdecl sub_1008C1A0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_1008C2A0(int a1);
// signed int __usercall sub_1008C2C0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_1008C760@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_1008C7B0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_1008C7D0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1008CB80@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_1008CCC0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_1008CD10@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_1008CDB0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_1008CDD0(int a1, int a2, int a3, int a4);
void __cdecl sub_1008CEC0(int a1);
// int __usercall sub_1008CED0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1008D570@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1008DF50@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1008E280(int a1, int a2);
int __cdecl sub_1008E2A0(unsigned __int8 *a1);
signed int __cdecl sub_1008E2C0(void *a1);
signed int __cdecl sub_1008E2E0(void *a1);
signed int __cdecl sub_1008E300(void *a1);
signed int __cdecl sub_1008E320(void *a1);
signed int __cdecl sub_1008E340(void *a1);
signed int __cdecl sub_1008E360(void *a1);
signed int __cdecl sub_1008E380(void *a1);
int __cdecl sub_1008E3E0(unsigned __int8 *a1, int a2);
char __cdecl sub_1008E410(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_1008E470(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
signed int __cdecl sub_1008E4D0(char a1, char a2);
int __cdecl sub_1008E530(char a1);
signed int __cdecl sub_1008E570(char a1, char a2, char a3);
int __cdecl sub_1008E5E0(char a1);
int __cdecl sub_1008E620(char a1);
char __cdecl sub_1008E660(char a1, int a2);
char __cdecl sub_1008E680(char a1, int a2);
char __cdecl sub_1008E6B0(char a1, int a2);
char __cdecl sub_1008E700(char a1, int a2);
char __cdecl sub_1008E730(char a1, int a2);
char __cdecl sub_1008E750(int a1);
char __cdecl sub_1008E770(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
int __cdecl sub_1008E7D0(char *a1, char a2);
bool __cdecl sub_1008E840(int a1, void *a2);
char __cdecl sub_1008E900(int a1, bool *a2);
char sub_1008E9C0();
int __cdecl sub_1008EA40(char a1);
char __cdecl sub_1008EA90(char a1);
char sub_1008EAC0();
BOOL __cdecl sub_1008EB60(int a1, int a2);
char __cdecl sub_1008EB80(int a1, char a2, int a3, int a4, int a5);
char __thiscall sub_1008EBC0(void *this);
// _DWORD *__usercall sub_1008EBE0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
char __cdecl sub_1008EC10(int a1, int a2);
char __cdecl sub_1008EC70(int a1, int a2);
char __cdecl sub_1008ECC0(int a1, int a2);
_DWORD *sub_1008EDC0();
int nullsub_7(void); // weak
int __cdecl sub_1008EE60(int, float); // idb
int __cdecl sub_1008EE80(int, float); // idb
char __cdecl sub_1008EEA0(char a1, void *a2);
unsigned __int8 __cdecl sub_1008EEF0(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_1008EF30(char a1, _DWORD *a2);
char __cdecl sub_1008EF70(char a1);
char __cdecl sub_1008EFA0(char a1, void *a2);
int __cdecl sub_1008F020(char a1, _DWORD *a2);
void __cdecl sub_1008F070(char a1, char a2);
char __cdecl sub_1008F0E0(int a1, int a2);
char __cdecl sub_1008F130(int a1, int a2);
char __cdecl sub_1008F1E0(int a1, int a2);
char __cdecl sub_1008F240(int a1, int a2);
char sub_1008F310();
int __cdecl sub_1008F320(int a1);
char __cdecl sub_1008F330(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_1008F370(const char *a1, int a2);
// char *__usercall sub_1008F3E0@<eax>(char *result@<eax>);
void __cdecl sub_1008F410(char *a1);
void __cdecl sub_1008F4D0(char *a1, char *a2);
void *__cdecl sub_1008F530(int a1);
int __cdecl sub_1008F6C0(int a1, int a2);
// char __usercall sub_1008F800@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1008F8D0(_DWORD *a1, char *a2);
BOOL __cdecl sub_1008F9B0(unsigned int a1);
BOOL __cdecl sub_1008F9D0(int a1);
_DWORD __cdecl sub_1008F9F0(_DWORD); // weak
unsigned int __cdecl sub_1008FA00(int a1, char a2);
signed int __cdecl sub_1008FA60(void *a1, int a2, unsigned int a3);
int __cdecl sub_1008FA80(int a1, int a2, int a3);
char __cdecl sub_1008FAA0(const char *a1, const char *a2);
int __cdecl sub_1008FBE0(int a1, int a2, unsigned int a3);
int sub_1008FC60();
void __cdecl sub_1008FC70(int a1);
int __cdecl sub_1008FCA0(int a1);
bool __cdecl sub_1008FCC0(int a1);
void *__cdecl sub_1008FCF0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_1008FD30@<eax>(int a1@<edx>, int a2, int a3);
// unsigned int __usercall sub_1008FD50@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_1008FD70@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_1008FD90(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_1008FDC0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_1008FEA0(int a1, int a2, int a3);
// void *__usercall sub_1008FF50@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_100901D0(int a1, int a2);
char __cdecl sub_100902A0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10090310@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10090670@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10090780(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10090910(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10090A60@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10090BB0(int a1, int a2);
signed int __cdecl sub_10090BF0(int a1, int a2);
bool __cdecl sub_10090C50(signed int a1);
int sub_10090CC0();
char sub_10090FE0();
char sub_10091200();
char sub_10091400();
char sub_10091580();
char sub_10091700();
char sub_10091870();
char sub_10091970();
char sub_10091AD0();
char sub_10091C30();
char sub_10091D90();
char sub_10091F00();
char sub_10092060();
char sub_100921C0();
char sub_100923E0();
char sub_10092540();
char sub_100926A0();
char sub_10092800();
char sub_10092970();
char sub_10092AD0();
char sub_10092C30();
char sub_10092E50();
char sub_10093050();
char sub_100931D0();
char sub_10093350();
char sub_100934C0();
char sub_100935B0();
char sub_10093710();
char sub_10093870();
char sub_100939D0();
char sub_10093B40();
char sub_10093CA0();
char sub_10093E00();
char sub_10094000();
char sub_10094160();
char sub_100942C0();
char sub_10094420();
char sub_10094590();
char sub_100946F0();
char sub_10094850();
char sub_10094DF0();
char sub_10095000();
char sub_100951F0();
char sub_10095360();
char sub_100954D0();
char sub_10095630();
char sub_10095720();
char sub_10095880();
char sub_100959E0();
char sub_10095B40();
char sub_10095CB0();
char sub_10095E10();
char sub_10095F70();
char sub_10096170();
char sub_100962D0();
char sub_10096430();
char sub_10096590();
char sub_10096700();
char sub_10096860();
char sub_100969C0();
char sub_10096BD0();
char sub_10096DC0();
char sub_10096F30();
char sub_100970A0();
char sub_10097200();
char sub_100972F0();
char sub_10097450();
char sub_100975B0();
char sub_10097710();
char sub_10097880();
char sub_100979E0();
char sub_10097B40();
char sub_10097D40();
char sub_10097EA0();
char sub_10098000();
char sub_10098160();
char sub_100982D0();
char sub_10098430();
char **sub_10098590();
int __cdecl sub_100985A0(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_100985C0@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_100985D0@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_10098800(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10098850(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_100988A0(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_100988F0(int a1))(int);
int __cdecl sub_10098970(int a1, int a2);
int (__cdecl *__cdecl sub_100989F0(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_10098A40(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10098A80(int a1, int a2, int a3))(int);
char __cdecl sub_10098AE0(char a1);
int __cdecl sub_10098B20(char a1);
int __cdecl sub_10098B40(int, void *); // idb
// int __usercall sub_10098BA0@<eax>(char a1@<al>);
BOOL __cdecl sub_10098BD0(char a1, int a2);
int __cdecl sub_10098C00(int, char, int, int, void *); // idb
char __cdecl sub_10098C30(void *a1);
BOOL __cdecl sub_10098C50(int a1);
char __cdecl sub_10098C70(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_10098CA0(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_10098D30(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
bool __cdecl sub_10098DD0(char a1, void *a2);
// signed int __usercall sub_10098E10@<eax>(char a1@<al>);
bool __cdecl sub_10098E30(char a1, void *a2);
bool __cdecl sub_10098F20(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_10098F50(unsigned __int8 a1);
// BOOL __usercall sub_10098F60@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10098F90(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_10099140(unsigned __int8 a1, int a2);
bool __cdecl sub_10099180(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char __cdecl sub_10099270(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10099310(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10099390(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10099400(char a1, void *a2);
char __cdecl sub_10099480(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10099500(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10099580(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100995F0(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10099700(char a1, void *a2);
bool __cdecl sub_10099720(unsigned __int8 a1, char *a2);
char __cdecl sub_10099760(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_100997A0();
char __cdecl sub_10099800(int a1, char *a2);
BOOL __cdecl sub_100998F0(int a1, int a2);
char __cdecl sub_10099910(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10099950(int a1, int a2);
BOOL __cdecl sub_10099A00(int a1, int a2);
char __cdecl sub_10099A20(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10099A60(void *a1);
char __cdecl sub_10099A80(void *a1);
char __cdecl sub_10099BD0(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10099D70(char a1);
// __int16 __usercall sub_10099DB0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10099DC0(unsigned __int8 a1, char *a2);
char __cdecl sub_10099E90(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10099F10(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1009A020(char a1);
char __cdecl sub_1009A070(char a1, int a2);
// int __usercall sub_1009A1E0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1009A220@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1009A260();
char __cdecl sub_1009A270(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1009A2D0(char a1, void *a2);
char __cdecl sub_1009A3F0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1009A470(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_1009A620(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_1009A750(char a1, int a2);
bool __cdecl sub_1009A7D0(void *a1);
char __cdecl sub_1009A820(char a1, int a2);
// __int16 __usercall sub_1009A900@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1009A910(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_1009A9A0(unsigned __int8 a1, char a2);
bool __cdecl sub_1009AA60(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_1009AB60(char a1);
int __cdecl sub_1009ABE0(int a1, int a2);
char __cdecl sub_1009AC00(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
bool __cdecl sub_1009ACD0(void *a1);
char __cdecl sub_1009AD10(char a1);
char __cdecl sub_1009AD40(char a1);
char __cdecl sub_1009AD70(char a1);
char __cdecl sub_1009ADB0(char a1);
int __cdecl sub_1009ADD0(char a1, char a2);
// bool __usercall sub_1009AE80@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_1009AEB0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_1009AF50(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1009AFD0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1009B050(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1009B0D0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1009B150(char a1);
// int __cdecl TXT_get_hndl(_DWORD); weak
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
// int __cdecl BMP_get_bm_def(_DWORD); weak
// int __cdecl BMP_get_xfrm(_DWORD); weak
// int TXT_get_static_string(void); weak
int __cdecl sub_1009B210(int a1);
int sub_1009B230();
int __cdecl sub_1009B250(int a1, int a2, int a3);
int __cdecl sub_1009B280(int a1, int a2);
__int16 __cdecl sub_1009B2B0(int a1);
int sub_1009B2D0();
int __cdecl sub_1009B2F0(int a1, int a2, int a3, int a4);
int sub_1009B320();
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_1009B380(int a1, int a2, int a3, int a4);
int __cdecl sub_1009B3B0(int a1);
int __cdecl sub_1009B3D0(int a1);
int __cdecl sub_1009B3F0(int a1, int a2);
int __cdecl sub_1009B420(int a1, int a2);
int __cdecl sub_1009B450(int a1, int a2, int a3, int a4);
int __cdecl sub_1009B480(int a1, int a2);
int __cdecl sub_1009B4B0(int a1);
int __cdecl sub_1009B4D0(int a1);
char __cdecl sub_1009B4F0(int a1, int a2);
int __cdecl sub_1009B560(_BYTE *a1);
int __cdecl sub_1009B5A0(int a1, int a2);
int __cdecl sub_1009B5D0(int a1, int a2);
int __cdecl sub_1009B5F0(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_1009B630();
int __cdecl sub_1009B680(int a1);
int __cdecl sub_1009B690(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_1009B6E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_1009B730();
int __cdecl j_gdi_pvg_load_identity();
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_1009B780(float, float, float, float, float, float); // idb
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1009B7E0(int a1);
int nullsub_3(void); // weak
int __cdecl sub_1009B830(int a1, int a2, int a3);
char __cdecl sub_1009B850(int a1, int a2, int a3);
int __cdecl sub_1009B890(int, void *, int, void *); // idb
int __cdecl sub_1009B8D0(int a1, int a2, int a3);
int __cdecl sub_1009B900(int a1, int a2, int a3);
int __cdecl sub_1009B920(int a1, int a2, int a3);
int __cdecl sub_1009B980(int a1, int a2, int a3);
char __cdecl sub_1009B9C0(int a1, int a2, int a3);
int __cdecl sub_1009BA00(int, void *, int, void *); // idb
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_1009BA60(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl j_FIL_vfs_has_dirty_data(_DWORD); // weak
int __cdecl sub_1009BAD0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD);
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_1009BB40(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_1009BB80(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_1009BC10(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_1009BC60(int a1);
int j_FIL_vfs_sync_all(void); // weak
int __cdecl sub_1009BC90(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1009BCC0(int a1, int a2, int a3, char a4);
char __cdecl sub_1009BCE0(int a1);
signed int __cdecl sub_1009BD10(unsigned int a1, int a2, int a3);
int __cdecl sub_1009BD30(int a1, int a2, int a3);
int __cdecl sub_1009BD50(int a1, int a2);
signed int __cdecl sub_1009BDB0(int a1);
// unsigned int __usercall sub_1009BE30@<eax>(const char **a1@<esi>);
// int __usercall sub_1009C130@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_1009C150(int a1);
unsigned int __cdecl sub_1009C220(LONG Value);
void __cdecl sub_1009C2B0(int a1, _BYTE *a2);
int __cdecl sub_1009C2E0(int a1, int a2);
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_get_uart(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_put_uart(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl j_HWM_pvg_set_uart(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int sub_1009C370(void); // weak
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1009C3C0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1009C410(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_1009C480(int a1);
int __cdecl sub_1009C4C0(int a1);
int __cdecl sub_1009C500(int a1);
int __cdecl sub_1009C540(int a1);
int __cdecl sub_1009C580(int a1, int a2, int a3, int a4);
int __cdecl sub_1009C5F0(int a1, int a2, int a3);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
int sub_1009C6A0(void); // weak
unsigned int __cdecl sub_1009C6B0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_1009C860@<eax>(int a1@<esi>);
int __cdecl sub_1009C910(int a1, unsigned __int64 a2);
// int __usercall sub_1009C9C0@<eax>(int a1@<ebx>, unsigned __int64 a2);
int __cdecl sub_1009CA50(int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
void __cdecl sub_1009CBB0(__int16 a1, _BYTE *a2);
char sub_1009CBE0();
int __cdecl sub_1009CC30(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
unsigned int *__cdecl sub_1009CD40(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
unsigned int *__cdecl sub_1009CE20(int a1);
int __cdecl sub_1009D170(int a1);
unsigned int *__cdecl sub_1009D350(int a1);
int __cdecl sub_1009D880(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_1009D8E0(int a1);
int __cdecl sub_1009D940(int a1, int a2, char a3);
void sub_1009DA30();
void sub_1009DA40();
int __cdecl sub_1009DA50(int a1, _BYTE *a2, int a3);
char __cdecl sub_1009DA90(char a1, char a2);
int __cdecl sub_1009DAB0(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_1009E2F0(_BYTE *a1);
bool __cdecl sub_1009E390(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_1009E4A0(int a1, _BYTE *a2, int a3);
int __cdecl sub_1009E590(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
int __cdecl sub_1009E7F0(int a1, __int16 a2, __int16 a3, char a4);
int __cdecl sub_1009ED40(int a1, signed int a2, int a3, int a4, int a5);
int __cdecl sub_1009F430(int a1, signed int a2, int a3, char a4);
int __cdecl sub_1009F8C0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_1009F9B0(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7);
char *__cdecl sub_100A0AF0(int a1, int a2, int a3, int a4);
char __cdecl sub_100A0B60(int a1, int a2);
char *__cdecl sub_100A0BB0(int a1, int a2);
signed int __cdecl sub_100A0C00(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_100A0D50(__int16 a1, __int16 a2);
char *__cdecl sub_100A0DF0(int a1, int a2);
char *__cdecl sub_100A0FA0(int a1, int a2);
char __cdecl sub_100A1150(int a1, __int16 a2, __int16 a3, __int16 a4, char a5);
int __cdecl sub_100A1BD0(int a1, __int16 a2, __int16 a3);
int __cdecl sub_100A1C30(int a1);
int __cdecl sub_100A1E00(int a1, signed int a2, signed int a3);
char __cdecl sub_100A22D0(int a1);
char __cdecl sub_100A2380(int a1);
int __cdecl sub_100A24F0(int a1);
char *__cdecl sub_100A2550(int a1);
unsigned int __cdecl sub_100A26A0(int a1, signed int a2, int a3, int a4);
int __cdecl sub_100A2760(int a1, int a2);
unsigned int __cdecl sub_100A2880(int a1, int a2);
int __cdecl sub_100A2A20(int a1, int a2, int a3);
int __cdecl sub_100A2AA0(int a1, int a2, int a3);
int __cdecl sub_100A2B10(int a1, int a2, int a3);
char __cdecl sub_100A2B90(int a1, signed int a2, int a3, int a4);
int __cdecl sub_100A2CA0(int a1, signed int a2, signed int a3);
int __cdecl sub_100A2D90(int a1, signed int a2, int a3, int a4);
int __cdecl sub_100A2E90(int a1, int a2);
char *__cdecl sub_100A2FC0(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_100A3100(int a1, signed int a2, int a3, int *a4);
int *__cdecl sub_100A3350(int a1, signed int a2, int a3);
int *__cdecl sub_100A3490(int a1, signed int a2, int a3);
int __cdecl sub_100A35D0(int a1, __int16 a2, __int16 a3, __int16 a4);
int __thiscall sub_100A3830(void *this);
void __fastcall sub_100A3840(int a1, int a2);
int __fastcall sub_100A3860(const char *a1, const char *a2);
// unsigned int __usercall sub_100A38A0@<eax>(const char *a1@<eax>);
int __cdecl sub_100A38C0(int a1, int a2);
int sub_100A38E0(int arg0, char *arg4, ...);
void *__cdecl sub_100A3A00(int a1, int a2);
signed int __cdecl sub_100A3A60(void *a1);
signed int __cdecl sub_100A3AB0(int a1, char a2, __int32 *a3);
int __cdecl sub_100A3B10(int a1);
signed int __cdecl sub_100A3B20(int a1);
int __cdecl sub_100A3B50(int, void *, size_t); // idb
int __cdecl sub_100A3BF0(int, void *); // idb
// void __usercall sub_100A3C90(int a1@<edx>, int a2@<esi>);
int __thiscall sub_100A3CC0(int this);
void __cdecl sub_100A3D40(int a1, int a2);
int __cdecl sub_100A3D90(int a1, int a2);
int __cdecl sub_100A3E10(int a1);
int __cdecl sub_100A3E40(int, int, char, int, void *); // idb
int __cdecl sub_100A3FE0(int, int, void *); // idb
int __cdecl sub_100A40C0(int, int, int, char, int, void *); // idb
int __cdecl sub_100A4120(int, int, char, int, void *); // idb
int (__cdecl *__cdecl sub_100A4160(void *a1))(int, void *);
void __cdecl sub_100A4240(void *a1);
// int (__cdecl *__usercall sub_100A4270@<eax>(int a1@<esi>, int a2))(int, int);
int __cdecl sub_100A4340(int, int, void *); // idb
int __cdecl sub_100A4370(int, int, void *); // idb
int __cdecl sub_100A43A0(int, int, char, int, void *); // idb
void __cdecl sub_100A43E0(int a1);
// int __usercall sub_100A4430@<eax>(int a1@<eax>);
void __cdecl sub_100A4490(void *a1);
int __cdecl sub_100A44F0(int a1, const char *a2, int a3);
int __cdecl sub_100A45C0(char a1, int a2, int a3);
int __cdecl sub_100A45F0(int a1, int a2);
int __cdecl sub_100A4640(int a1, char a2);
signed int __cdecl sub_100A4670(int a1, int a2);
// int __usercall sub_100A46A0@<eax>(int result@<eax>, int (__cdecl *a2)(int, int)@<ebx>, int *a3@<edi>, int a4);
int __cdecl sub_100A46E0(char a1, const char *a2, int a3);
int __cdecl sub_100A4710(char a1, int a2);
int __cdecl sub_100A4730(int a1, int a2, int (__cdecl *a3)(int, int), int *a4, int *a5);
signed int __cdecl sub_100A47D0(int a1, int a2);
int __cdecl sub_100A4810(int a1, int a2, int (__cdecl *a3)(int, int));
int __cdecl sub_100A48A0(char a1, int a2, int a3);
int __cdecl nullsub_4();
int __cdecl sub_100A48F0(int, void *, int); // idb
int __cdecl sub_100A4B00(int, void *, size_t); // idb
int __cdecl sub_100A4B80(int *a1, const char *a2);
// signed int __usercall sub_100A4CB0@<eax>(int a1@<edi>, int a2);
int *__cdecl sub_100A4E70(int *a1, int a2, int a3, int a4);
signed int __cdecl sub_100A4F40(int *a1);
int __cdecl nullsub_5(_DWORD); // weak
int __cdecl sub_100A4F90(int a1, char a2, const char *a3);
int __cdecl sub_100A5010(int a1, int *a2, int a3);
void __fastcall sub_100A5050(_DWORD *a1, int a2);
// signed int __usercall sub_100A5080@<eax>(_BYTE *a1@<edi>, int *a2@<esi>, int a3);
int __fastcall sub_100A50E0(int a1, int a2);
char __cdecl sub_100A5100(_DWORD *a1, unsigned int a2);
int __cdecl sub_100A51E0(int a1, unsigned __int8 a2, _BYTE *a3, unsigned int a4);
signed int __cdecl sub_100A5390(int a1, _BYTE *a2, unsigned int a3, int a4);
int __cdecl sub_100A54D0(int, char *, int, int); // idb
signed int __cdecl sub_100A5540(int a1, unsigned __int8 a2, char *a3);
void __cdecl sub_100A5590(int a1, int a2);
// int __usercall sub_100A5600@<eax>(unsigned int a1@<ebx>, int a2, _BYTE *a3, _BYTE *a4, unsigned int a5);
int __cdecl sub_100A5730(int a1, int a2);
int __cdecl sub_100A5760(int a1, int a2, _BYTE *a3);
signed int __cdecl sub_100A5B30(int a1, int a2);
signed int __cdecl sub_100A5E30(int a1, int a2);
int __cdecl sub_100A5F20(int *a1);
// unsigned int __usercall sub_100A5F40@<eax>(const char *a1@<eax>);
void __cdecl sub_100A5F60(int a1);
int __cdecl sub_100A5F80(int a1);
int __cdecl sub_100A5FA0(int a1);
int __cdecl sub_100A5FC0(int, char *, char *, size_t); // idb
void __cdecl sub_100A6070(int a1, int a2, char a3);
int __cdecl sub_100A6090(int, char *, int); // idb
char *__cdecl sub_100A6120(unsigned __int8 a1);
int __cdecl sub_100A6140(char a1, int a2);
char __cdecl sub_100A6160(_BYTE *a1, unsigned int a2);
char __cdecl sub_100A6260(const char *a1);
int __cdecl sub_100A6290(const char *a1, int a2);
int __cdecl sub_100A62C0(int a1);
int __cdecl sub_100A62E0(int a1);
void __cdecl sub_100A6300(int a1);
int __cdecl sub_100A6320(int a1);
_BYTE *__cdecl sub_100A6330(int a1);
int sub_100A63B0(int arg0, char *arg4, ...);
void *__cdecl sub_100A6400(int a1);
// signed int __usercall sub_100A6500@<eax>(int a1@<esi>);
// _BYTE *__usercall sub_100A6530@<eax>(int a1@<eax>);
// char __usercall sub_100A65F0@<al>(int a1@<eax>, _BYTE *a2@<ecx>);
// int __usercall sub_100A6680@<eax>(int a1@<eax>, int a2);
int __fastcall sub_100A66C0(int a1, int a2);
// void *__usercall sub_100A66F0@<eax>(int a1@<eax>, size_t a2@<ebx>, void *a3);
// int __usercall sub_100A6740@<eax>(int result@<eax>);
int __cdecl sub_100A67B0(int a1);
int __cdecl sub_100A6880(int a1);
// int __usercall sub_100A68A0@<eax>(int a1@<edi>);
char __cdecl sub_100A68D0(int a1);
_BYTE *__cdecl sub_100A6BC0(int a1);
signed int __cdecl sub_100A6FB0(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_100A7070(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_100A7090(unsigned int *a1, signed int a2, unsigned int a3);
double __cdecl sub_100A71C0(double a1, double a2);
double __cdecl sub_100A7220(float a1, float a2);
void __cdecl sub_100A72A0(double a1);
double __cdecl sub_100A72C0(float a1);
int __cdecl sub_100A7300(double); // idb
int __cdecl sub_100A7330(signed int a1, signed int a2);
double __cdecl sub_100A7380(float a1, float a2);
int __cdecl sub_100A73F0(float); // idb
double __cdecl sub_100A7420(float a1, float a2);
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_mon_data(_DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// void *__cdecl memset(void *, int, size_t);
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memcpy(void *, const void *, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int sprintf(char *, const char *, ...);
// int __cdecl strncmp(const char *, const char *, size_t);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl tolower(int);
// void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line);
// int _snprintf(char *, size_t, const char *, ...);
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isalnum(int);
// int __cdecl isprint(int);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strchr(const char *, int);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// double __cdecl ceil(double);
// double __cdecl floor(double);
// unsigned int __cdecl _control87(unsigned int, unsigned int);
// char *__cdecl strncpy(char *, const char *, size_t);
// double __cdecl atof(const char *);
// char *__cdecl strpbrk(const char *, const char *);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_100AA9F8(int a1, int a2, char a3);
// void *__cdecl memchr(const void *, int, size_t);
// char *__cdecl strrchr(const char *, int);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_100AC0E6(int, FILE *); // idb
// int __cdecl _output_l(int, int, struct localeinfo_struct *, int); idb
int __cdecl sub_100ACC7B(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// int __cdecl isleadbyte(int);
signed int __cdecl sub_100AE330(_DWORD *a1);
signed int __cdecl sub_100AE367(_DWORD *a1);
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_100AE988();
int (*sub_100AEE35())(void);
void __cdecl sub_100AEE59(); // idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_100AF6A9();
void **sub_100AF844();
signed int sub_100AF84A();
// _DWORD __cdecl _lock_file(_DWORD); weak
// _DWORD __cdecl _unlock_file(_DWORD); weak
int sub_100AFB25();
int __cdecl sub_100AFCE2(int a1, int a2, int a3);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_100B49FA(FILE *, int, struct localeinfo_struct *, int); // idb
void sub_100B6965();
// int _get_sse2_info(void); weak
int sub_100B6A1D();
int __cdecl sub_100B6A2A(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_100B6AD0(int, int, struct localeinfo_struct *); // idb
signed int __cdecl sub_100B6E68(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_100B7004(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_100B7626(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_100B7746(signed int a1);
// int __cdecl _fileno_0(FILE *);
// errno_t __cdecl wctomb_s(int *SizeConverted, char *MbCh, rsize_t SizeInBytes, wchar_t WCh);
int __cdecl sub_100B8725(int a1);
int __cdecl sub_100B872F(int a1);
int __cdecl sub_100B8739(int a1);
int __cdecl sub_100B8818(int a1);
// int __cdecl _stbuf(FILE *); idb
// int __cdecl _ftbuf(int, FILE *); idb
int __cdecl sub_100BA3BD(FILE *, int, int); // idb
int __cdecl sub_100BA50C(int a1, int a2, int a3);
int sub_100BA802();
signed int __cdecl sub_100BB122(int a1, int a2);
signed int __cdecl sub_100BB664(int a1, int a2);
int __cdecl sub_100BBD72(FILE *); // idb
int __cdecl sub_100BBE92(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
signed int __cdecl sub_100BCA34(signed int a1);
signed int __cdecl sub_100BCAB5(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_100BCBC6(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
wchar_t __cdecl sub_100BCE87(wchar_t WCh, FILE *a2);
// int __cdecl _read(int, void *, unsigned int);
int __cdecl sub_100BDD61(int, FILE *); // idb
signed int __cdecl sub_100BDED1(signed int a1);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1008CC80; // weak
int dword_100C03D8[] = { 56 }; // weak
int (__cdecl *off_100C03DC)(int, int, int, int, int) = &sub_10067720; // weak
int dword_100C03E0[] = { 12 }; // weak
_UNKNOWN unk_100C0B50; // weak
_UNKNOWN unk_100C0B58; // weak
_UNKNOWN unk_100C0B78; // weak
_UNKNOWN unk_100C2368; // weak
_UNKNOWN unk_100C2378; // weak
_UNKNOWN unk_100C2390; // weak
_UNKNOWN unk_100C23C8; // weak
_UNKNOWN unk_100C29C8; // weak
_UNKNOWN unk_100C29D8; // weak
_UNKNOWN unk_100C29E0; // weak
__int16 word_100C29E4[] = { 10 }; // weak
__int16 word_100C29E6[] = { 4 }; // weak
_UNKNOWN unk_100C3000; // weak
_UNKNOWN unk_100C3010; // weak
char *off_100C357C = "/shr_mem/cdp_diag_intf.shr"; // weak
char *off_100C3B2C[4] =
{
  "/mnt/card0/oem_diag.zip",
  "/mnt/card1/oem_diag.zip",
  "/mnt/card0/html/index.htm",
  "/mnt/card1/html/index.htm"
}; // weak
int dword_100C40E8[] = { 49152 }; // weak
int dword_100C40EC[] = { 32768 }; // weak
char byte_100C40F0[] = { '\0' }; // weak
char byte_100C4154[] = { '\x06' }; // weak
int (__cdecl *off_100C4158)(int, int) = &sub_100078A0; // weak
_UNKNOWN unk_100C4192; // weak
int (__cdecl *off_100C41B8)(int, int) = &sub_10009DE0; // weak
_UNKNOWN unk_100C42E0; // weak
int dword_100C5928[] = { 256 }; // weak
int word_100C592C = 21692749; // idb
_WORD word_100C592E[16] = { 331, 512, 0, 332, 330, 4096, 0, 550, 553, 8192, 0, 551, 554, 0, 8, 552 }; // idb
_UNKNOWN unk_100C6118; // weak
char byte_100C611C[1072] =
{
  'U',
  'N',
  'K',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  'A',
  'L',
  'E',
  'R',
  'T',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  'P',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  'B',
  'A',
  'R',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  'H',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  'H',
  'P',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\0',
  'P',
  'S',
  'I',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  '\0',
  '\0',
  '\0',
  'F',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\0',
  '\0',
  '\0',
  'C',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  '\0',
  '\0',
  '\0',
  'c',
  'a',
  'r',
  'd',
  '8',
  ' ',
  'p',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  '\0',
  '\0',
  '\0',
  'R',
  'A',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\v',
  '\0',
  '\0',
  '\0',
  'S',
  '_',
  'S',
  'E',
  'M',
  'I',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\f',
  '\0',
  '\0',
  '\0',
  'S',
  'E',
  'M',
  'I',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  'D',
  'E',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x0E',
  '\0',
  '\0',
  '\0',
  'd',
  'i',
  's',
  't',
  'a',
  'n',
  'c',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x0F',
  '\0',
  '\0',
  '\0',
  'S',
  'E',
  'C',
  'O',
  'N',
  'D',
  'S',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\0',
  '\0',
  '%',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x11',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\0',
  '\0',
  'm',
  't',
  '/',
  's',
  'e',
  'c',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x13',
  '\0',
  '\0',
  '\0',
  'm',
  't',
  '/',
  'm',
  'i',
  'n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x14',
  '\0',
  '\0',
  '\0',
  'f',
  't',
  '/',
  'm',
  'i',
  'n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\0',
  '\0',
  'k',
  'p',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x16',
  '\0',
  '\0',
  '\0',
  'k',
  't',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x17',
  '\0',
  '\0',
  '\0',
  'm',
  'p',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x18',
  '\0',
  '\0',
  '\0',
  'm',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x19',
  '\0',
  '\0',
  '\0',
  'm',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\0',
  '\0',
  'm',
  'i',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1B',
  '\0',
  '\0',
  '\0',
  'm',
  'i',
  'l',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1C',
  '\0',
  '\0',
  '\0',
  'f',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1D',
  '\0',
  '\0',
  '\0',
  'k',
  'm',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1E',
  '\0',
  '\0',
  '\0',
  'n',
  'm',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1F',
  '\0',
  '\0',
  '\0',
  'N',
  '*',
  'm',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '-',
  'f',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '!',
  '\0',
  '\0',
  '\0',
  'L',
  'B',
  'F',
  'I',
  'N',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\"',
  '\0',
  '\0',
  '\0',
  'M',
  '/',
  'S',
  '^',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '#',
  '\0',
  '\0',
  '\0',
  'g',
  '\'',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '$',
  '\0',
  '\0',
  '\0',
  'l',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '%',
  '\0',
  '\0',
  '\0',
  'g',
  'l',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '&',
  '\0',
  '\0',
  '\0',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\'',
  '\0',
  '\0',
  '\0',
  'l',
  't',
  '/',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '(',
  '\0',
  '\0',
  '\0',
  'g',
  'l',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ')',
  '\0',
  '\0',
  '\0',
  'I',
  'G',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '*',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'A',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '+',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'A',
  'V',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ',',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'B',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '-',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'D',
  'S',
  'L',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '.',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'A',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'A',
  'V',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'B',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '1',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'D',
  'S',
  'L',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '2',
  '\0',
  '\0',
  '\0',
  'l',
  't',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '3',
  '\0',
  '\0',
  '\0',
  'm',
  '/',
  'l',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '4',
  '\0',
  '\0',
  '\0',
  'm',
  'i',
  '/',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '5',
  '\0',
  '\0',
  '\0',
  'n',
  'm',
  '/',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '6',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '7',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '8',
  '\0',
  '\0',
  '\0',
  'g',
  'r',
  'm',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '9',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ':',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'A',
  'V',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ';',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'B',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '<',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'D',
  'S',
  'L',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '=',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '>',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'A',
  'V',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '?',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'B',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'D',
  'S',
  'L',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'A',
  '\0',
  '\0',
  '\0',
  'R',
  'P',
  'M',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'B',
  '\0',
  '\0',
  '\0',
  'r',
  'a',
  'd',
  '/',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100C6558; // weak
char aInactive[9] = "INACTIVE"; // weak
_UNKNOWN unk_100C6AC8; // weak
char *off_100C6B08 = "FIL_close"; // weak
_UNKNOWN unk_100C8DBC; // weak
int (__cdecl *off_100C8DC4)(int) = &sub_10004180; // weak
char byte_100C8DC8[] = { '\0' }; // weak
char aDiagnostics[12] = "DIAGNOSTICS"; // weak
char *off_100CAC70 = "global"; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
char *off_100CBD18 = "global"; // weak
_UNKNOWN unk_100CC178; // weak
char word_100CC1C0[] = { '.', '\0' }; // idb
int (__cdecl *off_100CC628[4])(int, int) = { &sub_1003F180, &sub_1003F1A0, &sub_10015050, &sub_10015060 }; // weak
char byte_100CC6F1[] = { 'o' }; // weak
int dword_100CC788[] = { 4294967295 }; // weak
char *off_100CC78C = "Error"; // weak
int (__cdecl *off_100CC790)(int, int, int, int, int) = &sub_1001A0B0; // weak
char byte_100CC948[] = { '\0' }; // weak
char byte_100CCAA8[] = { '\0' }; // weak
char byte_100CCEA8[] = { '\0' }; // weak
_BYTE dword_100CED28[496] =
{
  15,
  0,
  1,
  0,
  15,
  0,
  4,
  0,
  12,
  0,
  4,
  0,
  24,
  0,
  0,
  0,
  26,
  0,
  6,
  0,
  21,
  0,
  0,
  0,
  22,
  0,
  0,
  0,
  25,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  9,
  96,
  3,
  0,
  1,
  254,
  39,
  8,
  27,
  0,
  0,
  0,
  23,
  0,
  5,
  0,
  2,
  254,
  23,
  8,
  12,
  0,
  0,
  0,
  28,
  0,
  0,
  0,
  2,
  0,
  7,
  0,
  11,
  96,
  0,
  0,
  11,
  80,
  0,
  0,
  11,
  128,
  0,
  0,
  1,
  0,
  39,
  8,
  2,
  0,
  23,
  8,
  2,
  0,
  215,
  225,
  1,
  0,
  103,
  0,
  2,
  0,
  87,
  0,
  1,
  0,
  103,
  206,
  2,
  0,
  23,
  58,
  1,
  0,
  231,
  225,
  2,
  0,
  23,
  75,
  1,
  0,
  167,
  52,
  1,
  0,
  167,
  51,
  1,
  0,
  103,
  51,
  1,
  0,
  167,
  50,
  1,
  0,
  231,
  50,
  1,
  0,
  231,
  51,
  1,
  0,
  231,
  52,
  1,
  0,
  103,
  52,
  1,
  0,
  103,
  53,
  1,
  0,
  7,
  0,
  1,
  0,
  167,
  54,
  5,
  0,
  7,
  0,
  1,
  0,
  103,
  54,
  1,
  0,
  231,
  54,
  1,
  0,
  175,
  0,
  3,
  0,
  127,
  0,
  2,
  0,
  159,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  151,
  52,
  2,
  0,
  151,
  51,
  2,
  0,
  87,
  51,
  2,
  0,
  151,
  50,
  2,
  0,
  215,
  50,
  2,
  0,
  215,
  51,
  2,
  0,
  87,
  52,
  2,
  0,
  215,
  52,
  2,
  0,
  87,
  53,
  2,
  0,
  151,
  54,
  2,
  0,
  87,
  54,
  2,
  0,
  215,
  54,
  4,
  0,
  7,
  0,
  6,
  0,
  3,
  0,
  1,
  0,
  167,
  9,
  1,
  0,
  103,
  9,
  1,
  0,
  39,
  16,
  1,
  0,
  231,
  15,
  2,
  0,
  151,
  9,
  2,
  0,
  87,
  9,
  2,
  0,
  23,
  16,
  2,
  0,
  215,
  15,
  2,
  0,
  151,
  15,
  2,
  0,
  87,
  14,
  2,
  0,
  215,
  11,
  2,
  0,
  151,
  13,
  2,
  0,
  151,
  21,
  2,
  0,
  23,
  20,
  1,
  0,
  39,
  20,
  1,
  0,
  39,
  12,
  2,
  0,
  23,
  12,
  9,
  64,
  3,
  0,
  7,
  0,
  0,
  0,
  8,
  0,
  3,
  0,
  9,
  116,
  3,
  0,
  11,
  90,
  0,
  0,
  11,
  110,
  0,
  0,
  11,
  116,
  0,
  0,
  11,
  0,
  0,
  0,
  2,
  0,
  23,
  254,
  1,
  0,
  39,
  254,
  2,
  0,
  151,
  237,
  2,
  0,
  151,
  234,
  2,
  0,
  23,
  231,
  2,
  0,
  23,
  224,
  2,
  0,
  23,
  228,
  2,
  0,
  151,
  224,
  2,
  0,
  215,
  253,
  1,
  0,
  167,
  237,
  1,
  0,
  231,
  253,
  1,
  0,
  167,
  234,
  1,
  0,
  39,
  231,
  2,
  0,
  87,
  254,
  1,
  0,
  39,
  228,
  1,
  0,
  103,
  254,
  1,
  0,
  39,
  224,
  1,
  0,
  167,
  224,
  16,
  0,
  1,
  0,
  13,
  0,
  4,
  0,
  14,
  0,
  4,
  0,
  11,
  64,
  0,
  0,
  11,
  68,
  0,
  0,
  10,
  66,
  39,
  4,
  10,
  128,
  39,
  4,
  10,
  98,
  23,
  4,
  10,
  128,
  23,
  4,
  10,
  128,
  7,
  0,
  11,
  66,
  0,
  0,
  11,
  114,
  0,
  0,
  28,
  0,
  160,
  6,
  28,
  0,
  144,
  6,
  11,
  108,
  0,
  0,
  11,
  86,
  0,
  0,
  10,
  114,
  7,
  0,
  10,
  64,
  7,
  0,
  19,
  0,
  0,
  0,
  18,
  0,
  0,
  0
}; // idb
char byte_100CEFC0[] = { '0' }; // weak
int dword_100CEFCC[] = { 1178944579 }; // weak
_UNKNOWN unk_100CEFE8; // weak
_UNKNOWN unk_100CF000; // weak
_UNKNOWN unk_100CF004; // weak
int (__cdecl *off_100CF9C0[4])(int, int) = { &sub_1003F180, &sub_1003F1A0, &sub_1003F1C0, &sub_10039780 }; // weak
double dbl_100CF9D8[] = {  1.605962767520329e-231 }; // weak
int dword_100CF9FC[] = { 0 }; // weak
int dword_100CFA0C = 0; // idb
double dbl_100CFA18[] = { ?flt }; // weak
double dbl_100CFA20[] = {  1.0 }; // weak
double dbl_100CFAD8[] = {  1.0e16 }; // weak
_UNKNOWN unk_100CFB00; // weak
_UNKNOWN unk_100CFB78; // weak
char *off_100D1068 = "<Error #0 is reserved>"; // weak
int (__cdecl *off_100D1608[4])(int, int) = { &sub_1003F180, &sub_1003F1A0, &sub_1003F1C0, &sub_1003F1D0 }; // weak
__int16 word_100D1C0C = 48; // weak
_UNKNOWN unk_100D1D24; // weak
_UNKNOWN unk_100D1D34; // weak
void *off_100D1E40 = &unk_100D1DC8; // weak
int dword_100D1E44[] = { 0 }; // weak
char byte_100D1E48[] = { '\x01' }; // weak
char byte_100D1E4B[] = { '\0' }; // weak
int dword_100D1E4C[] = { 0 }; // weak
_UNKNOWN unk_100D27E0; // weak
char word_100D2B44[] = { ' ', '\0' }; // idb
_UNKNOWN unk_100D2B50; // weak
void *off_100D5618 = &unk_100D5530; // weak
char *off_100D7368[2] = { "%02d:%02u", "__:__" }; // weak
char *off_100D736C = "__:__"; // weak
char byte_100D7370[] = { '9' }; // weak
char a03d02u[11] = "%+03d:%02u"; // weak
int dword_100D7398 = 1; // weak
__int16 word_100D739C[] = { 99 }; // weak
int dword_100D73A0 = 4; // weak
char byte_100D73A4[] = { '\0' }; // weak
char byte_100D73A5[] = { '\x01' }; // weak
char byte_100D7628[] = { '#' }; // weak
char *off_100D8DE0 = "012345"; // idb
char *off_100DAAA4 = "%02u-%3s-%02u"; // idb
char *off_100DAAA8 = "__-___-__"; // weak
char byte_100DAAAC[] = { '\x06' }; // weak
char byte_100DAAAD[] = { '\x03' }; // weak
int dword_100DAAB0[] = { 3 }; // weak
int dword_100DAAB4[] = { 0 }; // weak
int dword_100DAAB8[] = { 7 }; // weak
char byte_100DAABC[] = { '\x01' }; // weak
int dword_100DCCD8[] = { 360 }; // weak
float flt_100DCCDC[] = {  360.0 }; // weak
char byte_100DCCE0[] = { '\0' }; // weak
char byte_100DCCE1[] = { '\x03' }; // weak
char byte_100DCCE2[] = { '\x01' }; // weak
char byte_100DCCE3[85] =
{
  '!',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '4',
  'C',
  '\x01',
  '\x04',
  '\0',
  '!',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  'C',
  '\0',
  '\x03',
  '\x01',
  '!',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  'C',
  '\0',
  '\x05',
  '\x01',
  '!',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '3',
  'C',
  '\x01',
  '\x03',
  '\x01',
  '',
  'W',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '4',
  'C',
  '\x01',
  '\x03',
  '\0',
  '',
  '',
  '\0',
  '\0',
  '\0'
}; // idb
void *off_100DD5A8 = &unk_100DD350; // weak
void *off_100DD5AC = &unk_100DD354; // weak
char *off_100DD5C0[2] = { "_ __@__.__'", "____@__.__'" }; // weak
char *off_100DD5C4 = "____@__.__'"; // weak
__int16 word_100DD5C8[] = { 0 }; // weak
__int16 word_100DD5CA[] = { 11 }; // weak
__int16 word_100DD5CC[] = { 11 }; // weak
__int16 word_100DD5CE[] = { 11 }; // weak
double dbl_100DD6C0 =  3600.0; // weak
__int16 word_100DD6C8[] = { 4094 }; // weak
_UNKNOWN unk_100DD6DE; // weak
char *(*off_100DF3B8[2])[3] = { &off_100DF380, &off_100DF39C }; // weak
char *off_100DF3C0 = "1"; // idb
_UNKNOWN unk_100E0A88; // weak
_UNKNOWN unk_100E0A94; // weak
char byte_100E15F4[] = { '@' }; // weak
char byte_100E15F5[] = { '@' }; // weak
char byte_100E15F6[] = { '@' }; // weak
_UNKNOWN unk_100E162E; // weak
char byte_100E1630[] = { '\x0E' }; // weak
char byte_100E27C0[] = { 'A' }; // weak
char byte_100E27D4[] = { 'A' }; // weak
_UNKNOWN unk_100E345C; // weak
char byte_100E345D[] = { '\x0E' }; // weak
_UNKNOWN unk_100E3558; // weak
__int16 word_100E355C[] = { 2 }; // weak
__int16 word_100E4094[] = { 81 }; // weak
_UNKNOWN unk_100E40C1; // weak
_UNKNOWN unk_100E461C; // weak
_UNKNOWN unk_100E4624; // weak
_UNKNOWN unk_100E462C; // weak
_UNKNOWN unk_100E4634; // weak
_UNKNOWN unk_100E46E0; // weak
void *off_100E46E4 = &unk_100E4654; // weak
char *off_100E4B58[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100E49C8 }; // weak
_UNKNOWN unk_100E4B6C; // weak
__int16 word_100E6D90[] = { 0 }; // weak
int dword_100E846C[] = { 88 }; // weak
__int16 word_100E891C[] = { 836 }; // weak
char *off_100E893C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_100E8950 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_100E8964 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_100E8978 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_100E898C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_100E89A0 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
_BYTE word_100E98EA[1574] =
{
  154,
  66,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  0,
  0,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0,
  0,
  14,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28
}; // idb
char *off_100F0D30 = "/shr_mem/mon_log_intf.shr"; // weak
char *off_100F0D44 = "/shr_mem/mon_main_intf.shr"; // weak
char *off_100F0DD8 = "/shr_mem/nav_intf.shr"; // weak
int (*off_100F1318[4])() = { &sub_10079330, &sub_10079320, &sub_10079310, &sub_10079300 }; // weak
char *off_100F20D0[4] = { "A", "AMPS", "", "" }; // weak
char *off_100F20D4[3] = { "AMPS", "", "" }; // weak
char byte_100F2FA7[] = { '\0' }; // weak
_UNKNOWN unk_100F3010; // weak
_UNKNOWN unk_100F31C0; // weak
int dword_100F31C4[] = { 1312 }; // weak
_UNKNOWN unk_100F4870; // weak
char byte_100F4874[] = { '\0' }; // weak
_UNKNOWN unk_100F58E8; // weak
char *off_100F5A8C[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100F5AA0 }; // weak
char *off_100F5C30 = "true"; // weak
char byte_100F5C34[] = { '\x01' }; // weak
char *off_100F5C98 = "failure listener"; // weak
_UNKNOWN unk_100F6420; // weak
char *off_100F6624[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_100F662C[3] = { "normal", "robust", "EQ" }; // weak
char *off_100F6634 = "EQ"; // weak
char *off_100F6650[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100F665C[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_100F6664[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_100F6900; // weak
char *off_100F6CC8 = "printf_listener"; // weak
__int16 word_100F78F4 = 2573; // weak
int (*off_100F79A8[2])() = { &sub_10098590, &sub_100710D0 }; // weak
char *off_100F7A58 = "gate_listener"; // weak
__int16 word_100F8958[] = { 43 }; // weak
char byte_100F895C[] = { '\x06' }; // weak
_WORD dword_100F8D80[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100F9180[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100F9580[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100F9980[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100F9D80[] = { 99 }; // weak
int dword_100FA180[] = { 25344 }; // weak
int dword_100FA580[] = { 6488064 }; // weak
int dword_100FA980[] = { 1660944384 }; // weak
int dword_100FADA8[] = { 128 }; // weak
int dword_100FADB8[] = { 0 }; // weak
int dword_100FADC8[] = { 0 }; // weak
char byte_100FAE39[] = { '\0' }; // weak
char byte_100FAE3A[] = { '\0' }; // weak
char byte_100FAE3B[] = { '\0' }; // weak
char byte_100FAE3C[] = { '\x10' }; // weak
int dword_100FAE50[] = { 0 }; // weak
_UNKNOWN unk_100FAEC8; // weak
_UNKNOWN unk_100FB348; // weak
char byte_100FB3C0[] = { '\0' }; // weak
char byte_100FB4C0[] = { '\0' }; // weak
char byte_100FB5C0[] = { '\0' }; // weak
int dword_100FB6C0[] = { 0 }; // weak
int dword_100FB738[] = { 0 }; // weak
__int16 word_100FB7B0[] = { 0 }; // weak
__int16 word_100FB7B2[] = { 0 }; // weak
__int16 word_100FB7B4[] = { 0 }; // weak
__int16 word_100FB7B6[] = { 0 }; // weak
int (__cdecl *off_100FB7B8)(int, int) = &sub_1008C030; // weak
void *off_100FB964 = &unk_100FAEC8; // weak
void *off_100FB978 = &unk_100FB348; // weak
_UNKNOWN unk_100FB98C; // weak
int dword_100FB9A0[] = { 0 }; // weak
int dword_100FB9E8[] = { 16 }; // weak
_UNKNOWN unk_100FBA38; // weak
_UNKNOWN unk_100FBAB8; // weak
_UNKNOWN unk_100FBB38; // weak
_UNKNOWN unk_100FBBB0; // weak
_UNKNOWN unk_100FBC28; // weak
_UNKNOWN unk_100FCC28; // weak
_UNKNOWN unk_100FEB08; // weak
_UNKNOWN unk_100FEB20; // weak
_UNKNOWN unk_100FEB68; // weak
int dword_100FEB6C[] = { 6767 }; // weak
_UNKNOWN unk_100FEB78; // weak
_UNKNOWN unk_100FEB90; // weak
_UNKNOWN unk_100FEBA8; // weak
int dword_100FEBAC[] = { 6769 }; // weak
_UNKNOWN unk_100FEBC0; // weak
int dword_100FEBC4[] = { 6093 }; // weak
char byte_100FEBD0[] = { '\x01' }; // weak
__int16 word_100FEBD2[] = { 3020 }; // weak
int (__cdecl *off_100FF8A0[3])(char) = { &sub_100712D0, &sub_100711E0, &sub_100711A0 }; // weak
_UNKNOWN unk_10101FF8; // weak
int dword_10101FFC[] = { 0 }; // weak
int dword_10104D28[] = { 1600085855 }; // weak
_UNKNOWN unk_10105BE8; // weak
char byte_10105BE9[] = { '\0' }; // weak
_UNKNOWN unk_10106B04; // weak
_UNKNOWN unk_10106B28; // weak
_UNKNOWN unk_10106CD0; // weak
char off_10107900[] = { '\x10', 'f', '\x0F', '\x10' }; // idb
int dword_1010791C = 1; // idb
char byte_10107938[] = { '\x01' }; // weak
char *off_1010793C[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_10107940[2] = { "2", "fail_normal_1" }; // weak
char off_10107944[8] = { '', 'x', '\x10', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_101079C8[] = { '\0' }; // weak
char byte_101079C9[] = { '\0' }; // weak
int dword_101079CC[] = { 0 }; // weak
char *off_101079D0 = "0, 0, 0"; // weak
double dbl_10107C38[] = {  0.0 }; // weak
double dbl_10107C40[] = {  0.0 }; // weak
double dbl_10107C48[] = {  0.0 }; // weak
int dword_10107C50[] = { 0 }; // weak
char off_10107C54[32] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10108858[] = {  0.0 }; // weak
float flt_1010885C[] = {  0.0 }; // weak
float flt_10108860[] = {  0.0 }; // weak
int dword_10108864[] = { 0 }; // weak
char off_10108868[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_10108FEC[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_1011DC48
}; // weak
int dword_10109000[] = { 0 }; // weak
int dword_10109004[] = { 0 }; // weak
int dword_10109008[] = { 0 }; // weak
int dword_1010900C[] = { 0 }; // weak
char *off_10109010 = "0, 0, 0"; // weak
__int16 word_10109798[] = { 0 }; // weak
__int16 word_1010979A[] = { 0 }; // weak
__int16 word_1010979C[] = { 0 }; // weak
int dword_101097A0[] = { 0 }; // weak
char *off_101097A4 = "0, 0, 0"; // weak
int dword_10109DA8[] = { 0 }; // weak
int dword_10109DAC[] = { 0 }; // weak
int dword_10109DB0[] = { 0 }; // weak
int dword_10109DB4[] = { 0 }; // weak
char off_10109DB8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010A540[] = { 0 }; // weak
int dword_1010A544[] = { 0 }; // weak
int dword_1010A548[] = { 0 }; // weak
int dword_1010A54C[] = { 0 }; // weak
int dword_1010A550[] = { 0 }; // weak
int dword_1010A554[] = { 0 }; // weak
int dword_1010A558[] = { 0 }; // weak
char off_1010A55C[32] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1010B160[] = { '\0' }; // weak
char byte_1010B161[] = { '\0' }; // weak
char byte_1010B162[] = { '\0' }; // weak
int dword_1010B164[] = { 0 }; // weak
char *off_1010B168 = "0, 0, 0"; // weak
int dword_1010B5F0[] = { 0 }; // weak
int dword_1010B5F4[] = { 0 }; // weak
int dword_1010B5F8[] = { 0 }; // weak
int dword_1010B5FC[] = { 0 }; // weak
char *off_1010B600 = "0, 0, 0"; // weak
int dword_1010BD88[] = { 0 }; // weak
int dword_1010BD8C[] = { 0 }; // weak
int dword_1010BD90[] = { 0 }; // weak
int dword_1010BD94[] = { 0 }; // weak
char off_1010BD98[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1010C0F8[] = { 0 }; // weak
__int16 word_1010C0FA[] = { 0 }; // weak
__int16 word_1010C0FC[] = { 0 }; // weak
int dword_1010C100[] = { 0 }; // weak
char *off_1010C104 = "0, 0, 0"; // weak
int dword_1010C3B8[] = { 0 }; // weak
int dword_1010C3BC[] = { 0 }; // weak
int dword_1010C3C0[] = { 0 }; // weak
int dword_1010C3C4[] = { 0 }; // weak
char off_1010C3C8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010C728[] = { 0 }; // weak
int dword_1010C72C[] = { 0 }; // weak
int dword_1010C730[] = { 0 }; // weak
int dword_1010C734[] = { 0 }; // weak
int dword_1010C738[] = { 0 }; // weak
int dword_1010C73C[] = { 0 }; // weak
int dword_1010C740[] = { 0 }; // weak
char *off_1010C744 = "0, 0, 0"; // weak
char byte_1010CCA8[] = { '\0' }; // weak
char byte_1010CCA9[] = { '\0' }; // weak
char byte_1010CCAA[] = { '\0' }; // weak
int dword_1010CCAC[] = { 0 }; // weak
char *off_1010CCB0 = "0, 0, 0"; // weak
int dword_1010CEB8[] = { 0 }; // weak
int dword_1010CEBC[] = { 0 }; // weak
int dword_1010CEC0[] = { 0 }; // weak
int dword_1010CEC4[] = { 0 }; // weak
char off_1010CEC8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1010D228[] = { '\x01' }; // weak
char *off_1010D22C[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_1010D230[2] = { "2", "fail_robust_1" }; // weak
char off_1010D234[8] = { '`', 't', '\x10', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1010D2B8[] = { '\0' }; // weak
char byte_1010D2B9[] = { '\0' }; // weak
int dword_1010D2BC[] = { 0 }; // weak
char *off_1010D2C0 = "0, 0, 0"; // weak
double dbl_1010D528[] = {  0.0 }; // weak
double dbl_1010D530[] = {  0.0 }; // weak
double dbl_1010D538[] = {  0.0 }; // weak
int dword_1010D540[] = { 0 }; // weak
char *off_1010D544 = "0, 0, 0"; // weak
float flt_1010E148[] = {  0.0 }; // weak
float flt_1010E14C[] = {  0.0 }; // weak
float flt_1010E150[] = {  0.0 }; // weak
int dword_1010E154[] = { 0 }; // weak
char off_1010E158[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010E8E0[] = { 0 }; // weak
int dword_1010E8E4[] = { 0 }; // weak
int dword_1010E8E8[] = { 0 }; // weak
int dword_1010E8EC[] = { 0 }; // weak
char *off_1010E8F0 = "0, 0, 0"; // weak
__int16 word_1010F078[] = { 0 }; // weak
__int16 word_1010F07A[] = { 0 }; // weak
__int16 word_1010F07C[] = { 0 }; // weak
int dword_1010F080[] = { 0 }; // weak
char *off_1010F084 = "0, 0, 0"; // weak
int dword_1010F688[] = { 0 }; // weak
int dword_1010F68C[] = { 0 }; // weak
int dword_1010F690[] = { 0 }; // weak
int dword_1010F694[] = { 0 }; // weak
char off_1010F698[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010FE20[] = { 0 }; // weak
int dword_1010FE24[] = { 0 }; // weak
int dword_1010FE28[] = { 0 }; // weak
int dword_1010FE2C[] = { 0 }; // weak
int dword_1010FE30[] = { 0 }; // weak
int dword_1010FE34[] = { 0 }; // weak
int dword_1010FE38[] = { 0 }; // weak
char off_1010FE3C[32] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10110A40[] = { '\0' }; // weak
char byte_10110A41[] = { '\0' }; // weak
char byte_10110A42[] = { '\0' }; // weak
int dword_10110A44[] = { 0 }; // weak
char *off_10110A48 = "0, 0, 0"; // weak
int dword_10110ED0[] = { 0 }; // weak
int dword_10110ED4[] = { 0 }; // weak
int dword_10110ED8[] = { 0 }; // weak
int dword_10110EDC[] = { 0 }; // weak
char *off_10110EE0 = "0, 0, 0"; // weak
int dword_10111668[] = { 0 }; // weak
int dword_1011166C[] = { 0 }; // weak
int dword_10111670[] = { 0 }; // weak
int dword_10111674[] = { 0 }; // weak
char off_10111678[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_101119D8[] = { 0 }; // weak
__int16 word_101119DA[] = { 0 }; // weak
__int16 word_101119DC[] = { 0 }; // weak
int dword_101119E0[] = { 0 }; // weak
char *off_101119E4 = "0, 0, 0"; // weak
int dword_10111C98[] = { 0 }; // weak
int dword_10111C9C[] = { 0 }; // weak
int dword_10111CA0[] = { 0 }; // weak
int dword_10111CA4[] = { 0 }; // weak
char off_10111CA8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10112008[] = { 0 }; // weak
int dword_1011200C[] = { 0 }; // weak
int dword_10112010[] = { 0 }; // weak
int dword_10112014[] = { 0 }; // weak
int dword_10112018[] = { 0 }; // weak
int dword_1011201C[] = { 0 }; // weak
int dword_10112020[] = { 0 }; // weak
char *off_10112024 = "0, 0, 0"; // weak
char byte_10112588[] = { '\0' }; // weak
char byte_10112589[] = { '\0' }; // weak
char byte_1011258A[] = { '\0' }; // weak
int dword_1011258C[] = { 0 }; // weak
char *off_10112590 = "0, 0, 0"; // weak
int dword_10112798[] = { 0 }; // weak
int dword_1011279C[] = { 0 }; // weak
int dword_101127A0[] = { 0 }; // weak
int dword_101127A4[] = { 0 }; // weak
char off_101127A8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10112B08[] = { '\x01' }; // weak
char *off_10112B0C[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_10112B10[2] = { "1", "pass_normal_1" }; // weak
char off_10112B14[8] = { '', 's', '\x10', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10112B58[] = { '\0' }; // weak
char byte_10112B59[] = { '\0' }; // weak
int dword_10112B5C[] = { 0 }; // weak
char *off_10112B60 = "0, 0, 0"; // weak
double dbl_10112DC8[] = {  0.0 }; // weak
double dbl_10112DD0[] = {  0.0 }; // weak
double dbl_10112DD8[] = {  0.0 }; // weak
int dword_10112DE0[] = { 0 }; // weak
char *off_10112DE4 = "0, 0, 0"; // weak
float flt_101139E8[] = {  0.0 }; // weak
float flt_101139EC[] = {  0.0 }; // weak
float flt_101139F0[] = {  0.0 }; // weak
int dword_101139F4[] = { 0 }; // weak
char off_101139F8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10114180[] = { 0 }; // weak
int dword_10114184[] = { 0 }; // weak
int dword_10114188[] = { 0 }; // weak
int dword_1011418C[] = { 0 }; // weak
char *off_10114190 = "0, 0, 0"; // weak
__int16 word_10114918[] = { 0 }; // weak
__int16 word_1011491A[] = { 0 }; // weak
__int16 word_1011491C[] = { 0 }; // weak
int dword_10114920[] = { 0 }; // weak
char *off_10114924 = "0, 0, 0"; // weak
int dword_10114F28[] = { 0 }; // weak
int dword_10114F2C[] = { 0 }; // weak
int dword_10114F30[] = { 0 }; // weak
int dword_10114F34[] = { 0 }; // weak
char off_10114F38[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101156C0[] = { 0 }; // weak
int dword_101156C4[] = { 0 }; // weak
int dword_101156C8[] = { 0 }; // weak
int dword_101156CC[] = { 0 }; // weak
int dword_101156D0[] = { 0 }; // weak
int dword_101156D4[] = { 0 }; // weak
int dword_101156D8[] = { 0 }; // weak
char off_101156DC[32] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_101162E0[] = { '\0' }; // weak
char byte_101162E1[] = { '\0' }; // weak
char byte_101162E2[] = { '\0' }; // weak
int dword_101162E4[] = { 0 }; // weak
char *off_101162E8 = "0, 0, 0"; // weak
int dword_10116770[] = { 0 }; // weak
int dword_10116774[] = { 0 }; // weak
int dword_10116778[] = { 0 }; // weak
int dword_1011677C[] = { 0 }; // weak
char *off_10116780 = "0, 0, 0"; // weak
int dword_10116F08[] = { 0 }; // weak
int dword_10116F0C[] = { 0 }; // weak
int dword_10116F10[] = { 0 }; // weak
int dword_10116F14[] = { 0 }; // weak
char off_10116F18[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10117278[] = { 0 }; // weak
__int16 word_1011727A[] = { 0 }; // weak
__int16 word_1011727C[] = { 0 }; // weak
int dword_10117280[] = { 0 }; // weak
char *off_10117284 = "0, 0, 0"; // weak
int dword_10117538[] = { 0 }; // weak
int dword_1011753C[] = { 0 }; // weak
int dword_10117540[] = { 0 }; // weak
int dword_10117544[] = { 0 }; // weak
char off_10117548[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101178A8[] = { 0 }; // weak
int dword_101178AC[] = { 0 }; // weak
int dword_101178B0[] = { 0 }; // weak
int dword_101178B4[] = { 0 }; // weak
int dword_101178B8[] = { 0 }; // weak
int dword_101178BC[] = { 0 }; // weak
int dword_101178C0[] = { 0 }; // weak
char *off_101178C4 = "0, 0, 0"; // weak
char byte_10117E28[] = { '\0' }; // weak
char byte_10117E29[] = { '\0' }; // weak
char byte_10117E2A[] = { '\0' }; // weak
int dword_10117E2C[] = { 0 }; // weak
char *off_10117E30 = "0, 0, 0"; // weak
int dword_10118038[] = { 0 }; // weak
int dword_1011803C[] = { 0 }; // weak
int dword_10118040[] = { 0 }; // weak
int dword_10118044[] = { 0 }; // weak
char off_10118048[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_101183A8[] = { '\x01' }; // weak
char *off_101183AC[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_101183B0[2] = { "1", "pass_robust_1" }; // weak
char off_101183B4[8] = { '', 's', '\x10', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_101183F8[] = { '\0' }; // weak
char byte_101183F9[] = { '\0' }; // weak
int dword_101183FC[] = { 0 }; // weak
char *off_10118400 = "0, 0, 0"; // weak
double dbl_10118668[] = {  0.0 }; // weak
double dbl_10118670[] = {  0.0 }; // weak
double dbl_10118678[] = {  0.0 }; // weak
int dword_10118680[] = { 0 }; // weak
char *off_10118684 = "0, 0, 0"; // weak
float flt_10119288[] = {  0.0 }; // weak
float flt_1011928C[] = {  0.0 }; // weak
float flt_10119290[] = {  0.0 }; // weak
int dword_10119294[] = { 0 }; // weak
char off_10119298[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10119A20[] = { 0 }; // weak
int dword_10119A24[] = { 0 }; // weak
int dword_10119A28[] = { 0 }; // weak
int dword_10119A2C[] = { 0 }; // weak
char *off_10119A30 = "0, 0, 0"; // weak
__int16 word_1011A1B8[] = { 0 }; // weak
__int16 word_1011A1BA[] = { 0 }; // weak
__int16 word_1011A1BC[] = { 0 }; // weak
int dword_1011A1C0[] = { 0 }; // weak
char *off_1011A1C4 = "0, 0, 0"; // weak
int dword_1011A7C8[] = { 0 }; // weak
int dword_1011A7CC[] = { 0 }; // weak
int dword_1011A7D0[] = { 0 }; // weak
int dword_1011A7D4[] = { 0 }; // weak
char off_1011A7D8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1011AF60[] = { 0 }; // weak
int dword_1011AF64[] = { 0 }; // weak
int dword_1011AF68[] = { 0 }; // weak
int dword_1011AF6C[] = { 0 }; // weak
int dword_1011AF70[] = { 0 }; // weak
int dword_1011AF74[] = { 0 }; // weak
int dword_1011AF78[] = { 0 }; // weak
char off_1011AF7C[32] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1011BB80[] = { '\0' }; // weak
char byte_1011BB81[] = { '\0' }; // weak
char byte_1011BB82[] = { '\0' }; // weak
int dword_1011BB84[] = { 0 }; // weak
char *off_1011BB88 = "0, 0, 0"; // weak
int dword_1011C010[] = { 0 }; // weak
int dword_1011C014[] = { 0 }; // weak
int dword_1011C018[] = { 0 }; // weak
int dword_1011C01C[] = { 0 }; // weak
char *off_1011C020 = "0, 0, 0"; // weak
int dword_1011C7A8[] = { 0 }; // weak
int dword_1011C7AC[] = { 0 }; // weak
int dword_1011C7B0[] = { 0 }; // weak
int dword_1011C7B4[] = { 0 }; // weak
char off_1011C7B8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1011CB18[] = { 0 }; // weak
__int16 word_1011CB1A[] = { 0 }; // weak
__int16 word_1011CB1C[] = { 0 }; // weak
int dword_1011CB20[] = { 0 }; // weak
char *off_1011CB24 = "0, 0, 0"; // weak
int dword_1011CDD8[] = { 0 }; // weak
int dword_1011CDDC[] = { 0 }; // weak
int dword_1011CDE0[] = { 0 }; // weak
int dword_1011CDE4[] = { 0 }; // weak
char off_1011CDE8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1011D148[] = { 0 }; // weak
int dword_1011D14C[] = { 0 }; // weak
int dword_1011D150[] = { 0 }; // weak
int dword_1011D154[] = { 0 }; // weak
int dword_1011D158[] = { 0 }; // weak
int dword_1011D15C[] = { 0 }; // weak
int dword_1011D160[] = { 0 }; // weak
char *off_1011D164 = "0, 0, 0"; // weak
char byte_1011D6C8[] = { '\0' }; // weak
char byte_1011D6C9[] = { '\0' }; // weak
char byte_1011D6CA[] = { '\0' }; // weak
int dword_1011D6CC[] = { 0 }; // weak
char *off_1011D6D0 = "0, 0, 0"; // weak
int dword_1011D8D8[] = { 0 }; // weak
int dword_1011D8DC[] = { 0 }; // weak
int dword_1011D8E0[] = { 0 }; // weak
int dword_1011D8E4[] = { 0 }; // weak
char off_1011D8E8[20] =
{
  'P',
  'x',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_1011E8C8; // weak
int dword_10121A94[] = { 0 }; // weak
__int16 *off_10121A98 = &word_100F78F4; // weak
_UNKNOWN unk_10121B28; // weak
_UNKNOWN unk_10121B2C; // weak
_UNKNOWN unk_10121B30; // weak
_UNKNOWN unk_10121B34; // weak
_UNKNOWN unk_10121B38; // weak
_UNKNOWN unk_10121B3C; // weak
char byte_10124D98[] = { '\x01' }; // weak
__int16 word_10124D9A[] = { 3020 }; // weak
char byte_10126660[] = { '\x01' }; // weak
__int16 word_10126668[] = { 3020 }; // weak
_UNKNOWN unk_1013B6C0; // weak
int dword_1013B6C4[] = { 6829 }; // weak
int dword_1013C538 = 64; // weak
__int16 word_1013C53C[] = { 6782 }; // weak
__int16 word_1013C540[] = { 128 }; // weak
_UNKNOWN unk_1013C55C; // weak
_DWORD dword_1013C560[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
__int16 word_1013D970[] = { 1565 }; // weak
__int16 word_1013D974[] = { 534 }; // weak
char byte_1013D978[] = { '\x04' }; // weak
__int16 word_1013D97A[] = { 6512 }; // weak
int dword_1013D990[] = { 118000 }; // weak
__int16 word_1013E4BA[] = { 233 }; // weak
int dword_1013E4C0[] = { 6201 }; // weak
__int16 word_10141070[] = { 114 }; // weak
_UNKNOWN unk_101418A8; // weak
int dword_101418AC[] = { 6006 }; // weak
char *off_10142758 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_10142878[] = { 551 }; // weak
_UNKNOWN unk_10147960; // weak
int dword_10147964[] = { 0 }; // weak
_UNKNOWN unk_10147978; // weak
int dword_1014797C[] = { 0 }; // weak
_UNKNOWN unk_101479A0; // weak
int dword_101479A4[] = { 0 }; // weak
_UNKNOWN unk_101479D0; // weak
int dword_101479D4[] = { 0 }; // weak
char byte_10149542[] = { '\x04' }; // weak
char byte_10149547[] = { '\a' }; // weak
_UNKNOWN unk_1014D278; // weak
int dword_1014D27C[] = { 3535 }; // weak
_UNKNOWN unk_1014D2B0; // weak
int dword_1014D2B4[] = { 6813 }; // weak
_UNKNOWN unk_1014D2E8; // weak
int dword_1014D2EC[] = { 9036 }; // weak
_UNKNOWN unk_1014D320; // weak
int dword_1014D324[] = { 6763 }; // weak
int dword_1014F6B0[] = { 6103 }; // weak
int dword_1014F6B4[] = { 8000 }; // weak
char byte_101502E8[] = { '\0' }; // weak
char byte_101502F4[12] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0'
}; // idb
int (__cdecl *off_10150300[16])(int, int) =
{
  &sub_100A0DF0,
  &sub_100A0DF0,
  &sub_100A0DF0,
  &sub_100A0FA0,
  &sub_100A0FA0,
  &sub_100A0FA0,
  &sub_100A0FA0,
  &sub_100A0DF0,
  &sub_100A0BB0,
  &sub_100A0B60,
  &sub_100A0B60,
  &sub_100A0BB0,
  &sub_100A0BB0,
  &sub_100A0B60,
  &sub_100A0B60,
  &sub_100A0BB0
}; // weak
int (__cdecl *off_10150320[8])(int, int) =
{
  &sub_100A0BB0,
  &sub_100A0B60,
  &sub_100A0B60,
  &sub_100A0BB0,
  &sub_100A0BB0,
  &sub_100A0B60,
  &sub_100A0B60,
  &sub_100A0BB0
}; // weak
int dword_10150348 = 0; // idb
int (__cdecl *off_10150748)(int, void *, size_t) = &sub_100A4B00; // weak
char byte_101508A8[] = { '\0' }; // weak
_DWORD off_101508AC[2] = { 269813916, 1 }; // idb
char byte_101508F0[] = { '\0' }; // weak
char *off_101508F4[2] = { "px", "aqua" }; // weak
char *off_101508F8 = "aqua"; // weak
char byte_101508FC[] = { '\0' }; // weak
char byte_101508FD[] = { '\xFF' }; // weak
char byte_101508FE[] = { '\xFF' }; // weak
char byte_10150978[] = { '\x01' }; // weak
char *off_1015097C = "background-color"; // weak
int (__cdecl *off_10150980)(int, char, int, int) = &sub_100A5390; // weak
_DWORD off_10150E30[3] = { 269815336, 6, 0 }; // idb
char *off_10151154 = "width"; // weak
int dword_10151670[] = { 0 }; // weak
_UNKNOWN unk_1015F960; // weak
_UNKNOWN unk_1015F968; // weak
char *off_10161000 = "id"; // weak
char *off_10161050 = "HTMLSelectElement"; // weak
char *off_10161098 = "id"; // weak
char *off_10161108 = "HTMLInputElement"; // weak
char *off_10161150 = "length"; // weak
char *off_10161170 = "HTMLCollection"; // weak
char *off_101611B8 = "innerHTML"; // weak
char *off_101611F8 = "color"; // weak
char *off_10161218 = "HTMLElement"; // weak
char *off_10161260 = "getAttribute"; // weak
char *off_10161288 = "style"; // weak
char *off_101612D0 = "appVersion"; // weak
char *off_10161310 = "navigator"; // weak
char *off_10161358 = "document"; // weak
char *off_101613A0 = "createElement"; // weak
char *off_101613C8 = "window"; // weak
char *off_10161410 = "Windowframes"; // weak
char *off_10161458 = "clearInterval"; // weak
char *off_1016147C = "location"; // weak
int (__cdecl *off_101614B0)(int, int, int, int, int) = &sub_10015860; // weak
char *off_10161510 = "Object"; // weak
char *off_10161558 = "__proto__"; // weak
char *off_10161598 = "toSource"; // weak
int (__cdecl *off_10161650)(int, int, int, int, int) = &sub_10015860; // weak
char *off_101616B0 = "With"; // weak
char aMessage[8] = "message"; // weak
char aFilename[9] = "fileName"; // weak
char aLinenumber[11] = "lineNumber"; // weak
char aStack_0[6] = "stack"; // weak
char *off_10161720 = "Error"; // weak
char *off_10161768 = "toSource"; // weak
int dword_10161790[] = { 4294967295 }; // weak
char *off_10161A38 = "escape"; // weak
int dword_10161A98 = 0; // weak
_UNKNOWN off_10161A9C; // weak
char *off_10161AA0 = "length"; // weak
char *off_10161AC0 = "String"; // weak
char *off_10161B08 = "quote"; // weak
char *off_10161CAC = "fromCharCode"; // weak
char *off_10161CC8 = "isNaN"; // weak
char *off_10161D08 = "Number"; // weak
char *off_10161D50 = "toSource"; // weak
double dbl_10161DB0 =  0.0; // weak
double dbl_10161DC0 =  0.0; // weak
double dbl_10161DD0 =  0.0; // weak
double dbl_10161DF0 =  0.0; // weak
char *off_10161E10 = "toSource"; // weak
char *off_10161E50 = "Script"; // weak
int (__cdecl *off_10161E98[3])(int, int) = { &sub_100384A0, &sub_100384C0, &sub_10021100 }; // weak
char *off_10161EA8 = "source"; // weak
char *off_10161F08 = "input"; // weak
char *off_10162008 = "RegExp"; // weak
char *off_10162050 = "toSource"; // weak
char *off_10162098 = "Object"; // weak
char *off_101620E0 = "arguments"; // weak
char *off_10162110 = "Call"; // weak
char *off_10162158 = "arguments"; // weak
char *off_101621B8 = "Function"; // weak
char *off_10162200 = "toSource"; // weak
_UNKNOWN unk_10162240; // weak
char *off_101622D0 = "Math"; // weak
char *off_10162318 = "toSource"; // weak
double dbl_10162408 =  1000.0; // weak
double dbl_10162410 =  8.64e7; // weak
double dbl_10162418 =  3600000.0; // weak
double dbl_10162420 =  60000.0; // weak
double dbl_10162428[] = {  0.0 }; // weak
char *off_101624E8 = "Date"; // weak
char *off_10162530[32] =
{
  "am",
  "pm",
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday",
  "saturday",
  "sunday",
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december",
  "gmt",
  "ut",
  "utc",
  "est",
  "edt",
  "cst",
  "cdt",
  "mst",
  "mdt",
  "pst",
  "pdt"
}; // weak
int dword_101625B0[] = { 4294967295 }; // weak
char aInvalidDate[13] = "Invalid Date"; // weak
char *off_10162640[20] =
{
  "Sun",
  "Mon",
  "Tue",
  "Wed",
  "Thu",
  "Fri",
  "Sat",
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
  "UTC"
}; // weak
char *off_1016265C[13] =
{
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
  "UTC"
}; // weak
char *off_1016268C = "UTC"; // weak
char *off_101626C0 = "getTime"; // weak
char *off_101628E0 = "Boolean"; // weak
char *off_10162928 = "toSource"; // weak
char *off_10162958 = "Array"; // weak
_UNKNOWN unk_101629AC; // weak
_UNKNOWN unk_101629B4; // weak
char *off_101629C0 = "toSource"; // weak
char *off_10162A98 = "PropertyIterator"; // weak
char *off_10162AE0[8] =
{
  "undefined",
  "object",
  "function",
  "string",
  "number",
  "boolean",
  "false",
  "true"
}; // weak
char *off_10162AF8[2] = { "false", "true" }; // weak
int (__cdecl *off_10162B00[3])(int, int) = { &sub_100384A0, &sub_100384C0, &sub_100384E0 }; // weak
int (__cdecl *off_10162B10)(int, int) = &sub_10038B60; // weak
char *off_10162B20[13] =
{
  "block",
  "label statement",
  "if statement",
  "else statement",
  "switch statement",
  "with statement",
  "try statement",
  "catch block",
  "finally statement",
  "do loop",
  "for loop",
  "for/in loop",
  "while loop"
}; // weak
char byte_10162B5C[] = { '\0' }; // weak
char byte_10162B5D[] = { '\0' }; // weak
char byte_10162B5E[] = { '\0' }; // weak
char *off_10162C20 = "break"; // weak
char *off_10162FE0[2] = { "increment", "decrement" }; // weak
void *off_10162FE8 = &unk_100D1DD0; // weak
char *off_10162FF4[2] = { "0123456789abcdef", "0123456789ABCDEF" }; // weak
char *off_10162FF8 = "0123456789ABCDEF"; // weak
char *off_10163000 = "lastChild"; // weak
char *off_10163020 = "Node"; // weak
char *off_10163068 = "appendChild"; // weak
char *off_10163090 = "HTMLTableCellElement"; // weak
char *off_101630D8 = "colSpan"; // weak
char *off_101630F8 = "HTMLTableElement"; // weak
char *off_10163140 = "insertRow"; // weak
int (__cdecl *off_10163158[3])(int, int) = { &sub_10051170, &sub_10051190, &sub_100511B0 }; // weak
double dbl_10163188 =  1.0e-300; // weak
double dbl_10163190 =  0.7853981633974483; // weak
double dbl_10163198 =  1.570796326794897; // weak
double dbl_101631A0 =  3.141592653589793; // weak
double dbl_101631A8 =  1.224646799147353e-16; // weak
double dbl_101631B0[] = {  1.0 }; // weak
_UNKNOWN unk_101631C0; // weak
double dbl_101631D0[] = {  0.0 }; // weak
double dbl_101631E0 =  1.0; // weak
double dbl_101631E8 =  2.0; // weak
double dbl_101631F0 =  9.007199254740992e15; // weak
double dbl_101631F8 =  1.0e300; // weak
double dbl_10163200 =  1.0e-300; // weak
double dbl_10163208 =  0.5999999999999946; // weak
double dbl_10163210 =  0.4285714285785502; // weak
double dbl_10163218 =  0.3333333298183774; // weak
double dbl_10163220 =  0.272728123808534; // weak
double dbl_10163228 =  0.2306607457755618; // weak
double dbl_10163230 =  0.2069750178003384; // weak
double dbl_10163238 =  0.166666666666666; // weak
double dbl_10163240 = -0.002777777777701559; // weak
double dbl_10163248 =  0.00006613756321437934; // weak
double dbl_10163250 = -0.000001653390220546525; // weak
double dbl_10163258 =  4.138136797057238e-8; // weak
double dbl_10163260 =  0.6931471805599453; // weak
double dbl_10163268 =  0.6931471824645996; // weak
double dbl_10163270 = -1.904654299957768e-9; // weak
double dbl_10163278 =  8.008566259537294e-17; // weak
double dbl_10163280 =  0.9617966939259756; // weak
double dbl_10163288 =  0.9617967009544373; // weak
double dbl_10163290 = -7.028461650952758e-9; // weak
double dbl_10163298 =  1.442695040888963; // weak
double dbl_101632A0 =  1.442695021629333; // weak
double dbl_101632A8 =  1.925962991126617e-8; // weak
double dbl_101632B0[] = {  0.4636476090008061 }; // weak
double dbl_101632C8 =  1.570796326794897; // weak
double dbl_101632D0[] = {  2.269877745296169e-17 }; // weak
double dbl_101632E8 =  6.123233995736766e-17; // weak
double dbl_101632F0 =  0.3333333333333293; // weak
double dbl_101632F8 = -0.1999999999987648; // weak
double dbl_10163300 =  0.1428571427250347; // weak
double dbl_10163308 = -0.1111111040546236; // weak
double dbl_10163310 =  0.09090887133436507; // weak
double dbl_10163318 = -0.0769187620504483; // weak
double dbl_10163320 =  0.06661073137387531; // weak
double dbl_10163328 = -0.05833570133790573; // weak
double dbl_10163330 =  0.04976877994615932; // weak
double dbl_10163338 = -0.03653157274421692; // weak
double dbl_10163340 =  0.01628582011536578; // weak
double dbl_10163348 =  1.0; // weak
double dbl_10163350 =  1.0e300; // weak
double dbl_10163358 =  1.801439850948198e16; // weak
double dbl_10163360 =  5.551115123125783e-17; // weak
double dbl_10163368 =  1.0e300; // weak
double dbl_10163370 =  1.0e-300; // weak
double dbl_10163378 =  1.0; // weak
double dbl_10163380 =  1.0e-300; // weak
double dbl_10163450 =  1.797693134862316e308; // weak
int (*off_1016368C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_10163CC8; // weak
void *off_10163D98 = &unk_1068B600; // weak
_UNKNOWN unk_10163DA8; // weak
_UNKNOWN unk_10163E08; // weak
char byte_10164018 = '\x03'; // weak
int dword_101646C0 = 1024; // weak
int dword_101646C4 = 4294966273; // weak
int dword_101646C8 = 53; // weak
int dword_101646CC = 11; // weak
int dword_101646D0 = 64; // weak
int dword_101646D4 = 1023; // weak
int dword_101646D8 = 128; // weak
int dword_101646DC = 4294967169; // weak
int dword_101646E0 = 24; // weak
int dword_101646E4 = 8; // weak
int dword_101646E8 = 32; // weak
int dword_101646EC = 127; // weak
_UNKNOWN unk_10164BE0; // weak
char byte_10164BE4 = '\0'; // weak
int dword_10164BE8 = 0; // weak
_UNKNOWN unk_10164BF0; // weak
char byte_10164CC0 = '\0'; // weak
char byte_10164CC8 = '\0'; // idb
int dword_10165CC8; // weak
char byte_10165CD0[]; // weak
char byte_10165CD2[]; // weak
__int16 word_10165CD4[]; // weak
int dword_10165CD8; // weak
int dword_10165CDC[]; // weak
__int16 word_10165CE0[]; // weak
char byte_10165CE8[]; // weak
char byte_10165D7E; // weak
_UNKNOWN unk_10165D80; // weak
_UNKNOWN unk_10165DAC; // weak
int dword_10165DD8[]; // weak
int dword_10165DDC[]; // weak
char byte_10165DE0[]; // weak
_UNKNOWN unk_10165EC8; // weak
void *dword_10165F48; // idb
char byte_10165F50; // idb
int dword_10166148[]; // weak
int dword_1016615C[]; // weak
int dword_10166170[]; // weak
int dword_10166174[]; // weak
int dword_10166178[]; // weak
int dword_10172170[]; // weak
int dword_10172174[]; // weak
int dword_10172178; // weak
int dword_1017217C; // weak
int dword_10172180; // weak
int dword_10172184; // weak
int dword_10172188; // weak
int dword_1017218C; // weak
int dword_10172190; // weak
int dword_10172194; // weak
_UNKNOWN unk_10172198; // weak
_UNKNOWN unk_10325476; // weak
_UNKNOWN unk_10572198; // weak
int dword_105722F4; // weak
int dword_105722F8; // weak
int dword_105722FC; // weak
int dword_10572308; // weak
int dword_1057230C; // weak
int dword_10572310; // weak
int dword_10572314; // weak
int dword_10572318; // weak
int dword_1057231C; // weak
int dword_10572320; // weak
int dword_10572324; // weak
_UNKNOWN unk_10572328; // weak
int dword_10572370; // weak
int dword_10572374; // weak
int dword_10572378; // idb
int dword_1057237C; // weak
wint_t dword_10572380; // idb
int dword_10572384; // weak
int dword_10572388; // weak
int dword_1057238C; // weak
int dword_10572390; // weak
int dword_10572394; // weak
int dword_10572398; // weak
char byte_1057239C; // weak
char byte_1057239D; // weak
char byte_1057239E; // weak
char byte_1057239F; // weak
char byte_105723A0; // weak
char byte_105723A8; // idb
char dword_105725A8[]; // idb
int dword_105725AC; // weak
_UNKNOWN unk_10572630; // weak
int dword_10572678; // weak
int dword_1057267C; // weak
double dbl_10572680; // weak
double dbl_10572688; // weak
int dword_10572690; // weak
int dword_10572694; // weak
int dword_10572698; // weak
int dword_1057269C; // weak
int dword_105726A0; // weak
int dword_105726A4; // weak
int dword_105726A8[]; // weak
int dword_105726AC; // weak
int dword_105726B0; // weak
int dword_105726B4; // weak
int dword_105726B8; // weak
int dword_105726BC; // weak
int dword_105726C0; // weak
int dword_105726C4; // weak
int dword_105726C8; // weak
int dword_105726D0[]; // weak
_UNKNOWN unk_1057270C; // weak
int dword_10572710; // weak
_UNKNOWN unk_10572714; // weak
_UNKNOWN unk_1057271C; // weak
double dbl_10572720; // weak
double dbl_10572728; // weak
__int16 word_10572730; // weak
__int16 word_10572732; // weak
int dword_10572734[]; // weak
int dword_10572738[]; // weak
int dword_10572740[]; // weak
int dword_10572744[]; // weak
_UNKNOWN unk_10572750; // weak
char byte_105728D4; // weak
__int16 word_105728D8[]; // weak
char byte_10572900[]; // weak
char byte_10583258; // weak
char byte_10583259; // weak
int dword_1058325C[]; // weak
int dword_10583270; // weak
int dword_10583274; // weak
_UNKNOWN unk_10584278; // weak
_UNKNOWN unk_10585278; // weak
int dword_105909C0; // weak
int dword_105909C4; // weak
int dword_105909C8; // weak
int dword_105909CC; // weak
int dword_105909D0; // weak
int dword_105909D4; // weak
int dword_105909D8; // weak
int dword_105909DC; // weak
int dword_105909E0; // weak
int dword_105909E4; // weak
int dword_105909E8; // weak
int dword_105909EC; // weak
int dword_105909F4; // weak
int dword_105909F8; // weak
int dword_105909FC; // weak
int dword_10590A00; // weak
int dword_10590A04; // weak
int dword_10590A08; // weak
int dword_10590A0C; // weak
int dword_10590A10; // weak
int dword_105910B8; // weak
_UNKNOWN unk_105910C0; // weak
char byte_10591398[]; // weak
char byte_10591399[]; // weak
_UNKNOWN unk_10592600; // weak
_UNKNOWN unk_10593FB0; // weak
int dword_105C0388; // weak
char byte_105C0390[]; // weak
char byte_105C0394[]; // weak
char byte_105C0395[]; // weak
int dword_105C039C[]; // weak
int dword_105C03A4[]; // weak
_UNKNOWN unk_105C03D8; // weak
_UNKNOWN unk_105C03D9; // weak
_UNKNOWN unk_105C03EF; // weak
_UNKNOWN unk_105C03F0; // weak
_UNKNOWN unk_105C03F1; // weak
_UNKNOWN unk_105C03F2; // weak
_UNKNOWN unk_105C03F4; // weak
_UNKNOWN unk_105C03F8; // weak
_UNKNOWN unk_105C03FC; // weak
_UNKNOWN unk_105C041C; // weak
_UNKNOWN unk_105C043C; // weak
_UNKNOWN unk_105C045C; // weak
_UNKNOWN unk_105C047C; // weak
_UNKNOWN unk_105C049C; // weak
_UNKNOWN unk_105C04BC; // weak
_UNKNOWN unk_105C04DC; // weak
_UNKNOWN unk_105C04FC; // weak
_UNKNOWN unk_105C051C; // weak
_UNKNOWN unk_105C053C; // weak
_UNKNOWN unk_105C055C; // weak
_UNKNOWN unk_105C057C; // weak
_UNKNOWN unk_105C059C; // weak
_UNKNOWN unk_105C05BC; // weak
_UNKNOWN unk_105C05DC; // weak
_UNKNOWN unk_105C05FC; // weak
_UNKNOWN unk_105C061C; // weak
_UNKNOWN unk_105C063C; // weak
_UNKNOWN unk_105C065C; // weak
_UNKNOWN unk_105C067C; // weak
_UNKNOWN unk_105C069C; // weak
_UNKNOWN unk_105C06BC; // weak
_UNKNOWN unk_105C06DC; // weak
_UNKNOWN unk_105C06FC; // weak
_UNKNOWN unk_105C071C; // weak
_UNKNOWN unk_105C073C; // weak
_UNKNOWN unk_105C075C; // weak
_UNKNOWN unk_105C077C; // weak
_UNKNOWN unk_105C0780; // weak
_UNKNOWN unk_105C0784; // weak
_UNKNOWN unk_105C0788; // weak
_UNKNOWN unk_105C078C; // weak
_UNKNOWN unk_105C0790; // weak
_UNKNOWN unk_105C0794; // weak
_UNKNOWN unk_105C07B4; // weak
_UNKNOWN unk_105C07D4; // weak
_UNKNOWN unk_105C07F4; // weak
_UNKNOWN unk_105C0814; // weak
_UNKNOWN unk_105C0834; // weak
_UNKNOWN unk_105C0854; // weak
_UNKNOWN unk_105C0874; // weak
_UNKNOWN unk_105C0894; // weak
_UNKNOWN unk_105C0895; // weak
_UNKNOWN unk_105C0896; // weak
_UNKNOWN unk_105C08E8; // weak
_UNKNOWN unk_105C0908; // weak
_UNKNOWN unk_105C0928; // weak
_UNKNOWN unk_105C092C; // weak
_UNKNOWN unk_105C0930; // weak
_UNKNOWN unk_105C0934; // weak
_UNKNOWN unk_105C0954; // weak
_UNKNOWN unk_105C0974; // weak
_UNKNOWN unk_105C0994; // weak
_UNKNOWN unk_105C09B4; // weak
_UNKNOWN unk_105C09D4; // weak
_UNKNOWN unk_105C09F4; // weak
_UNKNOWN unk_105C0A14; // weak
_UNKNOWN unk_105C0A34; // weak
_UNKNOWN unk_105C0A54; // weak
_UNKNOWN unk_105C0A9C; // weak
_UNKNOWN unk_105C0AE4; // weak
_UNKNOWN unk_105C0B2C; // weak
_UNKNOWN unk_105C0B74; // weak
_UNKNOWN unk_105C0BBC; // weak
_UNKNOWN unk_105C0C04; // weak
_UNKNOWN unk_105C0C4C; // weak
_UNKNOWN unk_105C0C94; // weak
_UNKNOWN unk_105C0CDC; // weak
_UNKNOWN unk_105C0D24; // weak
_UNKNOWN unk_105C0D6C; // weak
_UNKNOWN unk_105C0DB4; // weak
_UNKNOWN unk_105C0DFC; // weak
_UNKNOWN unk_105C0E44; // weak
_UNKNOWN unk_105C0E8C; // weak
_UNKNOWN unk_105C0ED4; // weak
_UNKNOWN unk_105C0F1C; // weak
_UNKNOWN unk_105C0F64; // weak
_UNKNOWN unk_105C0FAC; // weak
_UNKNOWN unk_105C0FF4; // weak
_UNKNOWN unk_105C103C; // weak
_UNKNOWN unk_105C1084; // weak
_UNKNOWN unk_105C10CC; // weak
_UNKNOWN unk_105C1114; // weak
_UNKNOWN unk_105C115C; // weak
_UNKNOWN unk_105C11A4; // weak
_UNKNOWN unk_105C11EC; // weak
_UNKNOWN unk_105C1234; // weak
_UNKNOWN unk_105C127C; // weak
_UNKNOWN unk_105C12C4; // weak
_UNKNOWN unk_105C12DC; // weak
_UNKNOWN unk_105C12FC; // weak
_UNKNOWN unk_105C131C; // weak
_UNKNOWN unk_105C1320; // weak
_UNKNOWN unk_105C13C4; // weak
_UNKNOWN unk_105C1468; // weak
_UNKNOWN unk_105C150C; // weak
_UNKNOWN unk_105C15B0; // weak
_UNKNOWN unk_105C1654; // weak
_UNKNOWN unk_105C16F8; // weak
_UNKNOWN unk_105C179C; // weak
_UNKNOWN unk_105C1840; // weak
_UNKNOWN unk_105C18E4; // weak
_UNKNOWN unk_105C1988; // weak
_UNKNOWN unk_105C1A2C; // weak
_UNKNOWN unk_105C1AD0; // weak
_UNKNOWN unk_105C1B74; // weak
_UNKNOWN unk_105C1C18; // weak
_UNKNOWN unk_105C1CBC; // weak
_UNKNOWN unk_105C1D60; // weak
_UNKNOWN unk_105C1E04; // weak
_UNKNOWN unk_105C1EA8; // weak
_UNKNOWN unk_105C1F4C; // weak
_UNKNOWN unk_105C1FF0; // weak
_UNKNOWN unk_105C2094; // weak
_UNKNOWN unk_105C2138; // weak
_UNKNOWN unk_105C21DC; // weak
_UNKNOWN unk_105C2280; // weak
_UNKNOWN unk_105C2324; // weak
_UNKNOWN unk_105C23C8; // weak
_UNKNOWN unk_105C246C; // weak
_UNKNOWN unk_105C2510; // weak
_UNKNOWN unk_105C25B4; // weak
_UNKNOWN unk_105C2658; // weak
_UNKNOWN unk_105C26FC; // weak
_UNKNOWN unk_105C27A0; // weak
_UNKNOWN unk_105C2844; // weak
_UNKNOWN unk_105C28E8; // weak
_UNKNOWN unk_105C298C; // weak
_UNKNOWN unk_105C2A30; // weak
_UNKNOWN unk_105C2AD4; // weak
_UNKNOWN unk_105C2B78; // weak
_UNKNOWN unk_105C2C1C; // weak
_UNKNOWN unk_105C2CC0; // weak
_UNKNOWN unk_105C2D64; // weak
_UNKNOWN unk_105C2E08; // weak
_UNKNOWN unk_105C2EAC; // weak
_UNKNOWN unk_105C2F50; // weak
_UNKNOWN unk_105C2FF4; // weak
_UNKNOWN unk_105C3098; // weak
_UNKNOWN unk_105C313C; // weak
_UNKNOWN unk_105C31E0; // weak
_UNKNOWN unk_105C3284; // weak
_UNKNOWN unk_105C3328; // weak
_UNKNOWN unk_105C33CC; // weak
_UNKNOWN unk_105C3470; // weak
_UNKNOWN unk_105C3514; // weak
_UNKNOWN unk_105C35B8; // weak
_UNKNOWN unk_105C365C; // weak
_UNKNOWN unk_105C3700; // weak
_UNKNOWN unk_105C37A4; // weak
_UNKNOWN unk_105C3848; // weak
_UNKNOWN unk_105C38EC; // weak
_UNKNOWN unk_105C3990; // weak
_UNKNOWN unk_105C3A34; // weak
_UNKNOWN unk_105C3AD8; // weak
_UNKNOWN unk_105C3B7C; // weak
_UNKNOWN unk_105C3C20; // weak
_UNKNOWN unk_105C3CC4; // weak
_UNKNOWN unk_105C3D68; // weak
_UNKNOWN unk_105C3E0C; // weak
_UNKNOWN unk_105C3EB0; // weak
_UNKNOWN unk_105C3F54; // weak
_UNKNOWN unk_105C3FF8; // weak
_UNKNOWN unk_105C409C; // weak
_UNKNOWN unk_105C4140; // weak
_UNKNOWN unk_105C41E4; // weak
_UNKNOWN unk_105C4288; // weak
_UNKNOWN unk_105C432C; // weak
_UNKNOWN unk_105C43D0; // weak
_UNKNOWN unk_105C4474; // weak
_UNKNOWN unk_105C4518; // weak
_UNKNOWN unk_105C45BC; // weak
_UNKNOWN unk_105C4660; // weak
_UNKNOWN unk_105C4704; // weak
_UNKNOWN unk_105C47A8; // weak
_UNKNOWN unk_105C484C; // weak
_UNKNOWN unk_105C48F0; // weak
_UNKNOWN unk_105C4994; // weak
_UNKNOWN unk_105C4A38; // weak
_UNKNOWN unk_105C4ADC; // weak
_UNKNOWN unk_105C4B80; // weak
_UNKNOWN unk_105C4C24; // weak
_UNKNOWN unk_105C4CC8; // weak
_UNKNOWN unk_105C4D6C; // weak
_UNKNOWN unk_105C4E10; // weak
_UNKNOWN unk_105C4EB4; // weak
_UNKNOWN unk_105C4F58; // weak
_UNKNOWN unk_105C4FFC; // weak
_UNKNOWN unk_105C50A0; // weak
_UNKNOWN unk_105C5144; // weak
_UNKNOWN unk_105C51E8; // weak
_UNKNOWN unk_105C528C; // weak
_UNKNOWN unk_105C5330; // weak
_UNKNOWN unk_105C5350; // weak
_UNKNOWN unk_105C5370; // weak
_UNKNOWN unk_105C5390; // weak
_UNKNOWN unk_105C53B0; // weak
_UNKNOWN unk_105C53D8; // weak
_UNKNOWN unk_105C53F4; // weak
_UNKNOWN unk_105C5410; // weak
_UNKNOWN unk_105C542C; // weak
_UNKNOWN unk_105C5448; // weak
_UNKNOWN unk_105C5464; // weak
_UNKNOWN unk_105C5480; // weak
_UNKNOWN unk_105C549C; // weak
_UNKNOWN unk_105C54B8; // weak
_UNKNOWN unk_105C54D4; // weak
_UNKNOWN unk_105C54F0; // weak
_UNKNOWN unk_105C550C; // weak
_UNKNOWN unk_105C5528; // weak
_UNKNOWN unk_105C5544; // weak
_UNKNOWN unk_105C5560; // weak
_UNKNOWN unk_105C557C; // weak
_UNKNOWN unk_105C5598; // weak
_UNKNOWN unk_105C55B4; // weak
_UNKNOWN unk_105C55D0; // weak
_UNKNOWN unk_105C55EC; // weak
_UNKNOWN unk_105C5608; // weak
_UNKNOWN unk_105C5624; // weak
_UNKNOWN unk_105C5640; // weak
_UNKNOWN unk_105C565C; // weak
_UNKNOWN unk_105C5678; // weak
_UNKNOWN unk_105C5694; // weak
_UNKNOWN unk_105C56B0; // weak
_UNKNOWN unk_105C56CC; // weak
_UNKNOWN unk_105C56E8; // weak
_UNKNOWN unk_105C5704; // weak
_UNKNOWN unk_105C5720; // weak
_UNKNOWN unk_105C573C; // weak
_UNKNOWN unk_105C5758; // weak
_UNKNOWN unk_105C5774; // weak
_UNKNOWN unk_105C5790; // weak
_UNKNOWN unk_105C57AC; // weak
_UNKNOWN unk_105C57C8; // weak
_UNKNOWN unk_105C57E4; // weak
_UNKNOWN unk_105C5800; // weak
_UNKNOWN unk_105C581C; // weak
_UNKNOWN unk_105C5838; // weak
_UNKNOWN unk_105C5854; // weak
_UNKNOWN unk_105C5870; // weak
_UNKNOWN unk_105C588C; // weak
_UNKNOWN unk_105C58A8; // weak
_UNKNOWN unk_105C58C4; // weak
_UNKNOWN unk_105C58E0; // weak
_UNKNOWN unk_105C58FC; // weak
_UNKNOWN unk_105C5918; // weak
_UNKNOWN unk_105C5934; // weak
_UNKNOWN unk_105C5950; // weak
_UNKNOWN unk_105C596C; // weak
_UNKNOWN unk_105C5988; // weak
_UNKNOWN unk_105C59A4; // weak
_UNKNOWN unk_105C59C0; // weak
_UNKNOWN unk_105C59DC; // weak
_UNKNOWN unk_105C59F8; // weak
_UNKNOWN unk_105C5A14; // weak
_UNKNOWN unk_105C5A30; // weak
_UNKNOWN unk_105C5A4C; // weak
_UNKNOWN unk_105C5A68; // weak
_UNKNOWN unk_105C5A84; // weak
_UNKNOWN unk_105C5AA0; // weak
_UNKNOWN unk_105C5ABC; // weak
_UNKNOWN unk_105C5AD8; // weak
_UNKNOWN unk_105C5AF4; // weak
_UNKNOWN unk_105C5B10; // weak
_UNKNOWN unk_105C5B2C; // weak
_UNKNOWN unk_105C5B48; // weak
_UNKNOWN unk_105C5B64; // weak
_UNKNOWN unk_105C5B80; // weak
_UNKNOWN unk_105C5B9C; // weak
_UNKNOWN unk_105C5BB8; // weak
_UNKNOWN unk_105C5BD4; // weak
_UNKNOWN unk_105C5BF0; // weak
_UNKNOWN unk_105C5C0C; // weak
_UNKNOWN unk_105C5C28; // weak
_UNKNOWN unk_105C5C44; // weak
_UNKNOWN unk_105C5C60; // weak
_UNKNOWN unk_105C5C7C; // weak
_UNKNOWN unk_105C5C98; // weak
_UNKNOWN unk_105C5CB4; // weak
_UNKNOWN unk_105C5CD0; // weak
_UNKNOWN unk_105C5CEC; // weak
_UNKNOWN unk_105C5D08; // weak
_UNKNOWN unk_105C5D24; // weak
_UNKNOWN unk_105C5D40; // weak
_UNKNOWN unk_105C5D5C; // weak
_UNKNOWN unk_105C5D78; // weak
_UNKNOWN unk_105C5D94; // weak
_UNKNOWN unk_105C5DB0; // weak
_UNKNOWN unk_105C5DCC; // weak
_UNKNOWN unk_105C5DE8; // weak
_UNKNOWN unk_105C5E04; // weak
_UNKNOWN unk_105C5E20; // weak
_UNKNOWN unk_105C5E3C; // weak
_UNKNOWN unk_105C5E58; // weak
_UNKNOWN unk_105C5E74; // weak
_UNKNOWN unk_105C5E90; // weak
_UNKNOWN unk_105C5EAC; // weak
_UNKNOWN unk_105C5EC8; // weak
_UNKNOWN unk_105C5ECC; // weak
_UNKNOWN unk_105C5ED0; // weak
_UNKNOWN unk_105C5ED4; // weak
_UNKNOWN unk_105C5ED8; // weak
_UNKNOWN unk_105C5EDC; // weak
_UNKNOWN unk_105C5EE0; // weak
_UNKNOWN unk_105C5EE4; // weak
_UNKNOWN unk_105C5EE8; // weak
_UNKNOWN unk_105C5EEC; // weak
_UNKNOWN unk_105C5EF0; // weak
_UNKNOWN unk_105C5EF4; // weak
_UNKNOWN unk_105C5EF8; // weak
_UNKNOWN unk_105C5EFC; // weak
_UNKNOWN unk_105C5F00; // weak
_UNKNOWN unk_105C5F04; // weak
_UNKNOWN unk_105C5F08; // weak
_UNKNOWN unk_105C5F0C; // weak
_UNKNOWN unk_105C5F10; // weak
_UNKNOWN unk_105C5FF4; // weak
_UNKNOWN unk_105C71B4; // weak
_UNKNOWN unk_105C71B8; // weak
_UNKNOWN unk_105C71E0; // weak
_UNKNOWN unk_105C7208; // weak
_UNKNOWN unk_105C7248; // weak
_UNKNOWN unk_105C72C8; // weak
_UNKNOWN unk_105C72CC; // weak
_UNKNOWN unk_105C72D0; // weak
_UNKNOWN unk_105C72D2; // weak
_UNKNOWN unk_105C72D4; // weak
_UNKNOWN unk_105C72D5; // weak
_UNKNOWN unk_105C72D6; // weak
_UNKNOWN unk_105C72D8; // weak
_UNKNOWN unk_105C733C; // weak
_UNKNOWN unk_105C7344; // weak
_UNKNOWN unk_105C734C; // weak
_UNKNOWN unk_105C7354; // weak
_UNKNOWN unk_105C735C; // weak
_UNKNOWN unk_105C7364; // weak
_UNKNOWN unk_105C736C; // weak
_UNKNOWN unk_105C7374; // weak
_UNKNOWN unk_105C737C; // weak
_UNKNOWN unk_105C7384; // weak
_UNKNOWN unk_105C738C; // weak
_UNKNOWN unk_105C7394; // weak
_UNKNOWN unk_105C739C; // weak
_UNKNOWN unk_105C73A4; // weak
_UNKNOWN unk_105C73AC; // weak
_UNKNOWN unk_105C73B4; // weak
_UNKNOWN unk_105C73BC; // weak
_UNKNOWN unk_105C73C4; // weak
_UNKNOWN unk_105C73CC; // weak
_UNKNOWN unk_105C73D4; // weak
_UNKNOWN unk_105C73DC; // weak
_UNKNOWN unk_105C73E4; // weak
_UNKNOWN unk_105C73EC; // weak
_UNKNOWN unk_105C73F4; // weak
_UNKNOWN unk_105C73FC; // weak
_UNKNOWN unk_105C7404; // weak
_UNKNOWN unk_105C740C; // weak
_UNKNOWN unk_105C7414; // weak
_UNKNOWN unk_105C741C; // weak
_UNKNOWN unk_105C7424; // weak
_UNKNOWN unk_105C742C; // weak
_UNKNOWN unk_105C7434; // weak
_UNKNOWN unk_105C743C; // weak
_UNKNOWN unk_105C7444; // weak
_UNKNOWN unk_105C744C; // weak
_UNKNOWN unk_105C7454; // weak
_UNKNOWN unk_105C745C; // weak
_UNKNOWN unk_105C7464; // weak
_UNKNOWN unk_105C746C; // weak
_UNKNOWN unk_105C7474; // weak
_UNKNOWN unk_105C765C; // weak
_UNKNOWN unk_105C766C; // weak
_UNKNOWN unk_105C767C; // weak
_UNKNOWN unk_105C768C; // weak
_UNKNOWN unk_105C768D; // weak
_UNKNOWN unk_105C768E; // weak
_UNKNOWN unk_105C7690; // weak
_UNKNOWN unk_105C7694; // weak
_UNKNOWN unk_105C773C; // weak
_UNKNOWN unk_105C7740; // weak
_UNKNOWN unk_105C7744; // weak
_UNKNOWN unk_105C7794; // weak
_UNKNOWN unk_105C7798; // weak
_UNKNOWN unk_105C779C; // weak
_UNKNOWN unk_105C788C; // weak
_UNKNOWN unk_105C797C; // weak
_UNKNOWN unk_105C7980; // weak
_UNKNOWN unk_105C7988; // weak
_UNKNOWN unk_105C7990; // weak
_UNKNOWN unk_105C7998; // weak
_UNKNOWN unk_105C79A0; // weak
_UNKNOWN unk_105C79A8; // weak
_UNKNOWN unk_105C79B0; // weak
_UNKNOWN unk_105C79B8; // weak
_UNKNOWN unk_105C79C0; // weak
_UNKNOWN unk_105C79C8; // weak
_UNKNOWN unk_105C79D0; // weak
_UNKNOWN unk_105C79D8; // weak
_UNKNOWN unk_105C79DC; // weak
_UNKNOWN unk_105C79E0; // weak
_UNKNOWN unk_105C79E4; // weak
_UNKNOWN unk_105C7A38; // weak
_UNKNOWN unk_105C7A8C; // weak
_UNKNOWN unk_105C7A94; // weak
_UNKNOWN unk_105C7A98; // weak
_UNKNOWN unk_105C7A9C; // weak
_UNKNOWN unk_105C7AA0; // weak
_UNKNOWN unk_105C7AA4; // weak
_UNKNOWN unk_105C7CAC; // weak
_UNKNOWN unk_105C7E0C; // weak
_UNKNOWN unk_105C7E24; // weak
_UNKNOWN unk_105C7E3C; // weak
_UNKNOWN unk_105C7E46; // weak
_UNKNOWN unk_105C7E48; // weak
_UNKNOWN unk_105C7E58; // weak
_UNKNOWN unk_105C7E5C; // weak
_UNKNOWN unk_105C7E60; // weak
_UNKNOWN unk_105C7E64; // weak
_UNKNOWN unk_105C7E65; // weak
_UNKNOWN unk_105C7E68; // weak
_UNKNOWN unk_105C7EB8; // weak
_UNKNOWN unk_105C7EBC; // weak
_UNKNOWN unk_105C7EBD; // weak
_UNKNOWN unk_105C7EBE; // weak
_UNKNOWN unk_105C7EBF; // weak
_UNKNOWN unk_105C7ED3; // weak
_UNKNOWN unk_105C7ED4; // weak
_UNKNOWN unk_105C7ED5; // weak
_UNKNOWN unk_105C7ED6; // weak
_UNKNOWN unk_105C7ED8; // weak
_UNKNOWN unk_105C7F78; // weak
_UNKNOWN unk_105C7FC8; // weak
_UNKNOWN unk_105C7FCC; // weak
_UNKNOWN unk_105C7FD0; // weak
_UNKNOWN unk_105C7FD4; // weak
_UNKNOWN unk_105C7FD8; // weak
_UNKNOWN unk_105C7FDC; // weak
_UNKNOWN unk_105C7FE0; // weak
_UNKNOWN unk_105C7FE4; // weak
_UNKNOWN unk_105C7FE8; // weak
_UNKNOWN unk_105C7FEC; // weak
_UNKNOWN unk_105C7FF0; // weak
_UNKNOWN unk_105C7FF4; // weak
_UNKNOWN unk_105C7FF8; // weak
_UNKNOWN unk_105C8138; // weak
_UNKNOWN unk_105C8144; // weak
_UNKNOWN unk_105C818C; // weak
_UNKNOWN unk_105C818D; // weak
_UNKNOWN unk_105C81B8; // weak
_UNKNOWN unk_105C81E8; // weak
_UNKNOWN unk_105C8210; // weak
_UNKNOWN unk_105C8214; // weak
_UNKNOWN unk_105C8218; // weak
_UNKNOWN unk_105C821C; // weak
_UNKNOWN unk_105C824C; // weak
_UNKNOWN unk_105C824D; // weak
_UNKNOWN unk_105C824E; // weak
_UNKNOWN unk_105C8250; // weak
_UNKNOWN unk_105C8254; // weak
_UNKNOWN unk_105C8258; // weak
_UNKNOWN unk_105C825C; // weak
_UNKNOWN unk_105C8260; // weak
_UNKNOWN unk_105C8264; // weak
_UNKNOWN unk_105C8268; // weak
_UNKNOWN unk_105C826C; // weak
_UNKNOWN unk_105C8270; // weak
_UNKNOWN unk_105C8274; // weak
_UNKNOWN unk_105C85D4; // weak
_UNKNOWN unk_105C85D8; // weak
_UNKNOWN unk_105C85E2; // weak
_UNKNOWN unk_105C85EC; // weak
int dword_105C9DA8; // weak
int dword_105C9DC0; // weak
int dword_105C9DC4; // weak
int dword_105C9DC8; // weak
int dword_105C9DCC; // weak
int dword_105C9DD8[]; // weak
int dword_105C9DDC; // weak
int dword_105C9DE0; // weak
int dword_105C9DE4; // weak
int dword_105C9DE8; // weak
int dword_105C9DEC[]; // weak
int dword_105C9DF0; // weak
int dword_105C9DF4; // weak
int dword_105C9DF8; // weak
int dword_105C9DFC; // weak
_UNKNOWN unk_105C9E00; // weak
char byte_105C9F18; // idb
char byte_105CA018[254]; // idb
char byte_105CA116[]; // weak
char byte_105CA117[]; // weak
char byte_105CA518[2800]; // idb
char byte_105CB008[1022]; // idb
char byte_105CB406[]; // weak
char byte_105CB407[]; // weak
char byte_105CB408[1022]; // idb
char byte_105CB806[]; // weak
char byte_105CB807[]; // weak
char byte_105CB808[1022]; // idb
char byte_105CBC06[]; // weak
char byte_105CBC07[]; // weak
int dword_105CEC08[]; // weak
int dword_105CEC1C[]; // weak
char byte_105CEC30[2800]; // idb
char byte_105CF720[2800]; // idb
char byte_105D0210[2800]; // idb
int dword_105D0D00[]; // weak
int dword_105D0D14[]; // weak
char byte_105D0D28[2796]; // idb
char byte_105D1814[]; // weak
char byte_105D1818[559]; // idb
char byte_105D1A47[]; // weak
int dword_105D2308[]; // weak
int dword_105D231C[]; // weak
char byte_105D2330[2800]; // idb
int dword_105D2E20; // weak
_UNKNOWN unk_105D2E28; // weak
_UNKNOWN unk_105D3980; // weak
_UNKNOWN unk_105D5CE4; // weak
_UNKNOWN unk_105D5CE8; // weak
int dword_105D5CEC; // weak
int dword_105D5CF0; // weak
_UNKNOWN unk_105D5CF8; // weak
_UNKNOWN unk_10624DD3; // weak
_UNKNOWN unk_10636F8C; // weak
_UNKNOWN unk_10636F94; // weak
_UNKNOWN unk_10636F9C; // weak
int dword_10636FA8; // weak
char byte_10636FB0[]; // weak
char byte_10637000[]; // weak
char byte_1063E350; // weak
char byte_1063E351; // weak
char byte_10640BE8[]; // weak
char byte_10640BE9[]; // weak
_UNKNOWN unk_10640C88; // weak
int dword_10640F58[]; // weak
int dword_10640F5C[]; // weak
_UNKNOWN unk_10641478; // weak
_UNKNOWN unk_10644380; // weak
_UNKNOWN unk_10644880; // weak
_UNKNOWN unk_10644928; // weak
char byte_10644948; // weak
char byte_10644949; // weak
char byte_1064494A; // weak
char byte_1064494B; // weak
_UNKNOWN unk_10644950; // weak
_UNKNOWN unk_10644970; // weak
int dword_10645A88; // weak
int dword_10645A8C; // weak
int dword_10645A90; // weak
int dword_10645A94; // weak
int dword_10645A98; // weak
int dword_10645A9C; // weak
_DWORD dword_10658288[16]; // idb
int dword_106582C8[]; // weak
int dword_10658308; // weak
int dword_10658310[]; // weak
char byte_10658350; // weak
char byte_10658351; // weak
int dword_1065836C; // weak
int dword_10658694; // weak
int dword_106586F0; // weak
int dword_106586FC; // weak
int dword_10658854; // weak
int dword_10658860; // weak
int dword_10658864; // weak
int dword_10658868; // weak
int dword_1065886C; // weak
int dword_10658870; // weak
int dword_10658CF0; // weak
int dword_10658CFC; // weak
int dword_10658D00; // weak
int dword_10658D04; // weak
int dword_10658D14; // weak
int dword_10658D18; // weak
int dword_10658D1C; // weak
int dword_10658D20; // weak
int dword_10658D24; // weak
int dword_10658DE8; // weak
int dword_10658DEC; // weak
int dword_10658DF0; // weak
int dword_10658DF4; // weak
int dword_10658DF8; // idb
void *dword_10658DFC; // idb
int dword_10658E00; // weak
char byte_10658E04; // weak
char byte_10658E05; // weak
char byte_10658E06; // weak
int dword_10658E20; // weak
_UNKNOWN unk_10658E24; // weak
_DWORD dword_1068AE40[120]; // idb
char byte_1068B020; // weak
int dword_1068B040[]; // weak
_BYTE dword_1068B044[1120]; // idb
int dword_1068B4A8; // weak
__int16 word_1068B4AC; // weak
int dword_1068B4B0; // weak
int dword_1068B4B4; // weak
int dword_1068B4C0[]; // weak
int dword_1068B4C4[]; // weak
char byte_1068B4D1[]; // weak
int dword_1068B510; // weak
int dword_1068B58C; // weak
int dword_1068B590; // weak
int dword_1068B5A0; // weak
int dword_1068B5A4; // weak
int dword_1068B5A8; // weak
int dword_1068B5AC; // weak
int dword_1068B5B0; // weak
int dword_1068B5B4; // weak
int dword_1068B5B8; // weak
int dword_1068B5BC; // weak
int dword_1068B5C0; // weak
char byte_1068B5C8[]; // weak
int dword_1068B5E4; // weak
void *dword_1068B5EC; // idb
int dword_1068C600; // weak
UINT uNumber; // idb
int dword_1068C620[]; // weak
int dword_1068C720; // weak
int dword_1068C738; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(int a1)
{
  int v1; // eax@2
  char v2; // ST1B_1@25
  char result; // al@40
  char *v4; // [sp+Ch] [bp-360h]@24
  char v5; // [sp+2Dh] [bp-33Fh]@1
  char v6; // [sp+2Eh] [bp-33Eh]@5
  char v7; // [sp+2Fh] [bp-33Dh]@1
  int v8; // [sp+30h] [bp-33Ch]@2
  char v9; // [sp+34h] [bp-338h]@1
  char v10; // [sp+167h] [bp-205h]@1
  __int16 v11; // [sp+168h] [bp-204h]@1
  char v12; // [sp+16Ch] [bp-200h]@1
  char v13; // [sp+230h] [bp-13Ch]@1
  char v14; // [sp+231h] [bp-13Bh]@1
  __int16 v15; // [sp+232h] [bp-13Ah]@26
  __int16 v16; // [sp+33Ch] [bp-30h]@31
  int v17; // [sp+340h] [bp-2Ch]@31
  char v18; // [sp+344h] [bp-28h]@31
  __int16 v19; // [sp+346h] [bp-26h]@31
  __int16 v20; // [sp+348h] [bp-24h]@31
  __int16 v21; // [sp+34Ah] [bp-22h]@31
  char v22; // [sp+34Ch] [bp-20h]@31
  unsigned __int8 v23; // [sp+353h] [bp-19h]@1
  int v24; // [sp+354h] [bp-18h]@2
  int v25; // [sp+358h] [bp-14h]@1
  char v26; // [sp+35Fh] [bp-Dh]@1
  int i; // [sp+360h] [bp-Ch]@1
  int v28; // [sp+364h] [bp-8h]@1
  int v29; // [sp+368h] [bp-4h]@2

  v12 = 9;
  v13 = 0;
  memset(&v14, 0, 0x100u);
  memset(&v9, 0, 0x12Cu);
  i = 0;
  v28 = 0;
  v25 = 0;
  v26 = 0;
  v7 = 0;
  v5 = 0;
  v10 = 0;
  *(_BYTE *)(a1 + 6) = 2;
  v11 = TXT_get_hndl(*(_DWORD *)(a1 + 52) + 12);
  v23 = *(_BYTE *)(*(_DWORD *)(a1 + 48) + 230);
  if ( **(_DWORD **)(*(_DWORD *)(*(_DWORD *)(a1 + 48) + 56) + 4 * v23) == 122 )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 48) + 56) + 4 * v23);
    v24 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 48) + 60) + 4 * v23);
    v1 = sub_100034E0(a1, *(_WORD *)(v8 + 6));
    v29 = v1;
    for ( i = 0; i < *(_WORD *)(v24 + 8); ++i )
    {
      LOWORD(v1) = i;
      v6 = (*(int (__cdecl **)(int, int, int))(v8 + 12))(a1, v29, v1);
      if ( v6 )
      {
        sub_10001550(*(_DWORD *)(v8 + 8), v29, &v9, 0x12Cu, 0);
        sub_100017A0(&v9);
        if ( !v26 && i == *(_WORD *)(v24 + 2) )
        {
          v26 = 1;
          if ( v7 )
          {
            v10 = 0;
            v5 = 1;
          }
          else
          {
            v10 = 1;
            v25 = 1;
          }
        }
        if ( !v7 && !strcmp(&v9, (const char *)(*(_DWORD *)(a1 + 52) + 12)) )
        {
          if ( v6 == 1 )
          {
            v7 = 1;
            if ( v26 )
            {
              v10 = 0;
              v5 = 1;
            }
            else
            {
              v10 = 1;
              v25 = -1;
            }
          }
          else
          {
            v13 = 0;
            sub_1006FBE0((int)&v14, "This selection cannot be highlighted: ", 256);
            sub_1006FDA0(&v14, (_BYTE *)(*(_DWORD *)(a1 + 52) + 12), 256);
          }
        }
        if ( v10 && v6 == 1 )
          ++v28;
        if ( v5 )
          break;
      }
      v1 = i + 1;
    }
    sub_10003450(0, v29);
    if ( i == *(_WORD *)(v24 + 8) )
    {
      v13 = 0;
      v28 = 0;
      v4 = &v14;
      do
        v2 = *v4++;
      while ( v2 );
      if ( (__int16 *)v4 == &v15 )
      {
        sub_1006FBE0((int)&v14, "This selection does not exist: ", 256);
        sub_1006FDA0(&v14, (_BYTE *)(*(_DWORD *)(a1 + 52) + 12), 256);
      }
    }
  }
  else
  {
    v13 = 0;
    v28 = 0;
    sub_1006FBE0((int)&v14, "Field type not recognized.", 256);
  }
  if ( v5 )
  {
    v13 = 1;
    i = 0;
    v16 = -32696;
    v17 = 0;
    v18 = v25;
    v19 = 57;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    while ( v28 > 0 && i < 15 )
    {
      sub_10002600(a1, (int)&v16, 20);
      --v28;
      ++i;
    }
    v13 = 1;
  }
  if ( v28 )
  {
    result = sub_1006FE00((_BYTE *)(*(_DWORD *)(a1 + 52) + 12));
  }
  else
  {
    if ( v13 == 1 )
    {
      v16 = -32696;
      v17 = *(_DWORD *)(a1 + 56);
      v18 = 1;
      v19 = 33;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      sub_10002600(a1, (int)&v16, 20);
    }
    else
    {
      v16 = -32696;
      v17 = *(_DWORD *)(a1 + 56);
      v18 = 1;
      v19 = 40;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      sub_10002600(a1, (int)&v16, 20);
    }
    result = sub_1006FAD0(&v12);
  }
  return result;
}
// 1009B1E4: using guessed type int __cdecl TXT_get_hndl(_DWORD);

//----- (10001550) --------------------------------------------------------
void __cdecl sub_10001550(int a1, int a2, char *a3, size_t a4, int a5)
{
  char *v5; // eax@13
  char *v6; // eax@15
  char *v7; // eax@17

  if ( a5 <= 5 )
  {
    if ( a1 && a2 )
    {
      switch ( *(_DWORD *)a1 )
      {
        case 0x4B:
          sub_10001550(*(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), a3, a4, a5 + 1);
          break;
        case 0x59:
          sub_1006FD70(a3, a4, "%f", *(float *)a2);
          break;
        case 0x5A:
          sub_1006FD70(a3, a4, "%li", *(_DWORD *)a2);
          break;
        case 0x62:
          *a3 = 0;
          break;
        case 0x66:
          sub_1006FD70(a3, a4, "%li", *(_DWORD *)a2);
          break;
        case 0x69:
          sub_1006FBE0((int)a3, (_BYTE *)a2, a4);
          break;
        case 0x6B:
          v5 = sub_10070850(*(_WORD *)a2);
          sub_1006FBE0((int)a3, v5, a4);
          break;
        case 0x74:
          *a3 = 0;
          break;
        case 0x44:
          v6 = sub_10070850(*(_WORD *)a2);
          sub_1006FBE0((int)a3, v6, a4);
          break;
        case 0x76:
          if ( (*(_BYTE *)(a2 + 4) & 7) == 1 )
          {
            v7 = sub_10070850(*(_WORD *)a2);
            sub_1006FBE0((int)a3, v7, a4);
          }
          else if ( *(_BYTE *)(a2 + 4) & 7 )
          {
            *a3 = 0;
          }
          else
          {
            sub_1006FBE0((int)a3, *(_BYTE **)a2, a4);
          }
          break;
        case 0x7C:
          sub_1006FBE0((int)a3, (_BYTE *)a2, a4);
          break;
        default:
          *a3 = 0;
          break;
      }
    }
    else
    {
      *a3 = 0;
    }
  }
  else
  {
    *a3 = 0;
  }
}

//----- (100017A0) --------------------------------------------------------
const char *__cdecl sub_100017A0(const char *a1)
{
  const char *result; // eax@4
  unsigned __int8 i; // [sp+23h] [bp-1h]@1

  for ( i = strlen(a1) - 1; a1[i] == 32; --i )
    ;
  result = (const char *)i;
  if ( i < strlen(a1) - 1 )
  {
    result = a1;
    a1[i + 1] = 0;
  }
  return result;
}

//----- (10001840) --------------------------------------------------------
int __cdecl sub_10001840(int a1, int a2)
{
  while ( a2 && !sub_10001AE0(a1, a2) )
    a2 = *(_DWORD *)(a2 + 4);
  return a2;
}

//----- (10001870) --------------------------------------------------------
char __cdecl sub_10001870(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@4

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_100035A0(a1, a4, a5);
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        LOBYTE(v6) = a1;
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_1009B630();
        sub_1009B680(1);
        v6 = sub_1009B5F0(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = dword_105722F4;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_1009B630();
      sub_1009B680(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_1009B5F0(a4, a5, 59);
      LOBYTE(v6) = sub_10001DA0(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      LOBYTE(v6) = a1;
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_10070AD0(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 105722F4: using guessed type int dword_105722F4;

//----- (10001A10) --------------------------------------------------------
char __cdecl sub_10001A10(int a1)
{
  char v2; // [sp+3h] [bp-11h]@1
  __int16 v3; // [sp+4h] [bp-10h]@1
  __int16 v4; // [sp+8h] [bp-Ch]@1
  __int16 v5; // [sp+Ch] [bp-8h]@1
  __int16 v6; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v5 = *(_WORD *)(a1 + 28);
  v4 = *(_WORD *)(a1 + 30);
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v3 = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1;
  if ( a1 == dword_1068B4A8 )
    v2 = 1;
  while ( *(_DWORD *)a1 )
  {
    a1 = *(_DWORD *)a1;
    if ( v5 >= (signed int)*(_WORD *)(a1 + 28)
      && v4 >= (signed int)*(_WORD *)(a1 + 30)
      && v6 <= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 34) - 1
      && v3 <= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 32) - 1 )
    {
      return 1;
    }
  }
  return v2;
}
// 1068B4A8: using guessed type int dword_1068B4A8;

//----- (10001AE0) --------------------------------------------------------
bool __cdecl sub_10001AE0(int a1, int a2)
{
  return *(_BYTE *)(a2 + 24) == 1 || *(_BYTE *)(a2 + 24) == 3;
}

//----- (10001B10) --------------------------------------------------------
char __cdecl sub_10001B10(int a1, int a2)
{
  __int64 v2; // rax@4
  int v3; // ecx@7

  if ( !a2 )
    sub_10070AD0(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(*(_DWORD *)(a1 + 444) + 4);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      break;
    case 1:
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = *(_DWORD *)(a1 + 24);
        sub_10001DA0(a1, *(_DWORD *)(a1 + 56));
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = *(_DWORD *)(a1 + 28);
      }
      v3 = a1 + 264;
      *(_DWORD *)v3 = dword_105722F4;
      *(_DWORD *)(v3 + 4) = *(&dword_105722F4 + 1);
      *(_DWORD *)(v3 + 8) = *(&dword_105722F4 + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(*(_DWORD *)(a1 + 444) + 4);
      sub_1009CC30(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8) != *(_DWORD *)(a1 + 44) )
      {
        sub_10001DA0(a1, *(_DWORD *)(a1 + 56));
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      }
      break;
    default:
      sub_10070AD0(".\\cdp_cnvs_utl.c", 473, 1, 0);
      break;
  }
  return 1;
}
// 1009B760: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 105722F4: using guessed type int dword_105722F4;

//----- (10001DA0) --------------------------------------------------------
int __cdecl sub_10001DA0(int a1, int a2)
{
  int result; // eax@1
  float v3; // ST0C_4@2
  float v4; // ST04_4@2

  result = a1;
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    j_gdi_pvg_load_identity();
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)*(_WORD *)(a2 + 32);
    sub_1009B780(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity();
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 1009B760: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 1009B770: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 1009B7D0: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001E90) --------------------------------------------------------
int sub_10001E90()
{
  int result; // eax@3
  int v1; // ecx@6
  signed int i; // [sp+4h] [bp-4h]@1
  unsigned int j; // [sp+4h] [bp-4h]@4
  signed int k; // [sp+4h] [bp-4h]@7

  for ( i = 0; i < 141; ++i )
  {
    dword_1068B040[2 * i] = 0;
    dword_1068B044[8 * i] = 0;
    result = i + 1;
  }
  for ( j = 0; j < 0x26; ++j )
  {
    v1 = dword_100C03D8[3 * j];
    dword_1068B040[2 * v1] = (int)*(&off_100C03DC + 3 * j);
    *(_DWORD *)&dword_1068B044[8 * v1] = dword_100C03E0[3 * j];
    result = j + 1;
  }
  for ( k = 0; k < 141; ++k )
    ;
  return result;
}
// 10001E90: too many cbuild loops
// 100C03D8: using guessed type int dword_100C03D8[];
// 100C03DC: using guessed type int (__cdecl *off_100C03DC)(int, int, int, int, int);
// 100C03E0: using guessed type int dword_100C03E0[];
// 1068B040: using guessed type int dword_1068B040[];

//----- (10001F40) --------------------------------------------------------
void sub_10001F40()
{
  void *v0; // ecx@8
  int v1; // [sp+0h] [bp-100h]@1
  _DWORD *v2; // [sp+4h] [bp-FCh]@1
  int v3; // [sp+8h] [bp-F8h]@20
  char v4; // [sp+Ch] [bp-F4h]@9
  char v5; // [sp+13h] [bp-EDh]@3
  int i; // [sp+14h] [bp-ECh]@16
  char v7; // [sp+18h] [bp-E8h]@5

  v2 = dword_1068AE40;
  dword_1068AE40[119] = &dword_10658E20;
  sub_1009B560(&v1);
  if ( !(v1 & 0x10) )
    sub_10070AD0(".\\cdp_main.c", 403, 1, 0);
  v1 |= 0x10u;
  v5 = sub_1009B4F0(1, 20000);
  if ( !v5 )
    sub_10070AD0(".\\cdp_main.c", 428, 1, 0);
  sub_10071120();
  sub_10070CE0(&v7);
  while ( 1 )
  {
    *((_BYTE *)v2 + 392) = 0;
    if ( v1 & 0x10 || v1 & 0x8000 )
    {
      sub_10002480((int)v2);
      *((_BYTE *)v2 + 2) = sub_100704C0(v0);
      *((_BYTE *)v2 + 4) = 0;
      v2[13] = &unk_10164BF0;
      *((_WORD *)v2 + 7) = 768;
      *((_WORD *)v2 + 8) = 1024;
      v2[16] = 4;
      *((_WORD *)v2 + 10) = 333;
      v2[6] = -1;
      v2[7] = -1;
      *((_BYTE *)v2 + 11) = 1;
      v2[18] = 0;
      *(_BYTE *)v2 = 0;
      while ( sub_1009B280(v2[13], (int)&v4) != 1 )
        ;
      unknown_libname_1();
      sub_100034B0((int)v2);
      sub_1000D6A0((unsigned int)v2);
      sub_10071110((int)&unk_100C0B50);
      sub_10071100((int)&unk_100C0B58);
      sub_100027A0((int)v2);
      sub_1000D800((unsigned int)v2);
    }
    if ( v1 & 2 )
      sub_100027E0((unsigned int)v2);
    if ( v1 & 1 )
    {
      v1 |= 0x20000000u;
      if ( (unsigned int)(sub_1009B2D0() - dword_10164BE8) >= 0x3E8 )
      {
        dword_10164BE8 += 1000;
        sub_100710E0(v2);
        sub_10070BC0((int *)&v7);
      }
    }
    for ( i = 0x40000000; (unsigned int)i >= 0x200; i = (unsigned int)i >> 1 )
    {
      if ( i != 0x8000 )
      {
        if ( i & v1 )
        {
          v3 = sub_10070B40(i);
          sub_100022A0((int)v2, v3);
          sub_100027E0((unsigned int)v2);
        }
      }
    }
    if ( *((_BYTE *)v2 + 392) || *((_BYTE *)v2 + 1) )
      sub_10002EE0((int)v2, (int)&dword_105722F4);
    sub_1009B560(&v1);
  }
}
// 10001E80: using guessed type int unknown_libname_1(void);
// 100710E0: using guessed type int __cdecl sub_100710E0(_DWORD);
// 10164BE8: using guessed type int dword_10164BE8;
// 105722F4: using guessed type int dword_105722F4;
// 10658E20: using guessed type int dword_10658E20;

//----- (100022A0) --------------------------------------------------------
int __cdecl sub_100022A0(int a1, int a2)
{
  unsigned __int16 v3; // [sp+8h] [bp-E0h]@8
  int v4; // [sp+Ch] [bp-DCh]@11
  int v5; // [sp+DCh] [bp-Ch]@1
  char v6; // [sp+E3h] [bp-5h]@1
  int v7; // [sp+E4h] [bp-4h]@1

  v6 = 2;
  v7 = 0;
  v5 = 0;
  if ( *(_DWORD *)(a2 + 4) )
  {
    v5 = *(_DWORD *)(a2 + 4);
    v6 = 0;
  }
  else if ( (signed int)*(_WORD *)a2 <= 32769 || (signed int)*(_WORD *)a2 >= 32781 )
  {
    v5 = 0;
    v6 = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 48);
    v6 = 1;
  }
  qmemcpy(&v3, (const void *)a2, 0xCCu);
  if ( v6 )
  {
    while ( v5 )
    {
      qmemcpy(&v3, (const void *)a2, 0xCCu);
      v4 = v5;
      if ( v3 == 32776 )
      {
        if ( (signed int)*(_BYTE *)(v5 + 243) > 0 && !--*(_BYTE *)(v5 + 243) )
        {
          v3 = -32648;
          *(_BYTE *)(v5 + 243) = *(_BYTE *)(v5 + 244);
          sub_10002600(a1, (int)&v3, 204);
          ++v7;
        }
      }
      else
      {
        sub_10002600(a1, (int)&v3, 204);
        ++v7;
      }
      if ( sub_10001AE0(a1, v5) )
        break;
      v5 = *(_DWORD *)(v5 + 4);
    }
  }
  else
  {
    sub_10002600(a1, (int)&v3, 204);
    ++v7;
  }
  return v7;
}

//----- (10002450) --------------------------------------------------------
int __cdecl sub_10002450(int a1, int a2)
{
  int i; // [sp+0h] [bp-4h]@1

  for ( i = *(_DWORD *)(a1 + 48); i && *(_DWORD *)(i + 8) != a2; i = *(_DWORD *)(i + 4) )
    ;
  return i;
}

//----- (10002480) --------------------------------------------------------
int __cdecl sub_10002480(int a1)
{
  int result; // eax@1

  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  result = a1;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (100024D0) --------------------------------------------------------
void sub_100024D0()
{
  byte_1068B020 = 0;
  sub_10071150(&unk_10164BE0);
  sub_1000D680();
}
// 1068B020: using guessed type char byte_1068B020;

//----- (100024F0) --------------------------------------------------------
int __cdecl sub_100024F0(int a1, int a2, int a3, int a4)
{
  if ( !a2 )
    sub_10070AD0(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *(_DWORD *)(a2 + 12) = sub_100034E0(a1, a3);
  *(_DWORD *)(a2 + 56) = sub_100034E0(a1, 4 * a4 + 4);
  *(_BYTE *)(a2 + 68) = a4;
  *(_BYTE *)(a2 + 231) = 0;
  if ( a4 > 0 )
  {
    *(_DWORD *)(a2 + 60) = sub_100034E0(a1, 4 * a4);
    *(_DWORD *)(a2 + 64) = sub_100034E0(a1, a4);
  }
  return *(_DWORD *)(a2 + 12);
}

//----- (100025A0) --------------------------------------------------------
char __cdecl sub_100025A0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10002600(a1, (int)&v4, 8);
}

//----- (100025D0) --------------------------------------------------------
char __cdecl sub_100025D0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10002670(a1, (int)&v4, 8);
}

//----- (10002600) --------------------------------------------------------
char __cdecl sub_10002600(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-18h]@1
  int v7; // [sp+4h] [bp-14h]@1
  int v8; // [sp+8h] [bp-10h]@1
  int v9; // [sp+Ch] [bp-Ch]@1
  int v10; // [sp+10h] [bp-8h]@1
  int v11; // [sp+14h] [bp-4h]@1

  v8 = 0;
  v10 = 1;
  v6 = a2;
  v7 = a3;
  v9 = 1000;
  v3 = sub_1009B480(*(_DWORD *)(a1 + 64), (int)&v6);
  v11 = v3;
  v4 = v3 == 0;
  if ( !v4 )
    LOBYTE(v4) = sub_10070AD0(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (10002670) --------------------------------------------------------
char __cdecl sub_10002670(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-18h]@1
  int v7; // [sp+4h] [bp-14h]@1
  int v8; // [sp+8h] [bp-10h]@1
  int v9; // [sp+Ch] [bp-Ch]@1
  int v10; // [sp+10h] [bp-8h]@1
  int v11; // [sp+14h] [bp-4h]@1

  v8 = 0;
  v10 = 2;
  v6 = a2;
  v7 = a3;
  v9 = 1000;
  v3 = sub_1009B480(*(_DWORD *)(a1 + 64), (int)&v6);
  v11 = v3;
  v4 = v3 == 0;
  if ( !v4 )
    LOBYTE(v4) = sub_10070AD0(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (100026E0) --------------------------------------------------------
int sub_100026E0()
{
  int result; // eax@1

  result = sub_1009B2D0();
  dword_10164BE8 = result;
  byte_10164BE4 = 0;
  return result;
}
// 10164BE4: using guessed type char byte_10164BE4;
// 10164BE8: using guessed type int dword_10164BE8;

//----- (10002700) --------------------------------------------------------
_DWORD *__cdecl sub_10002700(int a1)
{
  return sub_10071190(&unk_10164BE0, a1);
}

//----- (10002720) --------------------------------------------------------
int __cdecl sub_10002720(int a1, int a2, int a3)
{
  int result; // eax@7
  char v4; // [sp+0h] [bp-Ch]@5
  unsigned int v5; // [sp+8h] [bp-4h]@2

  if ( (unsigned int)((a3 * (1000 / *(_WORD *)(a1 + 20)) + 500) / 1000) >= 1 )
    v5 = (a3 * (1000 / *(_WORD *)(a1 + 20)) + 500) / 1000;
  else
    v5 = 1;
  if ( v5 >= 0xFF )
    v4 = -1;
  else
    v4 = v5;
  *(_BYTE *)(a2 + 244) = v4;
  result = a2;
  *(_BYTE *)(a2 + 243) = *(_BYTE *)(a2 + 244);
  return result;
}

//----- (100027A0) --------------------------------------------------------
int __cdecl sub_100027A0(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_1009B730();
    sub_1009B630();
    result = sub_1009B5F0(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
    *(_DWORD *)(a1 + 28) = result;
  }
  return result;
}

//----- (100027E0) --------------------------------------------------------
int __cdecl sub_100027E0(unsigned int a1)
{
  int result; // eax@1
  bool v2; // [sp+0h] [bp-8h]@4
  char v3; // [sp+4h] [bp-4h]@1

  while ( 1 )
  {
    result = sub_1009B280(*(_DWORD *)(a1 + 52), (int)&v3);
    if ( result == 1 )
      break;
    v2 = **(_WORD **)(a1 + 52) == 32840 || **(_WORD **)(a1 + 52) == 32802;
    *(_BYTE *)(a1 + 10) = v2;
    sub_100028A0(a1);
    if ( *(_BYTE *)(a1 + 6) != 1 && *(_BYTE *)(a1 + 10) && (*(_BYTE *)(a1 + 392) || *(_BYTE *)(a1 + 1)) )
    {
      sub_10002EE0(a1, (int)&dword_105722F4);
      *(_BYTE *)(a1 + 10) = 0;
    }
  }
  return result;
}
// 105722F4: using guessed type int dword_105722F4;

//----- (100028A0) --------------------------------------------------------
char __cdecl sub_100028A0(unsigned int a1)
{
  int v1; // ST38_4@2
  __int16 v2; // ST28_2@2
  int v3; // eax@12
  int v5; // [sp+8h] [bp-28h]@58
  unsigned int v6; // [sp+18h] [bp-18h]@3
  _DWORD *v7; // [sp+24h] [bp-Ch]@3
  char v8; // [sp+2Bh] [bp-5h]@3

  if ( (signed int)**(_WORD **)(a1 + 52) < 0x8000 )
  {
    v1 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 8);
    **(_WORD **)(a1 + 52) = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v1;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v2;
  }
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_10071160((int *)&unk_10164BE0, a1);
  v7 = *(_DWORD **)(a1 + 32);
  v8 = 0;
  while ( v7 )
  {
    if ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) == v7 )
    {
      v8 = 1;
      v7 = 0;
    }
    else
    {
      v7 = (_DWORD *)*v7;
    }
  }
  if ( v6 && !v8 && **(_WORD **)(a1 + 52) != 32833 )
  {
    LOBYTE(v3) = a1;
    if ( **(_WORD **)(a1 + 52) == 32792 )
      return v3;
    v6 = 0;
    *(_DWORD *)(a1 + 56) = 0;
  }
  LOBYTE(v3) = std::uncaught_exception();
  if ( !(_BYTE)v3 )
  {
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10002DA0(a1);
        break;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v6 + 24) & 3) || (*(_BYTE *)(v6 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v6 + 52));
        if ( v6 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v6 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v6 + 4);
          **(_DWORD **)(v6 + 4) = 0;
        }
        else
        {
          sub_10002480(a1);
        }
        break;
      case 0x8022:
      case 0x8078:
        if ( (signed int)*(_BYTE *)(a1 + 4) > 0 || v6 && sub_10001A10(v6) )
          v6 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && (unsigned __int8)sub_100705A0() != (unsigned __int8)byte_10164BE4 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_10164BE4 = sub_100705A0();
        }
        break;
      case 0x8041:
        v6 = sub_100034E0(a1, 332);
        qmemcpy((void *)v6, &unk_100C0B78, 0x14Cu);
        *(_DWORD *)(v6 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        if ( *(_DWORD *)(a1 + 48) )
        {
          *(_DWORD *)(v6 + 4) = *(_DWORD *)(a1 + 48);
          **(_DWORD **)(a1 + 48) = v6;
          *(_BYTE *)(v6 + 243) = *(_BYTE *)(*(_DWORD *)(v6 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v6;
        *(_DWORD *)(a1 + 48) = v6;
        --*(_BYTE *)(a1 + 4);
        break;
      default:
        if ( !v6 && (signed int)**(_WORD **)(a1 + 52) > 32782 && (signed int)**(_WORD **)(a1 + 52) < 0xFFFF )
          v6 = *(_DWORD *)(a1 + 48);
        break;
    }
    if ( v6 )
    {
      *(_DWORD *)(a1 + 56) = v6;
      *(_BYTE *)(a1 + 6) = 1;
      *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = v6;
      if ( **(_WORD **)(a1 + 52) == 32871 )
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
      sub_1000D5C0(a1);
      if ( *(_BYTE *)(a1 + 6) == 1 && !sub_100033E0(a1) )
        (*(void (__cdecl **)(unsigned int))(v6 + 8))(a1);
    }
    if ( !v6 || v6 > *(_DWORD *)(a1 + 48) && **(_WORD **)(a1 + 52) != 32833 && **(_WORD **)(a1 + 52) != 32792 )
    {
      v6 = 0;
      *(_DWORD *)(a1 + 56) = 0;
    }
    LOBYTE(v3) = sub_1000D1C0(a1);
    if ( v6 )
    {
      if ( *(_BYTE *)(a1 + 6) == 1 || *(_BYTE *)(a1 + 6) == 3 )
        sub_1000D1E0(a1);
      LOBYTE(v3) = a1;
      v5 = **(_WORD **)(a1 + 52);
      if ( v5 == 32792 )
      {
        sub_10003450(0, v6);
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 56) = 0;
        LOBYTE(v3) = a1;
        *(_BYTE *)(a1 + 1) = 1;
      }
      else if ( v5 == 32871 )
      {
        LOBYTE(v3) = sub_100025A0(a1, *(_DWORD *)(a1 + 56), -32734);
      }
      else if ( v5 == 32888 && *(_DWORD *)(a1 + 56) )
      {
        v3 = *(_DWORD *)(a1 + 56);
        *(_BYTE *)(v3 + 26) = 1;
      }
    }
  }
  return v3;
}
// 1009B620: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 10164BE4: using guessed type char byte_10164BE4;

//----- (10002DA0) --------------------------------------------------------
char __cdecl sub_10002DA0(int a1)
{
  void *v1; // ecx@1
  char result; // al@13
  __int16 v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@1
  __int16 v5; // [sp+8h] [bp-4h]@1

  v5 = 2;
  byte_10658E06 = **(_WORD **)(a1 + 52) == 32787;
  byte_1068B020 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v4 = *(_DWORD *)(a1 + 56);
  sub_1009B890(9129, &v3, 2, &v5);
  if ( (*(_DWORD *)(a1 + 64) == 1 || *(_DWORD *)(a1 + 64) == 9) && sub_100714F0(v1) != 2 && v3 & 0x1C )
  {
    byte_10658E06 = 0;
    byte_1068B020 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_100705A0() )
  {
    byte_10658E06 = 0;
    byte_1068B020 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a1 + 48);
  if ( *(_DWORD *)(a1 + 56) && *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) != 255 && !*(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) )
  {
    sub_10070780(a1, *(char **)(a1 + 56), &unk_100E4634);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v4;
  result = sub_1000D6F0(a1);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 10658E06: using guessed type char byte_10658E06;
// 1068B020: using guessed type char byte_1068B020;

//----- (10002EE0) --------------------------------------------------------
int __cdecl sub_10002EE0(int a1, int a2)
{
  __int64 v2; // rax@9
  int result; // eax@25
  int i; // [sp+0h] [bp-4h]@1

  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(*(_DWORD *)(a1 + 444) + 4);
  *(_WORD *)(a1 + 434) = 0;
  *(_WORD *)(a1 + 432) = 0;
  for ( i = *(_DWORD *)(a1 + 48); i && *(_DWORD *)(i + 4) && !sub_10001AE0(a1, i); i = *(_DWORD *)(i + 4) )
    ;
  if ( *(_DWORD *)(a1 + 24) == -1 )
  {
    if ( *(_BYTE *)(a1 + 11) )
    {
      j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
    }
    if ( i && *(_BYTE *)(i + 26) )
      sub_1000D760(a1, 1);
    *(_DWORD *)(a1 + 444) = a2;
    *(_WORD *)(a1 + 418) = 0;
    *(_WORD *)(a1 + 416) = 0;
    *(_DWORD *)(a1 + 420) = *(_DWORD *)(*(_DWORD *)(a1 + 444) + 4);
    *(_WORD *)(a1 + 434) = 0;
    *(_WORD *)(a1 + 432) = 0;
    while ( i )
    {
      sub_10003300(a1, i);
      i = *(_DWORD *)i;
    }
    sub_1000D760(a1, 0);
    if ( *(_BYTE *)(a1 + 11) )
      sub_1009B6E0(
        0,
        0,
        *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
        *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
        57,
        15,
        **(_DWORD **)(a1 + 444));
  }
  else
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( i && (*(_BYTE *)(i + 24) & 3) == 1 )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(i + 52));
      v2 = *(_WORD *)(a1 + 16) + 255;
      sub_1009B6E0(0, 0, (BYTE4(v2) + (signed int)v2) >> 8 << 8, *(_WORD *)(i + 34), 57, 15, *(_DWORD *)(i + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
      sub_1009B690(
        *(_DWORD *)(i + 52),
        *(_WORD *)(i + 28),
        *(_WORD *)(i + 30),
        *(_WORD *)(i + 28),
        *(_WORD *)(i + 30),
        *(_WORD *)(i + 32),
        *(_WORD *)(i + 34));
    }
    if ( i )
      sub_1000D760(a1, 1);
    while ( i )
    {
      sub_100031D0(a1, i);
      i = *(_DWORD *)i;
    }
    sub_1000D760(a1, 0);
  }
  result = a1;
  if ( *(_BYTE *)(a1 + 11) )
    result = j_gdi_pvg_update_display_wdw();
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 1009B750: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 1009B760: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 1009B7C0: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (100031D0) --------------------------------------------------------
char __cdecl sub_100031D0(int a1, int a2)
{
  char result; // al@1
  __int64 v3; // rax@8

  result = a2;
  if ( *(_DWORD *)(a2 + 52) != -1 )
  {
    if ( *(_BYTE *)(a2 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
        result = sub_1009B690(
                   *(_DWORD *)(a2 + 52),
                   *(_WORD *)(a2 + 28),
                   *(_WORD *)(a2 + 30),
                   0,
                   0,
                   *(_WORD *)(a2 + 32),
                   *(_WORD *)(a2 + 34));
    }
    else
    {
      result = a2;
      if ( *(_DWORD *)(a2 + 48) )
      {
        if ( *(_BYTE *)(a2 + 26) )
        {
          result = sub_10001A10(a2);
          if ( !result )
          {
            j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
            v3 = *(_WORD *)(a2 + 32) + 255;
            sub_1009B6E0(
              0,
              0,
              (BYTE4(v3) + (signed int)v3) >> 8 << 8,
              *(_WORD *)(a2 + 34),
              57,
              15,
              *(_DWORD *)(a2 + 48));
            j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
            result = sub_1009B690(
                       *(_DWORD *)(a2 + 52),
                       *(_WORD *)(a2 + 28),
                       *(_WORD *)(a2 + 30),
                       0,
                       0,
                       *(_WORD *)(a2 + 32),
                       *(_WORD *)(a2 + 34));
          }
        }
      }
    }
  }
  return result;
}
// 1009B760: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (10003300) --------------------------------------------------------
unsigned int *__cdecl sub_10003300(int a1, int a2)
{
  unsigned int *result; // eax@1
  __int64 v3; // rax@5
  int v4; // [sp+4h] [bp-Ch]@5
  __int16 v5; // [sp+8h] [bp-8h]@5
  __int16 v6; // [sp+Ah] [bp-6h]@5
  char v7; // [sp+Ch] [bp-4h]@5
  char v8; // [sp+Dh] [bp-3h]@5
  __int16 v9; // [sp+Eh] [bp-2h]@5

  result = (unsigned int *)a2;
  if ( !(*(_BYTE *)(a2 + 24) & 3) )
  {
    if ( *(_DWORD *)(a2 + 48) )
    {
      result = (unsigned int *)a2;
      if ( *(_BYTE *)(a2 + 26) )
      {
        result = (unsigned int *)(unsigned __int8)sub_10001A10(a2);
        if ( !(_BYTE)result )
        {
          v6 = *(_WORD *)(a2 + 32);
          v5 = *(_WORD *)(a2 + 34);
          v7 = 8;
          v3 = *(_WORD *)(a2 + 32) + 255;
          v9 = (unsigned __int16)((BYTE4(v3) + (signed int)v3) >> 8) << 8;
          v4 = *(_DWORD *)(a2 + 48);
          v8 = 0;
          result = sub_1009CD40(
                     a1 + 392,
                     (int)&v4,
                     0,
                     0,
                     *(_WORD *)(a2 + 28),
                     *(_WORD *)(a2 + 30),
                     *(_WORD *)(a2 + 32),
                     *(_WORD *)(a2 + 34));
        }
      }
    }
  }
  return result;
}

//----- (100033E0) --------------------------------------------------------
char __cdecl sub_100033E0(int a1)
{
  char v2; // [sp+3h] [bp-1h]@1

  v2 = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(a1 + 56) + 26) && **(_WORD **)(a1 + 52) == 32840 )
  {
    v2 = 1;
    *(_BYTE *)(a1 + 6) = 2;
  }
  return v2;
}

//----- (10003420) --------------------------------------------------------
int __cdecl sub_10003420(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256 << 8);
}

//----- (10003450) --------------------------------------------------------
char __cdecl sub_10003450(int a1, unsigned int a2)
{
  char result; // al@3
  int v3; // [sp+0h] [bp-4h]@4

  v3 = a2 && a2 >= (unsigned int)&unk_10658E24 && (result = a2, a2 < dword_10658E20);
  if ( !v3 )
    result = sub_10070AD0(".\\cdp_mem.c", 222, 1, 0);
  dword_10658E20 = a2;
  return result;
}
// 10658E20: using guessed type int dword_10658E20;

//----- (100034B0) --------------------------------------------------------
char __cdecl sub_100034B0(int a1)
{
  char result; // al@1

  dword_10658E20 = (int)&unk_10658E24;
  result = byte_10164CC0;
  if ( byte_10164CC0 )
    result = sub_10003600(a1);
  return result;
}
// 10164CC0: using guessed type char byte_10164CC0;
// 10658E20: using guessed type int dword_10658E20;

//----- (100034E0) --------------------------------------------------------
int __cdecl sub_100034E0(int a1, int a2)
{
  int v2; // ST14_4@9
  int v4; // [sp+0h] [bp-10h]@5
  unsigned int v5; // [sp+Ch] [bp-4h]@1

  v5 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_10164CC0 )
    sub_100037E0(a1, dword_10658E20 + 4 * v5 - *(_DWORD *)(a1 + 476));
  v4 = a2 && dword_10658E20 + 4 * v5 <= *(_DWORD *)(a1 + 476) + 204804;
  if ( !v4 )
    sub_10070AD0(".\\cdp_mem.c", 371, 1, 0);
  v2 = dword_10658E20;
  dword_10658E20 += 4 * v5;
  return v2;
}
// 10164CC0: using guessed type char byte_10164CC0;
// 10658E20: using guessed type int dword_10658E20;

//----- (100035A0) --------------------------------------------------------
int __cdecl sub_100035A0(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_10003420(a2, a3);
  return sub_100034E0(a1, v3);
}

//----- (100035D0) --------------------------------------------------------
int sub_100035D0()
{
  int result; // eax@1

  byte_10164CC0 = 0;
  result = (unsigned __int8)sub_1009BCE0((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( (_BYTE)result )
    byte_10164CC0 = 1;
  return result;
}
// 10164CC0: using guessed type char byte_10164CC0;

//----- (10003600) --------------------------------------------------------
char __cdecl sub_10003600(int a1)
{
  int v1; // eax@1
  bool v3; // [sp+3h] [bp-BDh]@4
  int v4; // [sp+4h] [bp-BCh]@1
  unsigned int v5; // [sp+Ch] [bp-B4h]@2
  char v6; // [sp+10h] [bp-B0h]@1
  char v7; // [sp+90h] [bp-30h]@1
  char v8[4]; // [sp+A4h] [bp-1Ch]@1
  int v9; // [sp+A8h] [bp-18h]@1
  int v10; // [sp+ACh] [bp-14h]@1
  int v11; // [sp+B0h] [bp-10h]@1
  int v12; // [sp+B4h] [bp-Ch]@1
  int i; // [sp+BCh] [bp-4h]@1

  i = 0;
  v4 = 0;
  *(_DWORD *)v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  sub_1009B2F0((int)&v7, 1, *(_DWORD *)(a1 + 64), 20);
  sub_1006FD70(&v6, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v7);
  LOBYTE(v1) = sub_1009BCE0((int)&v6);
  if ( (_BYTE)v1 )
  {
    v5 = j_FIL_vfs_open(&v6, 4, 0);
    v3 = v5 >= 0xFFFFFFC2 || !v5;
    LOBYTE(v1) = v3;
    if ( v3 )
    {
      dword_10165CC8 = 0;
    }
    else
    {
      sub_1009BB40(v5, &byte_10164CC8, 4096);
      sub_1009BA60(v5);
      v1 = (int)strstr(&byte_10164CC8, "usage:");
      if ( v1 )
      {
        for ( i = v1 - (_DWORD)&byte_10164CC8 + 7;
              i < v1 - (signed int)&byte_10164CC8 + 27 && word_100E6D90[(unsigned __int8)*(&byte_10164CC8 + i)] & 0x10;
              ++i )
        {
          v8[v4++] = *(&byte_10164CC8 + i);
        }
        v1 = j__atol(v8);
        dword_10165CC8 = v1;
      }
      else
      {
        dword_10165CC8 = 0;
      }
    }
  }
  else
  {
    dword_10165CC8 = 0;
  }
  return v1;
}
// 1009BB30: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100E6D90: using guessed type __int16 word_100E6D90[];
// 10165CC8: using guessed type int dword_10165CC8;

//----- (100037E0) --------------------------------------------------------
void *__cdecl sub_100037E0(int a1, unsigned int a2)
{
  void *result; // eax@1
  bool v3; // [sp+3h] [bp-1ADh]@10
  __int16 v4; // [sp+4h] [bp-1ACh]@1
  char v5; // [sp+8h] [bp-1A8h]@4
  unsigned int v6; // [sp+D4h] [bp-DCh]@3
  char v7; // [sp+D8h] [bp-D8h]@3
  int *v8; // [sp+158h] [bp-58h]@1
  char v9; // [sp+15Ch] [bp-54h]@3
  int v10; // [sp+170h] [bp-40h]@1
  char v11; // [sp+174h] [bp-3Ch]@1
  char v12[4]; // [sp+1ACh] [bp-4h]@1

  result = memset(&v11, 0, 0x32u);
  v10 = 0;
  v4 = 0;
  *(_DWORD *)v12 = 0;
  v8 = 0;
  if ( a1 && dword_10165CC8 < a2 )
  {
    dword_10165CC8 = a2;
    sub_1009B2F0((int)&v9, 1, *(_DWORD *)(a1 + 64), 20);
    sub_1006FD70(&v7, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v9);
    v6 = j_FIL_vfs_open(&v7, 10, 0);
    sub_1006FBE0((int)&byte_10164CC8, "HEAP STATISTICS:\r\n", 4096);
    if ( a2 > 0x32000 )
    {
      sub_1006FBE0((int)&v5, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_1006FDA0(&byte_10164CC8, &v5, 4096);
    }
    sub_1006FD70(&v5, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v9, a2, 204800);
    sub_1006FDA0(&byte_10164CC8, &v5, 4096);
    v8 = *(int **)(a1 + 32);
    while ( v8 )
    {
      sub_10003DC0((int)v8, &v4, &v11);
      sub_1006FD70(&v5, 0xC8u, "  Page[%d]: %s\r\n", *(_DWORD *)v12, &v11);
      sub_1006FDA0(&byte_10164CC8, &v5, 4096);
      v8 = (int *)*v8;
      ++*(_DWORD *)v12;
    }
    v3 = v6 >= 0xFFFFFFC2 || !v6;
    result = (void *)v3;
    if ( !v3 )
    {
      v10 = sub_1006FCA0(&byte_10164CC8, 0x1000u);
      j_FIL_vfs_write(v6, &byte_10164CC8, v10);
      sub_1009BC90(v6, v10, 0);
      result = (void *)sub_1009BA60(v6);
    }
  }
  return result;
}
// 1009BB30: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1009BCB0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 10165CC8: using guessed type int dword_10165CC8;

//----- (10003A30) --------------------------------------------------------
bool __cdecl sub_10003A30(unsigned int a1, char a2)
{
  void *v2; // ecx@4
  void *v3; // ecx@5
  char v5; // [sp+2h] [bp-Ah]@2
  char v6; // [sp+3h] [bp-9h]@2
  unsigned __int8 v7; // [sp+8h] [bp-4h]@4
  unsigned __int8 v8; // [sp+Ah] [bp-2h]@4
  char v9; // [sp+Bh] [bp-1h]@4

  if ( a2 >= 0 )
  {
    v6 = 1;
    v5 = 1;
  }
  else
  {
    v6 = -1;
    v5 = -1;
  }
  v8 = byte_100C8DC8[56 * sub_10071530(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 56) + 8))];
  v7 = v8;
  v9 = sub_10003D00(v8);
  if ( v8 != 1 )
  {
    if ( sub_10004090(v2) || (unsigned __int8)sub_10070100(v3) )
    {
      while ( a2 && v5 + v8 >= 0 && v5 + v8 < 1 )
      {
        if ( *(&byte_10165CD2[v8] + v5) && (unsigned __int8)sub_10003D00(v5 + v8) == (unsigned __int8)v9 )
        {
          v8 += v5;
          v5 = v6;
          a2 -= v6;
        }
        else
        {
          v5 += v6;
        }
      }
    }
    else
    {
      *(_BYTE *)(a1 + 392) = 1;
    }
  }
  if ( v8 != v7 )
  {
    sub_1006E380(a1, -3, (int (__cdecl *)(int))dword_10165CDC[v8], 0);
    sub_100040D0();
  }
  return v8 != v7;
}
// 10165CDC: using guessed type int dword_10165CDC[];

//----- (10003B90) --------------------------------------------------------
bool __cdecl sub_10003B90(unsigned int a1, char a2)
{
  void *v2; // ecx@5
  char v4; // [sp+2h] [bp-Eh]@2
  char v5; // [sp+3h] [bp-Dh]@2
  signed int v6; // [sp+4h] [bp-Ch]@4
  signed int v7; // [sp+8h] [bp-8h]@4
  char v8; // [sp+Eh] [bp-2h]@4
  bool v9; // [sp+Fh] [bp-1h]@1

  v9 = 0;
  if ( a2 >= 0 )
  {
    v5 = 1;
    v4 = 1;
  }
  else
  {
    v5 = -1;
    v4 = -1;
  }
  v6 = sub_10071530(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 56) + 8));
  v7 = v6;
  v8 = byte_100C8DC8[56 * v6];
  if ( v8 != 1 )
  {
    if ( sub_10004090((void *)(unsigned __int8)v8) || (unsigned __int8)sub_10070100(v2) )
    {
      while ( a2
           && v7 + v4 >= (unsigned __int16)word_10165CD4[(unsigned __int8)v8]
           && v7 + v4 <= (unsigned __int16)word_10165CE0[(unsigned __int8)v8]
           && (unsigned __int8)byte_100C8DC8[56 * (v7 + v4)] == (unsigned __int8)v8 )
      {
        if ( *(&byte_10165CE8[v7] + v4) )
        {
          v7 += v4;
          v4 = v5;
          a2 -= v5;
        }
        else
        {
          v4 += v5;
        }
      }
      v9 = v6 != v7;
      if ( v6 != v7 )
      {
        dword_10165CDC[(unsigned __int8)v8] = (int)*(&off_100C8DC4 + 14 * v7);
        sub_1006E380(a1, -3, *(&off_100C8DC4 + 14 * v7), 0);
        sub_100040D0();
      }
    }
    else
    {
      *(_BYTE *)(a1 + 392) = 1;
    }
  }
  return v9;
}
// 100C8DC4: using guessed type int (__cdecl *off_100C8DC4)(int);
// 10165CD4: using guessed type __int16 word_10165CD4[];
// 10165CDC: using guessed type int dword_10165CDC[];
// 10165CE0: using guessed type __int16 word_10165CE0[];

//----- (10003D00) --------------------------------------------------------
char __cdecl sub_10003D00(unsigned __int8 a1)
{
  return *(_BYTE *)(dword_10658E00 + 4 * (unsigned __int8)byte_10165CD0[a1] + 1);
}
// 10658E00: using guessed type int dword_10658E00;

//----- (10003D20) --------------------------------------------------------
__int16 __cdecl sub_10003D20(unsigned __int8 a1)
{
  return *(_WORD *)(dword_10658E00 + 4 * (unsigned __int8)byte_10165CD0[a1] + 2);
}
// 10658E00: using guessed type int dword_10658E00;

//----- (10003D40) --------------------------------------------------------
char __cdecl sub_10003D40(int (__cdecl *a1)(int))
{
  signed int v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10071530(a1);
  if ( v2 == -1 )
    sub_10070AD0(".\\cdp_page_list.c", 705, 1, 0);
  return byte_100C8DC8[56 * v2];
}

//----- (10003D90) --------------------------------------------------------
char __cdecl sub_10003D90(int (__cdecl *a1)(int))
{
  unsigned __int8 v1; // al@1

  v1 = sub_10003D40(a1);
  return sub_10003D00(v1);
}

//----- (10003DC0) --------------------------------------------------------
char *__cdecl sub_10003DC0(int a1, __int16 *a2, _BYTE *a3)
{
  char *result; // eax@3
  char v4; // cl@6
  _BYTE *v5; // [sp+8h] [bp-1Ch]@5
  char *v6; // [sp+Ch] [bp-18h]@5
  _BYTE *v7; // [sp+18h] [bp-Ch]@2
  char *v8; // [sp+1Ch] [bp-8h]@2
  signed int v9; // [sp+20h] [bp-4h]@1

  v9 = sub_10071530(*(int (__cdecl **)(int))(a1 + 8));
  *a2 = sub_10003D20(byte_100C8DC8[56 * v9]);
  if ( *(_DWORD *)(a1 + 252) )
  {
    v6 = *(char **)(a1 + 252);
    v5 = a3;
    do
    {
      v4 = *v6;
      *v5 = *v6++;
      result = v5++ + 1;
    }
    while ( v4 );
  }
  else
  {
    v8 = &aDiagnostics[56 * v9];
    v7 = a3;
    do
    {
      result = v8;
      LOBYTE(result) = *v8;
      *v7++ = *v8++;
    }
    while ( (_BYTE)result );
  }
  return result;
}

//----- (10003E90) --------------------------------------------------------
char __cdecl sub_10003E90(unsigned int a1)
{
  signed int i; // [sp+0h] [bp-8h]@1
  signed int j; // [sp+0h] [bp-8h]@4
  signed int k; // [sp+0h] [bp-8h]@7
  signed int l; // [sp+0h] [bp-8h]@13
  int m; // [sp+0h] [bp-8h]@16
  signed int n; // [sp+0h] [bp-8h]@22
  char v8; // [sp+6h] [bp-2h]@9
  char v9; // [sp+6h] [bp-2h]@18
  char v10; // [sp+7h] [bp-1h]@3

  dword_10658E00 = (int)&unk_100C8DBC;
  dword_10165CD8 = 0;
  for ( i = 0; i < 1; ++i )
  {
    *(&v10 + i) = 0;
    byte_10165CD2[i] = 1;
  }
  for ( j = 0; j <= 1; ++j )
    byte_10165CD0[*(_BYTE *)(dword_10658E00 + 4 * j)] = j;
  for ( k = 0; k < 1; ++k )
  {
    byte_10165CE8[k] = 1;
    v8 = byte_100C8DC8[56 * k];
    if ( (signed int)(unsigned __int8)v8 < 1 && !*(&v10 + (unsigned __int8)v8) )
    {
      word_10165CD4[(unsigned __int8)v8] = k;
      *(&v10 + (unsigned __int8)v8) = 1;
    }
  }
  for ( l = 0; l < 1; ++l )
  {
    *(&v10 + l) = 0;
    dword_10165CDC[l] = (int)*(&off_100C8DC4 + 14 * (unsigned __int16)word_10165CD4[l]);
  }
  for ( m = 0; m >= 0; --m )
  {
    v9 = byte_100C8DC8[56 * m];
    if ( (signed int)(unsigned __int8)v9 < 1 && !*(&v10 + (unsigned __int8)v9) )
    {
      word_10165CE0[(unsigned __int8)v9] = m;
      *(&v10 + (unsigned __int8)v9) = 1;
    }
  }
  sub_1000D7E0();
  sub_100040E0(a1);
  sub_1000D5C0(a1);
  for ( n = 0; n < 1; ++n )
    (*(&off_100C8DC4 + 14 * n))(a1);
  sub_1000D1C0(a1);
  sub_1000D1E0(a1);
  return sub_10003450(0, *(_DWORD *)(a1 + 56));
}
// 100C8DC4: using guessed type int (__cdecl *off_100C8DC4)(int);
// 10165CD4: using guessed type __int16 word_10165CD4[];
// 10165CD8: using guessed type int dword_10165CD8;
// 10165CDC: using guessed type int dword_10165CDC[];
// 10165CE0: using guessed type __int16 word_10165CE0[];
// 10658E00: using guessed type int dword_10658E00;

//----- (10004090) --------------------------------------------------------
char __thiscall sub_10004090(void *this)
{
  char v2; // [sp+3h] [bp-1h]@1

  v2 = 1;
  if ( !dword_10165CD8 && !sub_100700A0(this) )
    v2 = 0;
  dword_10165CD8 = sub_1009B2D0();
  return v2;
}
// 10165CD8: using guessed type int dword_10165CD8;

//----- (100040D0) --------------------------------------------------------
void sub_100040D0()
{
  ;
}

//----- (100040E0) --------------------------------------------------------
_WORD *__cdecl sub_100040E0(int a1)
{
  *(_DWORD *)(a1 + 56) = sub_100034E0(a1, 332);
  qmemcpy(*(void **)(a1 + 56), &unk_100C0B78, 0x14Cu);
  sub_100024F0(a1, *(_DWORD *)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_1009D940(a1 + 392, (int)&dword_105722F4, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_1009D8E0(a1 + 392);
}
// 105722F4: using guessed type int dword_105722F4;

//----- (10004180) --------------------------------------------------------
void __cdecl sub_10004180(int a1)
{
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8018:
    case 0x801F:
      sub_100042B0(a1);
      break;
    case 0x8022:
      sub_10004650(a1);
      break;
    case 0x8020:
      sub_10004310(a1);
      break;
    case 0x8041:
      sub_10004690(a1);
      break;
    case 0x8048:
      sub_10004720(a1);
      break;
    case 0x8051:
      sub_10004780(a1);
      break;
    case 0x806E:
      sub_100047B0(a1);
      break;
    case 0x8078:
      sub_100047D0(a1);
      break;
    default:
      return;
  }
}

//----- (100042B0) --------------------------------------------------------
void __cdecl sub_100042B0(int a1)
{
  int v1; // ST10_4@1
  int v2; // ST0C_4@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10006C30(v1);
  *(_DWORD *)(v1 + 12) = 0;
  if ( dword_10658DFC )
  {
    v2 = sub_10006A40();
    memset(dword_10658DFC, 0, 0xC0018u);
    sub_10006BC0(v2);
  }
}

//----- (10004310) --------------------------------------------------------
void __cdecl sub_10004310(int a1)
{
  void *v1; // ecx@11
  __int64 v2; // rax@14
  char v3; // [sp+0h] [bp-128h]@17
  char v4; // [sp+3Fh] [bp-E9h]@17
  char v5; // [sp+113h] [bp-15h]@20
  char *v6; // [sp+114h] [bp-14h]@14
  int v7; // [sp+118h] [bp-10h]@17
  int v8; // [sp+11Ch] [bp-Ch]@1
  void *v9; // [sp+120h] [bp-8h]@1
  int v10; // [sp+124h] [bp-4h]@11

  v8 = *(_DWORD *)(a1 + 52);
  v9 = *(void **)(*(_DWORD *)(a1 + 56) + 12);
  if ( sub_10006A60()
    && (!*((_DWORD *)v9 + 3)
     || (unsigned int)(sub_1009B2D0() - *((_DWORD *)v9 + 17)) >= 0x1F40
     || *((_DWORD *)dword_10658DFC + 196612) != *(_DWORD *)(v8 + 8))
    && (signed int)*(_WORD *)(v8 + 14) <= 768
    && (signed int)*(_WORD *)(v8 + 12) <= 1024
    && *(_DWORD *)(v8 + 8) <= 0x40u )
  {
    if ( *((_DWORD *)v9 + 3) )
      sub_100042B0(a1);
    v10 = sub_10006A40();
    *((_BYTE *)v9 + 64) = sub_100704E0(v1) == 2;
    *((_DWORD *)v9 + 18) = &unk_100C2368;
    *((_DWORD *)v9 + 19) = &unk_100C2378;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 231) = 0;
    *(_DWORD *)dword_10658DFC = dword_105722F4;
    *((_WORD *)dword_10658DFC + 3) = *(_WORD *)(v8 + 12);
    *((_WORD *)dword_10658DFC + 2) = *(_WORD *)(v8 + 14);
    *(_DWORD *)dword_10658DFC = (char *)dword_10658DFC + 12;
    v2 = *(_WORD *)(v8 + 12) + 255;
    *((_WORD *)dword_10658DFC + 5) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
    *((_BYTE *)dword_10658DFC + 8) = 8;
    *((_DWORD *)dword_10658DFC + 196612) = *(_DWORD *)(v8 + 8);
    *((_BYTE *)dword_10658DFC + 786445) = 1;
    *((_BYTE *)dword_10658DFC + 786444) = -1;
    sub_1000D7B0((int)dword_10658DFC);
    sub_10001870(a1, 0, 0, *(_WORD *)(v8 + 12), *(_WORD *)(v8 + 14), 1);
    memset(v9, 0, 0x40u);
    *(_WORD *)v9 = *(_WORD *)(v8 + 14);
    *((_WORD *)v9 + 1) = *(_WORD *)(v8 + 12);
    *((_WORD *)v9 + 2) = 0;
    *((_WORD *)v9 + 3) = 0;
    *((_DWORD *)v9 + 2) = a1;
    v6 = sub_10006BE0();
    if ( !v6 )
      v6 = "/mnt/card0/html/index.htm";
    if ( strstr(v6, "zip") )
    {
      sub_1009B830(6450, (int)&v3, 264);
      v4 = 0;
      v7 = sub_10009D40((int)v6, (int)&v3);
      if ( v7 == -34 )
      {
        v7 = sub_10009D40((int)v6, (int)&unk_100C23C8);
        if ( v7 == -34 )
          v7 = sub_10009D40((int)v6, (int)&unk_100C2390);
      }
      v6 = "/html/index.htm";
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    v7 = sub_100071C0(v6, (int)v9);
    sub_10002720(a1, *(_DWORD *)(a1 + 56), 333);
    sub_100025D0(a1, *(_DWORD *)(a1 + 56), -32648);
    *(_BYTE *)(a1 + 6) = 2;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
    sub_100069C0();
    *((_DWORD *)v9 + 17) = sub_1009B2D0();
    sub_10006BC0(v10);
  }
}
// 105722F4: using guessed type int dword_105722F4;

//----- (10004650) --------------------------------------------------------
int __cdecl sub_10004650(int a1)
{
  int result; // eax@1

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
  LOBYTE(result) = sub_100025D0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10004690) --------------------------------------------------------
bool __cdecl sub_10004690(int a1)
{
  int v1; // eax@1
  void *v2; // ST18_4@1

  v1 = sub_100024F0(a1, *(_DWORD *)(a1 + 56), 80, 20);
  v2 = (void *)v1;
  *(_DWORD *)(v1 + 72) = &unk_100C2368;
  *(_DWORD *)(v1 + 76) = &unk_100C2378;
  *(_DWORD *)(v1 + 68) = 0;
  dword_10658DFC = 0;
  memset((void *)v1, 0, 0x40u);
  return sub_1006CED0(a1, *(_WORD **)(a1 + 52), *((char **)v2 + 18), *((_DWORD *)v2 + 19), 0, 255);
}

//----- (10004720) --------------------------------------------------------
char __cdecl sub_10004720(int a1)
{
  bool v1; // ST0F_1@2
  char result; // al@3

  if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) == 56 )
    v1 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128;
  result = sub_100074D0(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), *(_WORD **)(a1 + 52));
  *(_BYTE *)(a1 + 6) = result;
  return result;
}

//----- (10004780) --------------------------------------------------------
char __cdecl sub_10004780(int a1)
{
  char result; // al@1

  result = sub_100074D0(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), *(_WORD **)(a1 + 52));
  *(_BYTE *)(a1 + 6) = result;
  return result;
}

//----- (100047B0) --------------------------------------------------------
int __cdecl sub_100047B0(int a1)
{
  int result; // eax@1
  int v2; // edx@1

  result = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  return result;
}

//----- (100047D0) --------------------------------------------------------
int __cdecl sub_100047D0(int a1)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@2

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  result = v2;
  if ( *(_DWORD *)(v2 + 12) )
  {
    v3 = sub_10006A40();
    sub_100074D0(v2, *(_WORD **)(a1 + 52));
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) )
    {
      sub_10007270(v2, *(_DWORD *)(v2 + 52), *(_WORD **)(a1 + 52), 0xFFu);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 0;
    }
    sub_10007270(v2, *(_DWORD *)(v2 + 60), *(_WORD **)(a1 + 52), 0xFFu);
    sub_10007270(v2, *(_DWORD *)(v2 + 56), *(_WORD **)(a1 + 52), *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
    *((_BYTE *)dword_10658DFC + 786444) = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
    sub_10006BC0(v3);
  }
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100048C0) --------------------------------------------------------
void __cdecl sub_100048C0(unsigned int a1)
{
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8041:
      sub_10004A50(a1);
      break;
    case 0x8022:
    case 0x8078:
      sub_100049D0(a1);
      break;
    case 0x8048:
      sub_10005830(a1);
      break;
    case 0x80AA:
      sub_10001000(a1);
      break;
    default:
      return;
  }
}

//----- (100049D0) --------------------------------------------------------
int __cdecl sub_100049D0(int a1)
{
  int v1; // ST1C_4@1
  int v2; // ST18_4@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60);
  sub_1006CED0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C29C8, (int)&unk_100C29D8, 0, 255);
  LOBYTE(result) = sub_1006CED0(
                     a1,
                     *(_WORD **)(a1 + 52),
                     (char *)(v1 + 8),
                     v2,
                     0,
                     *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10004A50) --------------------------------------------------------
void __cdecl sub_10004A50(unsigned int a1)
{
  int v1; // edx@4
  int v2; // eax@4
  int v3; // edx@4
  int v4; // ST2C_4@4
  int v5; // [sp+0h] [bp-18h]@6
  int v6; // [sp+4h] [bp-14h]@9
  _DWORD *v7; // [sp+10h] [bp-8h]@1
  int v8; // [sp+14h] [bp-4h]@1

  v8 = sub_100024F0(a1, *(_DWORD *)(a1 + 56), 1892, 1);
  v7 = *(_DWORD **)(*(_DWORD *)(a1 + 56) + 60);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4)
    && *(_DWORD *)(*(_DWORD *)(a1 + 52) + 36) == *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 4) + 8) )
  {
    *(_DWORD *)(v8 + 1852) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 16);
    *(_DWORD *)(v8 + 1856) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 20);
    v1 = *(_DWORD *)(v8 + 1856);
    v2 = v8 + 1860;
    *(_DWORD *)v2 = *(_DWORD *)v1;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v1 + 4);
    *(_DWORD *)(v2 + 8) = *(_DWORD *)(v1 + 8);
    *(_DWORD *)(v2 + 12) = *(_DWORD *)(v1 + 12);
    *(_DWORD *)(v8 + 1876) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 32);
    *(_BYTE *)(v8 + 1880) = 0;
    *(_WORD *)(v8 + 1890) = *(_WORD *)(v8 + 1860);
    *(_BYTE *)(v8 + 1888) = 0;
    *(_DWORD *)(v8 + 76) = 75;
    *(_WORD *)(v8 + 80) = 0;
    *(_WORD *)(v8 + 82) = 0;
    *(_WORD *)(v8 + 1884) = 0;
    *(_WORD *)(v8 + 1886) = 0;
    sub_100051F0(a1);
    v3 = *(_DWORD *)(a1 + 52);
    v4 = *(_DWORD *)(v3 + 28);
    sub_10004DF0(
      a1,
      (_WORD *)(v8 + 4),
      (_WORD *)(v8 + 6),
      (_WORD *)(v8 + 2),
      (_WORD *)v8,
      (_WORD *)(v8 + 1890),
      *(_WORD *)(v8 + 1884),
      (_WORD *)(v8 + 1886),
      (unsigned __int8 *)(v8 + 1888),
      (*(_WORD *)(*(_DWORD *)(v8 + 1852) + 4) & 8) == 8,
      *(_DWORD *)(v3 + 24));
    sub_10004EF0(a1);
    sub_10001870(a1, *(_WORD *)(v8 + 4), *(_WORD *)(v8 + 6), *(_WORD *)(v8 + 2), *(_WORD *)v8, 0);
    sub_100706B0(*(_DWORD *)(a1 + 56), (char *)(v8 + 8));
    *v7 = v8 + 40;
    *(_DWORD *)(v8 + 52) = 0;
    *(_WORD *)(v8 + 44) = *(_WORD *)(v8 + 1862);
    if ( *(_WORD *)(*(_DWORD *)(v8 + 1852) + 4) & 0x400 )
    {
      if ( (*(_WORD *)(*(_DWORD *)(v8 + 1852) + 4) & 0x3E0) >> 5 )
        v5 = (*(_WORD *)(*(_DWORD *)(v8 + 1852) + 4) & 0x3E0) >> 5;
      else
        LOBYTE(v5) = 10;
      if ( *(_WORD *)(v8 + 1862) - ((unsigned __int8)v5 - 1) / 2 >= 0 )
        v6 = *(_WORD *)(v8 + 1862) - ((unsigned __int8)v5 - 1) / 2;
      else
        LOWORD(v6) = 0;
      *(_WORD *)(v8 + 44) = v6;
    }
    *(_WORD *)(v8 + 42) = *(_WORD *)(v8 + 1862);
    *(_DWORD *)(v8 + 56) = v8 + 60;
    *(_WORD *)(v8 + 48) = *(_WORD *)(v8 + 1860);
    *(_WORD *)(v8 + 1882) = *(_WORD *)(v8 + 42);
    sub_10005590(a1, v8 + 60, *(_WORD *)(v8 + 1862), 0, 1);
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 0;
    sub_100025D0(a1, *(_DWORD *)(a1 + 56), -32734);
    sub_1006CDB0(
      a1,
      &unk_100E462C,
      *(char ***)(*(_DWORD *)(a1 + 56) + 56),
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
      0,
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
    *(_BYTE *)(a1 + 9) = 1;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 247) = 1;
    sub_10070780(a1, *(char **)(*(_DWORD *)(a1 + 56) + 4), &unk_100E461C);
    *(_BYTE *)(a1 + 6) = 2;
  }
  else
  {
    sub_1006E380(a1, 1, 0, 0);
    *(_BYTE *)(a1 + 6) = 2;
  }
}

//----- (10004DF0) --------------------------------------------------------
__int16 __cdecl sub_10004DF0(int a1, _WORD *a2, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, __int16 a7, _WORD *a8, unsigned __int8 *a9, char a10, char a11)
{
  __int16 result; // ax@1
  __int16 v12; // [sp+0h] [bp-20h]@1
  int v13; // [sp+4h] [bp-1Ch]@1
  char v14; // [sp+Bh] [bp-15h]@1
  __int16 v15; // [sp+Ch] [bp-14h]@1
  __int16 v16; // [sp+Eh] [bp-12h]@1
  __int16 v17; // [sp+10h] [bp-10h]@1
  __int16 v18; // [sp+12h] [bp-Eh]@1
  __int16 v19; // [sp+14h] [bp-Ch]@1
  __int16 v20; // [sp+18h] [bp-8h]@1
  __int16 v21; // [sp+1Ch] [bp-4h]@1

  v19 = 0;
  v12 = 0;
  v20 = 0;
  v21 = 0;
  v14 = 0;
  v13 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4);
  v16 = *(_WORD *)(v13 + 30);
  v18 = *(_WORD *)(v13 + 34) + *(_WORD *)(v13 + 30);
  v15 = *(_WORD *)(v13 + 28);
  v17 = *(_WORD *)(v13 + 32) + *(_WORD *)(v13 + 28);
  sub_10005300(a1, (int)&a11, (int)&v15, a6, a7, &v12, &v21, &v14, a9, a10);
  sub_10005010(a1, (int)&a11, (int)&v15, a8, &v19, &v20, &v14, *a9, a10);
  *a4 = v19;
  *a5 = v12;
  *a2 = v20;
  result = v21;
  *a3 = v21;
  return result;
}

//----- (10004EF0) --------------------------------------------------------
int __cdecl sub_10004EF0(int a1)
{
  int result; // eax@6
  unsigned int v2; // [sp+0h] [bp-14h]@1
  signed __int16 v3; // [sp+8h] [bp-Ch]@1
  int *v4; // [sp+Ch] [bp-8h]@1
  int v5; // [sp+10h] [bp-4h]@1

  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v4 = sub_1006D000(0x1026u);
  v2 = (sub_1006D920(0x1026u, 0) & 0xFF0000u) >> 16;
  v3 = 0;
  if ( *(_BYTE *)(v5 + 1888) )
    v3 = 64;
  *(_DWORD *)(v5 + 8) = 122;
  if ( *(_WORD *)(*(_DWORD *)(v5 + 1852) + 4) & 4 )
    *(_WORD *)(v5 + 12) = v3;
  else
    *(_WORD *)(v5 + 12) = v3 | 0x80;
  *(_WORD *)(v5 + 14) = 16;
  *(_DWORD *)(v5 + 16) = v5 + 76;
  *(_DWORD *)(v5 + 20) = sub_10005700;
  *(_WORD *)(v5 + 24) = *(_WORD *)(v5 + 1890);
  *(_WORD *)(v5 + 26) = *(_WORD *)(v5 + 1884) + 1;
  *(_WORD *)(v5 + 28) = 0;
  *(_WORD *)(v5 + 32) = 15;
  *(_WORD *)(v5 + 34) = v2 + *(_WORD *)(*v4 + 24) + 17 - *(_WORD *)(*v4 + 26) - 1;
  result = v5;
  *(_DWORD *)(v5 + 36) = 141;
  return result;
}

//----- (10005010) --------------------------------------------------------
_WORD *__cdecl sub_10005010(int a1, int a2, int a3, _WORD *a4, _WORD *a5, _WORD *a6, _BYTE *a7, unsigned __int8 a8, char a9)
{
  _WORD *result; // eax@21
  int v10; // [sp+Ch] [bp-20h]@1
  char v11; // [sp+13h] [bp-19h]@11
  __int16 v12; // [sp+14h] [bp-18h]@3
  int v13; // [sp+18h] [bp-14h]@4
  __int16 v14; // [sp+1Ch] [bp-10h]@1
  __int16 v15; // [sp+20h] [bp-Ch]@1
  __int16 v16; // [sp+24h] [bp-8h]@3
  __int16 v17; // [sp+28h] [bp-4h]@1

  v10 = *a4 + 6 * a8 + 28;
  v14 = *(_WORD *)(a1 + 16);
  v17 = 0;
  v15 = *(_WORD *)(a1 + 16);
  if ( a9 )
  {
    v14 = *(_WORD *)(a3 + 4) - *(_WORD *)a3 + 1;
    v17 = *(_WORD *)a3;
    v15 = *(_WORD *)(a3 + 4);
  }
  v12 = *(_WORD *)a2;
  v16 = v10 - v14;
  if ( v10 - v14 <= 0 )
  {
    do
    {
      if ( *a7 <= 1u )
      {
        LOWORD(v13) = v12 + 2;
        if ( v10 + v12 + 2 > v15 )
        {
          LOWORD(v13) = v15 - v10;
          if ( v15 - v10 <= v17 )
            LOWORD(v13) = v17;
        }
        v11 = 1;
      }
      else if ( *a7 == 2 )
      {
        v11 = 1;
        v13 = *(_WORD *)(a2 + 4) + 2;
        if ( v10 + v13 > v15 )
        {
          v13 = *(_WORD *)a2 - 2 - v10;
          if ( v13 < v17 )
          {
            v11 = 0;
            *a7 = 3;
          }
        }
      }
      else
      {
        v13 = (v14 - v10) / 2 + v17;
        if ( v10 + v13 > v15 )
        {
          v13 = v14 + v17 - v10;
          if ( v13 <= v17 )
            LOWORD(v13) = v17;
        }
        v11 = 1;
      }
    }
    while ( !v11 );
  }
  else
  {
    LOWORD(v10) = v10 - v16;
    *a4 -= v16;
    LOWORD(v13) = v17;
  }
  result = a5;
  *a5 = v10 - 1;
  *a6 = v13;
  return result;
}

//----- (100051F0) --------------------------------------------------------
int __cdecl sub_100051F0(int a1)
{
  int result; // eax@1
  __int16 v2; // [sp+0h] [bp-40h]@7
  __int16 v3; // [sp+Ch] [bp-34h]@4
  __int16 v4; // [sp+18h] [bp-28h]@3
  __int16 v5; // [sp+1Ch] [bp-24h]@3
  __int16 v6; // [sp+1Eh] [bp-22h]@3
  __int16 v7; // [sp+20h] [bp-20h]@3
  __int16 v8; // [sp+22h] [bp-1Eh]@3
  char v9; // [sp+24h] [bp-1Ch]@3
  __int16 v10; // [sp+34h] [bp-Ch]@3
  int i; // [sp+38h] [bp-8h]@1
  int v12; // [sp+3Ch] [bp-4h]@1

  result = a1;
  v12 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  for ( i = 0; i < *(_WORD *)(v12 + 1860); ++i )
  {
    sub_10005590(a1, (int)&v9, i, 0, 0);
    sub_1006CD30(a1, (char *)(v12 + 76), (int)&v9, &v5);
    v10 = v8 - v6 + 1;
    v4 = v7 - v5 + 1;
    if ( *(_WORD *)(v12 + 1884) <= v10 )
      v3 = v8 - v6 + 1;
    else
      v3 = *(_WORD *)(v12 + 1884);
    *(_WORD *)(v12 + 1884) = v3;
    if ( *(_WORD *)(v12 + 1886) <= v4 )
      v2 = v4;
    else
      v2 = *(_WORD *)(v12 + 1886);
    *(_WORD *)(v12 + 1886) = v2;
    result = i + 1;
  }
  return result;
}

//----- (10005300) --------------------------------------------------------
int __cdecl sub_10005300(int a1, int a2, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, char a10)
{
  int v10; // ST18_4@13
  int v11; // ST4C_4@25
  int result; // eax@41
  int v13; // [sp+0h] [bp-58h]@33
  int v14; // [sp+8h] [bp-50h]@5
  __int16 v15; // [sp+14h] [bp-44h]@14
  __int16 v16; // [sp+2Ch] [bp-2Ch]@10
  signed int v17; // [sp+30h] [bp-28h]@8
  int v18; // [sp+34h] [bp-24h]@22
  __int16 v19; // [sp+38h] [bp-20h]@10
  int v20; // [sp+3Ch] [bp-1Ch]@0
  char v21; // [sp+43h] [bp-15h]@10
  int v22; // [sp+44h] [bp-14h]@19
  __int16 v23; // [sp+48h] [bp-10h]@12
  signed int v24; // [sp+50h] [bp-8h]@2
  int v25; // [sp+54h] [bp-4h]@1

  v25 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( (signed int)*a4 <= 4 )
    v24 = *a4;
  else
    v24 = 4;
  if ( (*(_WORD *)(*(_DWORD *)(v25 + 1852) + 4) & 0x3E0) >> 5 )
    v14 = (*(_WORD *)(*(_DWORD *)(v25 + 1852) + 4) & 0x3E0) >> 5;
  else
    LOBYTE(v14) = 10;
  if ( (unsigned __int8)v14 >= (signed int)*a4 )
    v17 = *a4;
  else
    v17 = (unsigned __int8)v14;
  v21 = 0;
  v16 = *(_WORD *)(a1 + 14) - 1;
  v19 = 0;
  if ( a10 )
  {
    v16 = *(_WORD *)(a3 + 6);
    v19 = *(_WORD *)(a3 + 2);
  }
  v23 = v16 - v19 + 1;
  if ( *(_DWORD *)(a1 + 64) != 1 )
  {
    v10 = *(_WORD *)(a1 + 14) - 26;
    if ( v16 >= v10 )
      v15 = *(_WORD *)(a1 + 14) - 26;
    else
      v15 = v16;
    v16 = v15;
  }
  do
  {
    *a9 = 0;
    if ( *a4 > v17 )
      *a9 = 1;
    v22 = v17 * (a5 + 1) + 33;
    if ( *a8 )
    {
      if ( *a8 == 1 )
      {
        v11 = *(_WORD *)(a2 + 2) - 2 - v22 + 1;
        if ( v11 >= v19 )
        {
          LOWORD(v20) = *(_WORD *)(a2 + 2) - 2 - v22 + 1;
          v21 = 1;
        }
      }
      else if ( v22 <= v23 )
      {
        v20 = (v23 - v22) / 2 + v19;
        v21 = 1;
      }
    }
    else
    {
      v18 = *(_WORD *)(a2 + 6) + v22 + 2;
      if ( v18 <= v16 )
      {
        v20 = v18 - v22 + 2;
        v21 = 1;
      }
    }
    if ( !v21 )
    {
      if ( v17 > v24 )
      {
        --v17;
      }
      else
      {
        if ( (*(_WORD *)(*(_DWORD *)(v25 + 1852) + 4) & 0x3E0) >> 5 )
          v13 = (*(_WORD *)(*(_DWORD *)(v25 + 1852) + 4) & 0x3E0) >> 5;
        else
          LOBYTE(v13) = 10;
        if ( (unsigned __int8)v13 >= (signed int)*a4 )
          v17 = *a4;
        else
          v17 = (unsigned __int8)v13;
        ++*a8;
      }
    }
  }
  while ( !v21 );
  HIWORD(result) = HIWORD(a6);
  *a6 = v22;
  LOWORD(result) = v20;
  *a7 = v20;
  *a4 = v17;
  return result;
}

//----- (10005590) --------------------------------------------------------
int __cdecl sub_10005590(int a1, int a2, unsigned __int16 a3, unsigned __int16 a4, __int16 a5)
{
  int v6; // [sp+8h] [bp-4h]@1

  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 1) = 0;
  *(_WORD *)(a2 + 2) = 0;
  *(_WORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(*(_DWORD *)(v6 + 1868) + 4 * a3);
  if ( *(_WORD *)(*(_DWORD *)(v6 + 1852) + 4) & 1 )
    qmemcpy((void *)(v6 + 52 * a4 + 84), *(const void **)(v6 + 1864), 0x34u);
  else
    qmemcpy((void *)(v6 + 52 * a4 + 84), *(const void **)(*(_DWORD *)(v6 + 1864) + 4 * a3), 0x34u);
  *(_DWORD *)(a2 + 8) = v6 + 52 * a4 + 84;
  return sub_10005660(a1, *(char **)(a2 + 8), a5);
}

//----- (10005660) --------------------------------------------------------
int __cdecl sub_10005660(int a1, char *a2, __int16 a3)
{
  int result; // eax@1
  char *v4; // ST18_4@2
  int v5; // [sp+4h] [bp-10h]@1
  int v6; // [sp+8h] [bp-Ch]@1
  char *v7; // [sp+Ch] [bp-8h]@2
  int v8; // [sp+10h] [bp-4h]@1

  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v5 = *(_DWORD *)a2 & 0xFF;
  result = sub_10071590(&v5, 4u, (int)&unk_100C29E0, 8, 15, -1);
  v6 = result;
  if ( result != -1 )
  {
    v7 = &a2[(unsigned __int16)word_100C29E4[4 * v6]];
    v4 = &a2[(unsigned __int16)word_100C29E6[4 * v6]];
    *(_WORD *)v7 = a3 * (*(_WORD *)(v8 + 1886) - 2);
    *(_DWORD *)v4 &= 0xFFFF3FFF;
    result = *(_DWORD *)v4;
    *(_DWORD *)v4 = *(_DWORD *)v4;
  }
  return result;
}
// 100C29E4: using guessed type __int16 word_100C29E4[];
// 100C29E6: using guessed type __int16 word_100C29E6[];

//----- (10005700) --------------------------------------------------------
char __cdecl sub_10005700(int a1, int a2, unsigned __int16 a3)
{
  int v4; // [sp+0h] [bp-24h]@10
  char v5; // [sp+Bh] [bp-19h]@1
  int v6; // [sp+Ch] [bp-18h]@14
  int v7; // [sp+10h] [bp-14h]@14
  int v8; // [sp+14h] [bp-10h]@14
  int v9; // [sp+18h] [bp-Ch]@14
  int v10; // [sp+1Ch] [bp-8h]@7
  int v11; // [sp+20h] [bp-4h]@1

  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v5 = 0;
  if ( (a3 & 0x8000u) == 0 && (signed __int16)a3 < (signed int)*(_WORD *)(v11 + 1860) )
  {
    v5 = 2;
    if ( !*(_DWORD *)(v11 + 1872) || *(_BYTE *)(*(_DWORD *)(v11 + 1872) + (signed __int16)a3) )
      v5 = 1;
  }
  if ( v5 )
  {
    v10 = (unsigned __int16)(a3 - *(_WORD *)(v11 + 44) + 1);
    if ( v10 <= 0 )
      v10 = 0;
    if ( (*(_WORD *)(*(_DWORD *)(v11 + 1852) + 4) & 0x3E0) >> 5 )
      v4 = (*(_WORD *)(*(_DWORD *)(v11 + 1852) + 4) & 0x3E0) >> 5;
    else
      LOBYTE(v4) = 10;
    if ( v10 >= (unsigned __int8)v4 + 1 )
      v10 = (unsigned __int8)v4 + 1;
    sub_10005590(a1, (int)&v6, a3, v10, 1);
    *(_DWORD *)a2 = v6;
    *(_DWORD *)(a2 + 4) = v7;
    *(_DWORD *)(a2 + 8) = v8;
    *(_DWORD *)(a2 + 12) = v9;
  }
  return v5;
}

//----- (10005830) --------------------------------------------------------
void __cdecl sub_10005830(unsigned int a1)
{
  __int16 v1; // [sp+4h] [bp-30h]@6
  int v2; // [sp+8h] [bp-2Ch]@6
  __int16 v3; // [sp+Ch] [bp-28h]@6
  __int16 v4; // [sp+Eh] [bp-26h]@6
  int v5; // [sp+10h] [bp-24h]@6
  int v6; // [sp+14h] [bp-20h]@1
  __int16 v7; // [sp+18h] [bp-1Ch]@12
  int v8; // [sp+1Ch] [bp-18h]@12
  __int16 v9; // [sp+20h] [bp-14h]@12
  __int16 v10; // [sp+24h] [bp-10h]@8
  int v11; // [sp+28h] [bp-Ch]@8
  __int16 v12; // [sp+2Ch] [bp-8h]@1
  int v13; // [sp+30h] [bp-4h]@1

  v13 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4);
  v12 = *(_WORD *)(v13 + 42);
  if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) != 33 )
    *(_BYTE *)(a1 + 6) = sub_10070780(a1, *(char **)(a1 + 56), *(_WORD **)(a1 + 52));
  switch ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) )
  {
    case 0x21:
      if ( !*(_DWORD *)(v13 + 1872) || *(_BYTE *)(*(_DWORD *)(v13 + 1872) + *(_WORD *)(v13 + 42)) )
      {
        v2 = v6;
        v1 = -32687;
        v4 = *(_WORD *)(v13 + 42);
        v3 = *(_WORD *)(v13 + 1882);
        v5 = *(_DWORD *)(v13 + 1876);
        *(_WORD *)(*(_DWORD *)(v13 + 1856) + 2) = v4;
        sub_10002670(a1, (int)&v1, 16);
        sub_1006E380(a1, 1, 0, 0);
        *(_BYTE *)(a1 + 6) = 2;
      }
      break;
    case 0x20:
    case 0x28:
      v11 = v6;
      v10 = -32690;
      sub_10002670(a1, (int)&v10, 8);
      sub_1006E380(a1, 1, 0, 0);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x38:
    case 0x39:
      if ( v12 != *(_WORD *)(v13 + 42)
        && (!*(_DWORD *)(v13 + 1872) || *(_BYTE *)(*(_DWORD *)(v13 + 1872) + *(_WORD *)(v13 + 42))) )
      {
        v8 = v6;
        v7 = -32689;
        v9 = *(_WORD *)(v13 + 42);
        sub_10002670(a1, (int)&v7, 12);
      }
      *(_BYTE *)(a1 + 6) = 2;
      break;
    default:
      return;
  }
}

//----- (10005A20) --------------------------------------------------------
void __cdecl sub_10005A20(unsigned int a1)
{
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8041:
      byte_10165D7E = 0;
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x8050:
      sub_10005D70(a1);
      byte_10165D7E = 1;
      break;
    case 0x8022:
      sub_10005B60(a1);
      break;
    case 0x8048:
      *(_BYTE *)(a1 + 6) = 2;
      if ( byte_10165D7E )
        sub_10005BE0(a1);
      break;
    case 0x80AA:
      sub_10001000(a1);
      break;
    default:
      return;
  }
}
// 10165D7E: using guessed type char byte_10165D7E;

//----- (10005B60) --------------------------------------------------------
int __cdecl sub_10005B60(int a1)
{
  int v1; // ST1C_4@1
  int v2; // ST18_4@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60);
  sub_1006CED0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3000, (int)&unk_100C3010, 0, 255);
  LOBYTE(result) = sub_1006CED0(
                     a1,
                     *(_WORD **)(a1 + 52),
                     (char *)(v1 + 8),
                     v2,
                     0,
                     *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10005BE0) --------------------------------------------------------
void __cdecl sub_10005BE0(unsigned int a1)
{
  __int16 v1; // [sp+4h] [bp-30h]@4
  int v2; // [sp+8h] [bp-2Ch]@4
  __int16 v3; // [sp+Ch] [bp-28h]@4
  __int16 v4; // [sp+Eh] [bp-26h]@4
  int v5; // [sp+10h] [bp-24h]@4
  int v6; // [sp+14h] [bp-20h]@1
  __int16 v7; // [sp+18h] [bp-1Ch]@7
  int v8; // [sp+1Ch] [bp-18h]@7
  __int16 v9; // [sp+20h] [bp-14h]@7
  __int16 v10; // [sp+24h] [bp-10h]@5
  int v11; // [sp+28h] [bp-Ch]@5
  __int16 v12; // [sp+2Ch] [bp-8h]@1
  int v13; // [sp+30h] [bp-4h]@1

  v13 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4);
  v12 = *(_WORD *)(v13 + 46);
  if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) != 33 )
    *(_BYTE *)(a1 + 6) = sub_10070780(a1, *(char **)(a1 + 56), *(_WORD **)(a1 + 52));
  switch ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) )
  {
    case 0x21:
      v2 = v6;
      v1 = -32687;
      v4 = *(_WORD *)(v13 + 46);
      v3 = *(_WORD *)(v13 + 40);
      v5 = *(_DWORD *)(v13 + 116);
      **(_WORD **)(v13 + 100) = v4;
      sub_10002670(a1, (int)&v1, 16);
      sub_1006E380(a1, 1, 0, 0);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x20:
    case 0x28:
      v11 = v6;
      v10 = -32690;
      sub_10002670(a1, (int)&v10, 8);
      sub_1006E380(a1, 1, 0, 0);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x38:
    case 0x39:
      if ( v12 != *(_WORD *)(v13 + 46) )
      {
        v8 = v6;
        v7 = -32689;
        v9 = *(_WORD *)(v13 + 46);
        sub_10002670(a1, (int)&v7, 12);
      }
      break;
    default:
      return;
  }
}

//----- (10005D70) --------------------------------------------------------
void __cdecl sub_10005D70(unsigned int a1)
{
  void *v1; // ecx@4
  void *v2; // ecx@6
  void *v3; // ecx@8
  char v4; // [sp+3h] [bp-9h]@12
  _DWORD *v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v6 = sub_100024F0(a1, *(_DWORD *)(a1 + 56), 120, 1);
  v5 = *(_DWORD **)(*(_DWORD *)(a1 + 56) + 60);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4)
    && *(_DWORD *)(*(_DWORD *)(a1 + 52) + 28) == *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 4) + 8) )
  {
    *(_DWORD *)(v6 + 92) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
    *(_DWORD *)(v6 + 100) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12);
    *(_WORD *)(v6 + 96) = **(_WORD **)(v6 + 100);
    *(_DWORD *)(v6 + 116) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 24);
    if ( sub_100704E0((void *)v6) != 8
      && (v1 = (void *)(unsigned __int8)sub_100704E0(v1), v1 != (void *)2)
      && ((unsigned int)sub_100705C0(v1) & 3 || sub_10070580(v2) == 1)
      || (v3 = (void *)(unsigned __int8)sub_100704E0(v1), v3 == (void *)2)
      || sub_100704E0(v3) == 8 )
    {
      *(_DWORD *)(v6 + 112) = 4134;
    }
    else
    {
      *(_DWORD *)(v6 + 112) = 4134;
    }
    *(_BYTE *)(v6 + 110) = 0;
    *(_WORD *)(v6 + 104) = *(_WORD *)(*(_DWORD *)(v6 + 92) + 12);
    *(_BYTE *)(v6 + 111) = 0;
    *(_DWORD *)(v6 + 72) = 118;
    *(_DWORD *)(v6 + 80) = *(_DWORD *)(v6 + 112) | *(_DWORD *)(*(_DWORD *)(v6 + 92) + 4) & 0xC000;
    *(_BYTE *)(v6 + 76) = 0;
    *(_WORD *)(v6 + 84) = 0;
    *(_WORD *)(v6 + 88) = 0;
    *(_WORD *)(v6 + 90) = 0;
    sub_10006560(a1);
    v4 = 0;
    if ( *(_BYTE *)(*(_DWORD *)(v6 + 92) + 8) & 4 )
      v4 = 1;
    sub_100060C0(
      a1,
      (_WORD *)(v6 + 4),
      (_WORD *)(v6 + 6),
      (_WORD *)(v6 + 2),
      (_WORD *)v6,
      (_WORD *)(v6 + 104),
      *(_WORD *)(v6 + 106),
      (_WORD *)(v6 + 108),
      (unsigned __int8 *)(v6 + 111),
      1,
      v4,
      *(_DWORD *)(*(_DWORD *)(a1 + 52) + 16),
      *(_DWORD *)(*(_DWORD *)(a1 + 52) + 20));
    sub_100061F0(a1);
    sub_10001870(a1, *(_WORD *)(v6 + 4), *(_WORD *)(v6 + 6), *(_WORD *)(v6 + 2), *(_WORD *)v6, 0);
    sub_100706B0(*(_DWORD *)(a1 + 56), (char *)(v6 + 8));
    *v5 = v6 + 44;
    *(_DWORD *)(v6 + 56) = 0;
    *(_WORD *)(v6 + 48) = *(_WORD *)(v6 + 96);
    *(_WORD *)(v6 + 46) = *(_WORD *)(v6 + 96);
    *(_DWORD *)(v6 + 60) = v6 + 64;
    *(_WORD *)(v6 + 52) = *(_WORD *)(*(_DWORD *)(v6 + 92) + 12);
    *(_WORD *)(v6 + 40) = *(_WORD *)(v6 + 46);
    sub_100068D0(a1, v6 + 64, *(_WORD *)(v6 + 96));
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 0;
    sub_100025D0(a1, *(_DWORD *)(a1 + 56), -32734);
    sub_1006CDB0(
      a1,
      &unk_100E462C,
      *(char ***)(*(_DWORD *)(a1 + 56) + 56),
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
      0,
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
    *(_BYTE *)(a1 + 9) = 1;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 247) = 1;
    sub_10070780(a1, *(char **)(*(_DWORD *)(a1 + 56) + 4), &unk_100E461C);
    *(_BYTE *)(a1 + 6) = 2;
  }
  else
  {
    sub_1006E380(a1, 1, 0, 0);
    *(_BYTE *)(a1 + 6) = 2;
  }
}

//----- (100060C0) --------------------------------------------------------
__int16 __cdecl sub_100060C0(int a1, _WORD *a2, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, __int16 a7, _WORD *a8, unsigned __int8 *a9, char a10, char a11, int a12, int a13)
{
  __int16 result; // ax@4
  __int16 v14; // [sp+0h] [bp-28h]@1
  int v15; // [sp+4h] [bp-24h]@1
  char v16; // [sp+Bh] [bp-1Dh]@1
  __int16 v17; // [sp+Ch] [bp-1Ch]@1
  __int16 v18; // [sp+Eh] [bp-1Ah]@1
  __int16 v19; // [sp+10h] [bp-18h]@1
  __int16 v20; // [sp+12h] [bp-16h]@1
  int v21; // [sp+14h] [bp-14h]@2
  int v22; // [sp+18h] [bp-10h]@2
  __int16 v23; // [sp+1Ch] [bp-Ch]@1
  __int16 v24; // [sp+20h] [bp-8h]@1
  __int16 v25; // [sp+24h] [bp-4h]@1

  v23 = 0;
  v14 = 0;
  v24 = 0;
  v25 = 0;
  v16 = 0;
  v15 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4);
  v18 = *(_WORD *)(v15 + 30);
  v20 = *(_WORD *)(v15 + 34) + *(_WORD *)(v15 + 30);
  v17 = *(_WORD *)(v15 + 28);
  v19 = *(_WORD *)(v15 + 32) + *(_WORD *)(v15 + 28);
  if ( a10 )
  {
    v21 = a12;
    v22 = a13;
  }
  else
  {
    v21 = 0;
    v22 = 0;
    v16 = 3;
  }
  sub_100066D0(a1, (int)&v21, (int)&v17, a6, a7, &v14, &v25, &v16, a9, a11);
  sub_10006350(a1, (int)&v21, (int)&v17, a8, &v23, &v24, &v16, *a9, a11);
  *a4 = v23;
  *a5 = v14;
  *a2 = v24;
  result = v25;
  *a3 = v25;
  return result;
}

//----- (100061F0) --------------------------------------------------------
int __cdecl sub_100061F0(int a1)
{
  int result; // eax@8
  int v2; // [sp+0h] [bp-18h]@3
  unsigned int v3; // [sp+4h] [bp-14h]@1
  signed __int16 v4; // [sp+Ch] [bp-Ch]@1
  int *v5; // [sp+10h] [bp-8h]@1
  int v6; // [sp+14h] [bp-4h]@1

  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v5 = sub_1006D000(*(_DWORD *)(v6 + 112));
  v3 = (sub_1006D920(*(_DWORD *)(v6 + 112), 0) & 0xFF0000u) >> 16;
  v4 = 0;
  if ( *(_BYTE *)(v6 + 111) )
    v4 = 64;
  *(_WORD *)(v6 + 84) = *(_WORD *)(v6 + 108) - 2;
  *(_DWORD *)(v6 + 8) = 122;
  *(_WORD *)(v6 + 12) = v4;
  *(_WORD *)(v6 + 14) = 8;
  *(_DWORD *)(v6 + 16) = v6 + 72;
  *(_DWORD *)(v6 + 20) = sub_10006940;
  *(_WORD *)(v6 + 24) = *(_WORD *)(v6 + 104);
  *(_WORD *)(v6 + 26) = *(_WORD *)(v6 + 106) + 1;
  *(_WORD *)(v6 + 28) = 0;
  v2 = *(_DWORD *)(*(_DWORD *)(v6 + 92) + 4) & 0xC000;
  if ( v2 )
  {
    if ( v2 == 0x8000 )
      *(_WORD *)(v6 + 32) = *(_WORD *)(v6 + 84) / 2 + 15;
    else
      *(_WORD *)(v6 + 32) = *(_WORD *)(v6 + 84) + 14;
  }
  else
  {
    *(_WORD *)(v6 + 32) = 15;
  }
  result = v6;
  *(_WORD *)(v6 + 34) = v3 + *(_WORD *)(*v5 + 24) + 17 - *(_WORD *)(*v5 + 26) - 1;
  *(_DWORD *)(v6 + 36) = 141;
  return result;
}

//----- (10006350) --------------------------------------------------------
_WORD *__cdecl sub_10006350(int a1, int a2, int a3, _WORD *a4, _WORD *a5, _WORD *a6, _BYTE *a7, unsigned __int8 a8, char a9)
{
  int v9; // ST08_4@21
  _WORD *result; // eax@24
  __int16 v11; // [sp+4h] [bp-34h]@22
  int v12; // [sp+18h] [bp-20h]@1
  char v13; // [sp+1Fh] [bp-19h]@11
  __int16 v14; // [sp+20h] [bp-18h]@3
  int v15; // [sp+24h] [bp-14h]@4
  __int16 v16; // [sp+28h] [bp-10h]@1
  __int16 v17; // [sp+2Ch] [bp-Ch]@1
  int v18; // [sp+30h] [bp-8h]@3
  __int16 v19; // [sp+34h] [bp-4h]@1

  v12 = *a4 + 6 * a8 + 28;
  v16 = *(_WORD *)(a1 + 16);
  v19 = 0;
  v17 = *(_WORD *)(a1 + 16);
  if ( a9 )
  {
    v16 = *(_WORD *)(a3 + 4) - *(_WORD *)a3 + 1;
    v19 = *(_WORD *)a3;
    v17 = *(_WORD *)(a3 + 4);
  }
  v14 = *(_WORD *)a2;
  v18 = v12 - v16;
  if ( v12 - v16 <= 0 )
  {
    do
    {
      if ( *a7 <= 1u )
      {
        LOWORD(v15) = v14 + 2;
        if ( v12 + v14 + 2 > v17 )
        {
          LOWORD(v15) = v17 - v12;
          if ( v17 - v12 <= v19 )
            LOWORD(v15) = v19;
        }
        v13 = 1;
      }
      else if ( *a7 == 2 )
      {
        v13 = 1;
        v15 = *(_WORD *)(a2 + 4) + 2;
        if ( v12 + v15 > v17 )
        {
          v15 = *(_WORD *)a2 - 2 - v12;
          if ( v15 < v19 )
          {
            v13 = 0;
            *a7 = 3;
          }
        }
      }
      else
      {
        v15 = (v16 - v12) / 2 + v19;
        if ( v12 + v15 > v17 )
        {
          v15 = v16 + v19 - v12;
          if ( v15 <= v19 )
            LOWORD(v15) = v19;
        }
        v13 = 1;
      }
    }
    while ( !v13 );
  }
  else
  {
    v12 -= v18;
    *a4 -= v18;
    LOWORD(v15) = v19;
  }
  v9 = *(_WORD *)(a2 + 4) - *(_WORD *)a2 - 1;
  if ( v12 - 1 <= v9 )
    v11 = *(_WORD *)(a2 + 4) - *(_WORD *)a2 - 1;
  else
    v11 = v12 - 1;
  *a5 = v11;
  result = a6;
  *a6 = v15;
  return result;
}

//----- (10006560) --------------------------------------------------------
int __cdecl sub_10006560(int a1)
{
  int result; // eax@13
  int v2; // [sp+0h] [bp-44h]@11
  __int16 v3; // [sp+Ch] [bp-38h]@7
  __int16 v4; // [sp+18h] [bp-2Ch]@4
  __int16 v5; // [sp+24h] [bp-20h]@3
  __int16 v6; // [sp+28h] [bp-1Ch]@3
  __int16 v7; // [sp+2Ah] [bp-1Ah]@3
  __int16 v8; // [sp+2Ch] [bp-18h]@3
  __int16 v9; // [sp+2Eh] [bp-16h]@3
  __int16 v10; // [sp+30h] [bp-14h]@3
  int i; // [sp+34h] [bp-10h]@1
  char v12; // [sp+38h] [bp-Ch]@3
  int v13; // [sp+40h] [bp-4h]@1

  v13 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_WORD *)(v13 + 106) = 0;
  *(_WORD *)(v13 + 108) = 0;
  for ( i = 0; i < *(_WORD *)(*(_DWORD *)(v13 + 92) + 12); ++i )
  {
    sub_100068D0(a1, (int)&v12, i);
    sub_1006CD30(a1, (char *)(v13 + 72), (int)&v12, &v6);
    v10 = v9 - v7 + 1;
    v5 = v8 - v6 + 1;
    if ( *(_WORD *)(v13 + 106) <= v10 )
      v4 = v9 - v7 + 1;
    else
      v4 = *(_WORD *)(v13 + 106);
    *(_WORD *)(v13 + 106) = v4;
    if ( *(_WORD *)(v13 + 108) <= v5 )
      v3 = v5;
    else
      v3 = *(_WORD *)(v13 + 108);
    *(_WORD *)(v13 + 108) = v3;
  }
  if ( *(_WORD *)(v13 + 108) <= *(_WORD *)(*(_DWORD *)(a1 + 52) + 20)
                              - *(_WORD *)(*(_DWORD *)(a1 + 52) + 16)
                              - (6 * *(_BYTE *)(v13 + 111)
                               + 28) )
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 20)
       - *(_WORD *)(*(_DWORD *)(a1 + 52) + 16)
       - (6 * *(_BYTE *)(v13 + 111)
        + 28);
  else
    LOWORD(v2) = *(_WORD *)(v13 + 108);
  result = v13;
  *(_WORD *)(v13 + 108) = v2;
  return result;
}

//----- (100066D0) --------------------------------------------------------
int __cdecl sub_100066D0(int a1, int a2, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, char a10)
{
  int v10; // ST0C_4@10
  int v11; // ST3C_4@22
  int result; // eax@35
  __int16 v13; // [sp+8h] [bp-3Ch]@11
  __int16 v14; // [sp+1Ch] [bp-28h]@7
  signed int v15; // [sp+20h] [bp-24h]@5
  int v16; // [sp+24h] [bp-20h]@19
  __int16 v17; // [sp+28h] [bp-1Ch]@7
  int v18; // [sp+2Ch] [bp-18h]@0
  char v19; // [sp+33h] [bp-11h]@7
  int v20; // [sp+34h] [bp-10h]@16
  __int16 v21; // [sp+38h] [bp-Ch]@9
  signed int v22; // [sp+40h] [bp-4h]@2

  if ( (signed int)*a4 <= 4 )
    v22 = *a4;
  else
    v22 = 4;
  if ( (signed int)*a4 <= 10 )
    v15 = *a4;
  else
    v15 = 10;
  v19 = 0;
  v14 = *(_WORD *)(a1 + 14) - 1;
  v17 = 0;
  if ( a10 )
  {
    v14 = *(_WORD *)(a3 + 6);
    v17 = *(_WORD *)(a3 + 2);
  }
  v21 = v14 - v17 + 1;
  if ( *(_DWORD *)(a1 + 64) != 1 )
  {
    v10 = *(_WORD *)(a1 + 14) - 26;
    if ( v14 >= v10 )
      v13 = *(_WORD *)(a1 + 14) - 26;
    else
      v13 = v14;
    v14 = v13;
  }
  do
  {
    *a9 = 0;
    if ( *a4 > v15 )
      *a9 = 1;
    v20 = v15 * (a5 + 1) + 33;
    if ( *a8 )
    {
      if ( *a8 == 1 )
      {
        v11 = *(_WORD *)(a2 + 2) - 2 - v20 + 1;
        if ( v11 >= v17 )
        {
          LOWORD(v18) = *(_WORD *)(a2 + 2) - 2 - v20 + 1;
          v19 = 1;
        }
      }
      else if ( v20 <= v21 )
      {
        v18 = (v21 - v20) / 2 + v17;
        v19 = 1;
      }
    }
    else
    {
      v16 = *(_WORD *)(a2 + 6) + v20 + 2;
      if ( v16 <= v14 )
      {
        v18 = v16 - v20 + 2;
        v19 = 1;
      }
    }
    if ( !v19 )
    {
      if ( v15 > v22 )
      {
        --v15;
      }
      else
      {
        if ( (signed int)*a4 <= 10 )
          v15 = *a4;
        else
          v15 = 10;
        ++*a8;
      }
    }
  }
  while ( !v19 );
  HIWORD(result) = HIWORD(a6);
  *a6 = v20;
  LOWORD(result) = v18;
  *a7 = v18;
  *a4 = v15;
  return result;
}

//----- (100068D0) --------------------------------------------------------
int __cdecl sub_100068D0(int a1, int a2, unsigned __int16 a3)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  result = v5;
  v4 = *(_DWORD *)(v5 + 92);
  if ( *(_BYTE *)(v4 + 8) & 1 )
  {
    if ( (*(_BYTE *)(v4 + 8) & 1) == 1 )
    {
      *(_BYTE *)(a2 + 4) = 1;
      result = a2;
      *(_WORD *)a2 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 92) + 16) + 2 * a3);
    }
  }
  else
  {
    *(_BYTE *)(a2 + 4) = 0;
    result = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 92) + 16) + 4 * a3);
    *(_DWORD *)a2 = result;
  }
  return result;
}

//----- (10006940) --------------------------------------------------------
bool __cdecl sub_10006940(int a1, int a2, unsigned __int16 a3)
{
  bool v4; // [sp+0h] [bp-14h]@3
  int v5; // [sp+8h] [bp-Ch]@6
  int v6; // [sp+Ch] [bp-8h]@6
  int v7; // [sp+10h] [bp-4h]@1

  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v4 = (a3 & 0x8000u) == 0 && (signed __int16)a3 <= *(_WORD *)(*(_DWORD *)(v7 + 92) + 12) - 1;
  if ( v4 )
  {
    sub_100068D0(a1, (int)&v5, a3);
    *(_DWORD *)a2 = v5;
    *(_DWORD *)(a2 + 4) = v6;
  }
  return v4;
}

//----- (100069C0) --------------------------------------------------------
void sub_100069C0()
{
  __int16 v0; // [sp+0h] [bp-D8h]@2

  if ( dword_10658DFC )
  {
    *((_DWORD *)dword_10658DFC + 196613) = sub_1009B2D0();
    memset(&v0, 0, 0xCCu);
    v0 = -32735;
    sub_10006B00((int)&v0, 8, 0);
  }
}

//----- (10006A30) --------------------------------------------------------
void sub_10006A30()
{
  dword_10658DFC = 0;
}

//----- (10006A40) --------------------------------------------------------
int sub_10006A40()
{
  return sub_1009B3F0(82, 20000);
}

//----- (10006A60) --------------------------------------------------------
bool sub_10006A60()
{
  bool v1; // [sp+1h] [bp-3h]@11
  bool v2; // [sp+2h] [bp-2h]@5

  if ( !dword_10658DFC )
    dword_10658DFC = (void *)-15;
  v2 = (unsigned int)dword_10658DFC >= 0xFFFFFFC2 || !dword_10658DFC;
  if ( v2 )
  {
    sub_1009C220((LONG)&off_100C357C);
    sub_1009BDB0((int)&off_100C357C);
  }
  v1 = (unsigned int)dword_10658DFC >= 0xFFFFFFC2 || !dword_10658DFC;
  if ( dword_10658DFC == (void *)-15 )
    dword_10658DFC = 0;
  return v1 == 0;
}
// 100C357C: using guessed type char *off_100C357C;

//----- (10006B00) --------------------------------------------------------
int __cdecl sub_10006B00(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-18h]@1
  int v5; // [sp+4h] [bp-14h]@1
  int v6; // [sp+8h] [bp-10h]@1
  int v7; // [sp+Ch] [bp-Ch]@1
  int v8; // [sp+10h] [bp-8h]@1
  int v9; // [sp+14h] [bp-4h]@1

  *(_DWORD *)(a1 + 4) = 0;
  v6 = 0;
  v8 = 1;
  v4 = a1;
  v5 = a2;
  v7 = 1000;
  v9 = 21;
  if ( a3 )
  {
    v9 = sub_1009B480(4, (int)&v4);
  }
  else if ( dword_10658DFC
         && *((_DWORD *)dword_10658DFC + 196612) < 0x40u
         && *((_DWORD *)dword_10658DFC + 196612)
         && *((_BYTE *)dword_10658DFC + 786445) )
  {
    v9 = sub_1009B480(*((_DWORD *)dword_10658DFC + 196612), (int)&v4);
  }
  return v9;
}

//----- (10006BC0) --------------------------------------------------------
void __cdecl sub_10006BC0(int a1)
{
  if ( !a1 )
    sub_1009B3D0(82);
}

//----- (10006BE0) --------------------------------------------------------
char *sub_10006BE0()
{
  char *v1; // [sp+0h] [bp-8h]@3
  unsigned int i; // [sp+4h] [bp-4h]@1

  for ( i = 0; i < 4; ++i )
  {
    v1 = off_100C3B2C[i];
    if ( sub_1009BCE0((int)off_100C3B2C[i]) )
      return v1;
  }
  return 0;
}
// 100C3B2C: using guessed type char *off_100C3B2C[4];

//----- (10006C30) --------------------------------------------------------
int __cdecl sub_10006C30(int a1)
{
  sub_100096A0(a1);
  if ( *(_DWORD *)(a1 + 8) && *(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) )
  {
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 230) = -1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 68) = 0;
  }
  sub_100A43E0(*(_DWORD *)(a1 + 12));
  *(_DWORD *)(a1 + 12) = 0;
  return sub_10053EA0(dword_10658DF8, &unk_10165D80);
}

//----- (10006CA0) --------------------------------------------------------
int __cdecl sub_10006CA0(int a1)
{
  int v1; // edx@1
  int v3; // [sp+4h] [bp-D0h]@34
  int v4; // [sp+8h] [bp-CCh]@34
  int v5; // [sp+10h] [bp-C4h]@31
  int v6; // [sp+14h] [bp-C0h]@27
  int v7; // [sp+18h] [bp-BCh]@1
  signed int v8; // [sp+20h] [bp-B4h]@1
  signed int j; // [sp+24h] [bp-B0h]@21
  signed int i; // [sp+28h] [bp-ACh]@1
  int v11; // [sp+2Ch] [bp-A8h]@1
  int v12; // [sp+34h] [bp-A0h]@1
  __int16 v13; // [sp+C4h] [bp-10h]@1
  __int16 v14; // [sp+C6h] [bp-Eh]@1
  int v15; // [sp+D0h] [bp-4h]@12

  memset(&v11, 0, 0x9Cu);
  v1 = a1 + 18;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 28) = 0;
  v11 = a1;
  v12 = 0;
  v13 = *(_WORD *)(a1 + 4);
  v14 = *(_WORD *)(a1 + 6);
  *(_BYTE *)(a1 + 16) = 0;
  v7 = *(_DWORD *)(a1 + 12);
  v8 = 0;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 68) = 0;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 246) = 1;
  for ( i = 0; i < 20; ++i )
  {
    dword_10165DD8[3 * i] = 121;
    byte_10165DE0[12 * i] = i;
    dword_10165DDC[3 * i] = a1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 64) + i) = 3;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 56) + 4 * i) = &dword_10165DD8[3 * i];
  }
  sub_100096A0(a1);
  while ( v7 && v8 < 4 )
  {
    *(_BYTE *)(a1 + 16) = v8 + 1;
    v14 = *(_WORD *)(a1 + 6);
    *(_WORD *)(a1 + 8 * v8 + 18) = v14;
    *(_WORD *)(a1 + 8 * v8 + 20) = v13;
    *(_WORD *)(a1 + 8 * v8 + 24) = *(_WORD *)a1 - (v13 - *(_WORD *)(a1 + 4));
    *(_WORD *)(a1 + 8 * v8 + 22) = *(_WORD *)(a1 + 2);
    if ( *(_WORD *)(a1 + 8 * v8 + 24) > (signed int)*(_WORD *)a1 )
    {
      *(_WORD *)(a1 + 8 * v8 + 24) = *(_WORD *)a1;
      break;
    }
    if ( v8 >= 2 )
    {
      *(_WORD *)(a1 + 8 * v8 + 16) = *(_WORD *)(a1 + 8 * v8 + 20);
      if ( *(_WORD *)(a1 + 8 * v8 + 16) > (signed int)*(_WORD *)a1 )
      {
        *(_WORD *)(a1 + 8 * v8 + 16) = *(_WORD *)a1;
        break;
      }
    }
    v13 = 0;
    v15 = sub_100A4710(29, *(_DWORD *)v7);
    if ( v15 )
    {
      v15 = *(_DWORD *)(v15 + 28);
      if ( v15 )
        v15 = sub_100A4710(6, v15);
      if ( v15 )
      {
        sub_10007560((int)&v11, v15);
        v15 = *(_DWORD *)(v15 + 28);
      }
      else
      {
        v15 = sub_100A4710(29, *(_DWORD *)v7);
        v15 = *(_DWORD *)(v15 + 28);
        v15 = sub_100A4710(23, v15);
      }
    }
    if ( !v15 && !*(_DWORD *)(v7 + 72) )
      sub_100076F0((int)&v11, "Error with file\n");
    for ( j = 0; j < 5; ++j )
    {
      if ( *(_DWORD *)(v7 + 4 * j + 72) )
        sub_100076F0((int)&v11, *(void **)(v7 + 4 * j + 72));
    }
    while ( v15 )
    {
      v14 = *(_WORD *)(a1 + 6);
      sub_10007560((int)&v11, v15);
      v6 = *(_DWORD *)(v15 + 16) - 16;
      if ( v6 == *(_DWORD *)(*(_DWORD *)(v15 + 24) + 28) )
        v6 = 0;
      v15 = v6;
    }
    v13 += *(_WORD *)(a1 + 8 * v8 + 20);
    *(_DWORD *)(v7 + 12) &= 0xFFFFFFFD;
    if ( v7 == *(_DWORD *)(a1 + 12) )
    {
      v5 = 0;
      if ( *(_DWORD *)(v7 + 96) != v7 + 96 )
        v5 = *(_DWORD *)(v7 + 96) - 104;
      v7 = v5;
    }
    else
    {
      v3 = 0;
      v4 = *(_DWORD *)(v7 + 104);
      if ( v4 != *(_DWORD *)(v7 + 92) + 96 )
        v3 = v4 - 104;
      v7 = v3;
    }
    ++v8;
  }
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 230) >= (signed int)*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56)
                                                                                       + 68) )
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 230) = -1;
  return 0;
}
// 10165DD8: using guessed type int dword_10165DD8[];
// 10165DDC: using guessed type int dword_10165DDC[];

//----- (100071C0) --------------------------------------------------------
int __cdecl sub_100071C0(void *a1, int a2)
{
  signed int v2; // ecx@0
  signed int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  sub_10053EA0(dword_10658DF8, &unk_10165DAC);
  *(_DWORD *)(a2 + 12) = sub_100A3A00((int)&off_100C41B8, 1);
  if ( *(_DWORD *)(a2 + 12) )
    v4 = sub_100A48F0(*(_DWORD *)(a2 + 12), a1, 256);
  if ( !v4 )
  {
    v4 = sub_100A4F40(*(int **)(a2 + 12));
    if ( v4 )
    {
      sub_100A43E0(*(_DWORD *)(a2 + 12));
      *(_DWORD *)(a2 + 12) = 0;
    }
    else
    {
      v4 = sub_10006CA0(a2);
    }
  }
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 56) + 230) = -1;
  return v4;
}
// 100C41B8: using guessed type int (__cdecl *off_100C41B8)(int, int);

//----- (10007270) --------------------------------------------------------
int __cdecl sub_10007270(int a1, int a2, _WORD *a3, unsigned __int8 a4)
{
  int result; // eax@1
  bool v5; // [sp+2h] [bp-2Eh]@14
  bool v6; // [sp+3h] [bp-2Dh]@10
  int v7; // [sp+4h] [bp-2Ch]@17
  char v8; // [sp+13h] [bp-1Dh]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  signed int v10; // [sp+18h] [bp-18h]@1
  __int16 v11; // [sp+1Ch] [bp-14h]@1
  __int16 v12; // [sp+1Eh] [bp-12h]@1
  __int16 v13; // [sp+20h] [bp-10h]@1
  __int16 v14; // [sp+22h] [bp-Eh]@1
  int v15; // [sp+24h] [bp-Ch]@1
  signed int v16; // [sp+28h] [bp-8h]@1
  _BYTE *v17; // [sp+2Ch] [bp-4h]@4

  v9 = *(_DWORD *)(a1 + 8);
  v8 = *(_BYTE *)(*(_DWORD *)(v9 + 56) + 24);
  v11 = *(_WORD *)(*(_DWORD *)(v9 + 56) + 28);
  v12 = *(_WORD *)(*(_DWORD *)(v9 + 56) + 30);
  v14 = *(_WORD *)(*(_DWORD *)(v9 + 56) + 34);
  result = *(_DWORD *)(v9 + 56);
  v13 = *(_WORD *)(result + 32);
  v15 = a2;
  v16 = 0;
  v10 = -1;
  while ( v15 && v16 < 300000 )
  {
    v17 = (_BYTE *)(v15 + 8);
    if ( v10 != *(_BYTE *)v15 )
    {
      v10 = *(_BYTE *)v15;
      *(_WORD *)(*(_DWORD *)(v9 + 56) + 28) = *(_WORD *)(a1 + 8 * v10 + 18);
      *(_WORD *)(*(_DWORD *)(v9 + 56) + 30) = *(_WORD *)(a1 + 8 * v10 + 20);
      *(_WORD *)(*(_DWORD *)(v9 + 56) + 34) = *(_WORD *)(a1 + 8 * v10 + 24);
      *(_WORD *)(*(_DWORD *)(v9 + 56) + 32) = *(_WORD *)(a1 + 8 * v10 + 22);
      *(_BYTE *)(*(_DWORD *)(v9 + 56) + 24) |= 1u;
      sub_10001B10(v9, *(_DWORD *)(v9 + 56));
    }
    if ( *v17 || *a3 == 32833 )
    {
      v6 = v16 == a4 && sub_10070610(v9, a3, *(_DWORD *)(v9 + 56));
      *(_BYTE *)(v9 + 3) = v6;
      v5 = v16 == a4 && *(_DWORD *)(v9 + 56) == *(_DWORD *)(*(_DWORD *)(v9 + 48) + 4);
      *(_BYTE *)(v9 + 9) = v5;
      sub_100075B0(v9, (int)v17, (int)a3);
    }
    v7 = *(_DWORD *)(v15 + 40) - 40;
    if ( v7 == a2 )
      v7 = 0;
    result = v7;
    v15 = v7;
    ++v16;
  }
  if ( v10 != -1 )
  {
    *(_BYTE *)(*(_DWORD *)(v9 + 56) + 24) = v8;
    *(_WORD *)(*(_DWORD *)(v9 + 56) + 28) = v11;
    *(_WORD *)(*(_DWORD *)(v9 + 56) + 30) = v12;
    *(_WORD *)(*(_DWORD *)(v9 + 56) + 34) = v14;
    result = *(_DWORD *)(v9 + 56);
    *(_WORD *)(result + 32) = v13;
  }
  return result;
}

//----- (100074B0) --------------------------------------------------------
char __cdecl sub_100074B0(int a1, int a2, int a3, int a4, int a5)
{
  return sub_10009A80(*(_DWORD *)(a2 + 4), a5, *(_BYTE *)(a2 + 8));
}

//----- (100074D0) --------------------------------------------------------
char __cdecl sub_100074D0(int a1, _WORD *a2)
{
  int v3; // [sp+0h] [bp-8h]@2
  char v4; // [sp+7h] [bp-1h]@1

  v4 = 1;
  if ( *(_DWORD *)(a1 + 12) )
  {
    v3 = *a2;
    switch ( v3 )
    {
      case 32840:
        v4 = sub_10009A80(a1, (int)a2, *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 230));
        break;
      case 32849:
        sub_10009940(a1, (int)a2);
        break;
      case 32888:
        v4 = sub_10009A20(a1);
        break;
    }
  }
  return v4;
}

//----- (10007560) --------------------------------------------------------
int __cdecl sub_10007560(int a1, int a2)
{
  int v3; // [sp+0h] [bp-8h]@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v3 = -31;
  v4 = sub_10009720(a2);
  if ( v4 <= 4 )
    v3 = (*(&off_100C4158 + 2 * v4))(a1, a2);
  return v3;
}
// 100C4158: using guessed type int (__cdecl *off_100C4158)(int, int);

//----- (100075B0) --------------------------------------------------------
char __cdecl sub_100075B0(int a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  char v6; // [sp+Fh] [bp-1h]@1

  v6 = 1;
  v5 = *(_DWORD *)(a2 + 8) & 0xFF;
  v4 = 0;
  switch ( v5 )
  {
    case 66:
      v4 = a2 + 12;
      break;
    case 118:
      v4 = a2 + 24;
      break;
    case 76:
      v4 = a2 + 16;
      break;
    case 82:
      v4 = a2 + 16;
      break;
    case 105:
      v4 = *(_DWORD *)(a2 + 20);
      break;
    case 107:
      v4 = a2 + 20;
      break;
    case 110:
      v4 = a2 + 28;
      break;
    case 124:
      v4 = *(_DWORD *)(a2 + 24);
      break;
    default:
      break;
  }
  if ( v4 )
    v6 = ((int (__cdecl *)(int, int, int, int, int))dword_1068B040[2 * v5])(a1, a2 + 8, a2 + 2, v4, a3);
  return v6;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (100076F0) --------------------------------------------------------
__int16 __cdecl sub_100076F0(int a1, void *a2)
{
  void *v2; // eax@2
  unsigned int v4; // [sp+0h] [bp-1Ch]@1
  void *v5; // [sp+18h] [bp-4h]@4

  v4 = strlen((const char *)a2);
  if ( !*(_BYTE *)(a1 + *(_BYTE *)(*(_DWORD *)a1 + 16) + 3) )
  {
    v2 = sub_10009860(*(_DWORD *)a1, 0, *(_DWORD *)a1 + 52);
    if ( !v2 )
      return (unsigned int)v2;
    *((_DWORD *)v2 + 4) = 66;
    *((_WORD *)v2 + 5) = 0;
    *((_WORD *)v2 + 6) = 0;
    *((_BYTE *)v2 + 8) = 2;
    *((_BYTE *)v2 + 20) = 1;
    *(_BYTE *)(a1 + *(_BYTE *)(*(_DWORD *)a1 + 16) + 3) = 1;
  }
  v2 = sub_10009860(*(_DWORD *)a1, v4 + 1, *(_DWORD *)a1 + 52);
  v5 = v2;
  if ( v2 )
  {
    memcpy((char *)v2 + 48, a2, v4 + 1);
    *(_WORD *)(a1 + 152) += 20;
    *(_WORD *)(a1 + 154) += *(_WORD *)(*(_DWORD *)a1 + 6);
    *((_DWORD *)v5 + 4) = 105;
    *((_WORD *)v5 + 5) = *(_WORD *)(a1 + 154);
    *((_WORD *)v5 + 6) = *(_WORD *)(a1 + 152);
    *((_BYTE *)v5 + 8) = 2;
    *((_DWORD *)v5 + 5) = 4134;
    *((_DWORD *)v5 + 7) = (char *)v5 + 48;
    *((_WORD *)v5 + 13) = v4;
    *((_WORD *)v5 + 12) = 0;
    LOWORD(v2) = sub_1006D630(*((_BYTE **)v5 + 7), *((_DWORD *)v5 + 5));
    *((_WORD *)v5 + 12) = (_WORD)v2;
  }
  return (unsigned int)v2;
}

//----- (100078A0) --------------------------------------------------------
signed int __cdecl sub_100078A0(int *a1, int a2)
{
  signed int v3; // [sp+0h] [bp-8h]@1
  _DWORD *v4; // [sp+4h] [bp-4h]@1

  v3 = 0;
  v4 = sub_10009860(*a1, 0, *a1 + 52);
  if ( v4 )
  {
    v4[4] = 66;
    *((_WORD *)v4 + 5) = 0;
    *((_WORD *)v4 + 6) = 0;
    *((_BYTE *)v4 + 8) = 2;
    *((_BYTE *)v4 + 20) = 1;
    sub_10007930((int)v4, (int)a1, a2);
    *((_BYTE *)a1 + *(_BYTE *)(*a1 + 16) + 3) = 1;
  }
  else
  {
    v3 = -26;
  }
  return v3;
}

//----- (10007930) --------------------------------------------------------
int __cdecl sub_10007930(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // [sp+4h] [bp-20h]@21
  int v5; // [sp+8h] [bp-1Ch]@11
  int v6; // [sp+Ch] [bp-18h]@1
  _DWORD *v7; // [sp+10h] [bp-14h]@1
  char v8; // [sp+17h] [bp-Dh]@11
  signed int v9; // [sp+18h] [bp-Ch]@1
  int v10; // [sp+1Ch] [bp-8h]@4
  int v11; // [sp+20h] [bp-4h]@9

  v9 = 0;
  v7 = (_DWORD *)sub_10009770(a1);
  result = sub_100A4F90(*(_DWORD *)(*(_DWORD *)(a3 + 32) + 24), *(_BYTE *)(a3 + 2), 0);
  v6 = result;
  while ( !v9 )
  {
    if ( !v6 )
    {
      v10 = sub_100A46E0(8, 0, *(_DWORD *)(a3 + 40));
      if ( v10 && *(_DWORD *)(v10 + 8) )
        v6 = sub_100A4F90(*(_DWORD *)(*(_DWORD *)(a3 + 32) + 24), *(_BYTE *)(a3 + 2), *(const char **)(v10 + 8));
      v9 = 1;
    }
    if ( v6 )
      v11 = *(_DWORD *)(v6 + 8);
    else
      v11 = 0;
    result = v11;
    v5 = v11;
    v8 = 0;
    while ( v11 || !v8 )
    {
      if ( v11 )
      {
        switch ( *(_BYTE *)v11 )
        {
          case 0:
          case 1:
            sub_10007AD0(a1, v11);
            break;
          case 3:
            sub_10007D30(v7, v11);
            break;
          case 2:
            sub_10007D30(v7, v11);
            break;
          case 4:
            sub_10007DB0(a1, v11);
            break;
          default:
            break;
        }
        result = *(_DWORD *)(v11 + 8) - 8;
        v4 = *(_DWORD *)(v11 + 8) - 8;
        if ( v4 == v5 )
          v4 = 0;
        v11 = v4;
      }
      else
      {
        result = *(_DWORD *)(a3 + 44);
        v11 = *(_DWORD *)(a3 + 44);
        v5 = *(_DWORD *)(a3 + 44);
        v8 = 1;
      }
    }
    v6 = 0;
  }
  return result;
}

//----- (10007AD0) --------------------------------------------------------
int __cdecl sub_10007AD0(int a1, int a2)
{
  int v2; // ST10_4@8
  int result; // eax@8
  char v4; // t1@9
  char v5; // t1@10
  _DWORD *v6; // [sp+8h] [bp-8h]@1
  char v7; // [sp+Fh] [bp-1h]@1

  v6 = (_DWORD *)sub_10009770(a1);
  v7 = sub_1006E3A0(*(_BYTE *)(a2 + 4), *(_BYTE *)(a2 + 3), *(_BYTE *)(a2 + 2));
  if ( (signed int)(unsigned __int8)v7 > 19 )
  {
    if ( *(_BYTE *)a2 == 1 )
      v7 = 1;
    else
      v7 = 6;
  }
  if ( *(_BYTE *)a2 == 1 )
  {
    if ( v6 )
    {
      *v6 &= 0xFFFFFC1F;
      *v6 |= 32 * (unsigned __int8)v7 & 0x3E0;
    }
    v2 = *(_DWORD *)(a1 + 16);
    result = v2 - 66;
    switch ( v2 )
    {
      case 66:
        v4 = *(_BYTE *)(a1 + 20);
        *(_BYTE *)(a1 + 20) = 0;
        result = a1;
        *(_BYTE *)(a1 + 20) |= v7;
        break;
      case 82:
        v5 = *(_BYTE *)(a1 + 24);
        *(_BYTE *)(a1 + 24) = 0;
        result = a1;
        *(_BYTE *)(a1 + 24) |= v7;
        break;
      case 105:
        *(_DWORD *)(a1 + 20) &= 0xFFFFFC1F;
        result = a1;
        *(_DWORD *)(a1 + 20) |= 32 * (unsigned __int8)v7 & 0x3E0;
        break;
      case 107:
        *(_DWORD *)(a1 + 20) &= 0xFFFFFC1F;
        result = a1;
        *(_DWORD *)(a1 + 20) |= 32 * (unsigned __int8)v7 & 0x3E0;
        break;
      case 110:
        *(_WORD *)(a1 + 24) &= 0xFC1Fu;
        result = 32 * (unsigned __int8)v7 & 0x3E0 | *(_WORD *)(a1 + 24);
        *(_WORD *)(a1 + 24) = result;
        break;
      default:
        return result;
    }
  }
  else
  {
    if ( v6 )
    {
      *v6 &= 0xFFFFFFE0;
      *v6 |= v7 & 0x1F;
    }
    result = *(_DWORD *)(a1 + 16);
    if ( *(_DWORD *)(a1 + 16) == 110 )
    {
      *(_WORD *)(a1 + 24) &= 0xFFE0u;
      result = v7 & 0x1F | *(_WORD *)(a1 + 24);
      *(_WORD *)(a1 + 24) = result;
    }
  }
  return result;
}

//----- (10007D30) --------------------------------------------------------
_DWORD *__cdecl sub_10007D30(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@4
  unsigned int i; // [sp+0h] [bp-4h]@1

  for ( i = 0; i < 9; ++i )
  {
    if ( *(_BYTE *)(a2 + 2) == (unsigned __int8)byte_100C40F0[12 * i] )
    {
      *a1 &= ~dword_100C40E8[3 * i];
      result = a1;
      *a1 |= dword_100C40E8[3 * i] & dword_100C40EC[3 * i];
      return result;
    }
    result = (_DWORD *)(i + 1);
  }
  return result;
}
// 100C40E8: using guessed type int dword_100C40E8[];
// 100C40EC: using guessed type int dword_100C40EC[];

//----- (10007DB0) --------------------------------------------------------
__int16 __cdecl sub_10007DB0(int a1, int a2)
{
  int v2; // eax@1
  int *v3; // edx@3
  signed int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@3

  LOWORD(v2) = a2;
  v5 = *(_WORD *)(a2 + 2);
  if ( v5 <= 1024 )
  {
    v2 = *(_DWORD *)(a1 + 16);
    switch ( *(_DWORD *)(a1 + 16) )
    {
      case 0x4C:
        v3 = *(int **)(a1 + 28);
        v2 = *v3;
        v6 = *v3;
        if ( *v3 && *(_DWORD *)v6 == 105 )
        {
          LOWORD(v2) = v5;
          *(_WORD *)(v6 + 8) = v5;
        }
        break;
      case 0x52:
        *(_WORD *)(a1 + 20) = v5;
        break;
      case 0x6B:
        LOWORD(v2) = a1;
        *(_WORD *)(a1 + 24) = v5;
        break;
      case 0x69:
        LOWORD(v2) = v5;
        *(_WORD *)(a1 + 24) = v5;
        break;
      case 0x76:
        *(_WORD *)(a1 + 28) = v5;
        break;
      case 0x6E:
        LOWORD(v2) = a1;
        *(_WORD *)(a1 + 20) = v5;
        break;
      case 0x7C:
        LOWORD(v2) = v5;
        *(_WORD *)(a1 + 24) = v5;
        break;
      default:
        return v2;
    }
  }
  return v2;
}

//----- (10007ED0) --------------------------------------------------------
int __cdecl sub_10007ED0(int a1)
{
  if ( *(_DWORD *)(a1 + 8) <= 0 )
  {
    *(_WORD *)(a1 + 152) += 30;
  }
  else
  {
    *(_WORD *)(a1 + 152) += *(_WORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = 0;
  }
  *(_WORD *)(a1 + 154) = 0;
  return 0;
}

//----- (10007F40) --------------------------------------------------------
signed int __cdecl sub_10007F40(int a1, int a2)
{
  __int16 v2; // ax@55
  __int16 v3; // ax@89
  int *v4; // ecx@91
  int *v5; // edx@91
  int *v6; // edx@96
  int *v7; // ecx@97
  int *v8; // edx@97
  int *v9; // eax@97
  char *v11; // [sp+70h] [bp-CCh]@107
  int v12; // [sp+74h] [bp-C8h]@104
  signed int v13; // [sp+80h] [bp-BCh]@79
  const char *v14; // [sp+84h] [bp-B8h]@66
  signed int v15; // [sp+88h] [bp-B4h]@66
  int v16; // [sp+8Ch] [bp-B0h]@57
  signed int v17; // [sp+9Ch] [bp-A0h]@51
  size_t v18; // [sp+A0h] [bp-9Ch]@44
  int v19; // [sp+A4h] [bp-98h]@30
  signed int i; // [sp+B0h] [bp-8Ch]@89
  int v21; // [sp+B4h] [bp-88h]@64
  signed int v22; // [sp+B8h] [bp-84h]@64
  signed int v23; // [sp+BCh] [bp-80h]@1
  int v24; // [sp+CCh] [bp-70h]@27
  __int16 v25; // [sp+D0h] [bp-6Ch]@27
  void *v26; // [sp+D4h] [bp-68h]@7
  int v27; // [sp+D8h] [bp-64h]@1
  void *v28; // [sp+DCh] [bp-60h]@3
  size_t v29; // [sp+E0h] [bp-5Ch]@39
  _DWORD *v30; // [sp+E4h] [bp-58h]@1
  int v31; // [sp+E8h] [bp-54h]@64
  int v32; // [sp+ECh] [bp-50h]@85
  void *v33; // [sp+F0h] [bp-4Ch]@25
  size_t v34; // [sp+F4h] [bp-48h]@25
  int v35; // [sp+F8h] [bp-44h]@1
  char v36; // [sp+FFh] [bp-3Dh]@7
  int v37; // [sp+100h] [bp-3Ch]@96
  int v38; // [sp+104h] [bp-38h]@96
  int v39; // [sp+108h] [bp-34h]@96
  int **v40; // [sp+10Ch] [bp-30h]@85
  char *v41; // [sp+110h] [bp-2Ch]@14
  int v42; // [sp+114h] [bp-28h]@3
  int v43; // [sp+118h] [bp-24h]@64
  char *v44; // [sp+11Ch] [bp-20h]@5
  char *v45; // [sp+120h] [bp-1Ch]@27
  char *v46; // [sp+124h] [bp-18h]@63
  void *v47; // [sp+128h] [bp-14h]@23
  char *v48; // [sp+12Ch] [bp-10h]@5
  void *v49; // [sp+130h] [bp-Ch]@1
  int v50; // [sp+134h] [bp-8h]@27
  void *v51; // [sp+138h] [bp-4h]@40

  v27 = 0;
  v23 = 0;
  v30 = 0;
  v49 = 0;
  v35 = 0;
  if ( a2 && *(_DWORD *)(a2 + 28) )
  {
    v28 = 0;
    v42 = sub_100A46E0(0, 0, *(_DWORD *)(a2 + 40));
    if ( v42 )
      v28 = *(void **)(v42 + 8);
    v48 = *(char **)(*(_DWORD *)(a2 + 28) + 28);
    v44 = v48;
    while ( v48 )
    {
      v36 = v48[2];
      v26 = 0;
      v42 = sub_100A46E0(31, 0, *((_DWORD *)v48 + 10));
      if ( v42 )
        v26 = *(void **)(v42 + 8);
      switch ( v36 )
      {
        case 7:
          sub_10007ED0(a1);
          *(_WORD *)(a1 + 152) += 3;
          *(_WORD *)(a1 + 154) += 5;
          break;
        case 32:
          v41 = (char *)sub_1000F380((int)v48);
          if ( !v41 )
            sub_10070AD0(".\\cdp_utl_xhtml.c", 1850, 0, 0);
          if ( v41 )
          {
            if ( sub_1006FC30(v41, "submit", strlen(v41) + 1) )
            {
              if ( !sub_1006FC30(v41, "text", strlen(v41) + 1) )
              {
                if ( !v27 )
                {
                  *(_WORD *)(a1 + 152) += 8;
                  *(_WORD *)(a1 + 154) += 5;
                }
                ++v27;
                v34 = sub_1000F1F0(v48);
                if ( (signed int)v34 <= 0 )
                  v34 = 20;
                if ( (signed int)v34 > 4096 )
                  v29 = 20;
                v51 = (void *)sub_1000F310((int)v48);
                if ( !v51 )
                {
                  if ( v26 )
                    v51 = v26;
                  else
                    v51 = &unk_100C4192;
                }
                v18 = 0;
                if ( v51 )
                  v18 = strlen((const char *)v51);
                v49 = sub_10009860(*(_DWORD *)a1, v18 + 1, *(_DWORD *)a1 + 52);
                if ( !v49 )
                  return -26;
                v45 = (char *)v49 + 48;
                memcpy((char *)v49 + 48, v51, v18);
                v45[v18] = 0;
                *((_DWORD *)v49 + 4) = 110;
                *((_WORD *)v49 + 5) = *(_WORD *)(a1 + 154);
                *((_WORD *)v49 + 6) = *(_WORD *)(a1 + 152);
                *((_BYTE *)v49 + 8) = 2;
                *((_WORD *)v49 + 11) = 30;
                *((_BYTE *)v49 + 32) = 3;
                *((_WORD *)v49 + 12) = 2095;
                *((_DWORD *)v49 + 7) = 2095;
                *((_DWORD *)v49 + 9) = v45;
                *((_WORD *)v49 + 10) = 0;
                v33 = sub_10009860(*(_DWORD *)a1, v34 + 1, *(_DWORD *)a1 + 56);
                if ( !v33 )
                  return -26;
                v47 = (void *)sub_1000F3F0((int)v48);
                v45 = (char *)v33 + 48;
                memset((char *)v33 + 48, 0, v34 + 1);
                if ( v47 )
                {
                  v17 = strlen((const char *)v47);
                  if ( v17 >= (signed int)v34 )
                    memcpy(v45, v47, v34);
                  else
                    memcpy(v45, v47, v17);
                }
                v25 = sub_1006DC60("X", 36902, *(_WORD *)(dword_1068B510 + 30), (int)&v24, (int)&v50);
                *((_DWORD *)v33 + 4) = 105;
                *((_WORD *)v33 + 5) = *(_WORD *)(a1 + 154) + 5;
                *((_WORD *)v33 + 6) = *(_WORD *)(a1 + 152) + 25;
                *((_BYTE *)v33 + 8) = 2;
                *((_DWORD *)v33 + 5) = 2095;
                *((_DWORD *)v33 + 7) = v45;
                *((_WORD *)v33 + 13) = v34;
                *((_WORD *)v33 + 12) = 0;
                *((_DWORD *)v33 + 1) = v48;
                sub_10007930((int)v49, a1, (int)v48);
                sub_10007930((int)v33, a1, (int)v48);
                if ( !*((_WORD *)v33 + 12) )
                {
                  v2 = sub_1006D630("X", *((_DWORD *)v33 + 5));
                  *((_WORD *)v33 + 12) = v34 * v2;
                  *((_WORD *)v49 + 10) = *((_WORD *)v33 + 12);
                }
                *((_WORD *)v49 + 10) = *((_WORD *)v33 + 12) + 12;
                *(_WORD *)(a1 + 154) += *((_WORD *)v49 + 10) + 8;
                if ( v25 / 2 + *((_WORD *)v49 + 11) <= *(_DWORD *)(a1 + 8) )
                  v16 = *(_DWORD *)(a1 + 8);
                else
                  v16 = v25 / 2 + *((_WORD *)v49 + 11);
                *(_DWORD *)(a1 + 8) = v16;
              }
            }
            else
            {
              if ( v28 )
              {
                v42 = sub_100A46E0(41, 0, *((_DWORD *)v48 + 10));
                if ( !v42 )
                  sub_100A4370((int)v48, 41, v28);
              }
              if ( !v27 )
              {
                *(_WORD *)(a1 + 152) += 8;
                *(_WORD *)(a1 + 154) += 5;
              }
              v47 = (void *)sub_1000F3F0((int)v48);
              if ( !v47 )
                v47 = v41;
              v34 = strlen((const char *)v47);
              ++v27;
              v33 = sub_10009860(*(_DWORD *)a1, v34 + 1, *(_DWORD *)a1 + 56);
              if ( !v33 )
                return -26;
              v45 = (char *)v33 + 48;
              memcpy((char *)v33 + 48, v47, v34);
              v45[v34] = 0;
              v25 = sub_1006DC60(v45, 36902, *(_WORD *)(dword_1068B510 + 30), (int)&v24, (int)&v50);
              *((_DWORD *)v33 + 4) = 118;
              *((_WORD *)v33 + 5) = *(_WORD *)(a1 + 154);
              *((_WORD *)v33 + 6) = (v25 + 12) / 2 + *(_WORD *)(a1 + 152);
              *((_BYTE *)v33 + 8) = 2;
              *((_DWORD *)v33 + 6) = 36902;
              *((_DWORD *)v33 + 8) = v45;
              *((_BYTE *)v33 + 36) = 0;
              *((_WORD *)v33 + 14) = 0;
              *((_BYTE *)v33 + 20) = 1;
              *((_DWORD *)v33 + 1) = v48;
              sub_10007930((int)v33, a1, (int)v48);
              if ( !*((_WORD *)v33 + 14) )
                *((_WORD *)v33 + 14) = sub_1006D630(v45, *((_DWORD *)v33 + 6));
              *((_WORD *)v33 + 5) += *((_WORD *)v33 + 14) / 2 + 8;
              *(_WORD *)(a1 + 154) += *((_WORD *)v33 + 14) + 26;
              if ( v25 + 12 <= *(_DWORD *)(a1 + 8) )
                v19 = *(_DWORD *)(a1 + 8);
              else
                v19 = v25 + 12;
              *(_DWORD *)(a1 + 8) = v19;
            }
          }
          break;
        case 50:
          if ( !v27 )
          {
            *(_WORD *)(a1 + 152) += 8;
            *(_WORD *)(a1 + 154) += 5;
          }
          v46 = v48;
          ++v27;
          if ( *((_DWORD *)v48 + 7) )
          {
            v21 = sub_100A4710(42, *((_DWORD *)v46 + 7));
            v43 = 0;
            v35 = 0;
            v34 = 0;
            v31 = 0;
            v22 = 0;
            v30 = 0;
            while ( v21 )
            {
              v14 = *(const char **)(v21 + 8);
              v15 = 0;
              if ( v14 )
                v15 = strlen(v14);
              v29 = v15;
              if ( v15 > 4096 )
                v29 = 10;
              if ( v22 )
              {
                if ( !v30 )
                {
                  v51 = (void *)sub_1000ED30((int)v46);
                  if ( !v51 )
                  {
                    if ( v26 )
                      v51 = v26;
                    else
                      v51 = &unk_100C4192;
                  }
                  v13 = 0;
                  if ( v51 )
                    v13 = strlen((const char *)v51);
                  if ( v13 > (signed int)v34 )
                    v31 = sub_1006D630(v51, 0x82Fu);
                  v49 = sub_10009860(*(_DWORD *)a1, v13 + 1, *(_DWORD *)a1 + 52);
                  if ( !v49 )
                    return -26;
                  v45 = (char *)v49 + 48;
                  memcpy((char *)v49 + 48, v51, v13);
                  v45[v13] = 0;
                  *((_DWORD *)v49 + 4) = 110;
                  *((_WORD *)v49 + 5) = *(_WORD *)(a1 + 154);
                  *((_WORD *)v49 + 6) = *(_WORD *)(a1 + 152);
                  *((_BYTE *)v49 + 8) = 2;
                  *((_WORD *)v49 + 11) = 30;
                  *((_BYTE *)v49 + 32) = 3;
                  *((_WORD *)v49 + 12) = 2095;
                  *((_DWORD *)v49 + 7) = 2095;
                  *((_DWORD *)v49 + 9) = v45;
                  *((_WORD *)v49 + 10) = v31 + 12;
                  v40 = (int **)sub_100034E0(*(_DWORD *)(*(_DWORD *)a1 + 8), 16 * v35);
                  v32 = sub_100034E0(*(_DWORD *)(*(_DWORD *)a1 + 8), 4 * v35);
                  v30 = sub_10009860(*(_DWORD *)a1, 0, *(_DWORD *)a1 + 56);
                  if ( !v30 || !v32 || !v40 )
                    return -26;
                  v30[4] = 76;
                  *((_WORD *)v30 + 5) = *(_WORD *)(a1 + 154) + 5;
                  *((_WORD *)v30 + 6) = *(_WORD *)(a1 + 152) + 25;
                  *((_BYTE *)v30 + 8) = 2;
                  *((_WORD *)v30 + 10) = 8;
                  *((_WORD *)v30 + 12) = v35;
                  v3 = sub_1000EDA0((int)v46);
                  *((_WORD *)v30 + 13) = v3;
                  v30[7] = v40;
                  v30[8] = v32;
                  v30[9] = 0;
                  v30[1] = v46;
                  *v40 = (int *)&v40[v35];
                  **v40 = 105;
                  (*v40)[1] = 4134;
                  *((_WORD *)*v40 + 4) = 0;
                  *((_WORD *)*v40 + 5) = v34;
                  sub_10007930((int)v49, a1, (int)v46);
                  sub_10007930((int)v30, a1, (int)v46);
                  for ( i = 1; i < v35; ++i )
                  {
                    v40[i] = v40[i - 1] + 3;
                    v4 = v40[i - 1];
                    v5 = v40[i];
                    *v5 = *v4;
                    v5[1] = v4[1];
                    v5[2] = v4[2];
                  }
                  if ( *((_WORD *)v49 + 10) == *((_WORD *)*v40 + 4) )
                    *((_WORD *)v49 + 10) += 12;
                }
                *(_DWORD *)(v32 + 4 * v43) = sub_100034E0(*(_DWORD *)(*(_DWORD *)a1 + 8), v29 + 1);
                if ( !*(_DWORD *)(v32 + 4 * v43) )
                {
                  v23 = -26;
                  *((_WORD *)v30 + 12) = 0;
                  return v23;
                }
                memcpy(*(void **)(v32 + 4 * v43), *(const void **)(v21 + 8), v29);
                *(_BYTE *)(*(_DWORD *)(v32 + 4 * v43) + v29) = 0;
                v6 = *v40;
                v37 = **v40;
                v38 = v6[1];
                v39 = v6[2];
                sub_10007930((int)v30, a1, v21);
                if ( v43 )
                {
                  v7 = *v40;
                  v8 = v40[v43];
                  *v8 = **v40;
                  v8[1] = v7[1];
                  v8[2] = v7[2];
                  v9 = *v40;
                  *v9 = v37;
                  v9[1] = v38;
                  v9[2] = v39;
                }
              }
              else
              {
                ++v35;
                if ( (signed int)v29 > (signed int)v34 )
                {
                  v34 = v29;
                  v31 = sub_1006D630(*(_BYTE **)(v21 + 8), 0x82Fu);
                }
              }
              ++v43;
              v21 = sub_100A4640(v21, 42);
              if ( !v21 && !v22 )
              {
                v43 = 0;
                v22 = 1;
                v21 = sub_100A4710(42, *((_DWORD *)v46 + 7));
              }
            }
          }
          if ( v49 )
          {
            *(_WORD *)(a1 + 154) += *((_WORD *)v49 + 10) + 8;
            if ( *((_WORD *)v49 + 11) + 8 <= *(_DWORD *)(a1 + 8) )
              v12 = *(_DWORD *)(a1 + 8);
            else
              v12 = *((_WORD *)v49 + 11) + 8;
            *(_DWORD *)(a1 + 8) = v12;
          }
          break;
      }
      v11 = (char *)(*((_DWORD *)v48 + 4) - 16);
      if ( v11 == v44 )
        v11 = 0;
      v48 = v11;
    }
  }
  if ( *(_DWORD *)(a1 + 8) > 0 )
  {
    *(_WORD *)(a1 + 154) = 0;
    *(_WORD *)(a1 + 152) += *(_WORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = 0;
  }
  return v23;
}
// 1068B510: using guessed type int dword_1068B510;

//----- (10008F80) --------------------------------------------------------
signed int __cdecl sub_10008F80(int a1, int a2)
{
  signed int result; // eax@2
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  v3 = sub_10009860(*(_DWORD *)a1, 0, *(_DWORD *)a1 + 52);
  if ( v3 )
  {
    *(_WORD *)(a1 + 154) = 0;
    ++*(_WORD *)(a1 + 152);
    v3[4] = 82;
    *((_WORD *)v3 + 5) = *(_WORD *)(a1 + 154);
    *((_WORD *)v3 + 6) = *(_WORD *)(a1 + 152);
    *((_BYTE *)v3 + 8) = 2;
    *((_BYTE *)v3 + 24) = 32;
    *((_WORD *)v3 + 11) = *(_WORD *)(a1 + 152);
    *((_WORD *)v3 + 10) = *(_WORD *)(*(_DWORD *)a1 + 2) - *(_WORD *)(*(_DWORD *)a1 + 6);
    sub_10007930((int)v3, a1, a2);
    *(_WORD *)(a1 + 152) += 2;
    result = 0;
  }
  else
  {
    result = -26;
  }
  return result;
}

//----- (10009080) --------------------------------------------------------
signed int __cdecl sub_10009080(int a1, int a2)
{
  __int32 v2; // ecx@55
  int v4; // [sp+10h] [bp-54h]@60
  int v5; // [sp+14h] [bp-50h]@34
  int v6; // [sp+18h] [bp-4Ch]@28
  void *v7; // [sp+1Ch] [bp-48h]@39
  int v8; // [sp+20h] [bp-44h]@6
  int v9; // [sp+20h] [bp-44h]@41
  int v10; // [sp+24h] [bp-40h]@1
  int v11; // [sp+28h] [bp-3Ch]@22
  int v12; // [sp+2Ch] [bp-38h]@6
  signed int v13; // [sp+30h] [bp-34h]@9
  void *v14; // [sp+34h] [bp-30h]@1
  int v15; // [sp+34h] [bp-30h]@39
  int v16; // [sp+38h] [bp-2Ch]@1
  signed int v17; // [sp+38h] [bp-2Ch]@39
  int v18; // [sp+3Ch] [bp-28h]@23
  __int32 v19; // [sp+3Ch] [bp-28h]@54
  int v20; // [sp+40h] [bp-24h]@22
  char *v21; // [sp+44h] [bp-20h]@46
  int v22; // [sp+48h] [bp-1Ch]@44
  void *v23; // [sp+4Ch] [bp-18h]@1
  int v24; // [sp+50h] [bp-14h]@22
  int v25; // [sp+54h] [bp-10h]@39
  int v26; // [sp+58h] [bp-Ch]@39
  __int32 v27; // [sp+5Ch] [bp-8h]@44
  int v28; // [sp+60h] [bp-4h]@3

  v23 = 0;
  v14 = 0;
  v10 = 0;
  v16 = 0;
  memset((void *)(a1 + 92), 0, 0x3Cu);
  memset((void *)(a1 + 12), 0, 0x50u);
  if ( a2 && *(_DWORD *)(a2 + 28) )
  {
    v28 = sub_100A4710(63, *(_DWORD *)(a2 + 28));
    while ( v28 )
    {
      if ( *(_DWORD *)(v28 + 28) )
      {
        v8 = sub_100A4710(58, *(_DWORD *)(v28 + 28));
        v12 = 0;
        while ( v8 )
        {
          if ( *(_DWORD *)(v8 + 8) )
          {
            v13 = strlen(*(const char **)(v8 + 8));
            if ( v13 > 4096 )
              v13 = 4096;
          }
          else
          {
            v13 = 0;
          }
          v14 = sub_10009860(*(_DWORD *)a1, v13 + 1, *(_DWORD *)a1 + 52);
          if ( !v14 )
            return -26;
          *((_DWORD *)v14 + 1) = v8;
          *((_DWORD *)v14 + 4) = 124;
          *((_WORD *)v14 + 5) = v16;
          *((_WORD *)v14 + 6) = v12;
          *((_BYTE *)v14 + 8) = 2;
          *((_DWORD *)v14 + 5) = 4134;
          *((_BYTE *)v14 + 31) = 0;
          *((_BYTE *)v14 + 30) = 2;
          *((_DWORD *)v14 + 8) = 0;
          *((_WORD *)v14 + 13) = v13;
          *((_WORD *)v14 + 12) = 0;
          *((_WORD *)v14 + 14) = 0;
          if ( !v23 )
            v23 = v14;
          *((_DWORD *)v14 + 8) = (char *)v14 + 48;
          memcpy(*((void **)v14 + 8), *(const void **)(v8 + 8), v13);
          *(_BYTE *)(*((_DWORD *)v14 + 8) + v13) = 0;
          sub_10007930((int)v14, a1, v8);
          if ( !*((_WORD *)v14 + 12) )
            *((_WORD *)v14 + 12) = sub_1006D630(*((_BYTE **)v14 + 8), *((_DWORD *)v14 + 5));
          if ( *((_WORD *)v14 + 12) > (signed int)*(_WORD *)(a1 + 2 * v12 + 92)
            && !sub_100A46E0(11, 0, *(_DWORD *)(v8 + 40)) )
          {
            *(_WORD *)(a1 + 2 * v12 + 92) = *((_WORD *)v14 + 12);
          }
          v11 = sub_1006DC60(*((char **)v14 + 8), *((_DWORD *)v14 + 5), *((_BYTE *)v14 + 30), (int)&v24, (int)&v20);
          if ( v20 == 1 )
          {
            v18 = sub_1006D630(*((_BYTE **)v14 + 8), *((_DWORD *)v14 + 5));
            if ( v18 > *((_WORD *)v14 + 12) )
              v11 = v24 * ((v18 + *((_WORD *)v14 + 12) - 1) / *((_WORD *)v14 + 12)) - *((_BYTE *)v14 + 30);
          }
          *((_WORD *)v14 + 14) = v11;
          if ( v11 > *(_WORD *)(a1 + 2 * v16 + 12) )
            *(_WORD *)(a1 + 2 * v16 + 12) = v11;
          ++v12;
          do
          {
            v6 = *(_DWORD *)(v8 + 16) - 16;
            if ( v6 == *(_DWORD *)(*(_DWORD *)(v8 + 24) + 28) )
              v6 = 0;
            v8 = v6;
          }
          while ( v6 && *(_BYTE *)(v6 + 2) != 58 );
        }
      }
      ++v16;
      do
      {
        v5 = *(_DWORD *)(v28 + 16) - 16;
        if ( v5 == *(_DWORD *)(*(_DWORD *)(v28 + 24) + 28) )
          v5 = 0;
        v28 = v5;
      }
      while ( v5 && *(_BYTE *)(v28 + 2) != 63 );
    }
  }
  v7 = v14;
  v15 = (int)v23;
  v25 = 0;
  v26 = -1;
  v17 = -1;
  *(_WORD *)(a1 + 154) = 0;
  ++*(_WORD *)(a1 + 152);
  while ( v15 )
  {
    v25 = *(_WORD *)(v15 + 12);
    v9 = *(_DWORD *)(v15 + 4);
    while ( v25 > v26 + 1 )
      *(_WORD *)(a1 + 154) += *(_WORD *)(a1 + 2 * ++v26 + 92);
    v22 = sub_100A46E0(11, 0, *(_DWORD *)(v9 + 40));
    v27 = 1;
    if ( v22 )
    {
      if ( *(_DWORD *)(v22 + 8) )
      {
        v21 = *(char **)(v22 + 8);
        v27 = j__atol(v21);
        if ( !v27 || v25 + v27 > 30 )
          v27 = 1;
      }
    }
    if ( *(_WORD *)(v15 + 10) != v17 )
    {
      v17 = *(_WORD *)(v15 + 10);
      *(_WORD *)(a1 + 154) = 8;
      if ( v17 >= 1 )
        *(_WORD *)(a1 + 152) += *(_WORD *)(a1 + 2 * v17 + 10);
      if ( (void *)v15 != v23 )
        ++*(_WORD *)(a1 + 152);
    }
    *(_WORD *)(v15 + 10) = *(_WORD *)(a1 + 154);
    *(_WORD *)(v15 + 12) = *(_WORD *)(a1 + 152);
    *(_WORD *)(v15 + 28) = *(_WORD *)(a1 + 2 * v17 + 12);
    v19 = v27;
    while ( 1 )
    {
      v2 = v19--;
      if ( !v2 )
        break;
      *(_WORD *)(a1 + 154) += *(_WORD *)(a1 + 2 * (v19 + v25) + 92) + 3;
      if ( v19 )
        *(_WORD *)(v15 + 24) += 3;
    }
    if ( (void *)v15 == v7 )
      break;
    v26 = v25;
    v4 = *(_DWORD *)(v15 + 40) - 40;
    if ( (void *)v4 == v23 )
      v4 = 0;
    v15 = v4;
  }
  if ( v17 >= 0 )
    *(_WORD *)(a1 + 152) += *(_WORD *)(a1 + 2 * v17 + 12);
  *(_WORD *)(a1 + 152) += 2;
  return v10;
}

//----- (100096A0) --------------------------------------------------------
int __cdecl sub_100096A0(int a1)
{
  int result; // eax@6
  int v2; // edx@7
  unsigned int v3; // [sp+0h] [bp-8h]@1
  signed int i; // [sp+4h] [bp-4h]@1

  v3 = -1;
  for ( i = 0; i < 3; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 52) )
    {
      if ( *(_DWORD *)(a1 + 4 * i + 52) < v3 )
      {
        v3 = *(_DWORD *)(a1 + 4 * i + 52);
        sub_10003450(0, v3);
      }
    }
    result = i + 1;
  }
  v2 = a1 + 52;
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  return result;
}

//----- (10009720) --------------------------------------------------------
unsigned int __cdecl sub_10009720(int a1)
{
  unsigned int i; // [sp+0h] [bp-8h]@1

  i = 5;
  if ( a1 )
  {
    for ( i = 0; i <= 4 && (unsigned __int8)byte_100C4154[8 * i] != *(_BYTE *)(a1 + 2); ++i )
      ;
  }
  return i;
}

//----- (10009770) --------------------------------------------------------
int __cdecl sub_10009770(int a1)
{
  int v2; // [sp+4h] [bp-8h]@1
  _DWORD *v3; // [sp+8h] [bp-4h]@2

  v2 = 0;
  switch ( *(_DWORD *)(a1 + 16) )
  {
    case 0x4C:
      v3 = **(_DWORD ***)(a1 + 28);
      if ( v3 && *v3 == 105 )
        v2 = (int)(v3 + 1);
      break;
    case 0x6B:
      v2 = a1 + 20;
      break;
    case 0x69:
      v2 = a1 + 20;
      break;
    case 0x76:
      v2 = a1 + 24;
      break;
    case 0x6E:
      v2 = a1 + 28;
      break;
    case 0x7C:
      v2 = a1 + 20;
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (10009860) --------------------------------------------------------
void *__cdecl sub_10009860(int a1, int a2, int a3)
{
  int v3; // ST0C_4@4
  int v4; // ST10_4@4
  _DWORD *v5; // ST14_4@4
  void *v7; // [sp+Ch] [bp-4h]@1

  v7 = (void *)sub_100034E0(*(_DWORD *)(a1 + 8), a2 + 48);
  if ( v7 )
  {
    memset(v7, 0, 0x30u);
    *((_DWORD *)v7 + 10) = (char *)v7 + 40;
    *((_DWORD *)v7 + 11) = (char *)v7 + 40;
    *(_BYTE *)v7 = *(_BYTE *)(a1 + 16) - 1;
    if ( *(_DWORD *)a3 )
    {
      v3 = *(_DWORD *)a3 + 40;
      v4 = (int)v7 + 40;
      v5 = *(_DWORD **)(*(_DWORD *)a3 + 44);
      *(_DWORD *)(v3 + 4) = (char *)v7 + 40;
      *(_DWORD *)v4 = v3;
      *(_DWORD *)(v4 + 4) = v5;
      *v5 = (char *)v7 + 40;
    }
    else
    {
      *(_DWORD *)a3 = v7;
    }
    if ( a1 + 56 == a3 )
      ++*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 68);
  }
  return v7;
}

//----- (10009940) --------------------------------------------------------
char __cdecl sub_10009940(int a1, int a2)
{
  int v3; // [sp+0h] [bp-4h]@1

  v3 = sub_100099A0(*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 230), *(_DWORD *)(a1 + 56));
  if ( v3 && *(_DWORD *)(v3 + 4) )
    sub_1000EDD0(*(_DWORD *)(v3 + 4), *(_WORD *)(a2 + 10), 1);
  return 2;
}

//----- (100099A0) --------------------------------------------------------
int __cdecl sub_100099A0(signed int a1, int a2)
{
  int v3; // [sp+0h] [bp-Ch]@5
  int v4; // [sp+4h] [bp-8h]@1
  signed int i; // [sp+8h] [bp-4h]@1

  v4 = a2;
  for ( i = 0; v4 && i < 300000 && i < a1; ++i )
  {
    v3 = *(_DWORD *)(v4 + 40) - 40;
    if ( v3 == a2 )
      v3 = 0;
    v4 = v3;
  }
  if ( i != a1 )
    v4 = 0;
  return v4;
}

//----- (10009A20) --------------------------------------------------------
char __cdecl sub_10009A20(int a1)
{
  sub_1009B2D0();
  sub_100A4490(*(void **)(a1 + 12));
  if ( *(_DWORD *)(a1 + 12)
    && sub_100A3A60(*(void **)(a1 + 12))
    && *(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) == *(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) )
  {
    sub_10006CA0(a1);
  }
  return 2;
}

//----- (10009A80) --------------------------------------------------------
char __cdecl sub_10009A80(int a1, int a2, signed int a3)
{
  char v4; // [sp+Bh] [bp-25h]@7
  int v5; // [sp+Ch] [bp-24h]@1
  signed int v6; // [sp+10h] [bp-20h]@7
  int v7; // [sp+14h] [bp-1Ch]@1
  __int16 v8; // [sp+18h] [bp-18h]@7
  __int16 v9; // [sp+1Ah] [bp-16h]@7
  __int16 v10; // [sp+1Ch] [bp-14h]@7
  __int16 v11; // [sp+1Eh] [bp-12h]@7
  char v12; // [sp+23h] [bp-Dh]@1
  int v13; // [sp+24h] [bp-Ch]@7
  int v14; // [sp+28h] [bp-8h]@7
  char v15; // [sp+2Fh] [bp-1h]@7

  v5 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(v5 + 56);
  v12 = 1;
  if ( !v7 )
    sub_10070AD0(".\\cdp_utl_xhtml.c", 3260, 1, 0);
  if ( (*(_BYTE *)(*(_DWORD *)(v5 + 56) + 26) || *(_DWORD *)(v5 + 56) != *(_DWORD *)(v5 + 48))
    && a3 >= 0
    && a3 < *(_BYTE *)(v7 + 68) )
  {
    v14 = *(_DWORD *)(v5 + 56);
    v15 = *(_BYTE *)(v5 + 3);
    *(_DWORD *)(v5 + 56) = v7;
    *(_BYTE *)(v5 + 3) = sub_10070610(v5, (_WORD *)a2, v7);
    v4 = *(_BYTE *)(*(_DWORD *)(v5 + 56) + 24);
    v8 = *(_WORD *)(*(_DWORD *)(v5 + 56) + 28);
    v9 = *(_WORD *)(*(_DWORD *)(v5 + 56) + 30);
    v11 = *(_WORD *)(*(_DWORD *)(v5 + 56) + 34);
    v10 = *(_WORD *)(*(_DWORD *)(v5 + 56) + 32);
    v13 = sub_100099A0(a3, *(_DWORD *)(a1 + 56));
    v6 = -1;
    if ( v13 )
    {
      v6 = *(_BYTE *)v13;
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 28) = *(_WORD *)(a1 + 8 * v6 + 18);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 30) = *(_WORD *)(a1 + 8 * v6 + 20);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) -= *(_WORD *)(a1 + 8 * v6 + 20);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) -= *(_WORD *)(a1 + 8 * v6 + 18);
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 24) |= 1u;
      sub_10001B10(v5, v7);
      v12 = sub_100075B0(v5, v13 + 8, a2);
      if ( *(_WORD *)(a2 + 10) == 33 && *(_DWORD *)(v13 + 16) == 118 )
      {
        v12 = 2;
        sub_1000F480(*(_DWORD *)(v13 + 4));
      }
      if ( *(_WORD *)(a2 + 10) == 33 && *(_DWORD *)(v13 + 16) == 105 )
        sub_1000F420(*(_DWORD *)(v13 + 4), *(void **)(v13 + 28), 1);
    }
    if ( v6 != 1 )
    {
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 24) = v4;
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 28) = v8;
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 30) = v9;
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) = v11;
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) = v10;
      sub_10001B10(v5, v7);
    }
    *(_DWORD *)(v5 + 56) = v14;
    *(_BYTE *)(v5 + 3) = v15;
  }
  return v12;
}

//----- (10009D20) --------------------------------------------------------
int sub_10009D20()
{
  int result; // eax@1

  result = dword_10658DF4;
  dword_10658DF8 = dword_10658DF4;
  dword_10165F48 = 0;
  return result;
}
// 10658DF4: using guessed type int dword_10658DF4;

//----- (10009D40) --------------------------------------------------------
signed int __cdecl sub_10009D40(int a1, int a2)
{
  signed int v3; // [sp+0h] [bp-4h]@3

  if ( dword_10165F48 )
  {
    sub_100726F0(dword_10165F48);
    dword_10165F48 = 0;
  }
  dword_10165F48 = &unk_10165EC8;
  v3 = sub_10072750(a1, 4, &unk_10165EC8, a2);
  if ( v3 )
  {
    dword_10165F48 = 0;
  }
  else
  {
    v3 = sub_10071AB0((int)dword_10165F48);
    if ( v3 )
    {
      sub_100726F0(dword_10165F48);
      dword_10165F48 = 0;
    }
  }
  return v3;
}

//----- (10009DE0) --------------------------------------------------------
int *__cdecl sub_10009DE0(int a1, unsigned int a2)
{
  int *result; // eax@1
  bool v3; // [sp+1h] [bp-1h]@3

  result = (int *)sub_1009BA60(a2);
  v3 = a2 >= 0xFFFFFFC2 || !a2;
  if ( !v3 && (a2 & 3) == 1 )
    result = sub_10009FE0(a1, a2 & 0xFFFFFFFC);
  return result;
}

//----- (10009E30) --------------------------------------------------------
unsigned int __cdecl sub_10009E30(int a1, char *a2, char a3)
{
  bool v4; // [sp+3h] [bp-45h]@14
  int v5; // [sp+4h] [bp-44h]@1
  char *v6; // [sp+8h] [bp-40h]@11
  unsigned int v7; // [sp+Ch] [bp-3Ch]@12
  int v8; // [sp+10h] [bp-38h]@1
  int v9; // [sp+14h] [bp-34h]@12
  int v10; // [sp+18h] [bp-30h]@12
  __int16 v11; // [sp+1Ch] [bp-2Ch]@12
  int v12; // [sp+24h] [bp-24h]@12
  __int16 v13; // [sp+28h] [bp-20h]@12
  char *v14; // [sp+2Ch] [bp-1Ch]@12
  int v15; // [sp+30h] [bp-18h]@12
  char *v16; // [sp+34h] [bp-14h]@12
  int v17; // [sp+38h] [bp-10h]@12
  int v18; // [sp+3Ch] [bp-Ch]@12
  char v19; // [sp+40h] [bp-8h]@12
  int v20; // [sp+44h] [bp-4h]@12

  v8 = 4;
  v5 = a3 & 7;
  switch ( v5 )
  {
    case 1:
      v8 = 4;
      break;
    case 2:
      v8 = 2;
      break;
    case 4:
      v8 = 6;
      break;
  }
  if ( a3 & 8 )
    v8 |= 8u;
  if ( dword_10165F48 )
  {
    v6 = (char *)sub_1000A000(a1, 0xBC28u);
    if ( v6 )
    {
      memset(&v9, 0, 0x34u);
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = v6 + 736;
      v15 = 512;
      v16 = v6 + 1248;
      v17 = 46920;
      v18 = 15;
      v19 = -2;
      v20 = 0xFFFF;
      v7 = sub_10073780((int)dword_10165F48, a2, v8, v6, (int)&v9);
      v4 = v7 >= 0xFFFFFFC2 || !v7;
      if ( v4 )
        sub_10009FE0(a1, (unsigned int)v6);
    }
    else
    {
      sub_10070AD0("..\\lib\\adl\\dom_prj.c", 363, 0, 0);
      v7 = -26;
    }
  }
  else
  {
    v7 = j_FIL_vfs_open(a2, v8, 0);
  }
  return v7;
}
// 1009BB30: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10009FB0) --------------------------------------------------------
signed int __cdecl sub_10009FB0(int a1, unsigned int a2, void *a3, int a4)
{
  return sub_1009BB40(a2, a3, a4);
}

//----- (10009FE0) --------------------------------------------------------
int *__cdecl sub_10009FE0(int a1, unsigned int a2)
{
  return sub_10053E10(a2, dword_10658DF8);
}

//----- (1000A000) --------------------------------------------------------
int __cdecl sub_1000A000(int a1, unsigned int a2)
{
  return sub_10053CF0(a2, dword_10658DF8);
}

//----- (1000A020) --------------------------------------------------------
void *__cdecl sub_1000A020(int a1, void *a2, unsigned int a3)
{
  return sub_10053FC0(a2, a3, dword_10658DF8);
}

//----- (1000A040) --------------------------------------------------------
int __cdecl sub_1000A040(int a1, char *a2, va_list a3)
{
  int result; // eax@1

  result = _vsnprintf(&byte_10165F50, 0x1F4u, a2, a3);
  if ( result < 0 || result == 500 )
    *(&byte_10165F50 + 499) = 0;
  return result;
}

//----- (1000A090) --------------------------------------------------------
char sub_1000A090()
{
  sub_1009DA30();
  return sub_1000A0C0(0);
}

//----- (1000A0C0) --------------------------------------------------------
char __cdecl sub_1000A0C0(char a1)
{
  return sub_1009DA90(a1, -122);
}

//----- (1000A0E0) --------------------------------------------------------
unsigned int sub_1000A0E0()
{
  unsigned int result; // eax@3
  unsigned int i; // [sp+0h] [bp-4h]@1

  for ( i = 0; i < 5; ++i )
  {
    sub_1000A4F0(i);
    result = i + 1;
  }
  return result;
}

//----- (1000A110) --------------------------------------------------------
int __cdecl sub_1000A110(int a1, int a2, char a3)
{
  char v4; // [sp+0h] [bp-14h]@2
  char v5; // [sp+1h] [bp-13h]@2
  int v6; // [sp+4h] [bp-10h]@2
  int v7; // [sp+Ch] [bp-8h]@2
  int v8; // [sp+10h] [bp-4h]@1

  v8 = sub_1000A260(a1);
  if ( v8 < 0 )
  {
    v7 = -15;
  }
  else
  {
    v7 = 0;
    v5 = a3;
    v4 = 1;
    v6 = a2;
    sub_1000A4A0(v8, &v4);
    LOWORD(dword_10172170[2 * v8]) = a2;
    BYTE2(dword_10172170[2 * v8]) = a3;
  }
  return v7;
}
// 10172170: using guessed type int dword_10172170[];

//----- (1000A1A0) --------------------------------------------------------
void *sub_1000A1A0()
{
  dword_10172170[0] = -1;
  dword_10172174[0] = -1;
  dword_10172178 = -1;
  dword_1017217C = -1;
  dword_10172180 = -1;
  dword_10172184 = -1;
  dword_10172188 = -1;
  dword_1017218C = -1;
  dword_10172190 = -1;
  dword_10172194 = -1;
  return memset(dword_10166148, -1, 0xC028u);
}
// 10166148: using guessed type int dword_10166148[];
// 10172170: using guessed type int dword_10172170[];
// 10172174: using guessed type int dword_10172174[];
// 10172178: using guessed type int dword_10172178;
// 1017217C: using guessed type int dword_1017217C;
// 10172180: using guessed type int dword_10172180;
// 10172184: using guessed type int dword_10172184;
// 10172188: using guessed type int dword_10172188;
// 1017218C: using guessed type int dword_1017218C;
// 10172190: using guessed type int dword_10172190;
// 10172194: using guessed type int dword_10172194;

//----- (1000A1F0) --------------------------------------------------------
int __cdecl sub_1000A1F0(int a1, int a2, char a3)
{
  char v4; // [sp+0h] [bp-14h]@2
  char v5; // [sp+1h] [bp-13h]@2
  int v6; // [sp+4h] [bp-10h]@2
  int v7; // [sp+Ch] [bp-8h]@2
  int v8; // [sp+10h] [bp-4h]@1

  v8 = sub_1000A260(a1);
  if ( v8 < 0 )
  {
    v7 = -15;
  }
  else
  {
    v7 = 0;
    v5 = a3;
    v4 = 2;
    v6 = a2;
    sub_1000A4A0(v8, &v4);
  }
  return v7;
}

//----- (1000A260) --------------------------------------------------------
signed int __cdecl sub_1000A260(int a1)
{
  signed int v2; // [sp+0h] [bp-8h]@1
  unsigned int i; // [sp+4h] [bp-4h]@1

  v2 = -1;
  for ( i = 0; i < 5; ++i )
  {
    if ( dword_100C5928[2 * i] == a1 )
      return i;
  }
  return v2;
}
// 100C5928: using guessed type int dword_100C5928[];

//----- (1000A2B0) --------------------------------------------------------
int __cdecl sub_1000A2B0(int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int v5; // [sp+0h] [bp-18h]@1
  signed int v6; // [sp+4h] [bp-14h]@1
  int v7; // [sp+8h] [bp-10h]@1
  unsigned __int8 v8; // [sp+Fh] [bp-9h]@6
  char v9; // [sp+10h] [bp-8h]@6
  signed int i; // [sp+10h] [bp-8h]@16
  unsigned int v11; // [sp+2Ch] [bp+14h]@6

  v6 = sub_1000A260(a1);
  v5 = 0;
  v7 = sub_1009B2D0();
  if ( v6 >= 0 && a2 < 8 && a3 <= 1 && a4 <= 0xFF && !sub_1009B3F0(34, 10000) )
  {
    v11 = (unsigned __int8)a4;
    v8 = 0;
    v9 = 7;
    while ( v11 )
    {
      if ( v11 & 1 )
        v8 |= 1 << v9;
      v11 >>= 1;
      --v9;
    }
    if ( LOWORD(dword_10172170[2 * v6]) == a2 && BYTE2(dword_10172170[2 * v6]) == a3 )
    {
      if ( (unsigned int)(v7 - dword_10172174[2 * v6]) > 0x258 )
      {
        dword_10172174[2 * v6] = v7;
        sub_1000A1F0(a1, a2, a3);
      }
    }
    else
    {
      sub_1000A110(a1, a2, a3);
      sub_1009B4D0(100);
      sub_1000A1F0(a1, a2, a3);
      sub_1009B4D0(200);
    }
    for ( i = 0; i < 4096; ++i )
    {
      if ( dword_10166170[3 * i] == (a2 | (v8 << 8) | (v6 << 16)) || dword_10166170[3 * i] == -1 )
      {
        if ( (unsigned int)(v7 - dword_10166174[3 * i]) < 0x2710 && dword_10166170[3 * i] != -1 )
          v5 = dword_10166178[3 * i];
        break;
      }
    }
    sub_1009B3D0(34);
  }
  return v5;
}
// 10166170: using guessed type int dword_10166170[];
// 10166174: using guessed type int dword_10166174[];
// 10166178: using guessed type int dword_10166178[];
// 10172170: using guessed type int dword_10172170[];
// 10172174: using guessed type int dword_10172174[];

//----- (1000A4A0) --------------------------------------------------------
char __cdecl sub_1000A4A0(int a1, void *a2)
{
  sub_10074030(2, *((_WORD *)&word_100C592C + 4 * a1), a2, 0, 8, 1);
  return sub_10074170(2, *((_WORD *)&word_100C592C + 4 * a1), dword_100C5928[2 * a1]);
}
// 100C5928: using guessed type int dword_100C5928[];

//----- (1000A4F0) --------------------------------------------------------
int __cdecl sub_1000A4F0(int a1)
{
  int result; // eax@1
  int *v2; // ecx@3
  unsigned int v3; // [sp+0h] [bp-1038h]@3
  int v4[1025]; // [sp+4h] [bp-1034h]@12
  int j; // [sp+1008h] [bp-30h]@12
  char v6; // [sp+100Ch] [bp-2Ch]@2
  int v7; // [sp+101Ch] [bp-1Ch]@5
  unsigned __int8 v8; // [sp+1027h] [bp-11h]@12
  int v9; // [sp+1028h] [bp-10h]@3
  int v10; // [sp+102Ch] [bp-Ch]@19
  int i; // [sp+1030h] [bp-8h]@10
  unsigned int v12; // [sp+1034h] [bp-4h]@12

  result = sub_1009B3F0(34, 10000);
  if ( !result )
  {
    if ( sub_10073ED0(2, word_100C592E[4 * a1], (int)&v6) )
    {
      v2 = &v9;
      LOWORD(v2) = word_100C592E[4 * a1];
      if ( sub_10074530(2, (int)v2, &v3, (int)&v9) )
      {
        if ( !sub_10074560(&v3) && (v7 != dword_10166148[a1] || (unsigned __int16)v9 != dword_1016615C[a1]) )
        {
          LOWORD(v9) = v9 & 0xFFFC;
          dword_10166148[a1] = v7;
          dword_1016615C[a1] = (unsigned __int16)v9;
          if ( (unsigned __int16)v9 > 0x1004u || v3 >= 8 )
            return sub_1009B3D0(34);
          LOWORD(v9) = v9 - 4;
          LOWORD(v9) = (unsigned __int16)v9 >> 2;
          for ( i = 0; i < (unsigned __int16)v9; ++i )
          {
            v8 = v4[i];
            v12 = v3 | (v8 << 8) | (a1 << 16);
            for ( j = 0; j < 4096 && dword_10166170[3 * j] != v12 && dword_10166170[3 * j] != -1; ++j )
              ;
            if ( j >= 4096 )
            {
              v10 = 0;
              for ( j = 1; j < 4096; ++j )
              {
                if ( dword_10166174[3 * v10] > (unsigned int)dword_10166174[3 * j] )
                  v10 = j;
              }
              j = v10;
            }
            dword_10166170[3 * j] = v12;
            dword_10166178[3 * j] = v4[i];
            dword_10166174[3 * j] = v7;
          }
        }
      }
    }
    result = sub_1009B3D0(34);
  }
  return result;
}
// 10166148: using guessed type int dword_10166148[];
// 1016615C: using guessed type int dword_1016615C[];
// 10166170: using guessed type int dword_10166170[];
// 10166174: using guessed type int dword_10166174[];
// 10166178: using guessed type int dword_10166178[];
// 1000A4F0: using guessed type int var_1034[1025];

//----- (1000A720) --------------------------------------------------------
unsigned int sub_1000A720()
{
  unsigned int result; // eax@1
  BOOL (*v1)(); // [sp+0h] [bp-10h]@1
  int (*v2)(); // [sp+4h] [bp-Ch]@1
  void *v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v3 = &unk_10172198;
  v4 = 0x400000;
  v2 = sub_1000A770;
  v1 = sub_1000A780;
  dword_10658DF0 = (int)sub_10054250();
  result = sub_100540D0((int)&v1);
  dword_10658DF4 = result;
  return result;
}
// 10658DF0: using guessed type int dword_10658DF0;
// 10658DF4: using guessed type int dword_10658DF4;

//----- (1000A770) --------------------------------------------------------
int sub_1000A770()
{
  return sub_1009B3D0(84);
}

//----- (1000A780) --------------------------------------------------------
BOOL sub_1000A780()
{
  return sub_1009B3F0(84, 50) == 0;
}

//----- (1000A7A0) --------------------------------------------------------
char __cdecl sub_1000A7A0(_QWORD *a1)
{
  int v2; // [sp+0h] [bp-8h]@1
  char v3; // [sp+7h] [bp-1h]@1

  v3 = sub_10075D30((char *)&v2);
  *a1 = (unsigned int)(sub_10075B00(v2, 1970, 1990) - 86400);
  *a1 *= 1000000i64;
  return v3;
}

//----- (1000A810) --------------------------------------------------------
signed int __cdecl sub_1000A810(int a1, unsigned int a2)
{
  return sub_1000A850(a1, a2);
}

//----- (1000A830) --------------------------------------------------------
int sub_1000A830()
{
  dword_10658DEC = dword_10658DF4;
  return sub_10010110();
}
// 10010110: using guessed type int sub_10010110(void);
// 10658DEC: using guessed type int dword_10658DEC;
// 10658DF4: using guessed type int dword_10658DF4;

//----- (1000A850) --------------------------------------------------------
signed int __cdecl sub_1000A850(int a1, unsigned int a2)
{
  signed int v3; // [sp+8h] [bp-4h]@2

  qmemcpy(&unk_10572198, &off_100C6B08, 0x15Cu);
  if ( sub_10011BE0(a1, a2, (const char **)&unk_10572198) )
    v3 = 0;
  else
    v3 = -15;
  return v3;
}
// 100C6B08: using guessed type char *off_100C6B08;

//----- (1000A8A0) --------------------------------------------------------
int __cdecl sub_1000A8A0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@4
  signed int v6; // ST14_4@5
  unsigned int v7; // [sp+4h] [bp-4h]@3

  *a5 = -2147483647;
  if ( a3 == 1 && (*a4 & 7) == 2 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"i", (unsigned int)&v7) )
  {
    v6 = sub_1009BA60(v7);
    j_FIL_vfs_sync_all();
    *a5 = 2 * v6 | 1;
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to FIL_close\n", a3);
    result = 0;
  }
  return result;
}
// 1009BC80: using guessed type int j_FIL_vfs_sync_all(void);

//----- (1000A930) --------------------------------------------------------
int __cdecl sub_1000A930(int a1, int a2, int a3, signed int *a4, _DWORD *a5)
{
  unsigned int v6; // kr04_4@10
  signed int v7; // ST34_4@13
  char v8; // [sp+Ch] [bp-58h]@0
  unsigned int v9; // [sp+30h] [bp-34h]@3
  char *v10; // [sp+34h] [bp-30h]@5
  char v11; // [sp+38h] [bp-2Ch]@9

  *a5 = -2147483647;
  if ( a3 != 1 || (*a4 & 7) != 4 || !sub_10012620(a1, 1, a4, (unsigned __int8 *)"S", (unsigned int)&v9) )
  {
    sub_100110D0(a1, "invalid args %i to FIL_open\n", a3);
    return 0;
  }
  v10 = (char *)sub_10010FF0(v9);
  if ( !strncmp(v10, "/mnt/card0", 0xAu) || !strncmp(v10, "/mnt/card1", 0xAu) )
  {
    if ( strlen(v10) >= 0x28 )
    {
      sub_100110D0(a1, "filename too long to FIL_open\n", v8);
      return 0;
    }
    sprintf(&v11, "%s", v10);
  }
  else
  {
    v6 = strlen(v10);
    if ( v6 + 11 >= 0x28 )
    {
      sub_100110D0(a1, "filename too long to FIL_open\n", v6);
      return 0;
    }
    sprintf(&v11, "/mnt/card0/%s", v10);
  }
  v7 = j_FIL_vfs_open(&v11, 78, 1809);
  return sub_10010380(a1, (double)v7, (int)a5);
}
// 1009BB30: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1000AAE0) --------------------------------------------------------
int __cdecl sub_1000AAE0(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@6
  signed int v6; // eax@16
  bool v7; // [sp+7h] [bp-1011h]@9
  unsigned int v8; // [sp+Ch] [bp-100Ch]@5
  char v9; // [sp+10h] [bp-1008h]@1
  unsigned int v10; // [sp+1014h] [bp-4h]@13

  *a5 = -2147483647;
  memset(&v9, 0, 0x1000u);
  if ( a3 == 2
    && (*(_DWORD *)a4 & 7) == 2
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && sub_10012620(a1, 2, (signed int *)a4, (unsigned __int8 *)"iu", (unsigned int)&v8) )
  {
    v7 = v8 >= 0xFFFFFFC2 || !v8;
    if ( v7 )
    {
      sub_100110D0(a1, "invalid file handle (%i) to FIL_read\n", v8);
      result = 0;
    }
    else
    {
      if ( v10 > 0xFFF )
        sub_10011120(a1, "Requested (%i) bytes to FIL_read but no more than (%i) will be returned\n", v10);
      if ( v10 <= 0xFFF )
        v6 = sub_1009BB40(v8, &v9, v10);
      else
        v6 = sub_1009BB40(v8, &v9, 4095);
      if ( v6 <= 0 )
        memset(&v9, 0, 0x1000u);
      *a5 = sub_10010F20(a1, &v9) | 4;
      result = *a5;
    }
  }
  else
  {
    sub_100110D0(a1, "invalid args (%i) to FIL_read\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000AC90) --------------------------------------------------------
int __cdecl sub_1000AC90(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@5
  bool v6; // [sp+13h] [bp-11h]@8
  unsigned int v7; // [sp+18h] [bp-Ch]@12
  unsigned int v8; // [sp+1Ch] [bp-8h]@4
  const char *v9; // [sp+20h] [bp-4h]@12

  *a5 = -2147483647;
  if ( a3 == 2
    && (*(_DWORD *)a4 & 7) == 2
    && (*(_DWORD *)(a4 + 4) & 7) == 4
    && sub_10012620(a1, 2, (signed int *)a4, (unsigned __int8 *)"iS", (unsigned int)&v8) )
  {
    v6 = v8 >= 0xFFFFFFC2 || !v8;
    if ( v6 )
    {
      sub_100110D0(a1, "invalid file handle %i to FIL_write\n", v8);
      result = 0;
    }
    else
    {
      v9 = (const char *)sub_10010FF0(v7);
      *a5 = 2 * j_FIL_vfs_write(v8, v9, strlen(v9)) | 1;
      result = *a5;
    }
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to FIL_write\n", a3);
    result = 0;
  }
  return result;
}
// 1009BCB0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1000ADA0) --------------------------------------------------------
int __cdecl sub_1000ADA0(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  unsigned int v6; // eax@7
  unsigned int v7; // [sp+18h] [bp-24h]@1
  int v8; // [sp+1Ch] [bp-20h]@7
  const char *v9; // [sp+28h] [bp-14h]@7
  double v10; // [sp+2Ch] [bp-10h]@11
  __int64 v11; // [sp+34h] [bp-8h]@4

  v7 = 0;
  *a5 = -2147483647;
  if ( a3 != 4
    || !(*(_DWORD *)a4 & 1) && (*(_DWORD *)a4 & 7) != 4
    || !sub_10012620(a1, 3, (signed int *)(a4 + 4), (unsigned __int8 *)"ubu", (unsigned int)&v11) )
  {
    sub_100110D0(a1, "invalid args %i to IOP_get_arnc_diag_label\n", a3);
    return 0;
  }
  if ( (*(_DWORD *)a4 & 7) == 4 )
  {
    v6 = sub_100101C0(a1, *(_DWORD *)a4);
    v9 = (const char *)sub_10010FF0(v6);
    if ( sub_1000AEF0(v9, (int)&unk_100C6AC8, 5, &v8) )
    {
      sub_100110D0(a1, "unknown lru %s\n", (char)v9);
      return 0;
    }
  }
  else
  {
    v8 = *(_DWORD *)a4 >> 1;
  }
  v10 = (double)(unsigned int)sub_1000A2B0(v8, v11, HIDWORD(v11), v7);
  return sub_100103A0(a1, v10, (int)a5);
}
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (1000AEF0) --------------------------------------------------------
signed int __cdecl sub_1000AEF0(const char *a1, int a2, int a3, _DWORD *a4)
{
  char v4; // t1@4
  signed int v9; // [sp+1Ch] [bp-14h]@1
  int i; // [sp+28h] [bp-8h]@2
  int v13; // [sp+2Ch] [bp-4h]@4

  v9 = -24;
  if ( a1 )
  {
    for ( i = 0; i < a3; ++i )
    {
      v4 = *(_BYTE *)(a2 + 12 * i);
      v13 = strcmp(*(const char **)(a2 + 12 * i + 4), a1) == 0;
      if ( v13 )
      {
        v9 = 0;
        *a4 = *(_DWORD *)(a2 + 12 * i + 8);
        return v9;
      }
    }
  }
  return v9;
}

//----- (1000B040) --------------------------------------------------------
int __cdecl sub_1000B040(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@5
  int v6; // ecx@6
  unsigned __int8 v7; // [sp+13h] [bp-5h]@6
  int v8; // [sp+14h] [bp-4h]@4

  *a5 = -2147483647;
  if ( a3 == 1 && *a4 & 1 && *a4 != -2147483647 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"c", (unsigned int)&v8) )
  {
    *a5 = sub_10010160(a1);
    LOWORD(v6) = v8;
    if ( sub_10075EA0(v6, &v7) )
      result = sub_100103A0(a1, (double)v7, (int)a5);
    else
      result = 1;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to IOP_get_dscrt_in_data\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000B100) --------------------------------------------------------
int __cdecl sub_1000B100(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@5
  float v6; // [sp+Ch] [bp-8h]@6
  unsigned __int16 v7; // [sp+10h] [bp-4h]@4

  *a5 = -2147483647;
  if ( a3 == 1 && *a4 & 1 && *a4 != -2147483647 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"c", (unsigned int)&v7) )
  {
    *a5 = sub_10010160(a1);
    if ( sub_10075ED0(v7, &v6) )
      result = sub_100103A0(a1, v6, (int)a5);
    else
      result = 1;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to IOP_get_gea_input_data\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000B1C0) --------------------------------------------------------
signed int __cdecl sub_1000B1C0(int a1, int a2, int a3, int a4, int *a5)
{
  signed int result; // eax@11
  int *v6; // eax@22
  char v7; // [sp+10h] [bp-38h]@0
  bool v8; // [sp+14h] [bp-34h]@50
  bool v9; // [sp+18h] [bp-30h]@45
  bool v10; // [sp+1Ch] [bp-2Ch]@39
  bool v11; // [sp+20h] [bp-28h]@33
  bool v12; // [sp+24h] [bp-24h]@27
  __int16 v13; // [sp+28h] [bp-20h]@22
  int v14; // [sp+2Ch] [bp-1Ch]@22
  __int16 v15; // [sp+30h] [bp-18h]@14
  char v16; // [sp+37h] [bp-11h]@22
  unsigned __int8 v17; // [sp+38h] [bp-10h]@12
  unsigned __int8 v18; // [sp+3Fh] [bp-9h]@12
  unsigned __int16 v19; // [sp+40h] [bp-8h]@10
  int v20; // [sp+44h] [bp-4h]@22

  *a5 = -2147483647;
  if ( a3 == 4
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && *(_DWORD *)(a4 + 8) & 1
    && *(_DWORD *)(a4 + 8) != -2147483647
    && *(_DWORD *)(a4 + 12) & 1
    && *(_DWORD *)(a4 + 12) != -2147483647
    && sub_10012620(a1, 4, (signed int *)a4, (unsigned __int8 *)"cccc", (unsigned int)&v19) )
  {
    v18 = v17;
    if ( (signed int)v17 <= 5 )
    {
      v15 = 1;
      if ( v18 != 2 && v18 != 1 )
      {
        if ( v18 == 3 )
        {
          v15 = 2;
        }
        else if ( v18 == 4 )
        {
          v15 = 4;
        }
      }
      else
      {
        v15 = 4;
      }
      if ( (signed int)v19 >= 7 )
      {
        sub_100110D0(a1, "invalid pipe IOP_get_hsdb_data\n", v7);
        result = 0;
      }
      else
      {
        v6 = &v14;
        LOWORD(v6) = v20;
        v16 = sub_100744D0(v19, (int)v6, v13, v15, &v14);
        switch ( v18 )
        {
          case 2u:
            v12 = v16 && !sub_10076040((int)&v14, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
            v16 = v12;
            break;
          case 3u:
            v11 = v16 && !sub_10076180(&v14, -32768, 0x7FFF, 0, 0);
            v16 = v11;
            break;
          case 4u:
            v10 = v16 && !sub_10076220(&v14, 2147483648, 0x7FFFFFFF, 0, 0);
            v16 = v10;
            break;
          default:
            if ( v18 )
            {
              v8 = v16 && !sub_10076430(&v14, 0, 0xFFFFFFFF, 0, 0);
              v16 = v8;
            }
            else
            {
              v9 = v16 && !sub_10076340((unsigned __int8 *)&v14, 0, 0xFFu, 0, 0);
              v16 = v9;
            }
            break;
        }
        if ( v16 )
        {
          switch ( v18 )
          {
            case 2u:
              sub_10010380(a1, *(float *)&v14, (int)a5);
              break;
            case 3u:
              *a5 = 2 * (signed __int16)v14 | 1;
              break;
            case 4u:
              *a5 = 2 * v14 | 1;
              break;
            case 0u:
              *a5 = 2 * (unsigned __int8)v14 | 1;
              break;
            default:
              *a5 = 2 * v14 | 1;
              break;
          }
        }
        else
        {
          *a5 = sub_10010160(a1);
        }
        result = 1;
      }
    }
    else
    {
      sub_100110D0(a1, "invalid type to IOP_get_hsdb_data\n", v7);
      result = 0;
    }
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to IOP_get_hsdb_data\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000B530) --------------------------------------------------------
signed int __cdecl sub_1000B530(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  signed int result; // eax@6
  char v6; // [sp+0h] [bp-8h]@10
  unsigned __int16 v7; // [sp+4h] [bp-4h]@5

  *a5 = -2147483647;
  if ( a3 == 2
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && (*(_DWORD *)(a4 + 4) & 7) == 6
    && sub_10012620(a1, 2, (signed int *)a4, (unsigned __int8 *)"cb", (unsigned int)&v7) )
  {
    if ( (signed int)v7 >= 123 && (signed int)v7 <= 132 )
    {
      sub_10075E30(v7, v6);
      result = 1;
    }
    else
    {
      sub_100110D0(a1, "invalid packet id %i (expected range: %i-%i)\n", v7);
      result = 0;
    }
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to IOP_set_dscrt_out_data\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000B600) --------------------------------------------------------
signed int __cdecl sub_1000B600(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  *a5 = -2147483647;
  sub_100764E0();
  *a5 = 14;
  return 1;
}

//----- (1000B630) --------------------------------------------------------
signed int __cdecl sub_1000B630(int a1, int a2, int a3, signed int *a4, _DWORD *a5)
{
  int v5; // ecx@0
  signed int result; // eax@5
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  *a5 = -2147483647;
  if ( a3 == 1 && *a4 & 1 && *a4 != -2147483647 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"u", (unsigned int)&v7) )
  {
    sub_10076520((unsigned __int8)v7);
    *a5 = 14;
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_log_clear_section\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000B6C0) --------------------------------------------------------
int __cdecl sub_1000B6C0(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@9
  char v6; // [sp+0h] [bp-1B18h]@10
  char v7; // [sp+1B0Ch] [bp-Ch]@10
  int v8; // [sp+1B10h] [bp-8h]@8
  __int16 v9; // [sp+1B14h] [bp-4h]@10

  *a5 = -2147483647;
  if ( a3 == 3
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && *(_DWORD *)(a4 + 8) & 1
    && *(_DWORD *)(a4 + 8) != -2147483647
    && sub_10012620(a1, 3, (signed int *)a4, (unsigned __int8 *)"uuu", (unsigned int)&v8) )
  {
    if ( sub_10076690(v8, v7, v9, &v6) )
      sub_1000B7C0(a1, a2, a5, (int)&v6);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_data\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000B7C0) --------------------------------------------------------
signed int __cdecl sub_1000B7C0(int a1, int a2, _DWORD *a3, int a4)
{
  int v4; // eax@18
  int v5; // eax@19
  int v6; // eax@31
  unsigned __int8 i; // [sp+13h] [bp-71h]@10
  unsigned __int8 j; // [sp+13h] [bp-71h]@23
  int v10; // [sp+14h] [bp-70h]@2
  int v11; // [sp+18h] [bp-6Ch]@10
  unsigned __int8 v12; // [sp+1Ch] [bp-68h]@4
  unsigned __int8 v13; // [sp+1Dh] [bp-67h]@4
  unsigned __int16 v14; // [sp+1Eh] [bp-66h]@4
  int v15; // [sp+20h] [bp-64h]@10
  int v16; // [sp+24h] [bp-60h]@13
  int v17; // [sp+28h] [bp-5Ch]@10
  int v18; // [sp+2Ch] [bp-58h]@22
  int v19; // [sp+30h] [bp-54h]@10
  int v20; // [sp+34h] [bp-50h]@1
  int v21; // [sp+38h] [bp-4Ch]@22
  char v22; // [sp+3Ch] [bp-48h]@13
  __int16 v23; // [sp+74h] [bp-10h]@4
  unsigned __int8 v24; // [sp+76h] [bp-Eh]@4
  unsigned __int8 v25; // [sp+77h] [bp-Dh]@4
  int v26; // [sp+78h] [bp-Ch]@22
  int v27; // [sp+7Ch] [bp-8h]@22
  int v28; // [sp+80h] [bp-4h]@10

  v20 = a2;
  if ( *(_WORD *)a4 == 0xFFFF )
    v10 = sub_10010F20(a1, "UNKNOWN") | 4;
  else
    v10 = 2 * *(_WORD *)a4 | 1;
  sub_10010920(a1, v20, "id", (int)&v10);
  sub_10075A10((int)&v12, *(_DWORD *)(a4 + 4));
  sub_10075C30((int)&v23, *(_DWORD *)(a4 + 4));
  v10 = 2 * v14 | 1;
  sub_10010920(a1, v20, "year", (int)&v10);
  v10 = 2 * v12 | 1;
  sub_10010920(a1, v20, "month", (int)&v10);
  v10 = 2 * v13 | 1;
  sub_10010920(a1, v20, "day", (int)&v10);
  v10 = 2 * v23 | 1;
  sub_10010920(a1, v20, "hour", (int)&v10);
  v10 = 2 * v24 | 1;
  sub_10010920(a1, v20, "minute", (int)&v10);
  v10 = 2 * v25 | 1;
  sub_10010920(a1, v20, "second", (int)&v10);
  v10 = 2 * *(_DWORD *)(a4 + 8) | 1;
  sub_10010920(a1, v20, "millisecond", (int)&v10);
  v10 = 2 * *(_WORD *)(a4 + 12) | 1;
  sub_10010920(a1, v20, "tag", (int)&v10);
  v10 = 2 * *(_WORD *)(a4 + 14) | 1;
  sub_10010920(a1, v20, "addr", (int)&v10);
  if ( *(_BYTE *)(a4 + 3) == 255 )
  {
    v10 = sub_10010F20(a1, "UNKNOWN") | 4;
    sub_10010920(a1, v20, "inhibit", (int)&v10);
    v10 = sub_10010F20(a1, "UNKNOWN") | 4;
    sub_10010920(a1, v20, "set", (int)&v10);
  }
  else
  {
    v10 = 2 * ((*(_BYTE *)(a4 + 3) & 2) == 2) | 1;
    sub_10010920(a1, v20, "inhibit", (int)&v10);
    v10 = 2 * ((*(_BYTE *)(a4 + 3) & 1) == 1) | 1;
    sub_10010920(a1, v20, "set", (int)&v10);
  }
  v10 = 2 * *(_BYTE *)(a4 + 2) | 1;
  sub_10010920(a1, v20, "pts", (int)&v10);
  v10 = 2 * *(_BYTE *)(a4 + 6612) | 1;
  sub_10010920(a1, v20, "other_pts", (int)&v10);
  v10 = sub_10010F20(a1, (const char *)(a4 + 3422)) | 4;
  sub_10010920(a1, v20, "main_txt", (int)&v10);
  if ( *(_BYTE *)(a4 + 3546) == 5 )
    v10 = sub_10010F20(a1, "UNKNOWN") | 4;
  else
    v10 = 2 * *(_BYTE *)(a4 + 3546) | 1;
  sub_10010920(a1, v20, "lvl", (int)&v10);
  v10 = sub_10010F20(a1, (const char *)(a4 + 3453)) | 4;
  sub_10010920(a1, v20, "desc_txt", (int)&v10);
  v10 = sub_10010F20(a1, (const char *)(a4 + 3504)) | 4;
  sub_10010920(a1, v20, "txt_f1", (int)&v10);
  v10 = sub_10010F20(a1, (const char *)(a4 + 3525)) | 4;
  sub_10010920(a1, v20, "txt_f2", (int)&v10);
  v10 = sub_10010F20(a1, (const char *)(a4 + 3578)) | 4;
  sub_10010920(a1, v20, "pof_txt", (int)&v10);
  v10 = 2 * *(_WORD *)(a4 + 3576) | 1;
  sub_10010920(a1, v20, "pof_id", (int)&v10);
  v28 = sub_10010A00(a1, 0, 0);
  v10 = v28;
  sub_10010920(a1, v20, "names", (int)&v10);
  v15 = sub_10010A00(a1, 0, 0);
  v10 = v15;
  sub_10010920(a1, v20, "data", (int)&v10);
  v17 = sub_10010A00(a1, 0, 0);
  v10 = v17;
  sub_10010920(a1, v20, "units", (int)&v10);
  v19 = sub_10010A00(a1, 0, 0);
  v10 = v19;
  sub_10010920(a1, v20, "states", (int)&v10);
  v11 = sub_10010A00(a1, 0, 0);
  v10 = v11;
  sub_10010920(a1, v20, "trig_ids", (int)&v10);
  for ( i = 0; i < (signed int)*(_BYTE *)(a4 + 2); ++i )
  {
    switch ( *(_BYTE *)(a4 + i + 420) )
    {
      case 2:
        sub_1006FD70(&v22, 0x32u, "%f", *(float *)(a4 + 4 * i + 20));
        v16 = sub_10010F20(a1, &v22) | 4;
        sub_10010A30(a1, v15, i);
        break;
      case 3:
        sub_1006FD70(&v22, 0x32u, "%hd", *(_WORD *)(a4 + 4 * i + 20));
        v16 = sub_10010F20(a1, &v22) | 4;
        sub_10010A30(a1, v15, i);
        break;
      case 4:
        sub_1006FD70(&v22, 0x32u, "%d", *(_DWORD *)(a4 + 4 * i + 20));
        v16 = sub_10010F20(a1, &v22) | 4;
        sub_10010A30(a1, v15, i);
        break;
      case 0:
        sub_1006FD70(&v22, 0x32u, "%u", *(_BYTE *)(a4 + 4 * i + 20));
        v16 = sub_10010F20(a1, &v22) | 4;
        sub_10010A30(a1, v15, i);
        break;
      default:
        sub_1006FD70(&v22, 0x32u, "%u", *(_DWORD *)(a4 + 4 * i + 20));
        v16 = sub_10010F20(a1, &v22) | 4;
        sub_10010A30(a1, v15, i);
        break;
    }
    v16 = sub_10010F20(a1, (const char *)(a4 + 21 * i + 520)) | 4;
    sub_10010A30(a1, v28, i);
    v4 = sub_10071720((_DWORD *)(a4 + 4 * i + 2720), 4u, (int)&unk_100C6118, 16, 68);
    v16 = sub_10010F20(a1, &byte_100C611C[16 * v4]) | 4;
    sub_10010A30(a1, v17, i);
    if ( *(_BYTE *)(a4 + i + 3120) == 4 )
    {
      v16 = sub_10010F20(a1, "UNKNOWN") | 4;
    }
    else
    {
      v5 = sub_10071720((_DWORD *)(a4 + i + 3120), 1u, (int)&unk_100C6558, 21, 4);
      v16 = sub_10010F20(a1, &aInactive[21 * v5]) | 4;
    }
    sub_10010A30(a1, v19, i);
    v16 = 2 * *(_WORD *)(a4 + 2 * i + 3220) | 1;
    sub_10010A30(a1, v11, i);
  }
  v26 = sub_10010A00(a1, 0, 0);
  v10 = v26;
  sub_10010920(a1, v20, "other_names", (int)&v10);
  v18 = sub_10010A00(a1, 0, 0);
  v10 = v18;
  sub_10010920(a1, v20, "other_data", (int)&v10);
  v27 = sub_10010A00(a1, 0, 0);
  v10 = v27;
  sub_10010920(a1, v20, "other_units", (int)&v10);
  v21 = sub_10010A00(a1, 0, 0);
  v10 = v21;
  sub_10010920(a1, v20, "other_trig_ids", (int)&v10);
  if ( (signed int)*(_BYTE *)(a4 + 6612) > 0 )
  {
    for ( j = 0; j < (signed int)*(_BYTE *)(a4 + 6612); ++j )
    {
      switch ( *(_BYTE *)(a4 + j + 6613) )
      {
        case 2:
          sub_1006FD70(&v22, 0x32u, "%f", *(float *)(a4 + 4 * j + 5712));
          break;
        case 3:
          sub_1006FD70(&v22, 0x32u, "%hd", *(_WORD *)(a4 + 4 * j + 5712));
          break;
        case 4:
          sub_1006FD70(&v22, 0x32u, "%d", *(_DWORD *)(a4 + 4 * j + 5712));
          break;
        case 0:
          sub_1006FD70(&v22, 0x32u, "%u", *(_BYTE *)(a4 + 4 * j + 5712));
          break;
        default:
          sub_1006FD70(&v22, 0x32u, "%u", *(_DWORD *)(a4 + 4 * j + 5712));
          break;
      }
      v16 = sub_10010F20(a1, &v22) | 4;
      sub_10010A30(a1, v18, j);
      v16 = sub_10010F20(a1, (const char *)(a4 + 21 * j + 3609)) | 4;
      sub_10010A30(a1, v26, j);
      v6 = sub_10071720((_DWORD *)(a4 + 4 * j + 6112), 4u, (int)&unk_100C6118, 16, 68);
      v16 = sub_10010F20(a1, &byte_100C611C[16 * v6]) | 4;
      sub_10010A30(a1, v27, j);
      v16 = 2 * *(_WORD *)(a4 + 2 * j + 6714) | 1;
      sub_10010A30(a1, v21, j);
    }
  }
  *a3 = v20;
  return 1;
}
// 10010A00: using guessed type _DWORD __cdecl sub_10010A00(_DWORD, _DWORD, _DWORD);

//----- (1000C3A0) --------------------------------------------------------
int __cdecl sub_1000C3A0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@5
  char v6; // [sp+0h] [bp-1B10h]@6
  char v7; // [sp+1B0Ch] [bp-4h]@4

  *a5 = -2147483647;
  if ( a3 == 1 && *a4 & 1 && *a4 != -2147483647 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"u", (unsigned int)&v7) )
  {
    if ( sub_10076700(v7, &v6) )
      sub_1000B7C0(a1, a2, a5, (int)&v6);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_first\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000C460) --------------------------------------------------------
int __cdecl sub_1000C460(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@7
  char v6; // [sp+0h] [bp-1B18h]@8
  char v7; // [sp+1B10h] [bp-8h]@6
  __int16 v8; // [sp+1B14h] [bp-4h]@8

  *a5 = -2147483647;
  if ( a3 == 2
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && sub_10012620(a1, 2, (signed int *)a4, (unsigned __int8 *)"uu", (unsigned int)&v7) )
  {
    if ( sub_10076760(v7, v8, &v6) )
      sub_1000B7C0(a1, a2, a5, (int)&v6);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_first\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000C540) --------------------------------------------------------
int __cdecl sub_1000C540(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@7
  __int16 v6; // [sp+0h] [bp-38h]@8
  char v7; // [sp+4h] [bp-34h]@6
  char v8; // [sp+8h] [bp-30h]@1

  *a5 = -2147483647;
  memset(&v8, 0, 0x29u);
  if ( a3 == 2
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && sub_10012620(a1, 2, (signed int *)a4, (unsigned __int8 *)"uu", (unsigned int)&v7) )
  {
    sub_100767D0(v7, v6, (int)&v8, 41);
    *a5 = sub_10010F20(a1, &v8) | 4;
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_first\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000C620) --------------------------------------------------------
int __cdecl sub_1000C620(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@5
  char v6; // [sp+0h] [bp-28h]@4
  int v7; // [sp+4h] [bp-24h]@1
  int v8; // [sp+8h] [bp-20h]@1
  int v9; // [sp+Ch] [bp-1Ch]@1
  int v10; // [sp+10h] [bp-18h]@1
  int v11; // [sp+14h] [bp-14h]@1
  int v12; // [sp+18h] [bp-10h]@1
  int v13; // [sp+1Ch] [bp-Ch]@1
  int v14; // [sp+20h] [bp-8h]@1

  *a5 = -2147483647;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( a3 == 1 && *a4 & 1 && *a4 != -2147483647 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"u", (unsigned int)&v6) )
  {
    sub_10076840(v6, (int)&v7, 32);
    *a5 = sub_10010F20(a1, (const char *)&v7) | 4;
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_first\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000C6F0) --------------------------------------------------------
int __cdecl sub_1000C6F0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@5
  char v6; // [sp+0h] [bp-1B10h]@6
  char v7; // [sp+1B0Ch] [bp-4h]@4

  *a5 = -2147483647;
  if ( a3 == 1 && *a4 & 1 && *a4 != -2147483647 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"u", (unsigned int)&v7) )
  {
    if ( sub_100768B0(v7, &v6) )
      sub_1000B7C0(a1, a2, a5, (int)&v6);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_last\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000C7B0) --------------------------------------------------------
int __cdecl sub_1000C7B0(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@7
  char v6; // [sp+0h] [bp-1B18h]@8
  char v7; // [sp+1B10h] [bp-8h]@6
  __int16 v8; // [sp+1B14h] [bp-4h]@8

  *a5 = -2147483647;
  if ( a3 == 2
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && sub_10012620(a1, 2, (signed int *)a4, (unsigned __int8 *)"uu", (unsigned int)&v7) )
  {
    if ( sub_10076910(v7, v8, &v6) )
      sub_1000B7C0(a1, a2, a5, (int)&v6);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_last\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000C890) --------------------------------------------------------
int __cdecl sub_1000C890(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@9
  __int16 v6; // [sp+0h] [bp-1B1Ch]@10
  char v7; // [sp+4h] [bp-1B18h]@10
  __int16 v8; // [sp+10h] [bp-1B0Ch]@10
  __int16 v9; // [sp+12h] [bp-1B0Ah]@10
  char v10; // [sp+1B14h] [bp-8h]@10
  __int16 v11; // [sp+1B18h] [bp-4h]@8

  *a5 = -2147483647;
  if ( a3 == 3
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && *(_DWORD *)(a4 + 8) & 1
    && *(_DWORD *)(a4 + 8) != -2147483647
    && sub_10012620(a1, 3, (signed int *)a4, (unsigned __int8 *)"uuu", (unsigned int)&v11) )
  {
    v8 = v11;
    v9 = v6;
    if ( sub_10076980(v10, &v7) )
      sub_1000B7C0(a1, a2, a5, (int)&v7);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_next\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000C9A0) --------------------------------------------------------
int __cdecl sub_1000C9A0(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@11
  __int16 v6; // [sp+0h] [bp-1B1Ch]@12
  char v7; // [sp+4h] [bp-1B18h]@12
  __int16 v8; // [sp+10h] [bp-1B0Ch]@12
  __int16 v9; // [sp+12h] [bp-1B0Ah]@12
  char v10; // [sp+1B10h] [bp-Ch]@12
  __int16 v11; // [sp+1B14h] [bp-8h]@10
  __int16 v12; // [sp+1B18h] [bp-4h]@12

  *a5 = -2147483647;
  if ( a3 == 4
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && *(_DWORD *)(a4 + 8) & 1
    && *(_DWORD *)(a4 + 8) != -2147483647
    && *(_DWORD *)(a4 + 12) & 1
    && *(_DWORD *)(a4 + 12) != -2147483647
    && sub_10012620(a1, 4, (signed int *)a4, (unsigned __int8 *)"uuuu", (unsigned int)&v11) )
  {
    v8 = v11;
    v9 = v6;
    if ( sub_100769F0(v10, v12, &v7) )
      sub_1000B7C0(a1, a2, a5, (int)&v7);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_next\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000CAE0) --------------------------------------------------------
int __cdecl sub_1000CAE0(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@9
  __int16 v6; // [sp+0h] [bp-1B1Ch]@10
  char v7; // [sp+4h] [bp-1B18h]@10
  __int16 v8; // [sp+10h] [bp-1B0Ch]@10
  __int16 v9; // [sp+12h] [bp-1B0Ah]@10
  char v10; // [sp+1B14h] [bp-8h]@10
  __int16 v11; // [sp+1B18h] [bp-4h]@8

  *a5 = -2147483647;
  if ( a3 == 3
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && *(_DWORD *)(a4 + 8) & 1
    && *(_DWORD *)(a4 + 8) != -2147483647
    && sub_10012620(a1, 3, (signed int *)a4, (unsigned __int8 *)"uui", (unsigned int)&v11) )
  {
    v8 = v11;
    v9 = v6;
    if ( sub_10076A70(v10, &v7) )
      sub_1000B7C0(a1, a2, a5, (int)&v7);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_prev\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000CBF0) --------------------------------------------------------
int __cdecl sub_1000CBF0(int a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@11
  __int16 v6; // [sp+0h] [bp-1B1Ch]@12
  char v7; // [sp+4h] [bp-1B18h]@12
  __int16 v8; // [sp+10h] [bp-1B0Ch]@12
  __int16 v9; // [sp+12h] [bp-1B0Ah]@12
  char v10; // [sp+1B10h] [bp-Ch]@12
  __int16 v11; // [sp+1B14h] [bp-8h]@10
  __int16 v12; // [sp+1B18h] [bp-4h]@12

  *a5 = -2147483647;
  if ( a3 == 4
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && *(_DWORD *)(a4 + 8) & 1
    && *(_DWORD *)(a4 + 8) != -2147483647
    && *(_DWORD *)(a4 + 12) & 1
    && *(_DWORD *)(a4 + 12) != -2147483647
    && sub_10012620(a1, 4, (signed int *)a4, (unsigned __int8 *)"uuii", (unsigned int)&v11) )
  {
    v8 = v11;
    v9 = v6;
    if ( sub_10076AE0(v10, v12, &v7) )
      sub_1000B7C0(a1, a2, a5, (int)&v7);
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_log_prev\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000CD30) --------------------------------------------------------
int __cdecl sub_1000CD30(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@5
  __int16 v6; // ax@6
  char v7; // [sp+0h] [bp-8h]@4
  int v8; // [sp+4h] [bp-4h]@6

  *a5 = -2147483647;
  if ( a3 == 1 && *a4 & 1 && *a4 != -2147483647 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"u", (unsigned int)&v7) )
  {
    v6 = sub_10076B60(v7);
    v8 = (unsigned __int16)v6;
    *a5 = 2 * (unsigned __int16)v6 | 1;
    result = *a5;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to MON_get_rcnt_flt_indx\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000CDC0) --------------------------------------------------------
int __cdecl sub_1000CDC0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx@0

  *(_DWORD *)a5 = -2147483647;
  *(_DWORD *)a5 = 8 * (unsigned __int8)j_FIL_vfs_has_dirty_data(v5) | 6;
  return *(_DWORD *)a5;
}
// 1009BAC0: using guessed type int __cdecl j_FIL_vfs_has_dirty_data(_DWORD);

//----- (1000CDF0) --------------------------------------------------------
signed int __cdecl sub_1000CDF0(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  signed int result; // eax@2
  void *v6; // eax@14
  char v7; // [sp+0h] [bp-38h]@11
  int *v8; // [sp+4h] [bp-34h]@8
  __int16 v9; // [sp+8h] [bp-30h]@14
  char v10[4]; // [sp+Ch] [bp-2Ch]@1
  int v11; // [sp+10h] [bp-28h]@1
  int v12; // [sp+14h] [bp-24h]@1
  int v13; // [sp+18h] [bp-20h]@1
  int v14; // [sp+1Ch] [bp-1Ch]@1
  int v15; // [sp+20h] [bp-18h]@1
  int v16; // [sp+24h] [bp-14h]@1
  int v17; // [sp+28h] [bp-10h]@1
  int v18; // [sp+2Ch] [bp-Ch]@1
  int v19; // [sp+30h] [bp-8h]@1

  *a5 = -2147483647;
  *(_DWORD *)v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  if ( a3 == 3 )
  {
    if ( (*(_DWORD *)a4 & 7) == 4
      && *(_DWORD *)(a4 + 4) & 1
      && *(_DWORD *)(a4 + 4) != -2147483647
      && *(_DWORD *)(a4 + 8) & 1
      && *(_DWORD *)(a4 + 8) != -2147483647
      && sub_10012620(a1, 3, (signed int *)a4, (unsigned __int8 *)"Suu", (unsigned int)&v8) )
    {
      if ( sub_10011070(v8) )
      {
        if ( (unsigned int)sub_10011070(v8) <= 0x28 )
        {
          v6 = sub_10010FF0((unsigned int)v8);
          sprintf(v10, "%s", v6);
          sub_10076570(v7, v9, v10);
          *a5 = 14;
          result = 1;
        }
        else
        {
          sub_100110D0(a1, "filename length great than %i to MON_save_log_to_card\n", 40);
          result = 0;
        }
      }
      else
      {
        sub_100110D0(a1, "filename is empty to MON_save_log_to_card\n", v7);
        result = 0;
      }
    }
    else
    {
      sub_100110D0(a1, "invalid args %i to MON_save_log_to_card\n", 3);
      result = 0;
    }
  }
  else
  {
    sub_100110D0(a1, "Wrong number of arguments (%i) to MON_save_log_to_card\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000CF80) --------------------------------------------------------
int __cdecl sub_1000CF80(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax@3
  int v6; // eax@4
  int v8[20]; // [sp+0h] [bp-150h]@1
  char v9[244]; // [sp+50h] [bp-100h]@1
  int i; // [sp+148h] [bp-8h]@1
  int v11; // [sp+14Ch] [bp-4h]@4

  *(_DWORD *)a5 = -2147483647;
  sub_1009B830(6367, (int)v9, 240);
  memset(v8, 0, 0x50u);
  for ( i = 0; i < 20; ++i )
  {
    v5 = sub_10010F20(a1, &v9[12 * i]);
    v8[i] = v5 | 4;
  }
  v6 = sub_10010A00(a1, 20, v8);
  v11 = v6;
  *(_DWORD *)a5 = v6;
  return *(_DWORD *)a5;
}
// 10010A00: using guessed type _DWORD __cdecl sub_10010A00(_DWORD, _DWORD, _DWORD);
// 1000CF80: using guessed type char var_100[244];
// 1000CF80: using guessed type int var_150[20];

//----- (1000D040) --------------------------------------------------------
int __cdecl sub_1000D040(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax@3
  int v6; // eax@4
  int v8[20]; // [sp+0h] [bp-150h]@1
  char v9[244]; // [sp+50h] [bp-100h]@1
  int i; // [sp+148h] [bp-8h]@1
  int v11; // [sp+14Ch] [bp-4h]@4

  *(_DWORD *)a5 = -2147483647;
  sub_1009B830(6368, (int)v9, 240);
  memset(v8, 0, 0x50u);
  for ( i = 0; i < 20; ++i )
  {
    v5 = sub_10010F20(a1, &v9[12 * i]);
    v8[i] = v5 | 4;
  }
  v6 = sub_10010A00(a1, 20, v8);
  v11 = v6;
  *(_DWORD *)a5 = v6;
  return *(_DWORD *)a5;
}
// 10010A00: using guessed type _DWORD __cdecl sub_10010A00(_DWORD, _DWORD, _DWORD);
// 1000D040: using guessed type char var_100[244];
// 1000D040: using guessed type int var_150[20];

//----- (1000D100) --------------------------------------------------------
int __cdecl sub_1000D100(int a1, int a2, int a3, signed int *a4, _DWORD *a5)
{
  int result; // eax@5
  char v6; // [sp+10h] [bp-B0h]@4
  double v7; // [sp+B8h] [bp-8h]@6

  *a5 = -2147483647;
  if ( a3 == 1 && *a4 & 1 && *a4 != -2147483647 && sub_10012620(a1, 1, a4, (unsigned __int8 *)"c", (unsigned int)&v6) )
  {
    v7 = (double)(unsigned __int8)sub_10076BB0((int)&v6, 0);
    result = sub_100103A0(a1, v7, (int)a5);
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to SYS_alrt_is_set\n", a3);
    result = 0;
  }
  return result;
}

//----- (1000D1C0) --------------------------------------------------------
int __cdecl sub_1000D1C0(int a1)
{
  int result; // eax@1
  int v2; // edx@1

  result = a1;
  v2 = **(_WORD **)(a1 + 52);
  return result;
}

//----- (1000D1E0) --------------------------------------------------------
char __cdecl sub_1000D1E0(unsigned int a1)
{
  int v1; // eax@1
  int v3; // [sp+4h] [bp-14h]@1
  __int16 v4; // [sp+8h] [bp-10h]@13
  int v5; // [sp+Ch] [bp-Ch]@13
  char v6; // [sp+10h] [bp-8h]@11
  char v7; // [sp+11h] [bp-7h]@13
  bool v8; // [sp+17h] [bp-1h]@16

  LOBYTE(v1) = a1;
  v3 = **(_WORD **)(a1 + 52);
  if ( v3 == 32840 )
  {
    if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) & 0xC000 )
      *(_BYTE *)(a1 + 6) = 2;
    switch ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) )
    {
      case 0x21:
        v6 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) != 255 )
        {
          *(_BYTE *)(a1 + 6) = sub_100682F0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230), 1);
          if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 236) )
          {
            v5 = *(_DWORD *)(a1 + 56);
            v4 = -32705;
            v7 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
            sub_10002670(a1, (int)&v4, 12);
          }
        }
        break;
      case 0x38:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) == 255 )
          v8 = sub_10003B90(a1, *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8));
        break;
      case 0x39:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) == 255 )
        {
          v8 = sub_10003A30(a1, *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8));
        }
        else if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) != 255 )
        {
          v6 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
          *(_BYTE *)(a1 + 6) = sub_100682F0(
                                 a1,
                                 *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230),
                                 *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8));
          if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 236) )
          {
            v5 = *(_DWORD *)(a1 + 56);
            v4 = -32705;
            v7 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
            sub_10002670(a1, (int)&v4, 12);
          }
        }
        break;
      case 0x28:
        v6 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) == 255 )
        {
          sub_100682F0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 231), 0);
          if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 236) )
          {
            v5 = *(_DWORD *)(a1 + 56);
            v4 = -32705;
            v7 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
            sub_10002670(a1, (int)&v4, 12);
          }
        }
        else if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
        {
          sub_10068190(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
          if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 236) )
          {
            v5 = *(_DWORD *)(a1 + 56);
            v4 = -32705;
            v7 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
            sub_10002670(a1, (int)&v4, 12);
          }
        }
        else
        {
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
        }
        if ( dword_10658DFC )
          *((_BYTE *)dword_10658DFC + 786444) = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
        break;
      default:
        break;
    }
    LOBYTE(v1) = a1;
    if ( *(_BYTE *)(a1 + 6) == 1 )
      *(_BYTE *)(a1 + 6) = 0;
  }
  else if ( v3 == 32841 )
  {
    LOBYTE(v1) = a1;
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 68) )
    {
      *(_BYTE *)(a1 + 5) = 1;
      *(_BYTE *)(a1 + 6) = sub_10070780(a1, *(char **)(a1 + 56), *(_WORD **)(a1 + 52));
      v1 = *(_BYTE *)(a1 + 6);
      if ( v1 == 1 )
      {
        LOBYTE(v1) = sub_10070780(a1, *(char **)(a1 + 56), &unk_100E461C);
        *(_BYTE *)(a1 + 6) = v1;
      }
      *(_BYTE *)(a1 + 5) = 0;
    }
  }
  return v1;
}

//----- (1000D5C0) --------------------------------------------------------
char __cdecl sub_1000D5C0(int a1)
{
  char result; // al@1
  int v2; // ST04_4@4
  int v3; // [sp+4h] [bp-4h]@1

  result = a1;
  v3 = **(_WORD **)(a1 + 52);
  if ( v3 == 32840 )
  {
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10);
    result = v2 - 15;
    switch ( v2 )
    {
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 70:
      case 71:
      case 72:
        result = sub_1000D830(a1);
        break;
      default:
        return result;
    }
  }
  else if ( v3 == 32879 )
  {
    result = sub_1000DAE0(a1);
  }
  return result;
}

//----- (1000D680) --------------------------------------------------------
void sub_1000D680()
{
  ;
}

//----- (1000D6A0) --------------------------------------------------------
void __cdecl sub_1000D6A0(unsigned int a1)
{
  sub_10006A30();
  dword_10658DE8 = -1;
  *(_BYTE *)(a1 + 11) = 0;
  dword_105722F4 = 0;
  dword_105722F8 = 0;
  dword_105722FC = 8;
  sub_10003E90(a1);
  sub_1006DF50();
}
// 105722F4: using guessed type int dword_105722F4;
// 105722F8: using guessed type int dword_105722F8;
// 105722FC: using guessed type int dword_105722FC;
// 10658DE8: using guessed type int dword_10658DE8;

//----- (1000D6F0) --------------------------------------------------------
char __cdecl sub_1000D6F0(int a1)
{
  __int16 v2; // [sp+0h] [bp-D8h]@2
  int v3; // [sp+4h] [bp-D4h]@4

  if ( **(_WORD **)(a1 + 52) == 32787 )
    v2 = -32747;
  else
    v2 = -32746;
  v3 = 0;
  return sub_10002670(a1, (int)&v2, 204);
}

//----- (1000D760) --------------------------------------------------------
void __cdecl sub_1000D760(int a1, char a2)
{
  if ( a2 )
  {
    if ( a2 == 1 )
      dword_10658DE8 = sub_10006A40();
  }
  else
  {
    sub_100069C0();
    sub_10006BC0(dword_10658DE8);
    dword_10658DE8 = -1;
  }
}
// 10658DE8: using guessed type int dword_10658DE8;

//----- (1000D7B0) --------------------------------------------------------
int __cdecl sub_1000D7B0(int a1)
{
  int result; // eax@1

  dword_105722F4 = *(_DWORD *)a1;
  dword_105722F8 = *(_DWORD *)(a1 + 4);
  result = *(_DWORD *)(a1 + 8);
  dword_105722FC = *(_DWORD *)(a1 + 8);
  return result;
}
// 105722F4: using guessed type int dword_105722F4;
// 105722F8: using guessed type int dword_105722F8;
// 105722FC: using guessed type int dword_105722FC;

//----- (1000D7E0) --------------------------------------------------------
void sub_1000D7E0()
{
  byte_10658E04 = 0;
  byte_10658E05 = 0;
}
// 10658E04: using guessed type char byte_10658E04;
// 10658E05: using guessed type char byte_10658E05;

//----- (1000D800) --------------------------------------------------------
void __cdecl sub_1000D800(unsigned int a1)
{
  sub_1006E380(a1, -1, (int (__cdecl *)(int))sub_10004180, 0);
}

//----- (1000D830) --------------------------------------------------------
char __cdecl sub_1000D830(int a1)
{
  int v1; // eax@5
  int v3; // [sp+0h] [bp-1Ch]@1
  unsigned __int8 v4; // [sp+7h] [bp-15h]@19
  unsigned __int16 v5; // [sp+8h] [bp-14h]@16
  __int16 v6; // [sp+Ch] [bp-10h]@25
  int v7; // [sp+10h] [bp-Ch]@25
  unsigned __int8 v8; // [sp+14h] [bp-8h]@25
  char v9; // [sp+15h] [bp-7h]@25
  char v10; // [sp+16h] [bp-6h]@25
  char v11; // [sp+17h] [bp-5h]@25
  char v12; // [sp+18h] [bp-4h]@25

  v3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10);
  if ( v3 == 70 )
  {
    v1 = *(_DWORD *)(a1 + 56);
    if ( !*(_BYTE *)(v1 + 258) )
    {
      *(_BYTE *)(a1 + 6) = 2;
      return v1;
    }
    if ( sub_1000DDE0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259)) )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) = 26;
      LOBYTE(v1) = sub_1009B450(11, *(_DWORD *)(a1 + 52), 1, 1);
      return v1;
    }
    goto LABEL_15;
  }
  if ( v3 == 71 )
  {
    LOBYTE(v1) = a1;
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 258) )
    {
      sub_1000DE50(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259), -1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
      LOBYTE(v1) = a1;
      *(_BYTE *)(a1 + 6) = 2;
    }
  }
  else
  {
    if ( v3 != 72 )
    {
LABEL_15:
      if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) == 70 )
      {
        v5 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259);
        *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) = v5 + 15;
      }
      else
      {
        v5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) - 15;
      }
      LOBYTE(v1) = a1;
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 257) )
      {
        LOBYTE(v1) = *(_BYTE *)(*(_DWORD *)(a1 + 56) + v5 + 316);
        v4 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + v5 + 316);
        if ( v4 != 255 )
        {
          LOBYTE(v1) = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v4 + 4);
          if ( !(_BYTE)v1 )
          {
            if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v4 + 8) != -1 )
              sub_1000DC30(a1, *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v4 + 8));
            if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v4 + 3) == 1 )
              sub_1000DC50(a1, v4);
            v7 = 0;
            v6 = -32658;
            v8 = v4;
            v9 = v5 + 1;
            v11 = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v4 + 6);
            v12 = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v4 + 7);
            v10 = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v4 + 2);
            LOBYTE(v1) = sub_10002670(a1, (int)&v6, 16);
          }
        }
      }
      return v1;
    }
    LOBYTE(v1) = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 258);
    if ( (_BYTE)v1 )
    {
      sub_1000DE50(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259), 1);
      v1 = *(_DWORD *)(a1 + 56);
      *(_BYTE *)(v1 + 330) = 1;
      *(_BYTE *)(a1 + 6) = 2;
    }
  }
  return v1;
}

//----- (1000DAE0) --------------------------------------------------------
int __cdecl sub_1000DAE0(int a1)
{
  int result; // eax@1
  int v2; // edx@5
  __int16 *v3; // ecx@5
  __int16 *v4; // edx@6
  __int16 v5; // [sp+0h] [bp-90h]@2
  int v6; // [sp+4h] [bp-8Ch]@2
  char v7; // [sp+8h] [bp-88h]@2
  __int16 v8[60]; // [sp+Ch] [bp-84h]@5
  char v9; // [sp+84h] [bp-Ch]@10
  char v10; // [sp+85h] [bp-Bh]@10
  char v11; // [sp+86h] [bp-Ah]@2
  int i; // [sp+88h] [bp-8h]@2

  result = a1;
  if ( *(_DWORD *)(a1 + 48) )
  {
    v6 = 0;
    v5 = -32657;
    v11 = *(_BYTE *)(*(_DWORD *)(a1 + 48) + 260);
    v7 = *(_BYTE *)(*(_DWORD *)(a1 + 48) + 328);
    for ( i = 0; i < 12; ++i )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 48) + 4 * i + 268) )
      {
        v2 = *(_DWORD *)(*(_DWORD *)(a1 + 48) + 4 * i + 268);
        v3 = &v8[5 * i];
        *(_DWORD *)v3 = *(_DWORD *)v2;
        *((_DWORD *)v3 + 1) = *(_DWORD *)(v2 + 4);
        v3[4] = *(_WORD *)(v2 + 8);
      }
      else
      {
        v4 = &v8[5 * i];
        *(_DWORD *)v4 = 0;
        *((_DWORD *)v4 + 1) = 0;
        v4[4] = 0;
        v8[5 * i] = -1;
      }
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 258) = sub_10070500();
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 258) )
      sub_1000E030(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259));
    v9 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 258);
    v10 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259);
    result = sub_1009B450(11, (int)&v5, 1, 1);
  }
  return result;
}
// 1000DAE0: using guessed type __int16 var_84[60];

//----- (1000DC30) --------------------------------------------------------
int __cdecl sub_1000DC30(int a1, unsigned __int8 a2)
{
  return sub_1000DF10(a1, *(_DWORD *)(a1 + 56), a2);
}

//----- (1000DC50) --------------------------------------------------------
int __cdecl sub_1000DC50(int a1, unsigned __int8 a2)
{
  int result; // eax@1
  char v3; // [sp+1h] [bp-3h]@1
  unsigned __int8 i; // [sp+2h] [bp-2h]@7
  unsigned __int8 v5; // [sp+3h] [bp-1h]@1

  v3 = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 6);
  v5 = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 7);
  result = *(_DWORD *)(a1 + 56);
  if ( result == *(_DWORD *)(a1 + 48) )
  {
    if ( v3 == -1 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2) )
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2) = 0;
      else
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2) = 1;
    }
    else
    {
      for ( i = 0; i < (signed int)*(_BYTE *)(*(_DWORD *)(a1 + 56) + 257); ++i )
      {
        if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * i + 7) == v5
          && *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * i + 6) == v3 )
        {
          if ( i != a2 || *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2) )
          {
            if ( i != a2 )
              *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * i + 2) = 0;
          }
          else
          {
            *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * i + 2) = 1;
          }
        }
      }
    }
    result = *(_DWORD *)(a1 + 56);
    *(_BYTE *)(result + 330) = 1;
  }
  return result;
}

//----- (1000DDE0) --------------------------------------------------------
bool __cdecl sub_1000DDE0(int a1, char a2)
{
  void *v2; // ecx@3
  void *v3; // ecx@5
  bool v5; // [sp+1h] [bp-1h]@7

  v5 = a2 == 11
    && !*(_BYTE *)(*(_DWORD *)(a1 + 56) + 245)
    && ((v2 = (void *)(unsigned __int8)sub_100704E0((void *)a1), v2 == (void *)4) || sub_100704E0(v2) == 1)
    && ((unsigned int)sub_100705C0(v2) & 3 || sub_10070580(v3) == 1);
  return v5;
}

//----- (1000DE50) --------------------------------------------------------
char __cdecl sub_1000DE50(int a1, unsigned __int8 a2, char a3)
{
  int v3; // eax@1
  unsigned __int8 v5; // [sp+3h] [bp-5h]@4
  int i; // [sp+4h] [bp-4h]@1

  LOBYTE(v3) = a3 + a2;
  for ( i = a3 + a2; i < 12 && i >= 0; i += a3 )
  {
    v5 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + i + 316);
    if ( v5 == 255
      || *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v5 + 4)
      || i >= 12
      || *(_BYTE *)(*(_DWORD *)(a1 + 56) + 245) && i == 11 )
    {
      v3 = sub_1000DDE0(a1, i);
      if ( !(_BYTE)v3 )
        continue;
    }
    LOBYTE(v3) = i;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259) = i;
    return v3;
  }
  return v3;
}

//----- (1000DF10) --------------------------------------------------------
int __cdecl sub_1000DF10(int a1, int a2, unsigned __int8 a3)
{
  int result; // eax@1

  result = sub_1000DF40(a1, *(_DWORD *)(a1 + 56), a3);
  *(_BYTE *)(a2 + 260) = a3;
  return result;
}

//----- (1000DF40) --------------------------------------------------------
int __cdecl sub_1000DF40(int a1, int a2, unsigned __int8 a3)
{
  int result; // eax@1
  unsigned __int8 v4; // ST02_1@8
  unsigned __int8 i; // [sp+1h] [bp-1h]@2
  unsigned __int8 j; // [sp+1h] [bp-1h]@5

  result = a1;
  if ( a2 == *(_DWORD *)(a1 + 48) )
  {
    for ( i = 0; (signed int)i < 12; ++i )
    {
      *(_DWORD *)(a2 + 4 * i + 268) = 0;
      *(_BYTE *)(a2 + i + 316) = -1;
    }
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= (signed int)*(_BYTE *)(a2 + 257) )
        break;
      if ( *(_BYTE *)(*(_DWORD *)(a2 + 264) + 10 * j + 7) == a3 )
      {
        v4 = *(_BYTE *)(*(_DWORD *)(a2 + 264) + 10 * j + 5) - 1;
        *(_DWORD *)(a2 + 4 * v4 + 268) = *(_DWORD *)(a2 + 264) + 10 * j;
        *(_BYTE *)(a2 + v4 + 316) = j;
      }
    }
    *(_BYTE *)(a2 + 330) = 1;
  }
  return result;
}

//----- (1000E030) --------------------------------------------------------
char __cdecl sub_1000E030(int a1, unsigned __int8 a2)
{
  char result; // al@13
  unsigned __int8 v3; // [sp+2h] [bp-Ah]@5
  char v4; // [sp+3h] [bp-9h]@1
  signed int i; // [sp+4h] [bp-8h]@1
  signed int v6; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v6 = a2;
  for ( i = 0; i <= 12; ++i )
  {
    if ( v6 >= 12 )
      v6 = 0;
    v3 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + v6 + 316);
    if ( v3 != 255
      && !*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * v3 + 4)
      && v6 < 12
      && (!*(_BYTE *)(*(_DWORD *)(a1 + 56) + 245) || v6 != 11)
      || sub_1000DDE0(a1, v6) )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259) = v6;
      v4 = 1;
      break;
    }
    ++v6;
  }
  result = v4;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 258) = v4;
  return result;
}

//----- (1000E110) --------------------------------------------------------
void sub_1000E110()
{
  ;
}

//----- (1000E120) --------------------------------------------------------
void sub_1000E120()
{
  ;
}

//----- (1000E130) --------------------------------------------------------
void sub_1000E130()
{
  void *v0; // ecx@3
  int v1; // [sp+0h] [bp-Ch]@1
  char v2; // [sp+7h] [bp-5h]@1
  int v3; // [sp+8h] [bp-4h]@1

  v3 = 1;
  v2 = sub_1009B4F0(8, 1000);
  sub_1009B560(&v1);
  while ( 1 )
  {
    do
      sub_1009B560(&v1);
    while ( !(v1 & 1) );
    sub_1000A0E0();
    if ( !--v3 )
    {
      sub_1000E270(v0);
      v3 = 1;
    }
  }
}

//----- (1000E1A0) --------------------------------------------------------
int sub_1000E1A0()
{
  byte_105723A0 = 2;
  *(_DWORD *)dword_105725A8 = 0;
  dword_10572394 = 0;
  dword_10572370 = 0;
  dword_10572374 = 0;
  dword_10572378 = 0;
  dword_1057237C = 0;
  *(_DWORD *)&dword_10572380 = 0;
  dword_10572384 = 0;
  dword_10572388 = 0;
  dword_10572308 = 0;
  dword_1057230C = 0;
  dword_10572310 = 0;
  dword_10572314 = 0;
  dword_10572318 = 0;
  dword_1057231C = 0;
  dword_10572320 = 0;
  dword_10572324 = 0;
  dword_10572398 = 0;
  dword_105725AC = 1;
  dword_1057238C = (int)sub_1000E810;
  dword_10572390 = (int)sub_1000EA00;
  LOBYTE(dword_10572370) = 1;
  return sub_1009B420(45, 16);
}
// 10572308: using guessed type int dword_10572308;
// 1057230C: using guessed type int dword_1057230C;
// 10572310: using guessed type int dword_10572310;
// 10572314: using guessed type int dword_10572314;
// 10572318: using guessed type int dword_10572318;
// 1057231C: using guessed type int dword_1057231C;
// 10572320: using guessed type int dword_10572320;
// 10572324: using guessed type int dword_10572324;
// 10572370: using guessed type int dword_10572370;
// 10572374: using guessed type int dword_10572374;
// 1057237C: using guessed type int dword_1057237C;
// 10572384: using guessed type int dword_10572384;
// 10572388: using guessed type int dword_10572388;
// 1057238C: using guessed type int dword_1057238C;
// 10572390: using guessed type int dword_10572390;
// 10572394: using guessed type int dword_10572394;
// 10572398: using guessed type int dword_10572398;
// 105723A0: using guessed type char byte_105723A0;
// 105725AC: using guessed type int dword_105725AC;

//----- (1000E270) --------------------------------------------------------
int __thiscall sub_1000E270(void *this)
{
  int result; // eax@1

  sub_1000EB10(this);
  result = (unsigned __int8)byte_105723A0;
  if ( (signed int)(unsigned __int8)byte_105723A0 < 2 )
  {
    if ( !dword_10572388 || dword_105725AC || !(dword_10572370 & 1) )
      result = sub_1000E320();
    if ( dword_10572388 )
    {
      dword_10572374 = (int)&byte_105723A0;
      dword_10572378 = (int)&byte_105723A0;
      result = sub_10012A00((int)&dword_10572370);
      if ( dword_10572394 )
      {
        result = sub_1000EAA0((int)&dword_10572370, dword_10572378, "exit_code=%i%c\n", *(_DWORD *)dword_105725A8, 255);
        *(_DWORD *)dword_105725A8 = 0;
      }
    }
  }
  return result;
}
// 10572370: using guessed type int dword_10572370;
// 10572374: using guessed type int dword_10572374;
// 10572388: using guessed type int dword_10572388;
// 10572394: using guessed type int dword_10572394;
// 105723A0: using guessed type char byte_105723A0;
// 105725AC: using guessed type int dword_105725AC;

//----- (1000E320) --------------------------------------------------------
int sub_1000E320()
{
  int v1; // [sp+8h] [bp-40h]@1
  const char *v2; // [sp+Ch] [bp-3Ch]@1
  signed int (__cdecl *v3)(int, int, unsigned int, int); // [sp+10h] [bp-38h]@1
  char v4; // [sp+14h] [bp-34h]@1
  char v5; // [sp+15h] [bp-33h]@1
  __int16 v6; // [sp+16h] [bp-32h]@1
  const char *v7; // [sp+18h] [bp-30h]@1
  signed int (__cdecl *v8)(int, int, int, int); // [sp+1Ch] [bp-2Ch]@1
  char v9; // [sp+20h] [bp-28h]@1
  char v10; // [sp+21h] [bp-27h]@1
  __int16 v11; // [sp+22h] [bp-26h]@1
  const char *v12; // [sp+24h] [bp-24h]@1
  int (__cdecl *v13)(FILE *, int, int, int, int); // [sp+28h] [bp-20h]@1
  char v14; // [sp+2Ch] [bp-1Ch]@1
  char v15; // [sp+2Dh] [bp-1Bh]@1
  __int16 v16; // [sp+2Eh] [bp-1Ah]@1
  int v17; // [sp+30h] [bp-18h]@1
  int v18; // [sp+34h] [bp-14h]@1
  int v19; // [sp+38h] [bp-10h]@1
  int v20; // [sp+3Ch] [bp-Ch]@2
  int v21; // [sp+40h] [bp-8h]@8
  wint_t v22[2]; // [sp+44h] [bp-4h]@6
  int savedregs; // [sp+48h] [bp+0h]@8

  v2 = "print";
  v3 = sub_1000E5E0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = "reinit";
  v8 = sub_1000E520;
  v9 = 2;
  v10 = 0;
  v11 = 0;
  v12 = "version";
  v13 = sub_1000E6F0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v1 = 0;
  qmemcpy(&unk_10572328, &off_100CAC70, 0x48u);
  sub_1000E760();
  dword_105725AC = 0;
  if ( dword_10572388 )
    v20 = dword_10572388;
  else
    v20 = sub_10011590(0x80000);
  if ( v20 )
  {
    *(_DWORD *)v22 = sub_100102C0(v20, 0x2000);
    if ( *(_DWORD *)v22 )
    {
      sub_10011190(*(int *)v22, (int)sub_1000E790);
      sub_10010470(*(int *)v22, (int)(&savedregs - 7696));
      v21 = sub_100105B0(*(int *)v22, (char **)&unk_10572328, 0, 0);
      if ( v21 )
      {
        if ( sub_10011740(*(int *)v22, v21) )
        {
          sub_10010310(*(int *)v22, 0);
          sub_100102F0(*(int *)v22, (int)&dword_10572370);
          *(_DWORD *)&dword_10572380 = *(_DWORD *)v22;
          dword_10572384 = v21;
          dword_10572388 = v20;
          sub_1000A810(*(int *)v22, v21);
          sub_10011BE0(*(int *)v22, v21, &v2);
        }
        else
        {
          v1 = -15;
        }
      }
      else
      {
        v1 = -15;
      }
    }
    else
    {
      v1 = -15;
    }
  }
  else
  {
    v1 = -15;
  }
  if ( v1 < 0 )
  {
    if ( *(_DWORD *)v22 )
      iswlower(v22[0]);
    if ( v20 )
      sub_10010280(v20);
    *(_DWORD *)v22 = 0;
    v21 = 0;
    v20 = 0;
  }
  return v1;
}
// 100102C0: using guessed type _DWORD __cdecl sub_100102C0(_DWORD, _DWORD);
// 100CAC70: using guessed type char *off_100CAC70;
// 10572370: using guessed type int dword_10572370;
// 10572384: using guessed type int dword_10572384;
// 10572388: using guessed type int dword_10572388;
// 105725AC: using guessed type int dword_105725AC;

//----- (1000E520) --------------------------------------------------------
signed int __cdecl sub_1000E520(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@8
  int v5; // ST0C_4@9

  if ( a3 == 3
    && *(_DWORD *)a4 & 1
    && *(_DWORD *)a4 != -2147483647
    && *(_DWORD *)(a4 + 4) & 1
    && *(_DWORD *)(a4 + 4) != -2147483647
    && *(_DWORD *)(a4 + 8) & 1
    && *(_DWORD *)(a4 + 8) != -2147483647 )
  {
    dword_105725AC = *(_DWORD *)a4 >> 1;
    v5 = *(_DWORD *)(a4 + 4) >> 1;
    dword_10572394 = *(_DWORD *)(a4 + 8) >> 1;
    if ( v5 )
      LOBYTE(dword_10572370) = dword_10572370 & 0xFE;
    else
      LOBYTE(dword_10572370) = dword_10572370 | 1;
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "invalid args %i to _reinit, expected (int new_cx, int file_upld )\n", a3);
    result = 0;
  }
  return result;
}
// 10572370: using guessed type int dword_10572370;
// 10572394: using guessed type int dword_10572394;
// 105725AC: using guessed type int dword_105725AC;

//----- (1000E5E0) --------------------------------------------------------
signed int __cdecl sub_1000E5E0(int a1, int a2, unsigned int a3, int a4)
{
  const char *v5; // [sp+10h] [bp-10h]@3
  int v6; // [sp+14h] [bp-Ch]@8
  unsigned int i; // [sp+18h] [bp-8h]@1
  unsigned int v8; // [sp+1Ch] [bp-4h]@3

  for ( i = 0; i < a3; ++i )
  {
    v5 = 0;
    v8 = sub_100101C0(a1, *(_DWORD *)(a4 + 4 * i));
    if ( v8 )
      v5 = (const char *)sub_10010FF0(v8);
    if ( !v5 )
      return 0;
    if ( i )
    {
      v6 = 32;
      sub_1000EA00((int)&dword_10572370, dword_10572378, (int)&v6, 1u);
    }
    sub_1000EA00((int)&dword_10572370, dword_10572378, (int)v5, strlen(v5));
  }
  v6 = 10;
  sub_1000EA00((int)&dword_10572370, dword_10572378, (int)&v6, 1u);
  return 1;
}
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);
// 10572370: using guessed type int dword_10572370;

//----- (1000E6F0) --------------------------------------------------------
int __cdecl sub_1000E6F0(FILE *a1, int a2, int a3, int a4, int a5)
{
  if ( a3 && *(_DWORD *)a4 & 1 && *(_DWORD *)a4 != -2147483647 )
    *(_DWORD *)a5 = 2 * sub_10010310((int)a1, *(_DWORD *)a4 >> 1) | 1;
  else
    *(_DWORD *)a5 = 2 * _fileno(a1) | 1;
  return 1;
}

//----- (1000E760) --------------------------------------------------------
int sub_1000E760()
{
  int result; // eax@2

  if ( *(_DWORD *)&dword_10572380 )
    result = iswlower(dword_10572380);
  *(_DWORD *)&dword_10572380 = 0;
  dword_10572384 = 0;
  return result;
}
// 10572384: using guessed type int dword_10572384;

//----- (1000E790) --------------------------------------------------------
unsigned int __cdecl sub_1000E790(int a1, char *a2, int a3)
{
  char v4; // [sp+0h] [bp-108h]@3
  unsigned int v5; // [sp+104h] [bp-4h]@3

  if ( !(*(_DWORD *)(a3 + 24) & 1) )
    *(_DWORD *)dword_105725A8 = 3;
  v5 = sub_10012650(a1, a2, a3, 1, &v4, 0x100u);
  return sub_1000EA00((int)&dword_10572370, dword_10572378, (int)&v4, v5);
}
// 10572370: using guessed type int dword_10572370;

//----- (1000E810) --------------------------------------------------------
unsigned int __cdecl sub_1000E810(int a1, int a2, unsigned int *a3, unsigned int a4)
{
  char *v4; // eax@6
  signed int v6; // [sp+0h] [bp-1Ch]@1
  signed int v7; // [sp+4h] [bp-18h]@1
  unsigned int v8; // [sp+8h] [bp-14h]@1
  signed int v9; // [sp+8h] [bp-14h]@18
  int v10; // [sp+10h] [bp-Ch]@6
  int v11; // [sp+18h] [bp-4h]@5
  unsigned int v12; // [sp+18h] [bp-4h]@23

  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( dword_10572398 )
  {
    dword_10572398 = (sub_1009B320() - dword_10572398) / 0x3E8u;
    dword_10572320 += dword_10572398;
    if ( dword_10572324 < (unsigned int)dword_10572398 )
      dword_10572324 = dword_10572398;
    dword_10572398 = 0;
  }
  v11 = sub_1009B2D0();
  do
  {
    v4 = (char *)a3 + v8;
    LOBYTE(v4) = **(_BYTE **)(a1 + 4);
    v10 = j_HWM_pvg_get_uart(v4, (char *)a3 + v8, a4 - v8);
    if ( v10 )
    {
      if ( v10 >= 0 )
      {
        v8 += v10;
        if ( *(_BYTE *)a1 & 1 )
        {
          v6 = 1;
        }
        else
        {
          v7 = 0;
          if ( *((_BYTE *)a3 + v8 - 1) == 255 )
          {
            v6 = 1;
            *((_BYTE *)a3 + v8 - 1) = 0;
            v9 = v8 - 1;
            if ( sub_100A7090(a3, v9, 0xFFFFFFFF) )
              v8 = 0;
            else
              v8 = v9 - 4;
          }
        }
      }
      else
      {
        v6 = 1;
      }
    }
    else if ( ++v7 >= 10 )
    {
      if ( v7 >= 1000 )
        sub_1009B4D0(1000);
      else
        sub_1009B4D0(100);
    }
    else
    {
      sub_1009B4D0(20);
    }
  }
  while ( !v6 && v8 < a4 );
  v12 = sub_1009B2D0() - v11;
  dword_10572318 += v12;
  if ( v12 > dword_1057231C )
    dword_1057231C = v12;
  dword_10572308 += v8;
  if ( v8 > dword_10572310 )
    dword_10572310 = v8;
  dword_10572398 = sub_1009B320();
  return v8;
}
// 1009C310: using guessed type int __cdecl j_HWM_pvg_get_uart(_DWORD, _DWORD, _DWORD);
// 10572308: using guessed type int dword_10572308;
// 10572310: using guessed type int dword_10572310;
// 10572318: using guessed type int dword_10572318;
// 1057231C: using guessed type int dword_1057231C;
// 10572320: using guessed type int dword_10572320;
// 10572324: using guessed type int dword_10572324;
// 10572398: using guessed type int dword_10572398;

//----- (1000EA00) --------------------------------------------------------
unsigned int __cdecl sub_1000EA00(int a1, int a2, int a3, unsigned int a4)
{
  signed int v4; // ST14_4@5
  int v5; // eax@5
  signed int v6; // edx@6
  signed int v8; // [sp+0h] [bp-Ch]@1
  signed int v9; // [sp+4h] [bp-8h]@1

  v8 = 0;
  v9 = a4;
  dword_1057230C += a4;
  if ( a4 > dword_10572314 )
    dword_10572314 = a4;
  do
  {
    if ( v8 )
      sub_1009B4D0(50);
    v4 = v9;
    v5 = a3;
    LOBYTE(v5) = **(_BYTE **)(a1 + 8);
    v9 = j_HWM_pvg_put_uart(v5, a3, v9);
    a3 += v4 - v9;
    if ( v9 <= 0 )
      break;
    v6 = v8++;
  }
  while ( v6 < 1200 );
  return a4 - v9;
}
// 1009C340: using guessed type int __cdecl j_HWM_pvg_put_uart(_DWORD, _DWORD, _DWORD);
// 1057230C: using guessed type int dword_1057230C;
// 10572314: using guessed type int dword_10572314;

//----- (1000EAA0) --------------------------------------------------------
unsigned int sub_1000EAA0(int arg0, int arg4, char *arg8, ...)
{
  int v4; // [sp+4h] [bp-4h]@1
  va_list va; // [sp+1Ch] [bp+14h]@1

  va_start(va, arg8);
  v4 = _vsnprintf(&byte_105723A8, 0x200u, arg8, va);
  if ( v4 < 0 || v4 == 512 )
  {
    v4 = 511;
    *(&byte_105723A8 + 511) = 0;
  }
  return sub_1000EA00(arg0, arg4, (int)&byte_105723A8, v4);
}

//----- (1000EB10) --------------------------------------------------------
int __fastcall sub_1000EB10(void *a1)
{
  int result; // eax@1
  char v2; // al@3
  int v3; // edx@3
  int v4; // ecx@4
  int v5; // [sp+0h] [bp-8h]@1
  signed int i; // [sp+4h] [bp-4h]@1

  byte_1057239C = 0;
  byte_1057239D = 0;
  result = (unsigned __int8)byte_105723A0;
  v5 = (unsigned __int8)byte_105723A0;
  for ( i = 0; i < 2; ++i )
  {
    v2 = sub_100714F0(a1);
    sub_10076F10(v2, i, (int)&byte_1057239C);
    result = (unsigned __int8)byte_1057239C;
    if ( byte_1057239C == 7 )
    {
      v4 = v5;
      if ( v5 != i )
      {
        LOBYTE(v3) = byte_1057239F;
        LOBYTE(result) = byte_1057239E;
        LOBYTE(v4) = i;
        result = j_HWM_pvg_set_uart(v4, result, v3, 23);
      }
      break;
    }
    a1 = (void *)(i + 1);
  }
  byte_105723A0 = i;
  return result;
}
// 1009C360: using guessed type int __cdecl j_HWM_pvg_set_uart(_DWORD, _DWORD, _DWORD, _DWORD);
// 1057239C: using guessed type char byte_1057239C;
// 1057239D: using guessed type char byte_1057239D;
// 1057239E: using guessed type char byte_1057239E;
// 1057239F: using guessed type char byte_1057239F;
// 105723A0: using guessed type char byte_105723A0;

//----- (1000EBA0) --------------------------------------------------------
signed int sub_1000EBA0()
{
  char v1; // [sp+3h] [bp-1h]@1

  v1 = 0;
  sub_1009C370();
  sub_10079340();
  sub_1000A720();
  sub_1000A830();
  sub_10009D20();
  unknown_libname_2();
  sub_10079100();
  nullsub_3();
  sub_100792F0();
  sub_100739E0();
  sub_1000A1A0();
  sub_10079220();
  sub_10079210();
  sub_10079200();
  sub_1006E510();
  sub_10079120();
  sub_1009B4B0(5);
  sub_1000A090();
  sub_100790F0();
  sub_1000E1A0();
  sub_1009C2B0(73, &v1);
  sub_1000A0C0(v1);
  return sub_100772F0();
}
// 1000A0B0: using guessed type int unknown_libname_2(void);
// 1009B820: using guessed type int nullsub_3(void);
// 1009C370: using guessed type int sub_1009C370(void);

//----- (1000EC50) --------------------------------------------------------
int __cdecl sub_1000EC50(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100A46E0(31, 0, *(_DWORD *)(a1 + 40));
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  else
    result = 0;
  return result;
}

//----- (1000EC80) --------------------------------------------------------
int __cdecl sub_1000EC80(int a1, void *a2)
{
  if ( !sub_100A4370(a1, 31, a2) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLSelectElement.c", 0xEEu);
  return 0;
}

//----- (1000ECC0) --------------------------------------------------------
int __cdecl sub_1000ECC0(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100A46E0(40, 0, *(_DWORD *)(a1 + 40));
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  else
    result = 0;
  return result;
}

//----- (1000ECF0) --------------------------------------------------------
int __cdecl sub_1000ECF0(int a1, void *a2)
{
  if ( !sub_100A4370(a1, 40, a2) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLSelectElement.c", 0x14Eu);
  return 0;
}

//----- (1000ED30) --------------------------------------------------------
int __cdecl sub_1000ED30(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100A46E0(62, 0, *(_DWORD *)(a1 + 40));
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  else
    result = 0;
  return result;
}

//----- (1000ED60) --------------------------------------------------------
int __cdecl sub_1000ED60(int a1, void *a2)
{
  if ( !sub_100A4370(a1, 62, a2) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLSelectElement.c", 0x1AEu);
  return 0;
}

//----- (1000EDA0) --------------------------------------------------------
int __cdecl sub_1000EDA0(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  sub_100A3AB0(a1, 52, (__int32 *)&v2);
  return v2;
}

//----- (1000EDD0) --------------------------------------------------------
int __cdecl sub_1000EDD0(int a1, int a2, int a3)
{
  int result; // eax@3
  char v4; // [sp+8h] [bp-14h]@1
  char v5; // [sp+16h] [bp-6h]@1

  _snprintf(&v4, 0xFu, "%i", a2);
  v5 = 0;
  if ( !sub_100A4370(a1, 52, &v4) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLSelectElement.c", 0x211u);
  if ( a3 )
  {
    sub_1000F8F0(a1, 0);
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000EE70) --------------------------------------------------------
int __cdecl sub_1000EE70(int a1, int a2, int a3)
{
  int v3; // esi@1

  v3 = sub_100105B0(**(_DWORD **)(a1 + 20), &off_10161050, a2, 0);
  if ( v3 )
    sub_10010570(**(_DWORD **)(a1 + 20), v3, a3);
  if ( !sub_10010800(**(_DWORD **)(a1 + 20), v3, (int *)&off_10161000) )
    v3 = 0;
  sub_10012DA0(a1, v3, a3, (int)"options");
  return v3;
}
// 10161000: using guessed type char *off_10161000;
// 10161050: using guessed type char *off_10161050;

//----- (1000EEE0) --------------------------------------------------------
signed int __cdecl sub_1000EEE0(int a1, int a2, signed int a3, int *a4)
{
  int v4; // eax@1
  signed int result; // eax@2
  const char *v6; // eax@5
  const char *v7; // eax@6
  char v8; // [sp+0h] [bp-4h]@0

  v4 = sub_10010550(a1, a2);
  if ( v4 )
  {
    if ( a3 & 1 )
    {
      switch ( a3 >> 1 )
      {
        case 0:
          v6 = (const char *)sub_1000EC50(v4);
          *a4 = sub_10010F20(a1, v6) | 4;
          return 1;
        case 1:
          v7 = (const char *)sub_1000ECC0(v4);
          goto LABEL_9;
        case 2:
          *a4 = 2 * sub_1000EDA0(v4) | 1;
          return 1;
        case 3:
          v7 = (const char *)sub_1000ED30(v4);
LABEL_9:
          *a4 = sub_10010F20(a1, v7) | 4;
          break;
        default:
          break;
      }
    }
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v8);
    result = 0;
  }
  return result;
}

//----- (1000EFA0) --------------------------------------------------------
signed int __usercall sub_1000EFA0@<eax>(char a1@<bpl>, int a2, int a3, signed int a4, signed int *a5)
{
  int v5; // edi@1
  signed int result; // eax@2
  signed int v7; // ebx@3
  unsigned int v8; // eax@6
  void *v9; // eax@6
  char v10; // bp@6
  unsigned int v11; // eax@10
  void *v12; // eax@10
  char v13; // bp@10
  signed int v14; // eax@13
  signed int v15; // ebp@14
  unsigned int v16; // eax@18
  void *v17; // eax@18
  char v18; // bp@18
  char v19; // [sp+0h] [bp-8h]@0

  v5 = sub_10010550(a2, a3);
  if ( v5 )
  {
    v7 = 1;
    if ( a4 & 1 )
    {
      switch ( a4 >> 1 )
      {
        case 0:
          if ( (*a5 & 7) == 4 )
          {
            v8 = sub_100101C0(a2, *a5);
            v9 = sub_10010FF0(v8);
            v10 = (char)v9;
            if ( !sub_1000EC80(v5, v9) )
              goto LABEL_21;
            sub_100110D0(a2, "unable to set Select node id to %i\n", v10);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected string for id attribute\n", a1);
            result = 0;
          }
          return result;
        case 1:
          if ( (*a5 & 7) == 4 )
          {
            v11 = sub_100101C0(a2, *a5);
            v12 = sub_10010FF0(v11);
            v13 = (char)v12;
            if ( !sub_1000ECF0(v5, v12) )
              goto LABEL_21;
            sub_100110D0(a2, "unable to set Select node onchange event to %i\n", v13);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected string for onchange event\n", a1);
            result = 0;
          }
          return result;
        case 2:
          v14 = *a5;
          if ( *a5 & 1 )
          {
            v15 = v14 >> 1;
            if ( !sub_1000EDD0(v5, v14 >> 1, 0) )
              goto LABEL_21;
            sub_100110D0(a2, "unable to set index to %i\n", v15);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected integer for selectedIndex\n", a1);
            result = 0;
          }
          return result;
        case 3:
          if ( (*a5 & 7) != 4 )
          {
            v7 = 0;
            sub_100110D0(a2, "expected string for title attribute\n", a1);
            goto LABEL_21;
          }
          v16 = sub_100101C0(a2, *a5);
          v17 = sub_10010FF0(v16);
          v18 = (char)v17;
          if ( !sub_1000ED60(v5, v17) )
            goto LABEL_21;
          sub_100110D0(a2, "unable to set Select node title to %i\n", v18);
          result = 0;
          break;
        default:
          goto LABEL_21;
      }
    }
    else
    {
LABEL_21:
      result = v7;
    }
  }
  else
  {
    sub_100110D0(a2, "unable to find priv pointer\n", v19);
    result = 0;
  }
  return result;
}
// 1000EFA0: could not find valid save-restore pair for ebp
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (1000F180) --------------------------------------------------------
int __cdecl sub_1000F180(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100A46E0(31, 0, *(_DWORD *)(a1 + 40));
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  else
    result = 0;
  return result;
}

//----- (1000F1B0) --------------------------------------------------------
int __cdecl sub_1000F1B0(int a1, void *a2)
{
  if ( !sub_100A4370(a1, 31, a2) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLInputElement.c", 0xF3u);
  return 0;
}

//----- (1000F1F0) --------------------------------------------------------
__int32 __cdecl sub_1000F1F0(char *a1)
{
  int v1; // eax@1
  __int32 result; // eax@2

  v1 = sub_100A46E0(36, 0, *((_DWORD *)a1 + 10));
  if ( v1 )
    result = j__atol(*(const char **)(v1 + 8));
  else
    result = 0;
  return result;
}

//----- (1000F220) --------------------------------------------------------
int __cdecl sub_1000F220(int a1, int a2)
{
  char v3; // [sp+4h] [bp-14h]@1

  _snprintf(&v3, 0xFu, "%i", a2);
  if ( !sub_100A4370(a1, 36, &v3) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLInputElement.c", 0x15Au);
  return 0;
}

//----- (1000F2A0) --------------------------------------------------------
int __cdecl sub_1000F2A0(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100A46E0(41, 0, *(_DWORD *)(a1 + 40));
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  else
    result = 0;
  return result;
}

//----- (1000F2D0) --------------------------------------------------------
int __cdecl sub_1000F2D0(int a1, void *a2)
{
  if ( !sub_100A4370(a1, 41, a2) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLInputElement.c", 0x1BAu);
  return 0;
}

//----- (1000F310) --------------------------------------------------------
int __cdecl sub_1000F310(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100A46E0(62, 0, *(_DWORD *)(a1 + 40));
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  else
    result = 0;
  return result;
}

//----- (1000F340) --------------------------------------------------------
int __cdecl sub_1000F340(int a1, void *a2)
{
  if ( !sub_100A4370(a1, 62, a2) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLInputElement.c", 0x21Au);
  return 0;
}

//----- (1000F380) --------------------------------------------------------
int __cdecl sub_1000F380(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100A46E0(64, 0, *(_DWORD *)(a1 + 40));
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  else
    result = 0;
  return result;
}

//----- (1000F3B0) --------------------------------------------------------
int __cdecl sub_1000F3B0(int a1, void *a2)
{
  if ( !sub_100A4370(a1, 64, a2) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLInputElement.c", 0x27Au);
  return 0;
}

//----- (1000F3F0) --------------------------------------------------------
int __cdecl sub_1000F3F0(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100A46E0(65, 0, *(_DWORD *)(a1 + 40));
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  else
    result = 0;
  return result;
}

//----- (1000F420) --------------------------------------------------------
int __cdecl sub_1000F420(int a1, void *a2, int a3)
{
  int result; // eax@3

  if ( !sub_100A4370(a1, 65, a2) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLInputElement.c", 0x2E2u);
  if ( a3 )
  {
    sub_1000F8F0(a1, 0);
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000F480) --------------------------------------------------------
int __cdecl sub_1000F480(int a1)
{
  sub_1000F8F0(a1, 1);
  return 0;
}

//----- (1000F4A0) --------------------------------------------------------
char *__cdecl sub_1000F4A0(int a1, int a2, int a3)
{
  int v3; // esi@1
  char *result; // eax@3

  v3 = sub_100105B0(**(_DWORD **)(a1 + 20), &off_10161108, a2, 0);
  if ( v3 )
    sub_10010570(**(_DWORD **)(a1 + 20), v3, a3);
  result = sub_10010800(**(_DWORD **)(a1 + 20), v3, (int *)&off_10161098);
  if ( result )
    result = (char *)v3;
  return result;
}
// 10161098: using guessed type char *off_10161098;
// 10161108: using guessed type char *off_10161108;

//----- (1000F500) --------------------------------------------------------
signed int __cdecl sub_1000F500(int a1, int a2, signed int a3, _DWORD *a4)
{
  char *v4; // eax@1
  signed int result; // eax@2
  const char *v6; // eax@5
  const char *v7; // eax@9
  char v8; // [sp+0h] [bp-4h]@0

  v4 = (char *)sub_10010550(a1, a2);
  if ( v4 )
  {
    if ( a3 & 1 )
    {
      switch ( a3 >> 1 )
      {
        case 0:
          v6 = (const char *)sub_1000F180((int)v4);
          goto LABEL_6;
        case 1:
          *a4 = 2 * sub_1000F1F0(v4) | 1;
          return 1;
        case 2:
          v6 = (const char *)sub_1000F2A0((int)v4);
          goto LABEL_6;
        case 3:
          v7 = (const char *)sub_1000F310((int)v4);
          goto LABEL_12;
        case 4:
          v6 = (const char *)sub_1000F380((int)v4);
LABEL_6:
          *a4 = sub_10010F20(a1, v6) | 4;
          return 1;
        case 5:
          v7 = (const char *)sub_1000F3F0((int)v4);
LABEL_12:
          *a4 = sub_10010F20(a1, v7) | 4;
          break;
        default:
          break;
      }
    }
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v8);
    result = 0;
  }
  return result;
}

//----- (1000F5D0) --------------------------------------------------------
signed int __usercall sub_1000F5D0@<eax>(char a1@<dil>, int a2, int a3, signed int a4, signed int *a5)
{
  int v5; // ebx@1
  signed int result; // eax@2
  signed int v7; // edi@3
  unsigned int v8; // eax@6
  void *v9; // eax@6
  char v10; // bp@6
  signed int v11; // eax@9
  unsigned int v12; // eax@15
  void *v13; // eax@15
  char v14; // bp@15
  unsigned int v15; // eax@19
  void *v16; // eax@19
  char v17; // bp@19
  unsigned int v18; // eax@23
  void *v19; // eax@23
  char v20; // bp@23
  unsigned int v21; // eax@27
  void *v22; // eax@27
  char v23; // bp@27
  char v24; // [sp-8h] [bp-10h]@3
  char v25; // [sp+0h] [bp-8h]@0

  v5 = sub_10010550(a2, a3);
  if ( v5 )
  {
    v24 = a1;
    v7 = 1;
    if ( a4 & 1 )
    {
      switch ( a4 >> 1 )
      {
        case 0:
          if ( (*a5 & 7) == 4 )
          {
            v8 = sub_100101C0(a2, *a5);
            v9 = sub_10010FF0(v8);
            v10 = (char)v9;
            if ( !sub_1000F1B0(v5, v9) )
              goto LABEL_31;
            sub_100110D0(a2, "unable to set Input node id to %i\n", v10);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected string for id attribute\n", v24);
            result = 0;
          }
          return result;
        case 1:
          v11 = *a5;
          if ( *a5 & 1 && v11 != -2147483647 )
          {
            if ( !sub_1000F220(v5, v11 >> 1) )
              goto LABEL_31;
            sub_100110D0(a2, "unable to set Input node maxlength to %i\n", 0);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected integer for maxlength attribute\n", v24);
            result = 0;
          }
          return result;
        case 2:
          if ( (*a5 & 7) == 4 )
          {
            v12 = sub_100101C0(a2, *a5);
            v13 = sub_10010FF0(v12);
            v14 = (char)v13;
            if ( !sub_1000F2D0(v5, v13) )
              goto LABEL_31;
            sub_100110D0(a2, "unable to set Input node onsubmit event to %i\n", v14);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected string for onsubmit event\n", v24);
            result = 0;
          }
          return result;
        case 3:
          if ( (*a5 & 7) == 4 )
          {
            v15 = sub_100101C0(a2, *a5);
            v16 = sub_10010FF0(v15);
            v17 = (char)v16;
            if ( !sub_1000F340(v5, v16) )
              goto LABEL_31;
            sub_100110D0(a2, "unable to set Input node title to %i\n", v17);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected string for title attribute\n", v24);
            result = 0;
          }
          return result;
        case 4:
          if ( (*a5 & 7) == 4 )
          {
            v18 = sub_100101C0(a2, *a5);
            v19 = sub_10010FF0(v18);
            v20 = (char)v19;
            if ( !sub_1000F3B0(v5, v19) )
              goto LABEL_31;
            sub_100110D0(a2, "unable to set Input node type to %i\n", v20);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected string for type attribute\n", v24);
            result = 0;
          }
          return result;
        case 5:
          if ( (*a5 & 7) == 4 )
          {
            v21 = sub_100101C0(a2, *a5);
            v22 = sub_10010FF0(v21);
            v23 = (char)v22;
            if ( !sub_1000F420(v5, v22, 0) )
              goto LABEL_31;
            sub_100110D0(a2, "unable to set Input node value to %i\n", v23);
            result = 0;
          }
          else
          {
            sub_100110D0(a2, "expected string for value attribute\n", v24);
            result = 0;
          }
          break;
        default:
          v7 = 0;
          sub_100110D0(a2, "unknown id %i for Input node\n", a4 >> 1);
          goto LABEL_31;
      }
    }
    else
    {
LABEL_31:
      result = v7;
    }
  }
  else
  {
    sub_100110D0(a2, "unable to find priv pointer\n", v25);
    result = 0;
  }
  return result;
}
// 1000F5D0: could not find valid save-restore pair for edi
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (1000F8A0) --------------------------------------------------------
int __fastcall sub_1000F8A0(int a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax@2

  if ( !a1 || (v2 = *(int (__cdecl **)(int, int))(a1 + 52)) == 0 )
    _wassert(L"FALSE", L"..\\lib\\adl\\dom_xml\\DOM_pub_mem.h", 0x75u);
  return v2(a1, a2);
}

//----- (1000F8D0) --------------------------------------------------------
unsigned int __usercall sub_1000F8D0@<eax>(const char *a1@<eax>)
{
  unsigned int result; // eax@2

  if ( a1 )
    result = strlen(a1);
  else
    result = 0;
  return result;
}

//----- (1000F8F0) --------------------------------------------------------
void __cdecl sub_1000F8F0(int a1, char a2)
{
  int v2; // edi@3
  int v3; // eax@5
  const char *v4; // esi@7
  int v5; // ebx@8
  unsigned int v6; // eax@8
  int v7; // edi@11
  int v8; // eax@13
  const char *v9; // esi@15
  int v10; // ebx@16
  unsigned int v11; // eax@16

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        v7 = *(_DWORD *)(a1 + 32);
        if ( !v7 )
          _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_utl_dom.c", 0x276u);
        v8 = sub_100A46E0(41, 0, *(_DWORD *)(a1 + 40));
        if ( v7 )
        {
          if ( v8 )
          {
            v9 = *(const char **)(v8 + 8);
            if ( v9 )
            {
              v10 = *(_DWORD *)(v7 + 20);
              v11 = sub_1000F8D0(v9);
              if ( !sub_100125C0(*(_DWORD *)v10, *(_DWORD *)(v10 + 8), (int)v9, v11, (int)"onSubmit", 0, &a1) )
                sub_100A38E0(v7, "error parsing onEvent script %s\n", v9);
            }
          }
        }
      }
    }
    else
    {
      v2 = *(_DWORD *)(a1 + 32);
      if ( !v2 )
        _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_utl_dom.c", 0x253u);
      v3 = sub_100A46E0(40, 0, *(_DWORD *)(a1 + 40));
      if ( v2 )
      {
        if ( v3 )
        {
          v4 = *(const char **)(v3 + 8);
          if ( v4 )
          {
            v5 = *(_DWORD *)(v2 + 20);
            v6 = sub_1000F8D0(v4);
            if ( !sub_100125C0(*(_DWORD *)v5, *(_DWORD *)(v5 + 8), (int)v4, v6, (int)"onChange", 0, &a1) )
              sub_100A38E0(v2, "error parsing onChange script %s\n", v4);
          }
        }
      }
    }
  }
}

//----- (1000FA20) --------------------------------------------------------
int __cdecl sub_1000FA20(int a1, int a2)
{
  int v2; // ecx@1
  int result; // eax@1
  int *v4; // edx@3

  v2 = *(_DWORD *)(a1 + 20);
  result = *(_DWORD *)(v2 + 4);
  if ( result )
  {
    v4 = *(int **)(result + 4);
    *(_DWORD *)(result + 4) = a2;
    *(_DWORD *)a2 = result;
    *(_DWORD *)(a2 + 4) = v4;
    *v4 = a2;
  }
  else
  {
    *(_DWORD *)(v2 + 4) = a2;
  }
  return result;
}

//----- (1000FA50) --------------------------------------------------------
int __cdecl sub_1000FA50(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // eax@2
  int v4; // eax@5
  _DWORD *v5; // ecx@5
  void (__cdecl *v6)(int, _DWORD); // eax@5
  int (__cdecl *v7)(int, int); // eax@8

  v2 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(v2 + 4) == a2 )
  {
    v3 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 == a2 )
      v3 = 0;
    *(_DWORD *)(v2 + 4) = v3;
  }
  v4 = *(_DWORD *)a2;
  v5 = *(_DWORD **)(a2 + 4);
  *(_DWORD *)(v4 + 4) = v5;
  *v5 = v4;
  v6 = *(void (__cdecl **)(int, _DWORD))(a1 + 48);
  if ( !v6 )
    _wassert(L"FALSE", L"..\\lib\\adl\\dom_xml\\DOM_pub_mem.h", 0x53u);
  v6(a1, *(_DWORD *)(a2 + 20));
  v7 = *(int (__cdecl **)(int, int))(a1 + 48);
  if ( !v7 )
    _wassert(L"FALSE", L"..\\lib\\adl\\dom_xml\\DOM_pub_mem.h", 0x53u);
  return v7(a1, a2);
}

//----- (1000FAD0) --------------------------------------------------------
signed int __cdecl sub_1000FAD0(int a1, int a2)
{
  _DWORD *v2; // eax@1
  signed int result; // eax@6

  v2 = *(_DWORD **)(*(_DWORD *)(a1 + 20) + 4);
  if ( v2 )
  {
    while ( v2 != (_DWORD *)a2 )
    {
      v2 = (_DWORD *)*v2;
      if ( v2 == *(_DWORD **)(*(_DWORD *)(a1 + 20) + 4) )
        v2 = 0;
      if ( !v2 )
        goto LABEL_6;
    }
    sub_1000FA50(a1, a2);
    result = 1;
  }
  else
  {
LABEL_6:
    nullsub_8(a2);
    result = 0;
  }
  return result;
}
// 1000F890: using guessed type int __cdecl nullsub_8(_DWORD);

//----- (1000FB20) --------------------------------------------------------
int __cdecl sub_1000FB20(int a1, char *a2, int a3)
{
  int v3; // ebp@1
  char v5; // [sp+10h] [bp-104h]@1

  v3 = sub_100102E0(a1);
  sub_10012650(a1, a2, a3, 1, &v5, 0x100u);
  return sub_100A38E0(v3, &v5);
}

//----- (1000FB90) --------------------------------------------------------
int __cdecl sub_1000FB90(int a1)
{
  return sub_100A5FA0(*(_DWORD *)(a1 + 12));
}

//----- (1000FBA0) --------------------------------------------------------
void __cdecl sub_1000FBA0(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  int v4; // eax@3
  int v5; // esi@4
  int v6; // ebp@5
  char v7; // al@7
  int v8; // edx@10
  unsigned int v9; // eax@10
  char *v10; // eax@11
  char v11; // cl@12
  bool v12; // zf@16

  v2 = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 20);
    if ( v3 )
    {
      v4 = *(_DWORD *)(v3 + 4);
      if ( v4 )
      {
        v5 = v4;
        do
        {
          v6 = *(_DWORD *)v5;
          if ( *(_DWORD *)v5 == *(_DWORD *)(*(_DWORD *)(v2 + 20) + 4) )
            v6 = 0;
          v7 = *(_BYTE *)(v5 + 8);
          if ( v7 & 2 )
          {
            *(_DWORD *)(v5 + 16) = a2;
            *(_BYTE *)(v5 + 8) = v7 & 0xFD;
          }
          else if ( *(_DWORD *)(v5 + 16) + *(_DWORD *)(v5 + 12) <= (unsigned int)(a2 + 100) )
          {
            v8 = *(_DWORD *)(v5 + 20);
            v9 = 0;
            if ( v8 )
            {
              v10 = *(char **)(v5 + 20);
              do
                v11 = *v10++;
              while ( v11 );
              v9 = (unsigned int)&v10[-v8 - 1];
            }
            if ( !sub_100125C0(
                    **(_DWORD **)(v2 + 20),
                    *(_DWORD *)(*(_DWORD *)(v2 + 20) + 8),
                    v8,
                    v9,
                    (int)"evnt",
                    0,
                    &a1) )
              nullsub_8(*(_DWORD *)(v5 + 20));
            v12 = (*(_BYTE *)(v5 + 8) & 1) == 0;
            *(_DWORD *)(v5 + 16) = a2;
            if ( !v12 )
              sub_1000FA50(v2, v5);
          }
          v5 = v6;
        }
        while ( v6 );
      }
    }
  }
}
// 1000F890: using guessed type int __cdecl nullsub_8(_DWORD);

//----- (1000FC70) --------------------------------------------------------
int __cdecl sub_1000FC70(int a1)
{
  int result; // eax@1
  _DWORD *v2; // eax@4
  int (__cdecl *v3)(int, _DWORD); // eax@9

  result = *(_DWORD *)(a1 + 20);
  if ( result )
  {
    if ( *(_DWORD *)(result + 4) )
    {
      do
        sub_1000FA50(a1, *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4));
      while ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4) );
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4) = 0;
    v2 = *(_DWORD **)(a1 + 20);
    if ( *v2 )
    {
      iswlower(*v2);
      **(_DWORD **)(a1 + 20) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 16) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 20) = 0;
    }
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 12) && *(_DWORD *)(a1 + 92) == a1 )
    {
      sub_10010280(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 12));
      sub_100102B0();
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 12) = 0;
    }
    v3 = *(int (__cdecl **)(int, _DWORD))(a1 + 48);
    if ( !v3 )
      _wassert(L"FALSE", L"..\\lib\\adl\\dom_xml\\DOM_pub_mem.h", 0x53u);
    result = v3(a1, *(_DWORD *)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
  }
  return result;
}

//----- (1000FD30) --------------------------------------------------------
int __cdecl sub_1000FD30(int a1)
{
  int v1; // eax@1
  int v2; // eax@2
  signed int v3; // eax@3
  signed int v4; // ebp@4
  int v5; // eax@5
  int v6; // edi@5
  int v7; // eax@10
  unsigned int v8; // ebx@10
  int v9; // eax@15
  int v10; // eax@21
  int v11; // ecx@24
  int result; // eax@24
  int v13; // [sp-14h] [bp-24h]@14
  int v14; // [sp-8h] [bp-18h]@6
  int v15; // [sp+Ch] [bp-4h]@1

  qmemcpy(&unk_10572630, &off_100CBD18, 0x48u);
  v1 = *(_DWORD *)(a1 + 92);
  v15 = 0;
  if ( v1 && (v2 = *(_DWORD *)(v1 + 20)) != 0 && (v3 = *(_DWORD *)(v2 + 12)) != 0 )
  {
    v4 = v3;
  }
  else
  {
    v4 = sub_10011590(0x40000);
    if ( !v4 )
      _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_utl_dom.c", 0x15Cu);
  }
  v5 = sub_100102C0(v4, 0x2000);
  v6 = v5;
  if ( !v5 )
  {
    v14 = 360;
    goto LABEL_7;
  }
  sub_10011190(v5, (int)sub_1000FB20);
  v7 = sub_100105B0(v6, (char **)&unk_10572630, 0, 0);
  v8 = v7;
  if ( !v7 )
  {
    v14 = 376;
    goto LABEL_7;
  }
  if ( !sub_10011740(v6, v7) )
  {
    v14 = 383;
    goto LABEL_7;
  }
  sub_10010310(v6, 0);
  sub_100102F0(v6, a1);
  sub_10010470(v6, (int)(&v13 - 7672));
  if ( !*(_DWORD *)(a1 + 20) )
  {
    v9 = sub_1000F8A0(a1, 24);
    if ( !v9 )
    {
      v14 = 411;
      goto LABEL_7;
    }
    *(_DWORD *)v9 = 0;
    *(_DWORD *)(v9 + 4) = 0;
    *(_DWORD *)(v9 + 8) = 0;
    *(_DWORD *)(v9 + 12) = 0;
    *(_DWORD *)(v9 + 16) = 0;
    *(_DWORD *)(v9 + 20) = 0;
    *(_DWORD *)(a1 + 20) = v9;
  }
  if ( **(_DWORD **)(a1 + 20) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_utl_dom.c", 0x1A6u);
  **(_DWORD **)(a1 + 20) = v6;
  *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8) = v8;
  *(_DWORD *)(*(_DWORD *)(a1 + 20) + 12) = v4;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 92) + 20) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 92) + 20) = sub_1000F8A0(a1, 24);
    v10 = *(_DWORD *)(*(_DWORD *)(a1 + 92) + 20);
    if ( !v10 )
    {
      v14 = 436;
LABEL_7:
      _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_utl_dom.c", v14);
    }
    *(_DWORD *)v10 = 0;
    *(_DWORD *)(v10 + 4) = 0;
    *(_DWORD *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 12) = 0;
    *(_DWORD *)(v10 + 16) = 0;
    *(_DWORD *)(v10 + 20) = 0;
  }
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 92) + 20);
  v14 = a1;
  *(_DWORD *)(v11 + 12) = v4;
  sub_10013B50(v14);
  sub_100138C0(a1);
  sub_100136A0(a1);
  sub_10012F50(a1);
  sub_1000A810(v6, v8);
  result = v15;
  if ( v15 < 0 )
  {
    if ( v6 )
    {
      iswlower(v6);
      result = v15;
    }
    if ( v4 )
    {
      sub_10010280(v4);
      result = v15;
    }
  }
  return result;
}
// 100102C0: using guessed type _DWORD __cdecl sub_100102C0(_DWORD, _DWORD);
// 100CBD18: using guessed type char *off_100CBD18;

//----- (1000FF40) --------------------------------------------------------
signed int __usercall sub_1000FF40@<eax>(int a1@<edi>, char *a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // esi@1
  int v4; // eax@8
  signed int v5; // eax@8
  signed int v6; // ebx@8
  int v8; // [sp+Ch] [bp-24h]@8
  unsigned int v9; // [sp+10h] [bp-20h]@8
  int v10; // [sp+14h] [bp-1Ch]@8
  int v11; // [sp+18h] [bp-18h]@8
  int v12; // [sp+1Ch] [bp-14h]@8
  int v13; // [sp+20h] [bp-10h]@8
  int v14; // [sp+24h] [bp-Ch]@8
  int (__cdecl *v15)(int); // [sp+28h] [bp-8h]@8
  int v16; // [sp+2Ch] [bp-4h]@8

  v2 = sub_100A6090(a1, a2, 1);
  v3 = v2;
  if ( v2 >= 0xFFFFFFC2 || !v2 )
    v3 = sub_100A5F80(a1);
  if ( v3 >= 0xFFFFFFC2 || !v3 )
  {
    sub_100A38E0(a1, "unable to open script %s\n", a2);
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_utl_dom.c", 0x339u);
  }
  v9 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v8 = 0;
  v10 = 0;
  v16 = 0;
  v4 = *(_DWORD *)(a1 + 20);
  v9 = v3;
  v11 = a1;
  v15 = sub_1000FB90;
  v12 = *(_DWORD *)v4;
  v13 = *(_DWORD *)(v4 + 8);
  v14 = *(_DWORD *)(v4 + 12);
  v5 = sub_10012A00((int)&v8);
  v6 = v5;
  if ( v5 < 0 )
    sub_100A38E0(a1, "error %i parsing script %s\n", v5, a2);
  if ( v3 < 0xFFFFFFC2 && v3 )
    sub_100A5F60(a1);
  return v6;
}

//----- (10010030) --------------------------------------------------------
signed int __cdecl sub_10010030(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // ebp@1
  int v4; // esi@1
  _DWORD *v5; // eax@1
  signed int result; // eax@8
  int v7; // edx@12
  char *v8; // eax@13
  char v9; // cl@14

  v2 = a2;
  v3 = 0;
  v4 = sub_100A46E0(56, 0, *(_DWORD *)(a2 + 40));
  v5 = *(_DWORD **)(a1 + 20);
  if ( !v5 || !*v5 )
    v3 = sub_1000FD30(a1);
  if ( !*(_DWORD *)(a1 + 20) && !v0 )
  {
    nullsub_8(*(_DWORD *)(v4 + 8));
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_utl_dom.c", 0x22Fu);
  }
  if ( v4 && *(_DWORD *)(v4 + 8) )
  {
    result = sub_1000FF40(a1, *(char **)(v4 + 8));
  }
  else
  {
    v7 = *(_DWORD *)(v2 + 8);
    if ( !v7 )
      goto LABEL_19;
    v8 = *(char **)(v2 + 8);
    do
      v9 = *v8++;
    while ( v9 );
    if ( sub_100125C0(
           **(_DWORD **)(a1 + 20),
           *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8),
           v7,
           (unsigned int)&v8[-v7 - 1],
           0,
           0,
           &a2) )
    {
LABEL_19:
      result = v3;
    }
    else
    {
      sub_100A38E0(a1, "error parsing script %s\n", *(_DWORD *)(v2 + 8));
      result = -15;
    }
  }
  return result;
}
// 1000F890: using guessed type int __cdecl nullsub_8(_DWORD);

//----- (10010140) --------------------------------------------------------
void *__cdecl sub_10010140(void *a1, unsigned int a2)
{
  return sub_10053FC0(a1, a2, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10010160) --------------------------------------------------------
int __cdecl sub_10010160(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 24) + 468) | 2;
}

//----- (10010180) --------------------------------------------------------
int __cdecl sub_10010180(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480) | 4;
}

//----- (100101A0) --------------------------------------------------------
unsigned int __cdecl sub_100101A0(int a1, char a2)
{
  return sub_10028AB0(a1, (int *)&a2, 2);
}

//----- (100101E0) --------------------------------------------------------
signed int __cdecl sub_100101E0(int a1, int a2)
{
  int v2; // ecx@1
  unsigned int v3; // eax@2
  int v4; // ecx@3
  unsigned int v5; // eax@4
  signed int result; // eax@6

  v2 = a2 & 7;
  if ( !(a2 & 7) )
  {
    v3 = a2 & 0xFFFFFFF8;
    if ( a2 & 0xFFFFFFF8 )
    {
      v4 = *(_DWORD *)(*(_DWORD *)v3 + 4);
      if ( (int (__cdecl **)(int, int, int, int, int))v4 == &off_101614B0 )
      {
        v5 = *(_DWORD *)(*(_DWORD *)(v3 + 4) + 8) & 0xFFFFFFFE;
        if ( !*(_DWORD *)(v5 + 48) && (char **)v5 != &off_101621B8 )
          return 1;
        return 2;
      }
      if ( *(_DWORD *)(v4 + 56) )
        return 2;
    }
    return 1;
  }
  if ( a2 & 1 && a2 != -2147483647 || v2 == 2 )
  {
    result = 4;
  }
  else if ( v2 == 4 )
  {
    result = 3;
  }
  else
  {
    result = v2 != 6 ? 0 : 5;
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);
// 101621B8: using guessed type char *off_101621B8;

//----- (10010260) --------------------------------------------------------
char *__cdecl sub_10010260(int a1, unsigned int a2)
{
  char *result; // eax@2

  if ( a2 < 6 )
    result = off_10162AE0[a2];
  else
    result = 0;
  return result;
}
// 10162AE0: using guessed type char *off_10162AE0[8];

//----- (10010280) --------------------------------------------------------
int *__cdecl sub_10010280(unsigned int a1)
{
  sub_100385B0((void *)(a1 + 108));
  sub_1003A7D0(a1);
  sub_10039E90(a1);
  return sub_10053E10(a1, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100102B0) --------------------------------------------------------
int sub_100102B0()
{
  int result; // eax@1

  nullsub_9();
  sub_1003BDA0();
  result = dword_1057267C;
  if ( dword_1057267C )
  {
    result = sub_100512D0(dword_1057267C);
    dword_1057267C = 0;
  }
  return result;
}
// 1003E720: using guessed type int nullsub_9(void);
// 1057267C: using guessed type int dword_1057267C;

//----- (100102E0) --------------------------------------------------------
int __cdecl sub_100102E0(int a1)
{
  return *(_DWORD *)(a1 + 280);
}

//----- (100102F0) --------------------------------------------------------
int __cdecl sub_100102F0(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(a1 + 280) = a2;
  return result;
}

//----- (10010310) --------------------------------------------------------
int __cdecl sub_10010310(int a1, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 16);
  if ( a2 != result )
  {
    *(_DWORD *)(a1 + 16) = a2;
    if ( a2 == 120 )
    {
      *(_BYTE *)(a1 + 20) = 72;
      *(_BYTE *)(a1 + 21) = 73;
    }
    else
    {
      *(_BYTE *)(a1 + 20) = 18;
      *(_BYTE *)(a1 + 21) = 19;
    }
  }
  return result;
}

//----- (10010340) --------------------------------------------------------
int *__cdecl sub_10010340(int a1, unsigned int a2)
{
  int *result; // eax@1

  result = (int *)a2;
  if ( a2 )
    result = sub_10053E10(a2, dword_10658DEC);
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10010360) --------------------------------------------------------
double *__cdecl sub_10010360(int a1, double a2)
{
  return sub_1001F5B0(a1, a2);
}

//----- (10010380) --------------------------------------------------------
int __cdecl sub_10010380(int a1, double a2, int a3)
{
  return sub_1001F5D0(a1, a2, a3);
}

//----- (100103A0) --------------------------------------------------------
int __cdecl sub_100103A0(int a1, double a2, int a3)
{
  return sub_1001F600(a1, a2, a3);
}

//----- (100103C0) --------------------------------------------------------
signed int __cdecl sub_100103C0(int a1, int a2)
{
  return sub_1003A860(*(_DWORD *)(a1 + 24), a2);
}

//----- (100103D0) --------------------------------------------------------
void __cdecl sub_100103D0(int a1, unsigned int a2)
{
  sub_1003A9D0(a1, a2, 0);
}

//----- (100103F0) --------------------------------------------------------
_DWORD *__cdecl sub_100103F0(int a1)
{
  if ( *(_DWORD *)(a1 + 44) == a1 + 28 )
    sub_1003E6D0((_DWORD **)(a1 + 28));
  if ( *(_DWORD *)(a1 + 76) == a1 + 60 )
    sub_1003E6D0((_DWORD **)(a1 + 60));
  return sub_1003B310(a1, 0);
}

//----- (10010430) --------------------------------------------------------
_DWORD *__cdecl sub_10010430(int a1)
{
  _DWORD *result; // eax@1
  unsigned int v2; // ecx@1

  result = *(_DWORD **)(a1 + 24);
  v2 = result[19];
  if ( v2 > 0x2000 && v2 > result[20] + (result[20] >> 1) || result[26] > result[21] )
    result = sub_100103F0(a1);
  return result;
}

//----- (10010470) --------------------------------------------------------
int __cdecl sub_10010470(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(a1 + 12) = a2;
  return result;
}

//----- (10010490) --------------------------------------------------------
int __cdecl sub_10010490(int a1, signed int a2, int *a3)
{
  int result; // eax@1

  result = a2;
  if ( a2 & 1 && a2 != -2147483647 || (result = sub_10038B20(a1, a2)) != 0 )
  {
    *a3 = result;
    result = 1;
  }
  return result;
}

//----- (100104C0) --------------------------------------------------------
signed int sub_100104C0()
{
  return 1;
}

//----- (100104E0) --------------------------------------------------------
signed int sub_100104E0()
{
  return 1;
}

//----- (10010500) --------------------------------------------------------
signed int sub_10010500()
{
  return 1;
}

//----- (10010520) --------------------------------------------------------
signed int __cdecl sub_10010520(int a1, int a2, int a3, _DWORD *a4)
{
  return sub_10018370(a1, a2, a3, a4);
}

//----- (10010540) --------------------------------------------------------
void sub_10010540()
{
  ;
}

//----- (10010550) --------------------------------------------------------
unsigned int __cdecl sub_10010550(int a1, int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@3

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
  if ( v2 & 1 && v2 != -2147483647 )
    result = v2 & 0xFFFFFFFE;
  else
    result = 0;
  return result;
}

//----- (10010570) --------------------------------------------------------
signed int __cdecl sub_10010570(int a1, int a2, int a3)
{
  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) = a3 | 1;
  return 1;
}

//----- (10010590) --------------------------------------------------------
_DWORD *__cdecl sub_10010590(int a1, int a2)
{
  _DWORD *result; // eax@1

  result = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) & 0xFFFFFFF8);
  if ( !result || !*result )
    result = 0;
  return result;
}

//----- (100105B0) --------------------------------------------------------
int __cdecl sub_100105B0(int a1, char **a2, int a3, unsigned int a4)
{
  char **v4; // eax@1

  v4 = a2;
  if ( !a2 )
    v4 = &off_10161510;
  return sub_10017C40(a1, (int)v4, a3, a4);
}
// 10161510: using guessed type char *off_10161510;

//----- (100105D0) --------------------------------------------------------
char *__usercall sub_100105D0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>, unsigned int a4@<esi>, int a5, signed int (*a6)(), signed int (*a7)(), int a8, int a9)
{
  int v9; // ebx@1
  char *result; // eax@2
  int (__cdecl **v11)(int, int, int, int, int); // ecx@4

  v9 = a1;
  if ( (char)a1 >= 0 )
  {
    result = sub_10038950(a3, a2, strlen((const char *)a2), 0);
    if ( !result )
      return result;
  }
  else
  {
    result = (char *)(2 * a2 | 1);
    v9 &= 0xFFFFFF7F;
  }
  if ( a8
    && ((v11 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)a4 + 4), v11 == &off_101614B0)
     || v11 && *v11 == off_101614B0) )
  {
    result = (char *)sub_10017EF0(a3, a4, (int)result, a5, a6, a7, v9, a8, a9, 0);
  }
  else
  {
    result = (char *)(*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)a4 + 4) + 12))(
                       a3,
                       a4,
                       result,
                       a5,
                       a6,
                       a7,
                       v9,
                       0);
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10010680) --------------------------------------------------------
int __usercall sub_10010680@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>, unsigned int a4@<esi>, _WORD *a5, int a6, signed int (*a7)(), signed int (*a8)(), int a9, int a10)
{
  int result; // eax@3
  int (__cdecl **v11)(int, int, int, int, int); // ecx@5

  if ( a1 == -1 )
    a1 = sub_1001AFC0(a5);
  result = sub_10038A10(a3, (int)a5, a1, 0);
  if ( result )
  {
    if ( a9
      && ((v11 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)a4 + 4), v11 == &off_101614B0)
       || v11 && *v11 == off_101614B0) )
    {
      result = sub_10017EF0(a3, a4, result, a6, a7, a8, a2, a9, a10, 0);
    }
    else
    {
      result = (*(int (__cdecl **)(int, unsigned int, int, int, signed int (*)(), signed int (*)(), int, _DWORD))(*(_DWORD *)(*(_DWORD *)a4 + 4) + 12))(
                 a3,
                 a4,
                 result,
                 a6,
                 a7,
                 a8,
                 a2,
                 0);
    }
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10010720) --------------------------------------------------------
int __cdecl sub_10010720(int a1, unsigned int a2, int a3, char **a4, int a5, int a6)
{
  char **v6; // eax@1
  int v7; // ebx@3

  v6 = a4;
  if ( !a4 )
    v6 = &off_10161510;
  v7 = sub_10017C40(a1, (int)v6, a5, a2);
  if ( !v7 )
    return 0;
  if ( !sub_100105D0(a6, a3, a1, a2, v7, 0, 0, 0, 0) )
  {
    *(_DWORD *)(a1 + 92) = 0;
    return 0;
  }
  return v7;
}
// 10161510: using guessed type char *off_10161510;

//----- (10010780) --------------------------------------------------------
char *__cdecl sub_10010780(int a1, unsigned int a2, int a3)
{
  int v3; // ebx@1
  char *result; // eax@1
  int v5; // eax@3
  int v6; // [sp+48h] [bp-4h]@2

  v3 = a3;
  for ( result = (char *)1; *(_DWORD *)(v3 + 8); v3 += 16 )
  {
    result = (char *)sub_1001F600(a1, *(double *)v3, (int)&v6);
    if ( !result )
      break;
    v5 = *(_BYTE *)(v3 + 12);
    if ( !*(_BYTE *)(v3 + 12) )
      v5 = 6;
    result = sub_100105D0(v5, *(_DWORD *)(v3 + 8), a1, a2, v6, 0, 0, 0, 0);
    if ( !result )
      break;
  }
  return result;
}

//----- (10010800) --------------------------------------------------------
char *__cdecl sub_10010800(int a1, unsigned int a2, int *a3)
{
  int *v3; // ebx@1
  int v4; // edx@1
  char *result; // eax@1

  v3 = a3;
  v4 = *a3;
  for ( result = (char *)1; v4; v3 += 4 )
  {
    result = sub_100105D0(
               *((_BYTE *)v3 + 5),
               v4,
               a1,
               a2,
               -2147483647,
               (signed int (*)())v3[2],
               (signed int (*)())v3[3],
               8,
               *((_BYTE *)v3 + 4));
    if ( !result )
      break;
    v4 = v3[4];
  }
  return result;
}

//----- (10010860) --------------------------------------------------------
char *__cdecl sub_10010860(int a1, unsigned int a2, int a3, int a4, signed int (*a5)(), signed int (*a6)(), int a7)
{
  return sub_100105D0(a7, a3, a1, a2, a4, a5, a6, 0, 0);
}

//----- (10010890) --------------------------------------------------------
char *__usercall sub_10010890@<eax>(const char *a1@<edx>, int a2@<ebx>, int a3@<edi>, int a4, int a5)
{
  char *result; // eax@1

  result = sub_10038950(a3, (int)a1, strlen(a1), 0);
  if ( result )
    result = (char *)(*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 8))(
                       a3,
                       a2,
                       result,
                       a4,
                       a5);
  return result;
}

//----- (100108D0) --------------------------------------------------------
char *__cdecl sub_100108D0(int a1, int a2, const char *a3, int a4)
{
  char *result; // eax@1

  result = sub_10038950(a1, (int)a3, strlen(a3), 0);
  if ( result )
    result = (char *)(*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(
                       a1,
                       a2,
                       result,
                       a4);
  return result;
}

//----- (10010920) --------------------------------------------------------
char *__cdecl sub_10010920(int a1, int a2, const char *a3, int a4)
{
  char *result; // eax@1

  result = sub_10038950(a1, (int)a3, strlen(a3), 0);
  if ( result )
    result = (char *)(*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(
                       a1,
                       a2,
                       result,
                       a4);
  return result;
}

//----- (10010970) --------------------------------------------------------
char *__cdecl sub_10010970(int a1, int a2, const char *a3, int a4)
{
  char *result; // eax@1

  result = sub_10038950(a1, (int)a3, strlen(a3), 0);
  if ( result )
    result = (char *)(*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 32))(
                       a1,
                       a2,
                       result,
                       a4);
  return result;
}

//----- (100109C0) --------------------------------------------------------
int __cdecl sub_100109C0(int a1, unsigned int a2, _WORD *a3, int a4, int a5, signed int (*a6)(), signed int (*a7)(), int a8)
{
  return sub_10010680(a4, a8, a1, a2, a3, a5, a6, a7, 0, 0);
}

//----- (10010A10) --------------------------------------------------------
int __cdecl sub_10010A10(int a1, int a2, int a3)
{
  return (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(a1, a2, 2 * a3 | 1);
}

//----- (10010A30) --------------------------------------------------------
int __cdecl sub_10010A30(int a1, int a2, int a3)
{
  return (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(a1, a2, 2 * a3 | 1);
}

//----- (10010A50) --------------------------------------------------------
int *__cdecl sub_10010A50(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  int *v4; // esi@1
  signed int v5; // eax@4
  int *v6; // eax@6
  int v7; // edi@7
  int i; // ebp@7
  int *v9; // eax@9
  int v11; // [sp+10h] [bp-Ch]@1
  int v12; // [sp+14h] [bp-8h]@1
  int v13; // [sp+18h] [bp-4h]@11

  v2 = a2;
  v3 = *(_DWORD *)a2;
  v4 = 0;
  v11 = 0;
  if ( (*(int (__cdecl **)(int, int, _DWORD, int *, int *))(*(_DWORD *)(v3 + 4) + 40))(a1, a2, 0, &v11, &v12)
    && v12 & 1
    && v12 != -2147483647 )
  {
    v5 = v12 >> 1;
    if ( v12 >> 1 <= 0 )
      v5 = 8;
    v6 = sub_10016E50(a1, v5);
    v4 = v6;
    if ( v6 )
    {
      v7 = 0;
      for ( i = (int)(v6 + 1); ; *(_DWORD *)(i + 4 * v7++) = v13 )
      {
        if ( v7 == *v4 )
        {
          v9 = sub_10016E80(a1, v4, *v4 + ((unsigned int)(*v4 + 1) >> 1));
          v4 = v9;
          if ( !v9 )
            break;
          i = (int)(v9 + 1);
        }
        if ( !(*(int (__cdecl **)(int, int, signed int, int *, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 40))(
                a1,
                a2,
                1,
                &v11,
                &v13) )
          break;
        if ( !v11 )
        {
          *v4 = v7;
          return v4;
        }
      }
      v2 = a2;
    }
  }
  if ( v11 )
    (*(void (__cdecl **)(int, int, signed int, int *, _DWORD))(*(_DWORD *)(*(_DWORD *)v2 + 4) + 40))(a1, v2, 2, &v11, 0);
  if ( v4 )
    sub_10010480(a1, v4);
  return 0;
}
// 10010480: using guessed type _DWORD __cdecl sub_10010480(_DWORD, _DWORD);

//----- (10010B60) --------------------------------------------------------
unsigned int __cdecl sub_10010B60(int a1)
{
  int v1; // eax@1
  unsigned int result; // eax@2

  v1 = *(_DWORD *)(a1 + 24);
  if ( v1 )
    result = *(_DWORD *)(v1 + 8) & 0xFFFFFFF8;
  else
    result = 0;
  return result;
}

//----- (10010B80) --------------------------------------------------------
char *__cdecl sub_10010B80(int a1, unsigned int a2, const char *a3, int a4, __int16 a5, int a6)
{
  char *result; // eax@1

  result = sub_10038950(a1, (int)a3, strlen(a3), 0);
  if ( result )
    result = (char *)sub_10028A40(a1, a2, (int)result, a4, a5, a6);
  return result;
}

//----- (10010BE0) --------------------------------------------------------
unsigned int __usercall sub_10010BE0@<eax>(int a1@<esi>, int a2, int a3, int a4, int *a5)
{
  int v5; // edi@1
  unsigned int v6; // ebx@2
  int v8; // [sp+Ch] [bp-100h]@1
  int v9; // [sp+28h] [bp-E4h]@1
  char v10; // [sp+44h] [bp-C8h]@1
  int v11; // [sp+70h] [bp-9Ch]@12

  v5 = 0;
  sub_1003E280((int)&v9, (int)"code", 1024, 1u);
  sub_1003E280((int)&v8, (int)"note", 1024, 1u);
  if ( sub_1003F880(a2, &v10, (int)&v9, (int)&v8, *(_DWORD *)(a1 + 172), *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 180)) )
  {
    if ( sub_1004AF40(a2, a3, a1, (int)&v10) )
    {
      v6 = sub_10021E70(a2, (int)&v10, 0);
    }
    else
    {
      v6 = 0;
      v5 = (*(_DWORD *)(a1 + 124) >> 1) & 1;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( a5 )
    *a5 = v5;
  if ( !sub_100456B0(a2, a1) )
  {
    if ( v6 )
      sub_10021340(a2, v6);
    v6 = 0;
  }
  v11 = a4;
  sub_1003F940(a2, (int)&v10);
  sub_1003E6D0((_DWORD **)&v9);
  sub_1003E6D0((_DWORD **)&v8);
  return v6;
}

//----- (10010CF0) --------------------------------------------------------
int __cdecl sub_10010CF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  int result; // eax@1
  unsigned int v9; // esi@2

  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 76) + 12);
  result = sub_100475A0(a1, a4, a5, a6, a7, a3);
  if ( result )
  {
    v9 = sub_10010BE0(result, a1, a2, v7, 0);
    if ( !v9 && !*(_DWORD *)(a1 + 56) )
      sub_10019FD0(a1);
    result = v9;
  }
  return result;
}

//----- (10010D70) --------------------------------------------------------
int __cdecl sub_10010D70(int a1, int a2, int a3, unsigned int a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // edi@3

  result = sub_1004C3A0(a1, a3, a4 & 0xFFFF7FFF, ~(unsigned __int8)(a4 >> 15) & 1);
  v5 = result;
  if ( result )
  {
    if ( sub_1004CA00(result, a2) )
    {
      v6 = sub_1004C470(v5);
      sub_1004C450(v5);
      result = v6;
    }
    else
    {
      sub_1004C450(v5);
      result = 0;
    }
  }
  return result;
}

//----- (10010DE0) --------------------------------------------------------
signed int __cdecl sub_10010DE0(int a1, int a2, int a3, _DWORD *a4)
{
  signed int result; // eax@4

  if ( sub_10038170(a1, a2, a3, 0, 0, a4) )
  {
    result = 1;
  }
  else
  {
    if ( !*(_DWORD *)(a1 + 56) )
      sub_10019FD0(a1);
    result = 0;
  }
  return result;
}

//----- (10010E20) --------------------------------------------------------
int __cdecl sub_10010E20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  int v8; // ebx@1
  int result; // eax@1
  int v10; // edi@1
  int v11; // ebx@2

  v8 = *(_DWORD *)(a1 + 300);
  *(_DWORD *)(a1 + 300) = v8 | 0x10;
  result = sub_10010CF0(a1, a2, a3, a4, a5, a6, a7);
  v10 = result;
  *(_DWORD *)(a1 + 300) = v8;
  if ( result )
  {
    v11 = sub_10038170(a1, a2, result, 0, 0, a8);
    if ( !v11 && !*(_DWORD *)(a1 + 56) )
      sub_10019FD0(a1);
    sub_10010D60(a1, v10);
    result = v11;
  }
  return result;
}
// 10010D60: using guessed type _DWORD __cdecl sub_10010D60(_DWORD, _DWORD);

//----- (10010EB0) --------------------------------------------------------
int __cdecl sub_10010EB0(int a1, unsigned int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // esi@1
  int v5; // eax@2
  int v6; // edi@2

  result = sub_1001B0E0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    v5 = sub_1001AB10(a1, result, a3, 0);
    v6 = v5;
    if ( v5 )
    {
      if ( !sub_1001B1C0(v5, a2) )
        sub_10010340(a1, a2);
      result = v6;
    }
    else
    {
      sub_10010340(a1, v4);
      result = 0;
    }
  }
  return result;
}

//----- (10010F20) --------------------------------------------------------
int __cdecl sub_10010F20(int a1, const char *a2)
{
  int result; // eax@2
  unsigned int v3; // edi@3
  unsigned int v4; // esi@3
  int v5; // edi@4

  if ( a2 )
  {
    v3 = strlen(a2);
    result = sub_1001B0E0(a1, (int)a2, v3);
    v4 = result;
    if ( result )
    {
      v5 = sub_1001AB10(a1, result, v3, 0);
      if ( !v5 )
        sub_10010340(a1, v4);
      result = v5;
    }
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480);
  }
  return result;
}

//----- (10010F90) --------------------------------------------------------
char *__cdecl sub_10010F90(int a1, const char *a2)
{
  char *result; // eax@1

  result = sub_10038950(a1, (int)a2, strlen(a2), 2);
  if ( result )
    result = (char *)(*((_DWORD *)result + 2) & 0xFFFFFFF8);
  return result;
}

//----- (10010FD0) --------------------------------------------------------
int __cdecl sub_10010FD0(int a1, int a2, unsigned int a3)
{
  return sub_1001AB10(a1, a2, a3, 0);
}

//----- (10010FF0) --------------------------------------------------------
void *__cdecl sub_10010FF0(unsigned int a1)
{
  void *result; // eax@1

  result = (void *)sub_1001B200(a1);
  if ( !result )
    result = &unk_100C4192;
  return result;
}

//----- (10011010) --------------------------------------------------------
void *__cdecl sub_10011010(unsigned int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  int v3; // ecx@3

  result = sub_1001B420(a1);
  if ( !result )
  {
    v2 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 & 0x40000000 )
    {
      v3 = *(_DWORD *)(a1 + 4);
      if ( *(_DWORD *)v3 & 0x40000000 )
      {
        result = (void *)sub_1001A200(a1);
      }
      else if ( (v2 & 0x80000000) == 0 )
      {
        result = (void *)(*(_DWORD *)(v3 + 4) + 2 * ((v2 >> 15) & 0x7FFF));
      }
      else
      {
        result = *(void **)(v3 + 4);
      }
    }
    else
    {
      result = *(void **)(a1 + 4);
    }
  }
  return result;
}

//----- (10011070) --------------------------------------------------------
int __cdecl sub_10011070(int *a1)
{
  int result; // eax@1

  result = *a1;
  if ( *a1 & 0x40000000 )
    result = *a1 & ((result & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  return result;
}

//----- (100110A0) --------------------------------------------------------
void *__cdecl sub_100110A0(int a1, unsigned int a2)
{
  void *result; // eax@1
  _BYTE *v3; // eax@2

  result = sub_1001A220(a1, a2);
  if ( result )
  {
    v3 = (_BYTE *)sub_1003A730(a2);
    *v3 &= 0xFDu;
    result = (void *)1;
  }
  return result;
}

//----- (100110D0) --------------------------------------------------------
signed int __cdecl sub_100110D0(int a1, char *a2, char a3)
{
  return sub_1003EF20(a1, 0, a2, (int)&a3);
}

//----- (100110F0) --------------------------------------------------------
signed int __cdecl sub_100110F0(int a1, int a2, int a3, int a4, char a5)
{
  return sub_1003F020(a1, 0, (int (__cdecl *)(int, _DWORD, int))a2, a3, a4, 1, (int)&a5);
}

//----- (10011120) --------------------------------------------------------
signed int __cdecl sub_10011120(int a1, char *a2, char a3)
{
  return sub_1003EF20(a1, 1, a2, (int)&a3);
}

//----- (10011140) --------------------------------------------------------
int __cdecl sub_10011140(int a1, int a2, int a3, int a4, int a5, char a6)
{
  return sub_1003F020(a1, a2, (int (__cdecl *)(int, _DWORD, int))a3, a4, a5, 1, (int)&a6);
}

//----- (10011170) --------------------------------------------------------
int __cdecl sub_10011170(int a1)
{
  return sub_1003E8D0(a1, (int (__cdecl *)(_DWORD, _DWORD, signed int))sub_1003ED50);
}

//----- (10011190) --------------------------------------------------------
int __cdecl sub_10011190(int a1, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 276);
  *(_DWORD *)(a1 + 276) = a2;
  return result;
}

//----- (100111B0) --------------------------------------------------------
int __cdecl sub_100111B0(int a1)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 228) = dword_10161A98;
  *(_DWORD *)(a1 + 232) = off_10161A9C;
  *(_DWORD *)(a1 + 220) = dword_10161A98;
  *(_DWORD *)(a1 + 224) = off_10161A9C;
  *(_DWORD *)(a1 + 244) = dword_10161A98;
  *(_DWORD *)(a1 + 248) = off_10161A9C;
  *(_DWORD *)(a1 + 236) = dword_10161A98;
  *(_DWORD *)(a1 + 240) = off_10161A9C;
  result = *(_DWORD *)(a1 + 24);
  *(_BYTE *)(result + 96) = 1;
  return result;
}
// 10161A98: using guessed type int dword_10161A98;

//----- (10011230) --------------------------------------------------------
int __cdecl sub_10011230(int a1)
{
  return *(_BYTE *)(a1 + 294);
}

//----- (10011240) --------------------------------------------------------
signed int __cdecl sub_10011240(int a1, _DWORD *a2)
{
  signed int result; // eax@2

  if ( *(_BYTE *)(a1 + 294) )
  {
    *a2 = *(_DWORD *)(a1 + 296);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10011270) --------------------------------------------------------
int __cdecl sub_10011270(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 294) = 1;
  *(_DWORD *)(a1 + 296) = a2;
  return result;
}

//----- (10011290) --------------------------------------------------------
int __cdecl sub_10011290(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 294) = 0;
  *(_DWORD *)(a1 + 296) = -2147483647;
  return result;
}

//----- (100112B0) --------------------------------------------------------
void __cdecl sub_100112B0(int a1, unsigned int a2)
{
  int v2; // eax@3

  if ( a2 )
  {
    if ( *(_DWORD *)a2 )
    {
      v2 = *(_DWORD *)(a2 + 4);
      if ( !(v2 & 1) && (v2 & 7) != 6 )
        sub_100103C0(a1, a2 + 4);
    }
    sub_10010340(a1, a2);
  }
}

//----- (100112F0) --------------------------------------------------------
int sub_100112F0()
{
  int result; // eax@1

  sub_1003E730();
  sub_1003E260();
  sub_1003AAE0();
  result = 0;
  word_1068B4AC = 0;
  dword_1057267C = 0;
  return result;
}
// 1057267C: using guessed type int dword_1057267C;
// 1068B4AC: using guessed type __int16 word_1068B4AC;

//----- (10011310) --------------------------------------------------------
int __usercall sub_10011310@<eax>(int a1@<ebx>, const char **a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  const char *v6; // edi@1
  int result; // eax@4

  v5 = *(_DWORD *)(a1 + 264);
  v6 = *a2;
  if ( v5 )
  {
    while ( strncmp(v6, *(const char **)v5, *(_DWORD *)(v5 + 4)) )
    {
      v5 = *(_DWORD *)(v5 + 12);
      if ( !v5 )
        goto LABEL_4;
    }
    *a2 = &v6[*(_DWORD *)(v5 + 4)];
    result = (*(int (__cdecl **)(int, const char *, int, int, int))(v5 + 8))(a1, v6, a3, a4, a5);
  }
  else
  {
LABEL_4:
    sub_100110F0(a1, (int)sub_1003ED50, 0, 4, (char)v6);
    result = 0;
  }
  return result;
}

//----- (10011380) --------------------------------------------------------
_WORD *__cdecl sub_10011380(int a1, signed int a2, int a3, signed int *a4)
{
  signed int *v4; // edi@1
  _WORD *result; // eax@2
  unsigned int v6; // eax@9
  unsigned int v7; // ecx@9
  int v8; // eax@11
  int v9; // ecx@11
  double *v10; // eax@14
  double *v11; // ecx@14
  int v12; // [sp+10h] [bp-20h]@16
  int v13; // [sp+14h] [bp-1Ch]@3
  double v14; // [sp+18h] [bp-18h]@13
  char v15; // [sp+20h] [bp-10h]@18

  v4 = a4;
  switch ( a3 )
  {
    case 0:
      *a4 = -2147483647;
      result = (_WORD *)1;
      break;
    case 1:
      result = (_WORD *)sub_10017450(a1, a2, (unsigned int *)&v13);
      if ( result )
        *v4 = v13;
      break;
    case 2:
      if ( a2 & 7
        || !(a2 & 0xFFFFFFF8)
        || (char **)(*(_DWORD *)(*(_DWORD *)((a2 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8 )
      {
        v6 = sub_10028AB0(a1, &a2, 2);
        v7 = v6;
        result = (_WORD *)(v6 != 0);
        if ( result )
          *v4 = *(_DWORD *)(v7 + 4);
      }
      else
      {
        *a4 = a2;
        result = (_WORD *)1;
      }
      break;
    case 3:
      v8 = sub_1001ACB0(a1, a2);
      v9 = v8;
      result = (_WORD *)(v8 != 0);
      if ( result )
        *v4 = v9 | 4;
      break;
    case 4:
      result = sub_10020030(a1, a2, &v14);
      if ( result )
      {
        v10 = sub_1001F5B0(a1, v14);
        v11 = v10;
        result = (_WORD *)(v10 != 0);
        if ( result )
          *v4 = (unsigned int)v11 | 2;
      }
      break;
    case 5:
      result = (_WORD *)sub_1002D390(a1, a2, &v12);
      if ( result )
        *v4 = 8 * v12 | 6;
      break;
    default:
      sub_10050B00((int)&v15, 12, "%d", a3);
      sub_100110F0(a1, (int)sub_1003ED50, 0, 5, (unsigned int)&v15);
      result = 0;
      break;
  }
  return result;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10011590) --------------------------------------------------------
signed int __cdecl sub_10011590(int a1)
{
  signed int result; // eax@1
  void *v2; // eax@2
  signed int v3; // esi@2

  result = sub_1001AAB0();
  if ( result )
  {
    v2 = (void *)sub_10053CF0(0x22A4u, dword_10658DEC);
    v3 = (signed int)v2;
    if ( !v2 )
      return 0;
    memset(v2, 0, 0x22A4u);
    *(_DWORD *)(v3 + 484) = v3 + 484;
    *(_DWORD *)(v3 + 488) = v3 + 484;
    *(_DWORD *)(v3 + 572) = v3 + 572;
    *(_DWORD *)(v3 + 576) = v3 + 572;
    *(_DWORD *)(v3 + 580) = v3 + 580;
    *(_DWORD *)(v3 + 584) = v3 + 580;
    if ( !sub_1003A750(v3, a1) || (*(_DWORD *)(v3 + 8780) = 1, !sub_10039E40(v3)) )
    {
      sub_10010280(v3);
      return 0;
    }
    result = v3;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10011630) --------------------------------------------------------
char *__cdecl sub_10011630(int a1, unsigned int a2)
{
  int v2; // edi@1
  int v3; // ebx@3
  int v4; // esi@5
  unsigned int *v5; // eax@5
  char *v7; // esi@13
  unsigned int v8; // eax@14
  unsigned int *v9; // ebp@16
  unsigned int v10; // [sp+10h] [bp-8h]@5
  unsigned int v11; // [sp+14h] [bp-4h]@5
  signed int v12; // [sp+1Ch] [bp+4h]@5

  v2 = a1;
  if ( !*(_DWORD *)(a1 + 88) )
    *(_DWORD *)(a1 + 88) = a2;
  v3 = *(_DWORD *)(a1 + 308);
  if ( v3 && *(_DWORD *)(v3 + 16) )
  {
    v4 = *(_DWORD *)(a1 + 24);
    v10 = a2;
    v12 = 1;
    v11 = *(_DWORD *)(v4 + 184);
    v5 = sub_1003F720(v3, (int)&v10, 1);
    if ( !v5 )
      goto LABEL_23;
    if ( v5[1] && *((_BYTE *)v5 + 12) & 1 )
    {
      v11 = *(_DWORD *)(v4 + 196);
      v5 = sub_1003F720(v3, (int)&v10, 1);
    }
    if ( !v5 )
    {
LABEL_23:
      sub_10011170(v2);
      return 0;
    }
    v5[1] = v10;
    v5[2] = v11;
    v5[3] = 1;
  }
  else
  {
    v12 = 0;
  }
  v7 = sub_100295A0(v2, a2);
  if ( v7 )
  {
    v8 = sub_10018A00(v2, a2);
    if ( v8 )
    {
      **((_DWORD **)v7 + 1) = v8;
      v9 = *(unsigned int **)(a2 + 4);
      if ( !(*v9 & 0xFFFFFFF8) )
        *v9 = v8;
    }
    else
    {
      v7 = 0;
    }
  }
  if ( v12 )
    sub_1003F720(v3, (int)&v10, 2);
  return v7;
}

//----- (10011740) --------------------------------------------------------
BOOL __cdecl sub_10011740(int a1, unsigned int a2)
{
  return (*(int (__cdecl **)(int, unsigned int, _DWORD, signed int, _DWORD, _DWORD, signed int, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 12))(
           a1,
           a2,
           *(_DWORD *)(*(_DWORD *)(a1 + 24) + 124),
           -2147483647,
           0,
           0,
           4,
           0)
      && sub_10011630(a1, a2)
      && sub_1002EA60(a1, a2)
      && sub_1002D550(a1, a2)
      && sub_1002A050(a1, a2)
      && sub_10020A00(a1, a2)
      && sub_1001DDF0(a1, a2)
      && sub_10028440(a1, a2)
      && sub_10026C50(a1, a2)
      && sub_10021DF0(a1, a2)
      && sub_10019CE0(a1, a2)
      && sub_1002D100(a1, a2);
}

//----- (10011830) --------------------------------------------------------
int __cdecl sub_10011830(int a1, unsigned int a2)
{
  signed int v2; // ecx@1
  int v3; // esi@3

  v2 = a2;
  if ( !a2 )
    v2 = 1;
  *(_DWORD *)(*(_DWORD *)(a1 + 24) + 104) += v2;
  v3 = sub_10053CF0(v2, dword_10658DEC);
  if ( !v3 )
    sub_10011170(a1);
  return v3;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10011870) --------------------------------------------------------
void *__cdecl sub_10011870(int a1, void *a2, unsigned int a3)
{
  void *result; // eax@1
  void *v4; // esi@1

  result = sub_10053FC0(a2, a3, dword_10658DEC);
  v4 = result;
  if ( !result )
  {
    sub_10011170(a1);
    result = v4;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100118A0) --------------------------------------------------------
void *__cdecl sub_100118A0(int a1, void *a2)
{
  unsigned int v2; // kr00_4@1
  void *result; // eax@1

  v2 = strlen((const char *)a2);
  result = (void *)sub_10011830(a1, v2 + 1);
  if ( result )
    result = memcpy(result, a2, v2 + 1);
  return result;
}

//----- (100118F0) --------------------------------------------------------
unsigned int __cdecl sub_100118F0(int a1, int a2)
{
  int v2; // esi@1
  unsigned int result; // eax@4

  v2 = a2;
  if ( !(*(int (__cdecl **)(int, int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(
          a1,
          a2,
          *(_DWORD *)(*(_DWORD *)(a1 + 24) + 236),
          &a2) )
    goto LABEL_6;
  if ( a2 & 7
    || !(a2 & 0xFFFFFFF8)
    || (result = a2 & 0xFFFFFFF8,
        (char **)(*(_DWORD *)(*(_DWORD *)((a2 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8) )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 9, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) & 0xFFFFFFFE));
LABEL_6:
    result = 0;
  }
  return result;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10011970) --------------------------------------------------------
int __cdecl sub_10011970(int a1, int a2, const char *a3, const char *a4)
{
  int v5; // eax@4
  int (__cdecl **v6)(int, int, int, int, int); // ecx@5
  char *v7; // eax@8
  int v8; // esi@9
  void (__cdecl *v9)(int, int, int); // eax@11
  void (__cdecl *v10)(int, int, int); // ecx@14
  int v11; // ST20_4@16
  int v12; // [sp+Ch] [bp-8h]@1
  int v13; // [sp+10h] [bp-4h]@1

  if ( !sub_10010890(a3, a2, a1, (int)&v13, (int)&v12) )
    return 0;
  if ( !v12 )
  {
    sub_1003F160(a1, (char)a3);
    return 0;
  }
  v5 = v13;
  if ( v13 != a2
    || (v6 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)a2 + 4), v6 != &off_101614B0)
    && (!v6 || *v6 != off_101614B0) )
  {
    v10 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v13 + 4) + 52);
    if ( v10 )
    {
      v10(a1, v13, v12);
      v5 = v13;
    }
    v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 8) & 0xFFFFFFFE);
    sub_100110F0(a1, (int)sub_1003ED50, 0, 10, (char)a4);
    return 0;
  }
  v7 = sub_10038950(a1, (int)a4, strlen(a4), 0);
  if ( v7 )
    v8 = sub_10015BB0(
           a1,
           a2,
           (int)v7,
           *(signed int (**)())(v12 + 4),
           *(signed int (**)())(v12 + 8),
           *(_DWORD *)(v12 + 12),
           *(_BYTE *)(v12 + 16),
           *(_BYTE *)(v12 + 17) | 4,
           *(_WORD *)(v12 + 18)) != 0;
  else
    v8 = 0;
  v9 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 52);
  if ( v9 )
    v9(a1, a2, v12);
  return v8;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10011AB0) --------------------------------------------------------
char *__cdecl sub_10011AB0(int a1, int a2, const char *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10010970(a1, a2, a3, (int)&v5);
}

//----- (10011AD0) --------------------------------------------------------
#error "10011AFC: call analysis failed (funcsize=46)"

//----- (10011B50) --------------------------------------------------------
signed int __cdecl sub_10011B50(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // eax@1
  signed int result; // eax@2
  void (__cdecl *v6)(int, int, unsigned int, int); // ecx@3
  char v7; // [sp+0h] [bp-4h]@0

  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE;
  if ( a3 < *(_BYTE *)(v4 + 5) )
  {
    v6 = *(void (__cdecl **)(int, int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 92);
    if ( v6 )
      v6(a1, a2, a3 + ((*(_DWORD *)(v4 + 4) & 1) != 0) + 3, a4);
    result = 1;
  }
  else
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 166, v7);
    result = 0;
  }
  return result;
}

//----- (10011BC0) --------------------------------------------------------
const char *__cdecl sub_10011BC0(int a1)
{
  int v1; // eax@1
  const char *result; // eax@2

  v1 = *(_DWORD *)(a1 + 24);
  if ( v1 )
    result = (const char *)sub_10010FF0(*(_DWORD *)(v1 + 8) & 0xFFFFFFF8);
  else
    result = "anonymous";
  return result;
}

//----- (10011BE0) --------------------------------------------------------
signed int __cdecl sub_10011BE0(int a1, unsigned int a2, const char **a3)
{
  const char **v3; // esi@1
  const char *v4; // eax@1
  char *v5; // eax@2
  __int16 v6; // dx@3
  signed int result; // eax@4

  v3 = a3;
  v4 = *a3;
  if ( *a3 )
  {
    while ( 1 )
    {
      v5 = sub_10010B80(a1, a2, v4, (int)v3[1], *((_BYTE *)v3 + 8), *((_BYTE *)v3 + 9));
      if ( !v5 )
        break;
      v6 = *((_WORD *)v3 + 5);
      v3 += 3;
      *((_WORD *)v5 + 9) = v6;
      v4 = *v3;
      if ( !*v3 )
        goto LABEL_4;
    }
    result = 0;
  }
  else
  {
LABEL_4:
    result = 1;
  }
  return result;
}

//----- (10011C40) --------------------------------------------------------
int __cdecl sub_10011C40(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return sub_10010CF0(a1, a2, 0, a3, a4, a5, a6);
}

//----- (10011C70) --------------------------------------------------------
int __usercall sub_10011C70@<eax>(char a1@<bpl>, int a2, int a3, unsigned int a4)
{
  const char *v4; // eax@1
  int result; // eax@1
  int v6; // esi@1
  int v7; // edi@3

  v4 = sub_10011BC0(a3);
  result = sub_1004C3A0(a2, (int)v4, a4 & 0xFFFF7FFF, ~(unsigned __int8)(a4 >> 15) & 1);
  v6 = result;
  if ( result )
  {
    if ( sub_1004CA20(a1, result, a3) )
    {
      v7 = sub_1004C470(v6);
      sub_1004C450(v6);
      result = v7;
    }
    else
    {
      sub_1004C450(v6);
      result = 0;
    }
  }
  return result;
}

//----- (10011CF0) --------------------------------------------------------
int __cdecl sub_10011CF0(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  return sub_10010E20(a1, a2, 0, a3, a4, a5, a6, a7);
}

//----- (10011D20) --------------------------------------------------------
signed int *__cdecl sub_10011D20(int a1)
{
  signed int *result; // eax@1
  signed int *v2; // esi@1
  signed int v3; // eax@2
  int *v4; // edx@2
  int v5; // eax@3

  result = (signed int *)sub_10011830(a1, 8u);
  v2 = result;
  if ( result )
  {
    v3 = sub_10011240(a1, result + 1);
    *v2 = v3;
    if ( v3 )
    {
      v5 = *v4;
      if ( !(*v4 & 1) && (v5 & 7) != 6 )
        sub_1003AB10(a1, (int)v4, (unsigned int)"JSExceptionState.exception");
    }
    result = v2;
  }
  return result;
}

//----- (10011D70) --------------------------------------------------------
void __cdecl sub_10011D70(int a1, int a2)
{
  unsigned int v2; // edx@3
  unsigned int v3; // edx@4

  if ( a2 )
  {
    if ( *(_DWORD *)a2 )
    {
      sub_10011270(a1, *(_DWORD *)(a2 + 4));
      sub_100112B0(a1, v2);
    }
    else
    {
      sub_10011290(a1);
      sub_100112B0(a1, v3);
    }
  }
}

//----- (10011DB0) --------------------------------------------------------
signed int __cdecl sub_10011DB0(int a1, int a2, signed int *a3, unsigned __int8 *a4, int a5)
{
  unsigned __int8 v5; // bl@1
  bool v6; // zf@1
  __int64 v7; // ST10_8@9
  __int64 v8; // ST10_8@11
  __int64 v9; // ST10_8@13
  int v10; // eax@21
  signed int v11; // eax@29
  int v12; // eax@31
  unsigned int v13; // eax@32
  unsigned int v14; // eax@33
  int v16; // edi@41
  char v17; // al@42
  int v18; // [sp+18h] [bp-30h]@1
  signed int *v19; // [sp+1Ch] [bp-2Ch]@1
  unsigned __int8 *v20; // [sp+20h] [bp-28h]@1
  int v21; // [sp+24h] [bp-24h]@27
  int v22; // [sp+28h] [bp-20h]@1
  signed int *v23; // [sp+2Ch] [bp-1Ch]@1
  double v24; // [sp+30h] [bp-18h]@19
  char v25; // [sp+38h] [bp-10h]@42

  v18 = a5;
  v19 = a3;
  v5 = *a4;
  v6 = *a4 == 0;
  v23 = a3;
  v20 = a4;
  v22 = 1;
  if ( v6 )
    return 1;
  while ( 1 )
  {
    ++v20;
    if ( !isspace(v5) )
      break;
LABEL_38:
    v5 = *v20;
    if ( !*v20 )
      return 1;
  }
  if ( v5 == 47 )
  {
    v22 = 0;
    goto LABEL_38;
  }
  if ( v19 != &v23[a2] )
  {
    switch ( v5 )
    {
      case 0x62u:
        v18 += 4;
        if ( !sub_1002D390(a1, *v19, *(signed int **)(v18 - 4)) )
          return 0;
        ++v19;
        goto LABEL_38;
      case 0x63u:
        v18 += 4;
        HIDWORD(v7) = *v19;
        LODWORD(v7) = a1;
        if ( !sub_10020310(v7, *(_WORD **)(v18 - 4)) )
          return 0;
        ++v19;
        goto LABEL_38;
      case 0x69u:
        v18 += 4;
        HIDWORD(v8) = *v19;
        LODWORD(v8) = a1;
        if ( !sub_10020180(v8, *(_DWORD **)(v18 - 4)) )
          return 0;
        ++v19;
        goto LABEL_38;
      case 0x75u:
        v18 += 4;
        HIDWORD(v9) = *v19;
        LODWORD(v9) = a1;
        if ( !sub_100201D0(v9, *(_DWORD **)(v18 - 4)) )
          return 0;
        ++v19;
        goto LABEL_38;
      case 0x6Au:
        v18 += 4;
        if ( !sub_10020220(a1, *v19, *(signed int **)(v18 - 4)) )
          return 0;
        ++v19;
        goto LABEL_38;
      case 0x64u:
        v18 += 4;
        if ( !sub_10020030(a1, *v19, *(double **)(v18 - 4)) )
          return 0;
        ++v19;
        goto LABEL_38;
      case 0x49u:
        if ( !sub_10020030(a1, *v19, &v24) )
          return 0;
        v18 += 4;
        *(double *)*(_DWORD *)(v18 - 4) = sub_1001F900(v24);
        ++v19;
        goto LABEL_38;
      case 0x53u:
      case 0x57u:
      case 0x73u:
        v10 = sub_1001ACB0(a1, *v19);
        if ( !v10 )
          return 0;
        *v19 = v10 | 4;
        if ( v5 == 115 )
        {
          v18 += 4;
          **(_DWORD **)(v18 - 4) = sub_10010FF0(v10);
          ++v19;
        }
        else if ( v5 == 87 )
        {
          v18 += 4;
          **(_DWORD **)(v18 - 4) = sub_10011010(v10);
          ++v19;
        }
        else
        {
          v18 += 4;
          **(_DWORD **)(v18 - 4) = v10;
          ++v19;
        }
        goto LABEL_38;
      case 0x6Fu:
        if ( !sub_10017450(a1, *v19, (unsigned int *)&v21) )
          return 0;
        *v19 = v21;
        v18 += 4;
        **(_DWORD **)(v18 - 4) = v21;
        ++v19;
        goto LABEL_38;
      case 0x66u:
        v11 = *v19;
        if ( *v19 & 7
          || !(v11 & 0xFFFFFFF8)
          || (v12 = v11 & 0xFFFFFFF8, (char **)(*(_DWORD *)(*(_DWORD *)(v12 + 4) + 8) & 0xFFFFFFFE) != &off_101621B8) )
        {
          v14 = sub_10028AB0(a1, v19, 0);
          if ( !v14 )
            return 0;
          *v19 = *(_DWORD *)(v14 + 4);
          v18 += 4;
          **(_DWORD **)(v18 - 4) = v14;
          ++v19;
        }
        else
        {
          v13 = sub_10010550(a1, v12);
          v18 += 4;
          **(_DWORD **)(v18 - 4) = v13;
          ++v19;
        }
        break;
      case 0x76u:
        v18 += 4;
        **(_DWORD **)(v18 - 4) = *v19;
        goto LABEL_36;
      case 0x2Au:
LABEL_36:
        ++v19;
        goto LABEL_38;
      default:
        --v20;
        if ( sub_10011310(a1, (const char **)&v20, 1, (int)&v19, (int)&v18) )
          goto LABEL_38;
        return 0;
    }
    goto LABEL_38;
  }
  if ( !v22 )
    return 1;
  v16 = sub_10028AB0(a1, v23 - 2, 0);
  if ( v16 )
  {
    sub_10050B00((int)&v25, 12, "%u", a2);
    v17 = (unsigned int)sub_10011BC0(v16);
    sub_100110F0(a1, (int)sub_1003ED50, 0, 3, v17);
  }
  return 0;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10012240) --------------------------------------------------------
char *__cdecl sub_10012240(int a1, unsigned int a2, int a3, int *a4, int a5, __int16 a6, int *a7, const char **a8, int *a9, const char **a10)
{
  char *v10; // eax@1
  char v11; // cl@2
  char *result; // eax@3
  int v13; // ebx@3
  int v14; // edi@4
  unsigned int v15; // ebx@7
  int v16; // eax@8
  int v17; // ST14_4@9
  int v18; // eax@10
  int v19; // [sp+Ch] [bp-Ch]@6
  char *v20; // [sp+10h] [bp-8h]@3
  char v21; // [sp+14h] [bp-4h]@22

  v10 = (char *)*a4;
  do
    v11 = *v10++;
  while ( v11 );
  result = sub_10038950(a1, *a4, (unsigned int)&v10[-*a4 - 1], 0);
  v13 = (int)result;
  v20 = result;
  if ( result )
  {
    v14 = sub_10017C40(a1, (int)a4, a3, a2);
    if ( !v14 )
      return 0;
    if ( a5 )
    {
      v16 = sub_10028A40(a1, a2, v13, a5, a6, 0);
      v19 = v16 != 0;
      if ( !v16 )
        goto LABEL_21;
      v15 = *(_DWORD *)(v16 + 4);
      v17 = *(_DWORD *)(v16 + 4);
      *(_DWORD *)(v16 + 28) = a4;
      if ( !sub_100173E0(a1, v17, v14, 6) )
      {
LABEL_20:
        v13 = (int)v20;
LABEL_21:
        if ( v19 )
          (*(void (__cdecl **)(int, unsigned int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 32))(a1, a2, v13, &v21);
        goto LABEL_23;
      }
      v18 = *(_DWORD *)(v15 + 4);
      if ( (int *)(*(_DWORD *)(v18 + 8) & 0xFFFFFFFE) == a4 )
        *(_DWORD *)v18 = v14;
    }
    else
    {
      v19 = (*(int (__cdecl **)(int, unsigned int, int, int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4)
                                                                                            + 12))(
              a1,
              a2,
              v13,
              v14,
              0,
              0,
              0,
              0);
      if ( !v19 )
      {
LABEL_23:
        *(_DWORD *)(a1 + 92) = 0;
        return 0;
      }
      v15 = v14;
    }
    if ( a7 && !sub_10010800(a1, v14, a7)
      || a8 && !sub_10011BE0(a1, v14, a8)
      || a9 && !sub_10010800(a1, v15, a9)
      || a10 && !sub_10011BE0(a1, v15, a10) )
    {
      goto LABEL_20;
    }
    result = (char *)v14;
  }
  return result;
}

//----- (100123C0) --------------------------------------------------------
signed int __cdecl sub_100123C0(int a1, int a2, int *a3, int a4)
{
  signed int result; // eax@2
  int v5; // eax@4
  int v6; // ST18_4@5

  if ( (int *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE) == a3 )
  {
    result = 1;
  }
  else
  {
    if ( a4 )
    {
      v5 = sub_10028AB0(a1, (int *)(a4 - 8), 0);
      if ( v5 )
      {
        v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE);
        sub_10011BC0(v5);
        sub_100110F0(a1, (int)sub_1003ED50, 0, 8, *a3);
      }
    }
    result = 0;
  }
  return result;
}

//----- (10012430) --------------------------------------------------------
unsigned int __cdecl sub_10012430(int a1, int a2, int *a3, int a4)
{
  unsigned int result; // eax@1

  result = sub_100123C0(a1, a2, a3, a4);
  if ( result )
    result = sub_10010550(a1, a2);
  return result;
}

//----- (10012470) --------------------------------------------------------
int __cdecl sub_10012470(int a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  int result; // eax@1
  unsigned int v7; // esi@1
  int v8; // ebx@2

  result = sub_1001B0E0(a1, a3, a4);
  v7 = result;
  if ( result )
  {
    v8 = sub_10011C40(a1, a2, result, a4, a5, a6);
    sub_10010340(a1, v7);
    result = v8;
  }
  return result;
}

//----- (100124C0) --------------------------------------------------------
signed int __cdecl sub_100124C0(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // ebp@1
  signed int result; // eax@2
  int v6; // ebx@3
  int v7; // edi@3
  int v8; // eax@6
  int v9; // [sp+Ch] [bp-Ch]@3
  int v10; // [sp+10h] [bp-8h]@4
  signed int *v11; // [sp+14h] [bp-4h]@3

  v4 = sub_1001B0E0(a1, a3, a4);
  if ( v4 )
  {
    v6 = 1;
    v11 = sub_10011D20(a1);
    v9 = *(_DWORD *)(*(_DWORD *)(a1 + 76) + 12);
    v7 = sub_100475A0(a1, v4, a4, 0, 0, 0);
    if ( v7 )
    {
      v10 = sub_10011190(a1, 0);
      if ( !sub_1004AE20(a1, a2, v7) )
        v6 = ~(unsigned __int8)(*(_DWORD *)(v7 + 124) >> 1) & 1;
      sub_10011190(a1, v10);
      sub_100456B0(a1, v7);
      v8 = *(_DWORD *)(a1 + 76);
      if ( v8 == a1 + 60 || v9 - *(_DWORD *)(v8 + 4) > (unsigned int)(*(_DWORD *)(v8 + 12) - *(_DWORD *)(v8 + 4)) )
        sub_1003E5E0(a1 + 60, v9);
      else
        *(_DWORD *)(v8 + 12) = (v9 + 3) & 0xFFFFFFFC;
    }
    sub_10010340(a1, v4);
    sub_10011D70(a1, (int)v11);
    result = v6;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100125C0) --------------------------------------------------------
int __cdecl sub_100125C0(int a1, int a2, int a3, unsigned int a4, int a5, int a6, _DWORD *a7)
{
  int result; // eax@1
  unsigned int v8; // esi@1
  int v9; // ebx@2

  result = sub_1001B0E0(a1, a3, a4);
  v8 = result;
  if ( result )
  {
    v9 = sub_10011CF0(a1, a2, result, a4, a5, a6, a7);
    sub_10010340(a1, v8);
    result = v9;
  }
  return result;
}

//----- (10012620) --------------------------------------------------------
signed int __cdecl sub_10012620(int a1, int a2, signed int *a3, unsigned __int8 *a4, char a5)
{
  return sub_10011DB0(a1, a2, a3, a4, (int)&a5);
}

//----- (10012650) --------------------------------------------------------
int __cdecl sub_10012650(int a1, char *a2, int a3, char a4, char *a5, size_t a6)
{
  char *v6; // ebp@1
  size_t v7; // esi@1
  int result; // eax@2
  size_t v9; // edi@7
  int v10; // eax@8
  int v11; // eax@13
  int v12; // eax@17
  bool v13; // zf@18
  const char *v14; // eax@18
  char *i; // edi@21
  const char *v16; // edi@22
  int v17; // eax@22
  size_t v18; // edi@27
  int v19; // eax@28
  int v20; // eax@32
  size_t v21; // esi@34
  int v22; // eax@36
  int v23; // eax@37
  int v24; // eax@40
  size_t v25; // esi@42
  int v26; // edx@44
  signed int v27; // ecx@44
  bool v28; // sf@44
  signed int v29; // ebp@44
  signed int v30; // eax@46
  int v31; // edi@47
  char *v32; // edi@50
  char v33; // al@51
  int v34; // eax@55
  int v35; // esi@57
  int v36; // [sp+10h] [bp-90h]@44
  unsigned int v37; // [sp+14h] [bp-8Ch]@47
  int v38; // [sp+18h] [bp-88h]@44
  char v39; // [sp+1Ch] [bp-84h]@7
  char v40; // [sp+9Bh] [bp-5h]@11
  int v41; // [sp+9Ch] [bp-4h]@13

  v6 = a2;
  v7 = a6;
  if ( !a3 )
  {
    result = _snprintf(a5, a6, "%s\n", a2);
    if ( result < 0 )
      result = a6;
    return result;
  }
  if ( *(_BYTE *)(a3 + 24) & 1 && !a4 )
    return 0;
  memset(&v39, 0, 0x80u);
  v9 = 128;
  if ( *(_DWORD *)a3 )
  {
    v10 = _snprintf(&v39, 0x80u, "%s:", *(_DWORD *)a3);
    if ( v10 < 0 || v10 == 128 )
    {
      v40 = 0;
      v9 = 0;
    }
    else
    {
      v9 = 128 - v10;
    }
  }
  if ( *(_DWORD *)(a3 + 4) )
  {
    v11 = _snprintf((char *)&v41 - v9, v9, "%u:", *(_DWORD *)(a3 + 4));
    if ( v11 < 0 || v11 == v9 )
    {
      v40 = 0;
      v9 = 0;
    }
    else
    {
      v9 -= v11;
    }
  }
  v12 = *(_DWORD *)(a3 + 24);
  if ( v12 & 1 )
  {
    v13 = (v12 & 4) == 0;
    v14 = "strict ";
    if ( v13 )
      v14 = (const char *)&unk_100C4192;
    _snprintf((char *)&v41 - v9, v9, "%swarning: ", v14);
  }
  v40 = 0;
  for ( i = strchr(a2, 10); i; i = strchr(v16, 10) )
  {
    v16 = i + 1;
    v17 = _snprintf(&a5[a6] - v7, v7, "%s%s\n", &v39, v6);
    if ( v17 < 0 || v17 == v7 )
    {
      a5[a6 - 1] = 0;
      v7 = 0;
    }
    else
    {
      v7 -= v17;
    }
    v6 = (char *)v16;
  }
  v18 = a6;
  if ( v39 )
  {
    v19 = _snprintf(&a5[a6] - v7, v7, "%s\n", &v39);
    if ( v19 < 0 || v19 == v7 )
    {
      a5[a6 - 1] = 0;
      v7 = 0;
    }
    else
    {
      v7 -= v19;
    }
  }
  v20 = _snprintf(&a5[a6] - v7, v7, "%s\n", v6);
  if ( v20 < 0 || v20 == v7 )
  {
    a5[a6 - 1] = 0;
    v21 = 0;
  }
  else
  {
    v21 = v7 - v20;
  }
  v22 = *(_DWORD *)(a3 + 8);
  if ( v22 )
  {
    v24 = _snprintf(&a5[a6] - v21, v21, ":\n%s%s%s%s", &v39, v22, "\n", &v39);
    if ( v24 < 0 || v24 == v21 )
    {
      a5[a6 - 1] = 0;
      v25 = 0;
    }
    else
    {
      v25 = v21 - v24;
    }
    v26 = 0;
    v27 = 0;
    v13 = *(_DWORD *)(a3 + 12) == *(_DWORD *)(a3 + 8);
    v28 = *(_DWORD *)(a3 + 12) - *(_DWORD *)(a3 + 8) < 0;
    v38 = *(_DWORD *)(a3 + 12) - *(_DWORD *)(a3 + 8);
    v39 = 0;
    v29 = 127;
    v36 = 0;
    if ( !v28 && !v13 )
    {
      while ( *(_BYTE *)(v26 + *(_DWORD *)(a3 + 8)) == 9 )
      {
        v30 = (v27 + 8) & 0xFFFFFFF8;
        if ( v27 < v30 )
        {
          v31 = v30 - v27;
          v37 = (v27 + 8) & 0xFFFFFFF8;
          do
          {
            strncat(&v39, word_100CC1C0, v29-- > 0);
            --v31;
          }
          while ( v31 );
          v26 = v36;
          v27 = v37;
LABEL_53:
          v18 = a6;
        }
        v36 = ++v26;
        if ( v26 >= v38 )
          goto LABEL_55;
      }
      v32 = (char *)&v38 + 3;
      do
        v33 = (v32++)[1];
      while ( v33 );
      *(_WORD *)v32 = 46;
      ++v27;
      goto LABEL_53;
    }
LABEL_55:
    strncat(&v39, "^\n", 3 * (v29 > 3));
    v34 = _snprintf(&a5[v18] - v25, v25, &v39);
    if ( v34 < 0 || v34 == v25 )
    {
      a5[v18 - 1] = 0;
      v35 = 0;
    }
    else
    {
      v35 = v25 - v34;
      if ( v35 > 0 )
        return v18 - v35;
    }
    sub_10070AD0("..\\lib\\adl\\SCR\\SCR_process.c", 400, 8, 0);
    return v18 - v35;
  }
  v23 = _snprintf(&a5[a6] - v21, v21, "\n");
  if ( v23 < 0 )
    v23 = v21;
  return a6 + v23 - v21;
}

//----- (10012A00) --------------------------------------------------------
signed int __cdecl sub_10012A00(int a1)
{
  _BYTE *v1; // eax@1
  _BYTE *v2; // ebp@1
  unsigned int v3; // ebx@3
  _BYTE *v4; // esi@3
  int v5; // edi@6
  void (__cdecl *v6)(int, unsigned int, const char *, signed int); // eax@6
  unsigned int v7; // ecx@7
  bool v8; // zf@12
  int v9; // eax@15
  int v10; // ebp@22
  signed int v11; // edi@24
  int v12; // eax@48
  int v13; // ebp@48
  int v14; // edi@49
  unsigned int v15; // eax@54
  const char *v16; // eax@55
  unsigned int v17; // ecx@56
  signed int v19; // [sp+8h] [bp-24h]@11
  _BYTE *v20; // [sp+Ch] [bp-20h]@1
  unsigned int v21; // [sp+10h] [bp-1Ch]@18
  signed int v22; // [sp+14h] [bp-18h]@11
  int v23; // [sp+18h] [bp-14h]@6
  int v24; // [sp+1Ch] [bp-10h]@3
  signed int v25; // [sp+20h] [bp-Ch]@3
  signed int v26; // [sp+24h] [bp-8h]@3
  int v27; // [sp+28h] [bp-4h]@49

  v1 = (_BYTE *)sub_10053CF0(0x80000u, dword_10658DEC);
  v2 = v1;
  v20 = v1;
  if ( !v1 )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_process.c", 0x1DCu);
  memset(v1, 0, 0x80000u);
  v3 = (unsigned int)v2;
  v4 = v2;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  while ( 2 )
  {
    if ( (_BYTE *)v3 != v4 )
      memcpy_0(v2, v4, v3 - (_DWORD)v4);
    v5 = a1;
    v6 = *(void (__cdecl **)(int, unsigned int, const char *, signed int))(a1 + 32);
    v3 += v2 - v4;
    v4 = v2;
    v23 = -1;
    if ( v6 )
    {
      v7 = *(_DWORD *)(a1 + 8);
      if ( v7 < 0xFFFFFFC2 )
      {
        if ( v7 )
          v6(a1, v7, "js>", 3);
      }
    }
    while ( 2 )
    {
      v22 = 0;
      v19 = 0;
LABEL_12:
      v8 = v4 == (_BYTE *)v3;
      while ( 1 )
      {
        if ( v8 )
        {
          if ( (signed int)(v3 - (_DWORD)v2) >= 0x80000 )
            _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_process.c", 0x214u);
          v9 = (*(int (__cdecl **)(int, _DWORD, unsigned int, _BYTE *))(v5 + 28))(
                 v5,
                 *(_DWORD *)(v5 + 4),
                 v3,
                 &v2[-v3 + 0x80000]);
          v23 = v9;
          if ( (_BYTE *)v9 == &v2[-v3 + 0x80000] )
            _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_process.c", 0x224u);
          v19 = v9;
        }
        if ( v19 < 0 )
          break;
        v3 += v19;
        v21 = v3;
        if ( !(*(_BYTE *)v5 & 1) && (!v23 || v3 - (_DWORD)v2 != 0x80000) )
        {
          v25 = 1;
          v4 = (_BYTE *)v3;
          break;
        }
        v8 = v4 == (_BYTE *)v3;
        if ( (unsigned int)v4 < v3 )
        {
          v10 = v4 - v20;
          while ( !v22 )
          {
            v11 = *v4++;
            ++v10;
            if ( v11 == 10 || v11 == 13 )
            {
              v22 = 1;
              if ( v11 == 13 )
              {
                if ( (unsigned int)v4 < v3 && *v4 == 10 )
                {
                  ++v4;
                  v11 = 10;
                  ++v10;
                }
              }
              else if ( v11 == 10 && v26 == 13 )
              {
                v22 = 0;
              }
            }
            else if ( v11 == 8 && v10 >= 2 )
            {
              memcpy_0(v4 - 2, v4, v21 - (_DWORD)v4);
              v10 -= 2;
              v21 -= 2;
              v4 -= 2;
              v3 = v21;
            }
            v26 = v11;
            if ( (unsigned int)v4 >= v3 )
            {
              if ( !v22 )
              {
                v2 = v20;
                v5 = a1;
                goto LABEL_12;
              }
              break;
            }
          }
          v2 = v20;
          break;
        }
      }
      v23 = v4 - v2;
      if ( v19 < 0 )
        _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_process.c", 0x280u);
      if ( !v25 && !sub_100124C0(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20), (int)v2, v4 - v2) )
      {
        v5 = a1;
        continue;
      }
      break;
    }
    if ( v19 >= 0 && v4 != v2 )
    {
      sub_10011290(*(_DWORD *)(a1 + 16));
      v12 = sub_10012470(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20), (int)v2, v4 - v2, 0, v24++);
      v13 = v12;
      if ( v12 )
      {
        v14 = a1;
        if ( sub_10010DE0(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20), v12, &v27) )
        {
          if ( v27 != -2147483647 )
          {
            if ( *(_BYTE *)a1 & 1 )
            {
              if ( *(_DWORD *)(a1 + 32) )
              {
                if ( *(_DWORD *)(a1 + 8) )
                {
                  v15 = sub_100101C0(*(_DWORD *)(a1 + 16), v27);
                  if ( v15 )
                  {
                    v16 = (const char *)sub_10010FF0(v15);
                    if ( v16 )
                    {
                      v17 = strlen(v16);
                      v14 = a1;
                      (*(void (__cdecl **)(int, _DWORD, const char *, unsigned int))(a1 + 32))(
                        a1,
                        *(_DWORD *)(a1 + 8),
                        v16,
                        v17);
                      (*(void (__cdecl **)(int, _DWORD, const char *, signed int))(v14 + 32))(
                        v14,
                        *(_DWORD *)(v14 + 8),
                        "\n",
                        1);
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          v19 = -15;
        }
        sub_10010D60(*(_DWORD *)(v14 + 16), v13);
        if ( v19 >= 0 && !v25 )
        {
          v2 = v20;
          continue;
        }
      }
      else
      {
        v19 = -15;
      }
      v2 = v20;
    }
    break;
  }
  sub_10053E10((unsigned int)v2, dword_10658DEC);
  return v19;
}
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);
// 10010D60: using guessed type _DWORD __cdecl sub_10010D60(_DWORD, _DWORD);
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10012DA0) --------------------------------------------------------
char *__cdecl sub_10012DA0(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // esi@1
  char *result; // eax@3

  v4 = sub_10010720(**(_DWORD **)(a1 + 20), a2, a4, &off_10161170, 0, 4);
  if ( v4 )
    sub_10010570(**(_DWORD **)(a1 + 20), v4, a3);
  result = sub_10010800(**(_DWORD **)(a1 + 20), v4, (int *)&off_10161150);
  if ( result )
    result = (char *)v4;
  return result;
}
// 10161150: using guessed type char *off_10161150;
// 10161170: using guessed type char *off_10161170;

//----- (10012E10) --------------------------------------------------------
signed int __usercall sub_10012E10@<eax>(char a1@<sil>, int a2, int a3, int a4)
{
  signed int result; // eax@2
  signed int v5; // esi@3
  char v6; // [sp-4h] [bp-8h]@3
  char v7; // [sp+0h] [bp-4h]@0

  if ( sub_10010550(a2, a3) )
  {
    v6 = a1;
    v5 = 1;
    if ( a4 & 1 )
    {
      if ( (a4 & 0xFFFFFFFE) == 510 )
      {
        v5 = 0;
        sub_100110D0(a2, "set length not suppported yet\n", v6);
      }
    }
    result = v5;
  }
  else
  {
    sub_100110D0(a2, "unable to find priv pointer\n", v7);
    result = 0;
  }
  return result;
}
// 10012E10: could not find valid save-restore pair for esi

//----- (10012E70) --------------------------------------------------------
int __usercall sub_10012E70@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@3
  int v3; // ecx@4
  int result; // eax@5

  if ( a1
    && *(_BYTE *)(a1 + 2) == 50
    && (v2 = sub_100A45C0(42, *(_DWORD *)(a1 + 28), a2)) != 0
    && (v3 = *(_DWORD *)(v2 + 32)) != 0 )
  {
    result = sub_10012FC0(v3, v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10012EB0) --------------------------------------------------------
signed int __cdecl sub_10012EB0(int a1, int a2, signed int a3, int *a4)
{
  int v4; // eax@1
  char v6; // [sp+0h] [bp-4h]@0

  v4 = sub_10010550(a1, a2);
  if ( !v4 )
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v6);
    return 0;
  }
  if ( a3 & 1 )
  {
    if ( a3 >> 1 != 255 )
    {
      *a4 = sub_10012E70(v4, a3 >> 1);
      return 1;
    }
    *a4 = 3;
  }
  return 1;
}

//----- (10012F10) --------------------------------------------------------
int __fastcall sub_10012F10(const char *a1, const char *a2)
{
  int result; // eax@1

  result = 1;
  if ( a2 )
  {
    if ( a1 )
      result = strcmp(a2, a1);
  }
  return result;
}

//----- (10012F50) --------------------------------------------------------
char __cdecl sub_10012F50(int a1)
{
  int v1; // eax@1

  v1 = sub_100105B0(**(_DWORD **)(a1 + 20), &off_10161218, 0, 0);
  dword_10572678 = v1;
  if ( v1 )
  {
    if ( sub_10010800(**(_DWORD **)(a1 + 20), v1, (int *)&off_101611B8)
      && sub_10011BE0(**(_DWORD **)(a1 + 20), dword_10572678, (const char **)&off_10161260) )
    {
      return 1;
    }
    dword_10572678 = 0;
  }
  return 0;
}
// 101611B8: using guessed type char *off_101611B8;
// 10161218: using guessed type char *off_10161218;
// 10161260: using guessed type char *off_10161260;
// 10572678: using guessed type int dword_10572678;

//----- (10012FC0) --------------------------------------------------------
int __cdecl sub_10012FC0(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@2
  int v4; // ebp@6
  char v5; // al@8
  char *v6; // eax@9

  result = 0;
  if ( dword_10572678 )
  {
    v3 = sub_100105B0(**(_DWORD **)(a1 + 20), &off_10161218, 0, 0);
    if ( v3 )
      sub_10010570(**(_DWORD **)(a1 + 20), v3, a2);
    if ( sub_10010800(**(_DWORD **)(a1 + 20), v3, (int *)&off_101611B8) )
    {
      if ( sub_10011BE0(**(_DWORD **)(a1 + 20), v3, (const char **)&off_10161260) )
      {
        v4 = sub_10010720(**(_DWORD **)(a1 + 20), v3, (int)off_10161288, &off_10161288, 0, 0);
        if ( v4 )
        {
          sub_10010570(**(_DWORD **)(a1 + 20), v4, a2);
          if ( sub_10010800(**(_DWORD **)(a1 + 20), v4, (int *)&off_101611F8) )
          {
            v5 = *(_BYTE *)(a2 + 2);
            switch ( v5 )
            {
              case 50:
                v6 = (char *)sub_1000EE70(a1, v3, a2);
                break;
              case 32:
                v6 = sub_1000F4A0(a1, v3, a2);
                break;
              case 57:
                v6 = (char *)sub_10050FD0(a1, v3, a2);
                break;
              default:
                if ( v5 != 58 )
                  return sub_10050B30(a1, v3, a2);
                v6 = sub_10050E30(a1, v3, a2);
                break;
            }
            v3 = (int)v6;
            return sub_10050B30(a1, v3, a2);
          }
        }
      }
    }
    result = 0;
  }
  return result;
}
// 101611B8: using guessed type char *off_101611B8;
// 101611F8: using guessed type char *off_101611F8;
// 10161218: using guessed type char *off_10161218;
// 10161260: using guessed type char *off_10161260;
// 10161288: using guessed type char *off_10161288;
// 10572678: using guessed type int dword_10572678;

//----- (100130E0) --------------------------------------------------------
signed int __cdecl sub_100130E0(int a1, int a2, signed int a3, int *a4)
{
  unsigned int v4; // ebp@1
  unsigned int v6; // eax@4
  const char *v7; // eax@4
  const char *v8; // esi@9
  int v9; // eax@12
  char v10; // [sp+0h] [bp-8h]@0

  v4 = sub_10010550(a1, a2);
  if ( !v4 )
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v10);
    return 0;
  }
  if ( (*a4 & 7) == 4 )
  {
    v6 = sub_100101C0(a1, *a4);
    v7 = (const char *)sub_10010FF0(v6);
  }
  else
  {
    v7 = 0;
  }
  if ( a3 & 1 )
  {
    if ( a3 >> 1 )
    {
      sub_100110D0(a1, "unknown id %i\n", a3 >> 1);
      return 0;
    }
    v8 = *(const char **)(v4 + 8);
    if ( v8 )
    {
      if ( !v7 || !sub_10012F10(*(const char **)(v4 + 8), v7) )
      {
        v9 = sub_10010F20(a1, v8);
        if ( !v9 )
        {
          sub_100110D0(a1, "string copyz failed for %s\n", *(_DWORD *)(v4 + 8));
          return 0;
        }
        *a4 = v9 | 4;
      }
    }
  }
  return 1;
}
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (100131B0) --------------------------------------------------------
signed int __usercall sub_100131B0@<eax>(char a1@<bpl>, int a2, int a3, signed int a4, _DWORD *a5)
{
  int v5; // edi@1
  signed int v6; // ebx@1
  unsigned int v8; // eax@4
  const char *v9; // esi@4
  unsigned int v10; // eax@4
  size_t v11; // ebp@6
  int v12; // esi@15
  int v13; // eax@18
  void (__cdecl *v14)(int, int); // ecx@19
  int v15; // eax@23
  int (__cdecl *v16)(int, size_t); // ecx@24
  void *v17; // eax@25
  int v18; // edi@31
  char v19; // [sp-4h] [bp-18h]@3
  char v20; // [sp+0h] [bp-14h]@0
  const char *v21; // [sp+Ch] [bp-8h]@4

  v5 = sub_10010550(a2, a3);
  v6 = 0;
  if ( !v5 )
  {
    sub_100110D0(a2, "unable to find priv pointer\n", v20);
    return 0;
  }
  v19 = a1;
  if ( (*a5 & 7) == 4 )
  {
    v8 = sub_100101C0(a2, *a5);
    v9 = (const char *)sub_10010FF0(v8);
    v10 = 0;
    v21 = v9;
    if ( v9 )
      v10 = strlen(v9);
    v11 = v10;
  }
  else
  {
    v21 = 0;
    v11 = 0;
    v9 = 0;
  }
  if ( !(a4 & 1) )
    return 1;
  if ( a4 >> 1 )
  {
    if ( a4 >> 1 != 1 )
    {
      sub_100110D0(a2, "unknown id %i\n", a4 >> 1);
      return 0;
    }
    if ( !v9 || !sub_100A4340(v5, (int)"class", (void *)v9) )
    {
      sub_100110D0(a2, "unable to set class name\n", v19);
      return 0;
    }
    return 1;
  }
  v12 = *(_DWORD *)(v5 + 8);
  if ( v12 )
  {
    if ( v11 && !sub_10012F10(*(const char **)(v5 + 8), v21) )
      return 1;
    v13 = *(_DWORD *)(v5 + 32);
    v6 = 1;
    if ( !v13 || (v14 = *(void (__cdecl **)(int, int))(v13 + 48)) == 0 )
      _wassert(L"FALSE", L"..\\lib\\adl\\dom_xml\\DOM_pub_mem.h", 0x53u);
    v14(v13, v12);
    *(_DWORD *)(v5 + 8) = 0;
  }
  if ( v11 )
  {
    v15 = *(_DWORD *)(v5 + 32);
    if ( !v15 || (v16 = *(int (__cdecl **)(int, size_t))(v15 + 52)) == 0 )
      _wassert(L"FALSE", L"..\\lib\\adl\\dom_xml\\DOM_pub_mem.h", 0x75u);
    v17 = (void *)v16(v15, v11 + 1);
    *(_DWORD *)(v5 + 8) = v17;
    if ( !v17 )
      return 0;
    memcpy(v17, v21, v11);
    *(_BYTE *)(*(_DWORD *)(v5 + 8) + v11) = 0;
    goto LABEL_31;
  }
  if ( v6 )
  {
LABEL_31:
    *(_BYTE *)(v5 + 1) |= 1u;
    v18 = *(_DWORD *)(v5 + 32);
    if ( v18 )
      *(_DWORD *)(v18 + 12) |= 2u;
  }
  return 1;
}
// 100131B0: could not find valid save-restore pair for ebp
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (100133A0) --------------------------------------------------------
signed int __usercall sub_100133A0@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5, int *a6)
{
  int v6; // ebx@3
  unsigned int v7; // eax@3
  unsigned int v8; // esi@3
  unsigned int v9; // eax@6
  const char *v10; // eax@6
  signed int result; // eax@7
  char v12; // al@8
  int v13; // eax@8
  const char *v14; // esi@8
  const char *v15; // eax@9
  int v16; // eax@11

  if ( a4 != 1 || (*a5 & 7) != 4 )
  {
    sub_100110D0(a2, "invalid args %i to appendChild\n", a4);
    result = 0;
  }
  else
  {
    v6 = sub_100102E0(a2);
    v7 = sub_10010550(a2, a3);
    v8 = v7;
    if ( v6 && v7 && *(_DWORD *)(v7 + 32) == v6 )
    {
      v9 = sub_100101C0(a2, *a5);
      v10 = (const char *)sub_10010FF0(v9);
      if ( v10 )
      {
        v12 = sub_100A6260(v10);
        v13 = sub_100A46E0(v12, 0, *(_DWORD *)(v8 + 40));
        v14 = (const char *)&unk_100C4192;
        if ( v13 )
        {
          v15 = *(const char **)(v13 + 8);
          if ( v15 )
            v14 = v15;
        }
        v16 = sub_10010F20(a2, v14);
        if ( v16 )
        {
          *a6 = v16 | 4;
          result = 1;
        }
        else
        {
          sub_100110D0(a2, "string copyz failed for %s\n", (char)v14);
          result = 0;
        }
      }
      else
      {
        sub_100110D0(a2, "invalid attribute names\n", a1);
        result = 0;
      }
    }
    else
    {
      sub_100110D0(a2, "unable to find priv pointer\n", a1);
      result = 0;
    }
  }
  return result;
}
// 100133A0: could not find valid save-restore pair for edi
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (100134C0) --------------------------------------------------------
int __usercall sub_100134C0@<eax>(char a1@<dil>, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@4
  unsigned int v6; // eax@4
  int v7; // esi@4
  unsigned int v8; // eax@7
  void *v9; // ebx@7
  unsigned int v10; // eax@7
  void *v11; // eax@7
  int v12; // eax@9
  int v13; // esi@9
  int result; // eax@11

  if ( a4 != 2 || (*(_DWORD *)a5 & 7) != 4 || (*(_DWORD *)(a5 + 4) & 7) != 4 )
  {
    sub_100110D0(a2, "invalid args %i to appendChild\n", a4);
    result = 0;
  }
  else
  {
    v5 = sub_100102E0(a2);
    v6 = sub_10010550(a2, a3);
    v7 = v6;
    if ( v5 && v6 && *(_DWORD *)(v6 + 32) == v5 )
    {
      v8 = sub_100101C0(a2, *(_DWORD *)a5);
      v9 = sub_10010FF0(v8);
      v10 = sub_100101C0(a2, *(_DWORD *)(a5 + 4));
      v11 = sub_10010FF0(v10);
      if ( v9 && v11 )
      {
        v12 = sub_100A4340(v7, (int)v9, v11);
        *(_BYTE *)(v7 + 1) |= 1u;
        v13 = *(_DWORD *)(v7 + 32);
        if ( v13 )
          *(_DWORD *)(v13 + 12) |= 2u;
        result = v12 != 0;
      }
      else
      {
        sub_100110D0(a2, "invalid attribute names\n", a1);
        result = 0;
      }
    }
    else
    {
      sub_100110D0(a2, "unable to find priv pointer\n", a1);
      result = 0;
    }
  }
  return result;
}
// 100134C0: could not find valid save-restore pair for edi
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (100135C0) --------------------------------------------------------
signed int __cdecl sub_100135C0(int a1, int a2, int a3, _DWORD *a4)
{
  signed int result; // eax@2
  unsigned int v5; // eax@4
  char v6; // [sp+0h] [bp-4h]@0

  if ( sub_10010550(a1, a2) )
  {
    if ( (*a4 & 7) == 4 )
    {
      v5 = sub_100101C0(a1, *a4);
      sub_10010FF0(v5);
    }
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v6);
    result = 0;
  }
  return result;
}
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (10013610) --------------------------------------------------------
signed int __cdecl sub_10013610(int a1, int a2, signed int a3, _DWORD *a4)
{
  int v4; // esi@1
  signed int result; // eax@2
  unsigned int v6; // eax@4
  char *v7; // eax@4
  int v8; // esi@9
  char v9; // [sp+0h] [bp-8h]@0

  v4 = sub_10010550(a1, a2);
  if ( v4 )
  {
    if ( (*a4 & 7) == 4 )
    {
      v6 = sub_100101C0(a1, *a4);
      v7 = (char *)sub_10010FF0(v6);
    }
    else
    {
      v7 = 0;
    }
    if ( a3 & 1 && !(unsigned __int8)(a3 >> 1) && !sub_100A5540(v4, 0, v7) )
    {
      *(_BYTE *)(v4 + 1) |= 1u;
      v8 = *(_DWORD *)(v4 + 32);
      if ( v8 )
        *(_DWORD *)(v8 + 12) |= 2u;
    }
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v9);
    result = 0;
  }
  return result;
}
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (100136A0) --------------------------------------------------------
char *__cdecl sub_100136A0(int a1)
{
  int v1; // eax@1
  unsigned int v2; // esi@1
  char *result; // eax@3

  v1 = sub_10010720(
         **(_DWORD **)(a1 + 20),
         *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8),
         (int)off_10161310,
         &off_10161310,
         0,
         4);
  v2 = v1;
  if ( v1 )
    sub_10010570(**(_DWORD **)(a1 + 20), v1, a1);
  result = sub_10010800(**(_DWORD **)(a1 + 20), v2, (int *)&off_101612D0);
  if ( result )
    result = (char *)v2;
  return result;
}
// 101612D0: using guessed type char *off_101612D0;
// 10161310: using guessed type char *off_10161310;

//----- (10013700) --------------------------------------------------------
signed int __cdecl sub_10013700(int a1, int a2, signed int a3, int *a4)
{
  signed int result; // eax@2
  int v5; // eax@8
  char v6; // [sp+0h] [bp-90h]@0
  char v7[4]; // [sp+Ch] [bp-84h]@8
  int v8; // [sp+10h] [bp-80h]@8

  if ( sub_10010550(a1, a2) )
  {
    if ( a3 & 1 )
    {
      if ( a3 >> 1 == 100 )
      {
        v5 = sub_10010F20(a1, "1.0 (GDU006-B0319-C114.01)");
      }
      else if ( a3 >> 1 == 101 )
      {
        v5 = sub_10010F20(a1, "GARMIN");
      }
      else
      {
        if ( a3 >> 1 != 102 )
          _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_Navigator.c", 0x10Eu);
        memset(v7, 0, 0x80u);
        v8 = 3100233;
        *(_DWORD *)v7 = 1297236295;
        strncat(v7, "1.0 (GDU006-B0319-C114.01)", 127 - strlen(v7));
        v5 = sub_10010F20(a1, v7);
      }
      *a4 = v5 | 4;
    }
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v6);
    result = 0;
  }
  return result;
}

//----- (10013840) --------------------------------------------------------
int __cdecl sub_10013840(int a1, int a2, signed int a3)
{
  char v4; // [sp+0h] [bp-4h]@0

  if ( sub_10010550(a1, a2) )
  {
    if ( a3 & 1 && a3 >> 1 != 100 && a3 >> 1 != 101 && a3 >> 1 != 102 )
      _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_Navigator.c", 0x15Fu);
    sub_100110D0(a1, "set navigator property not suppported\n", v4);
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_Navigator.c", 0x172u);
  }
  sub_100110D0(a1, "unable to find priv pointer\n", v4);
  return 0;
}

//----- (100138C0) --------------------------------------------------------
bool __cdecl sub_100138C0(int a1)
{
  int v1; // eax@1
  int v2; // edi@1
  bool result; // al@2
  bool v4; // bl@3

  v1 = sub_10010720(
         **(_DWORD **)(a1 + 20),
         *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8),
         (int)off_10161358,
         &off_10161358,
         0,
         0);
  v2 = v1;
  if ( v1 )
  {
    v4 = sub_10011BE0(**(_DWORD **)(a1 + 20), v1, (const char **)&off_101613A0) != 0;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 16) )
      _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_document.c", 0xA6u);
    result = v4;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 16) = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10161358: using guessed type char *off_10161358;
// 101613A0: using guessed type char *off_101613A0;

//----- (10013940) --------------------------------------------------------
int __usercall sub_10013940@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5, int *a6)
{
  int v6; // esi@3
  int result; // eax@4
  unsigned int v8; // eax@5
  const char *v9; // eax@5
  char v10; // bl@5
  int v11; // eax@7
  int v12; // eax@8
  int v13; // [sp+4h] [bp-8h]@5

  if ( a4 != 1 || (*a5 & 7) != 4 )
  {
    sub_100110D0(a2, "invalid args %i to getElementById\n", a4);
    result = 0;
  }
  else
  {
    v6 = sub_100102E0(a2);
    if ( v6 )
    {
      v8 = sub_100101C0(a2, *a5);
      v9 = (const char *)sub_10010FF0(v8);
      v10 = (char)v9;
      sub_100A6290(v9, (int)&v13);
      if ( (_BYTE)v13 == 68 )
      {
        sub_100110D0(a2, "unsupported element name %s\n", v10);
        result = 0;
      }
      else
      {
        v11 = sub_100A40C0(v6, v6 + 4, 0, 1, (int)&v13, 0);
        if ( v11 )
        {
          v12 = sub_10012FC0(v6, v11);
          *a6 = v12;
          result = v12 != 0;
        }
        else
        {
          sub_100110D0(a2, "could not create node %s\n", v10);
          result = 0;
        }
      }
    }
    else
    {
      sub_100110D0(a2, "unable to find priv pointer\n", a1);
      result = 0;
    }
  }
  return result;
}
// 10013940: could not find valid save-restore pair for edi
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (10013A50) --------------------------------------------------------
int __usercall sub_10013A50@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5, int *a6)
{
  int *v6; // edi@3
  int result; // eax@4
  unsigned int v8; // eax@6
  void *v9; // esi@6
  int v10; // eax@8
  int v11; // eax@9
  char v12; // [sp-8h] [bp-Ch]@3

  if ( a4 != 1 || (*a5 & 7) != 4 )
  {
    sub_100110D0(a2, "invalid args %i to getElementById\n", a4);
    result = 0;
  }
  else
  {
    v12 = a1;
    v6 = (int *)sub_100102E0(a2);
    if ( v6 )
    {
      if ( (*a5 & 7) == 4 )
      {
        v8 = sub_100101C0(a2, *a5);
        v9 = sub_10010FF0(v8);
      }
      else
      {
        v9 = 0;
      }
      v10 = sub_100A48A0(31, (int)v9, *v6);
      if ( v10 )
      {
        v11 = sub_10012FC0((int)v6, v10);
        *a6 = v11;
        result = v11 != 0;
      }
      else
      {
        sub_100110D0(a2, "element with id %s not found\n", (char)v9);
        result = 0;
      }
    }
    else
    {
      sub_100110D0(a2, "unable to find priv pointer\n", v12);
      result = 0;
    }
  }
  return result;
}
// 10013A50: could not find valid save-restore pair for edi
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (10013B20) --------------------------------------------------------
int __fastcall sub_10013B20(int a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax@2

  if ( !a1 || (v2 = *(int (__cdecl **)(int, int))(a1 + 52)) == 0 )
    _wassert(L"FALSE", L"..\\lib\\adl\\dom_xml\\DOM_pub_mem.h", 0x75u);
  return v2(a1, a2);
}

//----- (10013B50) --------------------------------------------------------
char __cdecl sub_10013B50(int a1)
{
  int v1; // eax@1
  unsigned int v2; // edi@1
  signed int v3; // ebx@5
  int v4; // eax@8

  v1 = sub_10010720(
         **(_DWORD **)(a1 + 20),
         *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8),
         (int)off_101613C8,
         &off_101613C8,
         0,
         0);
  v2 = v1;
  if ( !v1 )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_window.c", 0xCEu);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 20) )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_window.c", 0xD4u);
  *(_DWORD *)(*(_DWORD *)(a1 + 20) + 20) = v1;
  v3 = sub_10010570(**(_DWORD **)(a1 + 20), v1, a1);
  if ( !sub_10010800(**(_DWORD **)(a1 + 20), v2, (int *)&off_1016147C)
    || !sub_10011BE0(**(_DWORD **)(a1 + 20), v2, (const char **)&off_10161458) )
  {
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_window.c", 0xE0u);
  }
  if ( v3 )
  {
    v4 = sub_10010720(**(_DWORD **)(a1 + 20), v2, (int)"frames", &off_10161410, 0, 4);
    if ( !v4 )
      _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_window.c", 0xF9u);
    sub_10010570(**(_DWORD **)(a1 + 20), v4, a1);
  }
  return v3;
}
// 101613C8: using guessed type char *off_101613C8;
// 10161410: using guessed type char *off_10161410;
// 10161458: using guessed type char *off_10161458;
// 1016147C: using guessed type char *off_1016147C;

//----- (10013C60) --------------------------------------------------------
int __cdecl sub_10013C60(int a1)
{
  int v1; // ecx@2
  int result; // eax@3
  int v3; // eax@7

  if ( !a1 )
    goto LABEL_12;
  v1 = *(_DWORD *)(a1 + 20);
  if ( v1 )
  {
    result = *(_DWORD *)(v1 + 20);
    if ( result )
      return result;
    if ( v1 )
    {
      if ( *(_DWORD *)v1 )
        _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_window.c", 0x136u);
    }
  }
  sub_1000FD30(a1);
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
    result = *(_DWORD *)(v3 + 20);
  else
LABEL_12:
    result = 0;
  return result;
}

//----- (10013CC0) --------------------------------------------------------
signed int __usercall sub_10013CC0@<eax>(char a1@<dil>, int a2, int a3, int a4, signed int *a5)
{
  int v5; // eax@4
  signed int result; // eax@5

  if ( a4 == 1 && *a5 & 1 && *a5 != -2147483647 )
  {
    v5 = sub_10010550(a2, a3);
    if ( v5 )
    {
      result = sub_1000FAD0(v5, *a5 >> 1);
    }
    else
    {
      sub_100110D0(a2, "unable to find priv pointer\n", a1);
      result = 0;
    }
  }
  else
  {
    sub_100110D0(a2, "invalid args %i to clearInterval\n", a4);
    result = 0;
  }
  return result;
}
// 10013CC0: could not find valid save-restore pair for edi

//----- (10013D30) --------------------------------------------------------
signed int __usercall sub_10013D30@<eax>(char a1@<bl>, int a2, int a3, int a4, int a5, int *a6)
{
  int v6; // esi@3
  int v7; // ebx@4
  signed int result; // eax@6
  signed int v9; // edi@7
  unsigned int v10; // eax@7
  const char *v11; // eax@9
  const char *v12; // ebp@9
  signed int v13; // edi@9
  int v14; // esi@11
  void *v15; // eax@13
  void (__cdecl *v16)(int, int); // eax@14
  char v17; // [sp-4h] [bp-1Ch]@4
  char v18; // [sp+Ch] [bp-Ch]@7
  double v19; // [sp+10h] [bp-8h]@3
  signed int v20; // [sp+24h] [bp+Ch]@7

  if ( a4 != 2 || (*(_DWORD *)a5 & 7) != 4 )
  {
    v6 = a2;
    goto LABEL_20;
  }
  v6 = a2;
  if ( !sub_100101D0(a2, *(_DWORD *)(a5 + 4), &v19) )
  {
LABEL_20:
    sub_100110D0(v6, "invalid args %i to setInterval\n", a4);
    return 0;
  }
  v17 = a1;
  v7 = sub_10010550(a2, a3);
  if ( !v7 )
  {
    sub_100110D0(a2, "unable to find priv pointer\n", v17);
    return 0;
  }
  v9 = (signed int)v19;
  v20 = (signed int)v19;
  v10 = sub_100101C0(a2, *(_DWORD *)a5);
  v18 = v10;
  if ( v9 < 0 || !v10 )
    return 0;
  v11 = (const char *)sub_10010FF0(v10);
  v12 = v11;
  v13 = 0;
  if ( v11 )
    v13 = strlen(v11);
  v14 = sub_10013B20(v7, 24);
  if ( v14 && v13 > 0 )
  {
    *(_DWORD *)(v14 + 8) = 0;
    *(_DWORD *)(v14 + 20) = 0;
    *(_DWORD *)(v14 + 12) = v20;
    *(_DWORD *)(v14 + 16) = 0;
    *(_BYTE *)(v14 + 8) = 2;
    *(_DWORD *)v14 = v14;
    *(_DWORD *)(v14 + 4) = v14;
    v15 = (void *)sub_10013B20(v7, v13 + 1);
    *(_DWORD *)(v14 + 20) = v15;
    if ( v15 )
    {
      memcpy(v15, v12, v13);
      *(_BYTE *)(v13 + *(_DWORD *)(v14 + 20)) = 0;
      sub_1000FA20(v7, v14);
      *a6 = 2 * v14 | 1;
      result = 1;
    }
    else
    {
      sub_100110D0(a2, "unable to allocate space for scr %s\n", v18);
      v16 = *(void (__cdecl **)(int, int))(v7 + 48);
      if ( !v16 )
        _wassert(L"FALSE", L"..\\lib\\adl\\dom_xml\\DOM_pub_mem.h", 0x53u);
      v16(v7, v14);
      result = 0;
    }
  }
  else
  {
    sub_100110D0(a2, "unable to allocate event\n", v17);
    result = 0;
  }
  return result;
}
// 10013D30: could not find valid save-restore pair for ebx
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);
// 100101D0: using guessed type _DWORD __cdecl sub_100101D0(_DWORD, _DWORD, _DWORD);

//----- (10013EF0) --------------------------------------------------------
signed int __cdecl sub_10013EF0(int a1, int a2, signed int a3, int *a4)
{
  int v4; // eax@1
  signed int result; // eax@2
  int v6; // eax@4
  char v7; // [sp+0h] [bp-8h]@0

  v4 = sub_10010550(a1, a2);
  if ( v4 )
  {
    if ( a3 & 1 )
    {
      v6 = sub_100A45F0(v4, a3 >> 1);
      if ( !v6 )
        _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_window.c", 0x22Eu);
      *a4 = sub_10013C60(v6);
      result = 1;
    }
    else
    {
      *a4 = a2;
      result = 1;
    }
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v7);
    result = 0;
  }
  return result;
}

//----- (10013F80) --------------------------------------------------------
signed int __cdecl sub_10013F80(int a1, int a2)
{
  signed int result; // eax@2
  char v3; // [sp+0h] [bp-4h]@0

  if ( sub_10010550(a1, a2) )
  {
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v3);
    result = 0;
  }
  return result;
}

//----- (10013FB0) --------------------------------------------------------
signed int __cdecl sub_10013FB0(int a1, int a2, signed int a3, int *a4)
{
  unsigned int v4; // eax@1
  int v6; // eax@6
  char v7; // [sp+0h] [bp-4h]@0

  v4 = sub_10010550(a1, a2);
  if ( !v4 )
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v7);
    return 0;
  }
  if ( !(a3 & 1) )
    return 1;
  if ( a3 >> 1 == 51 )
  {
    *a4 = sub_10010F20(a1, *(const char **)(v4 + 16)) | 4;
    return 1;
  }
  if ( a3 >> 1 != 52 )
    return 1;
  v6 = sub_10013C60(*(_DWORD *)(v4 + 92));
  if ( !v6 )
    _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_window.c", 0x2B6u);
  *a4 = v6;
  return 1;
}

//----- (10014050) --------------------------------------------------------
signed int __cdecl sub_10014050(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // edi@1
  signed int result; // eax@2
  unsigned int v6; // eax@6
  char *v7; // eax@6
  char *v8; // esi@8
  char v9; // [sp+0h] [bp-90h]@0
  char v10; // [sp+Ch] [bp-84h]@8

  v4 = sub_10010550(a1, a2);
  if ( v4 )
  {
    if ( a3 & 1 )
    {
      if ( (a3 & 0xFFFFFFFE) == 102 && (*a4 & 7) == 4 )
      {
        v6 = sub_100101C0(a1, *a4);
        v7 = (char *)sub_10010FF0(v6);
        if ( v7 )
        {
          if ( *v7 == 47 )
          {
            v8 = v7;
          }
          else
          {
            v8 = &v10;
            sub_100A5FC0(v4, v7, &v10, 0x80u);
          }
          sub_100A3BF0(v4, v8);
        }
      }
    }
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v9);
    result = 0;
  }
  return result;
}
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (10014130) --------------------------------------------------------
int __usercall sub_10014130@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int result; // eax@2

  if ( a1 )
    result = sub_10011140(a2, 5, (int)sub_1003ED50, 0, 158, (unsigned int)(&off_10161558)[16 * a1]);
  else
    result = 1;
  return result;
}
// 10161558: using guessed type char *off_10161558;

//----- (10014160) --------------------------------------------------------
int __cdecl sub_10014160(int a1, int a2, signed int a3, _DWORD *a4)
{
  signed int v4; // edi@1
  signed int v5; // ebx@1
  int result; // eax@2
  int v7; // eax@4
  signed int v8; // ecx@4
  _DWORD *v9; // ebp@6

  v4 = a3;
  v5 = a3 >> 1;
  if ( !(*(_BYTE *)(a1 + 300) & 1) || (result = sub_10014130(a3 >> 1, a1)) != 0 )
  {
    if ( v4 == 1 )
    {
      v7 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 280);
      v8 = 0;
    }
    else
    {
      v7 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 276);
      v8 = 1;
    }
    v9 = a4;
    result = (*(int (__cdecl **)(int, int, int, signed int, _DWORD *, signed int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 44))(
               a1,
               a2,
               v7,
               v8,
               a4,
               &a3);
    if ( result )
    {
      *v9 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v5);
      result = 1;
    }
  }
  return result;
}

//----- (100141F0) --------------------------------------------------------
int __cdecl sub_100141F0(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int v4; // edi@1
  int result; // eax@2
  _DWORD *v6; // esi@3
  int v7; // eax@3
  int v8; // [sp+4h] [bp-4h]@3

  v4 = a1;
  if ( !(*(_BYTE *)(a1 + 300) & 1) || (result = sub_10014130(2, a1)) != 0 )
  {
    v6 = a2;
    v7 = *a2;
    a1 = 0;
    result = (*(int (__cdecl **)(int, _DWORD *, _DWORD, int *, int *))(*(_DWORD *)(v7 + 4) + 40))(v4, a2, 0, &a1, &v8);
    if ( result )
    {
      if ( v8 & 1 && v8 != -2147483647 )
        *a4 = v8;
      else
        *a4 = 1;
    }
    if ( a1 )
      result = (*(int (__cdecl **)(int, _DWORD *, signed int, int *, _DWORD))(*(_DWORD *)(*v6 + 4) + 40))(
                 v4,
                 v6,
                 2,
                 &a1,
                 0);
  }
  return result;
}

//----- (10014290) --------------------------------------------------------
unsigned int __cdecl sub_10014290(unsigned int a1)
{
  return a1 >> 3;
}

//----- (100142A0) --------------------------------------------------------
int __cdecl sub_100142A0(int a1, unsigned int a2, _DWORD *a3)
{
  int v3; // ebx@1
  int v4; // ebp@1
  int v5; // esi@1
  int v6; // eax@1
  int v7; // edi@1
  int *v8; // eax@1
  int v9; // ecx@1
  int *v11; // eax@5
  int *v12; // edi@5
  int v13; // eax@6
  bool v14; // zf@6
  bool v15; // sf@6
  int v16; // esi@6
  int v17; // edi@8
  int (__cdecl **v18)(int, int, int, int, int); // eax@11
  int v19; // eax@15
  void (__cdecl *v20)(int, int, int); // ecx@23
  int *v21; // [sp+10h] [bp-20h]@5
  int v22; // [sp+14h] [bp-1Ch]@8
  int v23; // [sp+18h] [bp-18h]@8
  int *v24; // [sp+1Ch] [bp-14h]@7
  int v25; // [sp+20h] [bp-10h]@6
  char v26; // [sp+24h] [bp-Ch]@10
  int v27; // [sp+28h] [bp-8h]@6
  int v28; // [sp+2Ch] [bp-4h]@2

  v3 = a1;
  v4 = a2;
  v5 = *(_DWORD *)(a1 + 260);
  v6 = sub_10014290(a2);
  v7 = v6;
  v8 = sub_10051360(v5, v6, v4);
  v9 = *v8;
  if ( *v8 )
  {
    if ( !*(_DWORD *)(v9 + 12) )
      *(_DWORD *)(v9 + 12) = 4 * ++*(_DWORD *)(v3 + 256);
    v12 = 0;
  }
  else
  {
    v28 = sub_100513D0(v5, v8, v7, v4, 0);
    if ( !v28 )
    {
      sub_10011170(v3);
      return 0;
    }
    v11 = sub_10010A50(v3, v4);
    v12 = v11;
    v21 = v11;
    if ( !v11 )
      return 0;
    v13 = *v11;
    v14 = *v12 == 0;
    v15 = *v12 < 0;
    v16 = 1;
    v25 = 0;
    v27 = v13;
    if ( !v15 && !v14 )
    {
      v24 = v12 + 1;
      while ( 1 )
      {
        v17 = *v24;
        v16 = (*(int (__cdecl **)(int, int, int, int *, int *))(*(_DWORD *)(*(_DWORD *)v4 + 4) + 8))(
                v3,
                v4,
                *v24,
                &v23,
                &v22);
        if ( !v16 )
        {
LABEL_35:
          v12 = v21;
          goto LABEL_36;
        }
        if ( !v22 )
          goto LABEL_25;
        v16 = (*(int (__cdecl **)(int, int, int, int, char *))(*(_DWORD *)(*(_DWORD *)v23 + 4) + 24))(
                v3,
                v23,
                v17,
                v22,
                &v26);
        if ( v16 )
        {
          v18 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v23 + 4);
          if ( (v18 == &off_101614B0 || v18 && *v18 == off_101614B0) && v26 & 0x30 )
          {
            v19 = 0;
            a1 = 0;
            if ( v26 & 0x10 )
            {
              v19 = *(_DWORD *)(v22 + 4);
              a1 = *(_DWORD *)(v22 + 4);
            }
            if ( v26 & 0x20 )
            {
              if ( v19 )
                v16 = sub_100142A0(v3, v19 & 0xFFFFFFF8, 0) != 0;
              v19 = *(_DWORD *)(v22 + 8);
              a1 = *(_DWORD *)(v22 + 8);
            }
            goto LABEL_23;
          }
          v16 = (*(int (__cdecl **)(int, int, int, int *))(*(_DWORD *)(*(_DWORD *)v4 + 4) + 16))(v3, v4, v17, &a1);
        }
        v19 = a1;
LABEL_23:
        v20 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v23 + 4) + 52);
        if ( !v20 )
          goto LABEL_26;
        v20(v3, v23, v22);
LABEL_25:
        v19 = a1;
LABEL_26:
        if ( !v16 )
          goto LABEL_35;
        if ( !(v19 & 7) && v19 && !sub_100142A0(v3, v19 & 0xFFFFFFF8, 0) )
        {
          v16 = 0;
          goto LABEL_35;
        }
        ++v24;
        if ( ++v25 >= v27 )
        {
          v12 = v21;
          break;
        }
      }
    }
    if ( !a3 )
LABEL_36:
      sub_10010480(v3, v12);
    if ( !v16 )
      return 0;
    v9 = v28;
  }
  if ( a3 )
    *a3 = v12;
  return v9;
}
// 10010480: using guessed type _DWORD __cdecl sub_10010480(_DWORD, _DWORD);
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (100144E0) --------------------------------------------------------
int __cdecl sub_100144E0(int a1, int a2, int a3, unsigned int *a4)
{
  int v4; // edi@1
  int v5; // eax@2
  bool v7; // zf@5
  int v8; // ebp@6
  unsigned int v9; // ebx@9
  int **v10; // edi@11
  unsigned int *v11; // edi@15
  int v12; // ST1C_4@18
  int v13; // eax@20
  int *v14; // eax@20
  int v15; // eax@24
  int v16; // eax@24
  int *v17; // [sp+Ch] [bp-2Ch]@5
  unsigned int *v18; // [sp+10h] [bp-28h]@1
  int **v19; // [sp+14h] [bp-24h]@1
  int v20; // [sp+18h] [bp-20h]@1
  int v21; // [sp+1Ch] [bp-1Ch]@20
  char v22; // [sp+20h] [bp-18h]@24

  v19 = (int **)a3;
  *a4 = 0;
  v4 = *(_DWORD *)(a1 + 260);
  v20 = a2;
  v18 = a4;
  if ( !v4 )
  {
    v5 = sub_100511F0(8u, (int)sub_10014290, (int)sub_100516C0, (int)sub_100516C0, 0, 0);
    v4 = v5;
    if ( !v5 )
    {
      sub_10011170(a1);
      return 0;
    }
    *(_DWORD *)(a1 + 260) = v5;
  }
  v7 = *(_DWORD *)(a1 + 252) == 0;
  v17 = 0;
  if ( !v7 )
  {
    v13 = sub_10014290(a2);
    v21 = v13;
    v14 = sub_10051360(v4, v13, a2);
    v8 = *v14;
    if ( *v14 )
      goto LABEL_9;
    v8 = sub_100513D0(v4, v14, v21, a2, 0);
    if ( v8 )
    {
      *v18 = 0;
      LOBYTE(v9) = 0;
      goto LABEL_11;
    }
    sub_10011170(a1);
LABEL_17:
    if ( !*(_DWORD *)(a1 + 252) )
    {
      v12 = *(_DWORD *)(a1 + 260);
      *(_DWORD *)(a1 + 256) = 0;
      sub_100512D0(v12);
      *(_DWORD *)(a1 + 260) = 0;
    }
    return 0;
  }
  v8 = sub_100142A0(a1, a2, &v17);
  if ( !v8 )
    goto LABEL_17;
  if ( !v19 )
  {
    sub_10010480(a1, v17);
    v17 = 0;
  }
LABEL_9:
  v9 = *(_DWORD *)(v8 + 12);
  if ( v9 )
  {
    v15 = sub_10050B00((int)&v22, 20, "#%u%c", v9 >> 2);
    v16 = sub_1001B0E0(a1, (int)&v22, v15);
    *v18 = v16;
    if ( !v16 )
    {
      if ( v17 )
        sub_10010480(a1, v17);
      goto LABEL_17;
    }
  }
  else
  {
    *v18 = 0;
  }
LABEL_11:
  v10 = v19;
  if ( !(v9 & 1) )
  {
    if ( v19 )
    {
      if ( !v17 )
      {
        v17 = sub_10010A50(a1, v20);
        if ( !v17 )
        {
          v11 = v18;
          if ( *v18 )
          {
            sub_10010340(a1, *v18);
            *v11 = 0;
          }
          goto LABEL_17;
        }
      }
    }
    ++*(_DWORD *)(a1 + 252);
  }
  if ( v10 )
    *v10 = v17;
  return v8;
}
// 10010480: using guessed type _DWORD __cdecl sub_10010480(_DWORD, _DWORD);

//----- (10014720) --------------------------------------------------------
int __cdecl sub_10014720(int a1, int *a2)
{
  bool v2; // zf@1
  int v3; // ST04_4@2
  int result; // eax@2

  v2 = (*(_DWORD *)(a1 + 252))-- == 1;
  if ( v2 )
  {
    v3 = *(_DWORD *)(a1 + 260);
    *(_DWORD *)(a1 + 256) = 0;
    result = sub_100512D0(v3);
    *(_DWORD *)(a1 + 260) = 0;
  }
  if ( a2 )
  {
    result = *a2;
    if ( *a2 )
    {
      result = sub_10010480(a1, *a2);
      *a2 = 0;
    }
  }
  return result;
}
// 10010480: using guessed type _DWORD __cdecl sub_10010480(_DWORD, _DWORD);

//----- (10014780) --------------------------------------------------------
int __cdecl sub_10014780(int a1, int a2, int a3, int *a4, int *a5)
{
  int result; // eax@2
  int v6; // edi@5
  int v7; // ecx@8
  _WORD *v8; // ebx@9
  int v9; // ebp@9
  int v10; // eax@10
  void *v11; // esi@12
  _WORD *v12; // eax@13
  _WORD *v13; // ST10_4@16
  _DWORD *v14; // eax@20
  int v15; // ecx@20
  bool v16; // zf@20
  bool v17; // sf@20
  signed int v18; // esi@22
  int v19; // edx@25
  int (__cdecl **v20)(int, int, int, int, int); // eax@25
  int v21; // eax@29
  signed int v22; // edi@30
  int (__cdecl *v23)(int, int, signed int, int *); // eax@34
  int v24; // eax@34
  void (__cdecl *v25)(int, int, int); // ecx@35
  signed int v26; // edi@40
  int v27; // eax@44
  int v28; // esi@44
  int v29; // eax@48
  unsigned int v30; // eax@50
  int v31; // ecx@51
  void *v32; // eax@52
  int v33; // esi@58
  char *v34; // eax@63
  int v35; // esi@63
  unsigned int v36; // eax@64
  int v37; // ecx@65
  unsigned int v38; // eax@66
  int v39; // esi@72
  int v40; // edi@72
  unsigned int v41; // kr00_4@75
  int v42; // eax@76
  int v43; // eax@79
  int v44; // esi@79
  int v45; // eax@83
  int *v46; // eax@85
  int v47; // ecx@86
  int v48; // eax@86
  int v49; // eax@88
  unsigned int v50; // esi@90
  const char *v51; // eax@91
  int v52; // ebp@92
  int v53; // edx@93
  unsigned int v54; // eax@94
  int v55; // esi@94
  int v56; // ecx@97
  const void *v57; // eax@98
  int v58; // ebp@103
  int v59; // esi@104
  int v60; // ebp@104
  int v61; // esi@106
  void (__cdecl *v62)(int, int, int); // eax@120
  char v63; // [sp+0h] [bp-58h]@0
  int v64; // [sp+0h] [bp-58h]@61
  int v65; // [sp+4h] [bp-54h]@12
  char *v66; // [sp+8h] [bp-50h]@68
  void *v67; // [sp+Ch] [bp-4Ch]@76
  int v68; // [sp+10h] [bp-48h]@23
  int v69; // [sp+14h] [bp-44h]@7
  int v70; // [sp+18h] [bp-40h]@22
  int v71; // [sp+1Ch] [bp-3Ch]@22
  const char *v72; // [sp+20h] [bp-38h]@20
  int v73; // [sp+24h] [bp-34h]@59
  void *v74; // [sp+28h] [bp-30h]@54
  int v75; // [sp+2Ch] [bp-2Ch]@76
  int *v76; // [sp+30h] [bp-28h]@62
  _WORD *v77; // [sp+34h] [bp-24h]@7
  int v78; // [sp+38h] [bp-20h]@20
  _DWORD *v79; // [sp+3Ch] [bp-1Ch]@7
  char v80; // [sp+40h] [bp-18h]@24
  int v81; // [sp+44h] [bp-14h]@1
  int v82[2]; // [sp+48h] [bp-10h]@30
  int v83[2]; // [sp+50h] [bp-8h]@30

  if ( (unsigned int)&v81 <= *(_DWORD *)(a1 + 12) )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 26, v63);
    return 0;
  }
  v6 = *(_DWORD *)(a1 + 16) != 120 && !*(_DWORD *)(a1 + 252);
  v69 = v6;
  result = sub_100144E0(a1, a2, (int)&v79, (unsigned int *)&v77);
  if ( !result )
    return result;
  v7 = *(_DWORD *)(result + 12);
  if ( v7 & 1 )
  {
    v8 = v77;
    v9 = sub_1001AFC0(v77);
    goto LABEL_10;
  }
  v11 = v77;
  v65 = 1;
  if ( v77 )
  {
    v13 = v77;
    *(_DWORD *)(result + 12) = v7 | 1;
    v9 = sub_1001AFC0(v13);
    v8 = sub_10053FC0(v11, 2 * v9 + 6, dword_10658DEC);
    if ( !v8 )
    {
      sub_10053E10((unsigned int)v11, dword_10658DEC);
      goto LABEL_116;
    }
    if ( v6 )
    {
      v6 = 0;
      v69 = 0;
    }
  }
  else
  {
    v12 = (_WORD *)sub_10053CF0(2 * (2 * (v6 != 0) + 2) + 2, dword_10658DEC);
    v8 = v12;
    v9 = 0;
    if ( !v12 )
      goto LABEL_116;
    if ( v6 )
    {
      *v12 = 40;
      v9 = (int)v11 + 1;
    }
  }
  v14 = v79;
  v8[v9] = 123;
  v15 = *v14;
  ++v9;
  v16 = *v14 == 0;
  v17 = *v14 < 0;
  v72 = 0;
  v78 = 0;
  v81 = v15;
  if ( v17 || v16 )
  {
LABEL_113:
    v8[v9++] = 125;
    if ( v6 )
      v8[v9++] = 41;
    v8[v9] = 0;
    goto LABEL_116;
  }
  v77 = v14 + 1;
  while ( 1 )
  {
    v18 = *(_DWORD *)v77;
    v65 = (*(int (__cdecl **)(int, int, _DWORD, int *, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 8))(
            a1,
            a2,
            *(_DWORD *)v77,
            &v70,
            &v71);
    if ( !v65 )
      goto LABEL_116;
    v68 = 0;
    if ( v71 )
      break;
LABEL_37:
    if ( !v65 )
      goto LABEL_116;
    if ( v18 & 1 && v18 != -2147483647 )
      v26 = 0;
    else
      v26 = v18;
    if ( !(v18 & 1) )
      v18 = *(_DWORD *)(v18 + 8);
    v27 = sub_1001ACB0(a1, v18);
    v28 = v27;
    if ( !v27 )
    {
LABEL_122:
      v65 = 0;
      goto LABEL_116;
    }
    *a4 = v27 | 4;
    if ( v26 && (*(_DWORD *)(v26 + 12) || !sub_10028320(v27)) )
    {
      v29 = sub_1004C310(a1, v28, 39);
      v28 = v29;
      if ( !v29 )
        goto LABEL_122;
      *a4 = v29 | 4;
    }
    v30 = *(_DWORD *)v28;
    if ( !(*(_DWORD *)v28 & 0x40000000) )
    {
      v32 = *(void **)(v28 + 4);
      goto LABEL_57;
    }
    v31 = *(_DWORD *)(v28 + 4);
    if ( *(_DWORD *)v31 & 0x40000000 )
    {
      v32 = (void *)sub_1001A200(v28);
LABEL_57:
      v74 = v32;
      goto LABEL_58;
    }
    if ( (v30 & 0x80000000) == 0 )
      v74 = (void *)(*(_DWORD *)(v31 + 4) + 2 * ((v30 >> 15) & 0x7FFF));
    else
      v74 = *(void **)(v31 + 4);
LABEL_58:
    v33 = *(_DWORD *)v28;
    if ( v33 & 0x40000000 )
      v73 = v33 & ((v33 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    else
      v73 = v33;
    v64 = 0;
    if ( v68 > 0 )
    {
      v76 = a4 + 1;
      while ( 1 )
      {
        v34 = sub_1001AD70(a1, v83[v64]);
        v35 = (int)v34;
        if ( !v34 )
          goto LABEL_122;
        *v76 = (unsigned int)v34 | 4;
        v36 = *(_DWORD *)v34;
        if ( !(*(_DWORD *)v35 & 0x40000000) )
          break;
        v37 = *(_DWORD *)(v35 + 4);
        if ( *(_DWORD *)v37 & 0x40000000 )
        {
          v38 = sub_1001A200(v35);
LABEL_71:
          v66 = (char *)v38;
          goto LABEL_72;
        }
        if ( (v36 & 0x80000000) == 0 )
          v66 = (char *)(*(_DWORD *)(v37 + 4) + 2 * ((v36 >> 15) & 0x7FFF));
        else
          v66 = *(char **)(v37 + 4);
LABEL_72:
        v39 = *(_DWORD *)v35;
        v40 = v39;
        if ( v39 & 0x40000000 )
          v40 = v39 & ((v39 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        if ( v82[v64] )
        {
          v41 = strlen("function");
          v66 += 2 * (v41 + 1);
          v40 -= v41 + 1;
        }
        v67 = 0;
        v75 = 0;
        v42 = v83[v64];
        if ( !(v42 & 7) && v42 && *(_WORD *)v66 != 35 )
        {
          v43 = sub_100144E0(a1, v42 & 0xFFFFFFF8, 0, (unsigned int *)&v67);
          v44 = v43;
          if ( !v43 )
            goto LABEL_122;
          if ( *(_BYTE *)(v43 + 12) & 1 )
          {
            v66 = (char *)v67;
            v40 = sub_1001AFC0(v67);
          }
          else
          {
            if ( v67 )
            {
              v45 = sub_1001AFC0(v67);
              *(_DWORD *)(v44 + 12) |= 1u;
              v75 = v45;
            }
            sub_10014720(a1, 0);
          }
        }
        v46 = (int *)v82[v64];
        if ( v46 )
        {
          v47 = *v46;
          v48 = *v46;
          if ( v48 & 0x40000000 )
            v48 = v47 & ((v48 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
          v49 = v48 + 1;
        }
        else
        {
          v49 = 0;
        }
        v50 = (unsigned int)v8;
        v8 = sub_10053FC0(
               v8,
               2 * (v9 + v73 + v40 + v75 + v49 + (v72 != 0 ? 2 : 0) + (v69 != 0) + 1) + 4,
               dword_10658DEC);
        if ( !v8 )
        {
          sub_10010340(a1, (unsigned int)v67);
          sub_10053E10(v50, dword_10658DEC);
          goto LABEL_116;
        }
        v51 = v72;
        if ( v72 )
        {
          v8[v9] = *v72;
          v52 = v9 + 1;
          v8[v52] = v51[1];
          v9 = v52 + 1;
        }
        v53 = v82[v64];
        v72 = ", ";
        if ( v53 )
        {
          v54 = *(_DWORD *)v53;
          v55 = *(_DWORD *)v53;
          if ( *(_DWORD *)v53 & 0x40000000 )
            v55 = v54 & ((v55 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
          if ( *(_DWORD *)v53 & 0x40000000 )
          {
            v56 = *(_DWORD *)(v53 + 4);
            if ( *(_DWORD *)v56 & 0x40000000 )
            {
              v57 = (const void *)sub_1001A200(v82[v64]);
            }
            else if ( (v54 & 0x80000000) == 0 )
            {
              v57 = (const void *)(*(_DWORD *)(v56 + 4) + 2 * ((v54 >> 15) & 0x7FFF));
            }
            else
            {
              v57 = *(const void **)(v56 + 4);
            }
          }
          else
          {
            v57 = *(const void **)(v53 + 4);
          }
          memcpy(&v8[v9], v57, 2 * v55);
          v58 = v55 + v9;
          v8[v58] = 32;
          v9 = v58 + 1;
        }
        v59 = v73;
        memcpy(&v8[v9], v74, 2 * v73);
        v60 = v59 + v9;
        if ( !v82[v64] )
          v8[v60++] = 58;
        v61 = v75;
        if ( v75 )
        {
          memcpy(&v8[v60], v67, 2 * v75);
          v60 += v61;
        }
        memcpy(&v8[v60], v66, 2 * v40);
        v9 = v40 + v60;
        if ( v67 )
          sub_10010340(a1, (unsigned int)v67);
        ++v76;
        if ( ++v64 >= v68 )
          goto LABEL_111;
      }
      v38 = *(_DWORD *)(v35 + 4);
      goto LABEL_71;
    }
LABEL_111:
    v77 += 2;
    if ( ++v78 >= v81 )
    {
      v6 = v69;
      goto LABEL_113;
    }
  }
  v65 = (*(int (__cdecl **)(int, int, signed int, int, char *))(*(_DWORD *)(*(_DWORD *)v70 + 4) + 24))(
          a1,
          v70,
          v18,
          v71,
          &v80);
  if ( v65 )
  {
    v19 = v70;
    v20 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v70 + 4);
    if ( (v20 == &off_101614B0 || v20 && *v20 == off_101614B0) && v80 & 0x30 )
    {
      v21 = v71;
      if ( v80 & 0x10 )
      {
        v83[0] = *(_DWORD *)(v71 + 4);
        v82[0] = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 248) + 8) & 0xFFFFFFF8;
        v22 = 1;
        v68 = 1;
      }
      else
      {
        v22 = v68;
      }
      if ( v80 & 0x20 )
      {
        v83[v22] = *(_DWORD *)(v71 + 8);
        v82[v22] = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 284) + 8) & 0xFFFFFFF8;
        v68 = v22 + 1;
      }
    }
    else
    {
      v23 = *(int (__cdecl **)(int, int, signed int, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16);
      v68 = 1;
      v82[0] = 0;
      v24 = v23(a1, a2, v18, v83);
      v19 = v70;
      v65 = v24;
      v21 = v71;
    }
    v25 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v19 + 4) + 52);
    if ( v25 )
      v25(a1, v19, v21);
    goto LABEL_37;
  }
  v62 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v70 + 4) + 52);
  if ( v62 )
    v62(a1, v70, v71);
LABEL_116:
  sub_10014720(a1, (int *)&v79);
  if ( !v65 )
  {
    if ( !v8 )
      return 0;
LABEL_118:
    sub_10053E10((unsigned int)v8, dword_10658DEC);
    return 0;
  }
  if ( v8 )
  {
LABEL_10:
    v10 = sub_1001AB10(a1, (int)v8, v9, 0);
    if ( v10 )
    {
      *a5 = v10 | 4;
      return 1;
    }
    goto LABEL_118;
  }
  sub_10011170(a1);
  return 0;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);
// 10658DEC: using guessed type int dword_10658DEC;
// 10014780: using guessed type int var_8[2];
// 10014780: using guessed type int var_10[2];

//----- (10014F50) --------------------------------------------------------
int __cdecl sub_10014F50(int a1, int a2, int a3, int *a4, int *a5)
{
  int result; // eax@2
  const char *v6; // edi@3
  _WORD *v7; // esi@3
  __int16 v8; // cx@5
  __int16 v9; // cx@6
  __int16 v10; // cx@7
  unsigned int v11; // eax@8
  int v12; // eax@8

  if ( *(_DWORD *)(a1 + 16) == 120 )
  {
    result = sub_10014780(a1, a2, a3, a4, a5);
  }
  else
  {
    v6 = *(const char **)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE);
    v7 = (_WORD *)sub_10011830(a1, 2 * strlen(v6) + 20);
    result = 0;
    if ( v7 )
    {
      *v7 = 91;
      do
      {
        v8 = (unsigned __int8)byte_100CC6F1[result++];
        v7[result] = v8;
      }
      while ( v8 );
      v9 = *v6;
      v7[result] = v9;
      if ( v9 )
      {
        do
        {
          v10 = (v6++)[1];
          v7[++result] = v10;
        }
        while ( v10 );
      }
      v7[result] = 93;
      v11 = result + 1;
      v7[v11] = 0;
      v12 = sub_1001AB10(a1, (int)v7, v11, 0);
      if ( v12 )
      {
        *a5 = v12 | 4;
        result = 1;
      }
      else
      {
        sub_10010340(a1, (unsigned int)v7);
        result = 0;
      }
    }
  }
  return result;
}

//----- (10015040) --------------------------------------------------------
signed int __cdecl sub_10015040(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  *a5 = a2;
  return 1;
}

//----- (10015050) --------------------------------------------------------
int __cdecl sub_10015050(int a1, int a2)
{
  return a2 + 4;
}

//----- (10015060) --------------------------------------------------------
int __cdecl sub_10015060(int a1, int a2)
{
  return *(_DWORD *)(a2 + 4) ^ (*(_DWORD *)a2 >> 3);
}

//----- (10015070) --------------------------------------------------------
BOOL __cdecl sub_10015070(int a1, int a2, int a3)
{
  return *(_DWORD *)(a2 + 4) == *(_DWORD *)a3 && *(_DWORD *)(a2 + 8) == *(_DWORD *)(a3 + 4);
}

//----- (10015090) --------------------------------------------------------
signed int __usercall sub_10015090@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, unsigned int **a4)
{
  int v4; // eax@1
  unsigned int *v5; // eax@4
  signed int result; // eax@5
  unsigned int v7; // ecx@6

  v4 = *(_DWORD *)(a3 + 308);
  if ( !v4 )
  {
    v4 = sub_1003F6B0(off_100CC628, 0, 16, 0x10u);
    if ( !v4 )
    {
LABEL_5:
      sub_10011170(a3);
      return 0;
    }
    *(_DWORD *)(a3 + 308) = v4;
  }
  v5 = sub_1003F720(v4, a2, 1);
  if ( !v5 )
    goto LABEL_5;
  v7 = v5[3];
  if ( v7 & a1 )
  {
    *a4 = 0;
    result = 1;
  }
  else
  {
    if ( !v5[1] )
    {
      v5[1] = *(_DWORD *)a2;
      v5[2] = *(_DWORD *)(a2 + 4);
    }
    v5[3] = a1 | v7;
    *a4 = v5;
    result = 1;
  }
  return result;
}
// 100CC628: using guessed type int (__cdecl *off_100CC628[4])(int, int);

//----- (10015110) --------------------------------------------------------
unsigned int *__usercall sub_10015110@<eax>(unsigned int *result@<eax>, int a2@<ecx>, int a3@<ebx>, int a4, int a5)
{
  int v5; // esi@1
  bool v6; // zf@3

  v5 = *(_DWORD *)(a2 + 308);
  if ( *(_DWORD *)(v5 + 24) != a5 )
    result = sub_1003F720(v5, a3, 0);
  v6 = (~a4 & result[3]) == 0;
  result[3] &= ~a4;
  if ( v6 )
  {
    if ( *(_DWORD *)(v5 + 20) >= (unsigned int)(1 << (32 - *(_WORD *)(v5 + 8))) >> 2 )
      result = sub_1003F720(v5, a3, 2);
    else
      result = (unsigned int *)sub_1003F580(v5, (int *)result);
  }
  return result;
}

//----- (10015170) --------------------------------------------------------
signed int __cdecl sub_10015170(int a1, int a2, int a3, int a4, int *a5, int a6)
{
  int v6; // ebp@1
  signed int result; // eax@1
  unsigned int *v8; // ebx@2
  int v9; // edi@4
  int v10; // edx@4
  int v11; // ebp@4
  int v12; // [sp+10h] [bp-14h]@1
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@4
  int v15; // [sp+1Ch] [bp-8h]@4
  int v16; // [sp+20h] [bp-4h]@4

  v6 = a2;
  v12 = a2;
  v13 = a3;
  result = sub_10015090(2, (int)&v12, a1, (unsigned int **)&a2);
  if ( result )
  {
    v8 = (unsigned int *)a2;
    if ( a2 )
    {
      v9 = *(_DWORD *)(*(_DWORD *)(a1 + 308) + 24);
      v14 = a3;
      v10 = *a5;
      v15 = a4;
      v16 = v10;
      v11 = sub_100302A0(a1, v6, a6, 0, 3, (int)&v14, a5);
      sub_10015110(v8, a1, (int)&v12, 2, v9);
      result = v11;
    }
    else
    {
      result = a2 + 1;
    }
  }
  return result;
}

//----- (10015220) --------------------------------------------------------
_DWORD *__cdecl sub_10015220(int a1, _DWORD *a2, int a3, int a4)
{
  signed int *v4; // ebp@1
  int v5; // eax@1
  int *v6; // esi@1
  unsigned int v7; // eax@3
  int v8; // edi@4
  unsigned int v9; // eax@5
  _DWORD *result; // eax@6
  signed int v11; // esi@8
  char v12; // [sp+10h] [bp-8h]@9
  char v13; // [sp+14h] [bp-4h]@9

  v4 = (signed int *)a4;
  v5 = *(_DWORD *)(a4 + 4);
  v6 = (int *)(a4 + 4);
  if ( v5 & 7
    || !(v5 & 0xFFFFFFF8)
    || (v7 = v5 & 0xFFFFFFF8, (char **)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 8) & 0xFFFFFFFE) != &off_101621B8) )
  {
    v9 = sub_10028AB0(a1, (int *)(a4 + 4), 0);
    if ( !v9 )
      return 0;
    v8 = *(_DWORD *)(v9 + 4);
  }
  else
  {
    v8 = v7;
  }
  *v6 = v8;
  v11 = *v4;
  if ( !sub_10010490(a1, *v4, &a4)
    || !(*(int (__cdecl **)(int, _DWORD *, int, signed int, char *, char *))(*(_DWORD *)(*a2 + 4) + 44))(
          a1,
          a2,
          a4,
          3,
          &v13,
          &v12) )
  {
    return 0;
  }
  if ( v12 & 2 )
    result = (_DWORD *)1;
  else
    result = sub_10051C70(a1, a2, v11, (int)sub_10015170, v8);
  return result;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (100152F0) --------------------------------------------------------
_DWORD *__cdecl sub_100152F0(int a1, int a2, int a3, int *a4)
{
  return sub_10051F80(a1, a2, *a4, 0, 0);
}

//----- (10015310) --------------------------------------------------------
int __cdecl sub_10015310(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@1
  int v6; // edx@3
  int v7; // ecx@5
  int (__cdecl **v8)(int, int, int, int, int); // eax@7
  void (__cdecl *v9)(int, int, int); // eax@12
  int v10; // [sp+4h] [bp-Ch]@1
  int v11; // [sp+8h] [bp-8h]@2
  int v12; // [sp+Ch] [bp-4h]@2

  result = sub_10010490(a1, *a4, &v10);
  if ( result )
  {
    result = (*(int (__cdecl **)(int, int, int, int *, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 8))(
               a1,
               a2,
               v10,
               &v12,
               &v11);
    if ( result )
    {
      v6 = v11;
      if ( v11 )
      {
        v7 = v12;
        if ( v12 == a2 )
        {
          *a5 = 14;
        }
        else
        {
          v8 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v12 + 4);
          if ( v8 == &off_101614B0 || v8 && *v8 == off_101614B0 )
            *a5 = 8 * ((~*(_BYTE *)(v11 + 16) & 0x44) == 0) | 6;
          else
            *a5 = 6;
        }
        v9 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v7 + 4) + 52);
        if ( v9 )
          v9(a1, v7, v6);
        result = 1;
      }
      else
      {
        *a5 = 6;
        result = v6 + 1;
      }
    }
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10015400) --------------------------------------------------------
int __cdecl sub_10015400(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@1
  int v6; // ecx@6
  void (__cdecl *v7)(int, int, int); // ecx@10
  int v8; // edi@13
  void (__cdecl *v9)(int, int, int); // eax@13
  int v10; // [sp+4h] [bp-10h]@1
  int v11; // [sp+8h] [bp-Ch]@2
  int v12; // [sp+Ch] [bp-8h]@2
  int v13; // [sp+10h] [bp-4h]@13

  result = sub_10010490(a1, *a4, &v10);
  if ( result )
  {
    result = (*(int (__cdecl **)(int, int, int, int *, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 8))(
               a1,
               a2,
               v10,
               &v11,
               &v12);
    if ( result )
    {
      if ( v12 )
      {
        if ( v11 == a2
          || ((v6 = *(_DWORD *)(*(_DWORD *)v11 + 4), (int (__cdecl **)(int, int, int, int, int))v6 == &off_101614B0)
           || v6 && *(int (__cdecl **)(int, int, int, int, int))v6 == off_101614B0)
          && !(~*(_BYTE *)(v12 + 16) & 0x44) )
        {
          v8 = (*(int (__cdecl **)(int, int, int, int, int *))(*(_DWORD *)(*(_DWORD *)v11 + 4) + 24))(
                 a1,
                 v11,
                 v10,
                 v12,
                 &v13);
          v9 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v11 + 4) + 52);
          if ( v9 )
            v9(a1, v11, v12);
          if ( v8 )
            *a5 = 8 * (v13 & 1) | 6;
          result = v8;
        }
        else
        {
          v7 = *(void (__cdecl **)(int, int, int))(v6 + 52);
          if ( v7 )
            v7(a1, v11, v12);
          *a5 = 6;
          result = 1;
        }
      }
      else
      {
        result = 1;
        *a5 = 6;
      }
    }
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10015520) --------------------------------------------------------
int __cdecl sub_10015520(int a1, int a2, int a3, int a4)
{
  signed int *v4; // edi@1
  int v5; // esi@1
  char v7; // [sp+Ch] [bp-Ch]@5
  char v8; // [sp+10h] [bp-8h]@6
  char v9; // [sp+14h] [bp-4h]@6

  v4 = (signed int *)a4;
  v5 = *(_DWORD *)(a4 + 4);
  if ( sub_100101E0(a1, *(_DWORD *)(a4 + 4)) != 2 )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 151, (unsigned int)"getter");
    return 0;
  }
  if ( !sub_10010490(a1, *v4, &a4)
    || !sub_10030430(a1, a2, a4, 0x10u, &v7)
    || !(*(int (__cdecl **)(int, int, int, signed int, char *, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 44))(
          a1,
          a2,
          a4,
          3,
          &v9,
          &v8) )
  {
    return 0;
  }
  return (*(int (__cdecl **)(int, int, int, signed int, unsigned int, _DWORD, signed int, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4)
                                                                                                 + 12))(
           a1,
           a2,
           a4,
           -2147483647,
           v5 & 0xFFFFFFF8,
           0,
           80,
           0);
}

//----- (100155F0) --------------------------------------------------------
int __cdecl sub_100155F0(int a1, int a2, int a3, int a4)
{
  signed int *v4; // edi@1
  int v5; // esi@1
  char v7; // [sp+Ch] [bp-Ch]@5
  char v8; // [sp+10h] [bp-8h]@6
  char v9; // [sp+14h] [bp-4h]@6

  v4 = (signed int *)a4;
  v5 = *(_DWORD *)(a4 + 4);
  if ( sub_100101E0(a1, *(_DWORD *)(a4 + 4)) != 2 )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 151, (unsigned int)"setter");
    return 0;
  }
  if ( !sub_10010490(a1, *v4, &a4)
    || !sub_10030430(a1, a2, a4, 0x20u, &v7)
    || !(*(int (__cdecl **)(int, int, int, signed int, char *, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 44))(
          a1,
          a2,
          a4,
          3,
          &v9,
          &v8) )
  {
    return 0;
  }
  return (*(int (__cdecl **)(int, int, int, signed int, _DWORD, unsigned int, signed int, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4)
                                                                                                 + 12))(
           a1,
           a2,
           a4,
           -2147483647,
           0,
           v5 & 0xFFFFFFF8,
           96,
           0);
}

//----- (100156C0) --------------------------------------------------------
signed int __cdecl sub_100156C0(int a1, int a2, int a3, signed int *a4, _DWORD *a5)
{
  signed int result; // eax@2
  int v6; // edx@4
  void (__cdecl *v7)(int, int, int); // eax@7
  int v8; // [sp+4h] [bp-Ch]@1
  int v9; // [sp+8h] [bp-8h]@3
  int v10; // [sp+Ch] [bp-4h]@3

  if ( sub_10010490(a1, *a4, &v8)
    && (*(int (__cdecl **)(int, int, int, int *, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 8))(a1, a2, v8, &v10, &v9) )
  {
    v6 = v9;
    if ( v9 )
    {
      if ( *(_BYTE *)(v9 + 16) & 0x10 )
        *a5 = *(_DWORD *)(v9 + 4);
      v7 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v10 + 4) + 52);
      if ( v7 )
        v7(a1, v10, v6);
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10015750) --------------------------------------------------------
signed int __cdecl sub_10015750(int a1, int a2, int a3, signed int *a4, _DWORD *a5)
{
  signed int result; // eax@2
  int v6; // edx@4
  void (__cdecl *v7)(int, int, int); // eax@7
  int v8; // [sp+4h] [bp-Ch]@1
  int v9; // [sp+8h] [bp-8h]@3
  int v10; // [sp+Ch] [bp-4h]@3

  if ( sub_10010490(a1, *a4, &v8)
    && (*(int (__cdecl **)(int, int, int, int *, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 8))(a1, a2, v8, &v10, &v9) )
  {
    v6 = v9;
    if ( v9 )
    {
      if ( *(_BYTE *)(v9 + 16) & 0x20 )
        *a5 = *(_DWORD *)(v9 + 8);
      v7 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v10 + 4) + 52);
      if ( v7 )
        v7(a1, v10, v6);
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100157E0) --------------------------------------------------------
unsigned int __cdecl sub_100157E0(int a1, unsigned int a2)
{
  unsigned int result; // eax@1
  int (__cdecl *v3)(int, unsigned int); // eax@2

  result = a2;
  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
  {
    v3 = *(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4) + 48);
    if ( v3 )
      result = v3(a1, **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
    else
      result = **(_DWORD **)(a2 + 4) & 0xFFFFFFF8;
  }
  return result;
}

//----- (10015810) --------------------------------------------------------
int (__cdecl **sub_10015810())(int, int, int, int, int)
{
  return &off_10161650;
}
// 10161650: using guessed type int (__cdecl *off_10161650)(int, int, int, int, int);

//----- (10015820) --------------------------------------------------------
int __cdecl sub_10015820(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = 5;
  *(_DWORD *)(a1 + 12) = *(_BYTE *)(a4 + 5) + ((*(_DWORD *)(a4 + 4) & 1) != 0) + 3;
  return result;
}

//----- (10015880) --------------------------------------------------------
_DWORD *__cdecl sub_10015880(int a1, _DWORD *a2)
{
  _DWORD *result; // eax@1

  result = a2;
  ++*result;
  return result;
}

//----- (10015890) --------------------------------------------------------
_DWORD *__cdecl sub_10015890(int a1, int a2, int a3)
{
  _DWORD *result; // eax@1
  bool v4; // zf@1
  int v5; // ecx@1

  result = (_DWORD *)a2;
  v4 = *(_DWORD *)a2 == 1;
  --*result;
  v5 = *(_DWORD *)(a2 + 4);
  if ( v4 )
  {
    (*(void (__cdecl **)(int, int))(v5 + 4))(a1, a2);
    result = 0;
  }
  else if ( ((int (__cdecl **)(int, int, int, int, int))v5 == &off_101614B0
          || v5 && *(int (__cdecl **)(int, int, int, int, int))v5 == off_101614B0)
         && *(_DWORD *)(a2 + 16) == a3 )
  {
    *(_DWORD *)(a2 + 16) = 0;
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (100158E0) --------------------------------------------------------
signed int __usercall sub_100158E0@<eax>(unsigned int a1@<eax>, const char *a2@<edx>, int a3@<ebx>, _DWORD *a4)
{
  unsigned int v4; // esi@1
  char *v5; // eax@1
  int v7; // ecx@4
  unsigned int v8; // ecx@6
  int v9; // edx@10
  int v10; // eax@11
  void (__cdecl *v11)(int, int, int); // ecx@11
  int v12; // [sp+Ch] [bp-8h]@9
  int v13; // [sp+10h] [bp-4h]@9

  v4 = a1;
  v5 = sub_10038950(a3, (int)a2, strlen(a2), 0);
  if ( !v5 )
    return 0;
  if ( v4 || (v7 = *(_DWORD *)(a3 + 56)) != 0 && (v4 = *(_DWORD *)(v7 + 52)) != 0 )
  {
    do
    {
      v8 = v4;
      v4 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 4) & 0xFFFFFFF8;
    }
    while ( v4 );
  }
  else
  {
    v8 = *(_DWORD *)(a3 + 88);
    if ( !v8 )
    {
LABEL_7:
      *a4 = -2147483647;
      return 1;
    }
  }
  if ( !(*(int (__cdecl **)(int, unsigned int, char *, int *, int *))(*(_DWORD *)(*(_DWORD *)v8 + 4) + 8))(
          a3,
          v8,
          v5,
          &v13,
          &v12) )
    return 0;
  v9 = v12;
  if ( !v12 )
    goto LABEL_7;
  v10 = v13;
  *a4 = *(_DWORD *)(*(_DWORD *)(v13 + 4) + 4 * *(_DWORD *)(v12 + 12));
  v11 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v10 + 4) + 52);
  if ( v11 )
    v11(a3, v10, v9);
  return 1;
}

//----- (100159B0) --------------------------------------------------------
void __cdecl sub_100159B0(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  unsigned int v4; // ST04_4@4

  v2 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 )
  {
    v3 = *(_DWORD *)(a1 + 24);
    if ( *(_DWORD *)(v3 + 548) )
      (*(void (__cdecl **)(int, int, _DWORD, _DWORD))(v3 + 548))(a1, a2, 0, *(_DWORD *)(v3 + 552));
    sub_10052020(a1, a2);
    (*(void (__cdecl **)(int, int))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE) + 36))(a1, a2);
    sub_10015890(a1, v2, a2);
    v4 = *(_DWORD *)(a2 + 4) - 4;
    *(_DWORD *)a2 = 0;
    sub_10010340(a1, v4);
    *(_DWORD *)(a2 + 4) = 0;
  }
}

//----- (10015A30) --------------------------------------------------------
unsigned int *__cdecl sub_10015A30(int a1, int a2, _DWORD *a3)
{
  int v3; // ebx@1
  unsigned int v4; // esi@1
  unsigned int v5; // esi@2
  unsigned int *result; // eax@2
  unsigned int *v7; // edx@2
  unsigned int v8; // eax@3

  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)(*(_DWORD *)a2 + 12);
  if ( v4 >= *(_DWORD *)(*(_DWORD *)a2 + 8) )
  {
    v5 = ((v4 + 1) >> 1) + v4;
    result = (unsigned int *)sub_10011870(a1, (void *)(*(_DWORD *)(a2 + 4) - 4), 4 * v5 + 4);
    v7 = result;
    if ( !result )
      return result;
    v8 = *result + 1;
    if ( v8 <= v5 )
      memset32(&v7[v8], -2147483647, v5 - v8 + 1);
    *(_DWORD *)(v3 + 8) = v5;
    *v7 = v5;
    *(_DWORD *)(a2 + 4) = v7 + 1;
  }
  result = (unsigned int *)1;
  *a3 = (*(_DWORD *)(v3 + 12))++;
  return result;
}

//----- (10015AB0) --------------------------------------------------------
unsigned int __cdecl sub_10015AB0(int a1, int a2, int a3)
{
  int v3; // edi@1
  unsigned int result; // eax@3
  unsigned int v5; // esi@4
  unsigned int v6; // esi@5

  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * a3) = -2147483647;
  v3 = *(_DWORD *)a2;
  if ( *(_DWORD *)(*(_DWORD *)a2 + 12) == a3 + 1 )
    *(_DWORD *)(v3 + 12) = a3;
  result = *(_DWORD *)(v3 + 8);
  if ( result > 5 )
  {
    v5 = *(_DWORD *)(v3 + 12);
    result >>= 1;
    if ( v5 < result )
    {
      v6 = (v5 >> 1) + v5;
      if ( v6 < 5 )
        v6 = 5;
      result = (unsigned int)sub_10011870(a1, (void *)(*(_DWORD *)(a2 + 4) - 4), 4 * v6 + 4);
      if ( result )
      {
        *(_DWORD *)(v3 + 8) = v6;
        *(_DWORD *)result = v6;
        result += 4;
        *(_DWORD *)(a2 + 4) = result;
      }
    }
  }
  return result;
}

//----- (10015B30) --------------------------------------------------------
int __usercall sub_10015B30@<eax>(_WORD *a1@<eax>, int a2, int a3)
{
  int v3; // esi@1
  __int16 *v4; // edi@1
  unsigned int v5; // ebp@1
  unsigned int v6; // ebx@1
  unsigned __int16 i; // ax@2
  int v8; // ebx@4
  int result; // eax@11

  v3 = *a1 - 48;
  v4 = a1 + 1;
  v5 = 0;
  v6 = 0;
  if ( *a1 != 48 )
  {
    for ( i = *v4; i < 0x80u; v3 = v6 + 10 * v3 )
    {
      if ( !isdigit(i) )
        break;
      v8 = (unsigned __int16)*v4;
      i = v4[1];
      ++v4;
      v6 = v8 - 48;
      v5 = v3;
    }
  }
  if ( *v4 || v5 >= 0x6666666 && (v5 != 107374182 || v6 > 3) )
  {
    result = a2;
  }
  else
  {
    if ( a3 )
      v3 = -v3;
    result = 2 * v3 | 1;
  }
  return result;
}

//----- (10015BB0) --------------------------------------------------------
_DWORD *__cdecl sub_10015BB0(int a1, int a2, int a3, signed int (*a4)(), signed int (*a5)(), signed int a6, int a7, int a8, int a9)
{
  _DWORD *result; // eax@1
  int v10; // ebx@2
  unsigned int v11; // esi@4
  _WORD *v12; // edi@4
  int v13; // ebp@4
  _DWORD *v14; // [sp+0h] [bp-4h]@1

  result = sub_10039ED0(a1, a2);
  v14 = result;
  if ( result )
  {
    v10 = a3;
    if ( !(a3 & 1) || a3 == -2147483647 )
    {
      v11 = *(_DWORD *)(a3 + 8) & 0xFFFFFFF8;
      v12 = *(_WORD **)(v11 + 4);
      v13 = *v12 == 45;
      if ( *v12 == 45 )
        ++v12;
      if ( *v12 < 0x80u && isdigit(*v12) && (unsigned int)(*(_DWORD *)v11 - v13) <= 0xA )
        v10 = sub_10015B30(v12, a3, v13);
    }
    result = (_DWORD *)sub_10039FC0(a1, (int)v14, v10, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

//----- (10015C70) --------------------------------------------------------
_DWORD *__cdecl sub_10015C70(int a1, unsigned int a2, int a3, int a4, char a5, signed int (*a6)(), signed int (*a7)())
{
  _DWORD *result; // eax@1
  int v8; // edx@3
  unsigned int v9; // ecx@4
  int v10; // esi@4
  int v11; // ecx@4
  int v12; // esi@4

  result = sub_10039ED0(a1, a2);
  if ( result )
  {
    result = sub_1003A470(a1, (int)result, a3, a4, a5, a6, a7);
    if ( result )
    {
      v8 = *(_DWORD *)(a1 + 24) + 588;
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 24) + 8784) )
      {
        v9 = (*result ^ (a2 >> 3)) & 0x3FF;
        v10 = *(_DWORD *)(v8 + 8 * v9);
        v11 = v8 + 8 * v9;
        v12 = *(_DWORD *)(v11 + 4);
        *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8780) = 0;
        *(_DWORD *)v11 = a2;
        *(_DWORD *)(v11 + 4) = result;
      }
    }
  }
  return result;
}

//----- (10015D00) --------------------------------------------------------
int __cdecl sub_10015D00(int a1, unsigned int a2, int a3, _DWORD *a4, unsigned int *a5)
{
  unsigned int v5; // esi@3
  _WORD *v6; // edi@3
  int v7; // ebp@3
  unsigned int v8; // ebx@9
  int v9; // edi@10
  unsigned int v10; // eax@11
  unsigned int v11; // ebp@12
  int v12; // edx@15
  int v13; // eax@15
  int v14; // edi@16
  signed int v15; // ebp@16
  _BYTE *v16; // ecx@17
  int v17; // ecx@18
  int v18; // eax@23
  int v19; // edi@25
  int v20; // eax@27
  int (__cdecl **v21)(int, int, int, int, int); // edx@27
  int v22; // eax@34
  unsigned int v23; // eax@44
  int (__cdecl **v24)(int, int, int, int, int); // ecx@45
  int v26; // [sp-8h] [bp-3Ch]@33
  unsigned int v27; // [sp+10h] [bp-24h]@11
  int v28; // [sp+14h] [bp-20h]@10
  int *v29; // [sp+18h] [bp-1Ch]@23
  signed int (*v30)(); // [sp+1Ch] [bp-18h]@12
  unsigned int *v31; // [sp+20h] [bp-14h]@13
  unsigned int v32; // [sp+24h] [bp-10h]@9
  int v33; // [sp+28h] [bp-Ch]@15
  unsigned int v34; // [sp+2Ch] [bp-8h]@13
  int v35; // [sp+30h] [bp-4h]@13

  if ( !(a3 & 1) || a3 == -2147483647 )
  {
    v5 = *(_DWORD *)(a3 + 8) & 0xFFFFFFF8;
    v6 = *(_WORD **)(v5 + 4);
    v7 = *v6 == 45;
    if ( *v6 == 45 )
      ++v6;
    if ( *v6 < 0x80u && isdigit(*v6) && (unsigned int)(*(_DWORD *)v5 - v7) <= 0xA )
      a3 = sub_10015B30(v6, a3, v7);
  }
  v8 = a2;
  v32 = a2;
  while ( 1 )
  {
    v9 = *(_DWORD *)v8;
    v28 = *(_DWORD *)v8;
    if ( *(_DWORD *)(*(_DWORD *)v8 + 16) == v8 )
    {
      v10 = *sub_10039580(v9, a3, 0) & 0xFFFFFFFE;
      v27 = v10;
      if ( v10 )
        goto LABEL_52;
    }
    else
    {
      v27 = 0;
    }
    v11 = *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) & 0xFFFFFFFE;
    v30 = *(signed int (**)())(v11 + 28);
    if ( v30 == sub_10010500 )
      goto LABEL_44;
    v34 = v8;
    v35 = a3;
    if ( !sub_10015090(1, (int)&v34, a1, &v31) )
      return 0;
    if ( !v31 )
    {
LABEL_53:
      *a4 = 0;
      *a5 = 0;
      return 1;
    }
    v12 = *(_DWORD *)(*(_DWORD *)(a1 + 308) + 24);
    *a5 = 0;
    v13 = *(_DWORD *)(v11 + 4);
    v33 = v12;
    if ( !(v13 & 4) )
    {
      v22 = a3;
      if ( !(a3 & 1) )
        v22 = *(_DWORD *)(a3 + 8);
      v19 = ((int (__cdecl *)(int, unsigned int, int))v30)(a1, a2, v22);
      if ( !v19 )
        goto LABEL_40;
      v20 = *(_DWORD *)a2;
      v28 = *(_DWORD *)a2;
      if ( *(_DWORD *)(*(_DWORD *)a2 + 16) != a2 )
        goto LABEL_40;
      v26 = a3;
      goto LABEL_39;
    }
    v14 = *(_DWORD *)(a1 + 56);
    v15 = 0;
    if ( v14 )
    {
      v16 = *(_BYTE **)(v14 + 56);
      if ( v16 )
      {
        v17 = dword_100D1E4C[4 * *v16];
        if ( (v17 & 0x30) != 16 )
          v15 = 1;
        if ( v17 & 0x40 || *(_BYTE *)(v14 + 76) & 8 )
          v15 |= 2u;
      }
    }
    v29 = (int *)((v13 & 0x20) != 0 ? v32 : 0);
    ++*(_DWORD *)(*(_DWORD *)(a1 + 24) + 72);
    v18 = a3;
    if ( !(a3 & 1) )
      v18 = *(_DWORD *)(a3 + 8);
    v19 = ((int (__cdecl *)(int, unsigned int, int, signed int, int **))v30)(a1, a2, v18, v15, &v29);
    --*(_DWORD *)(*(_DWORD *)(a1 + 24) + 72);
    if ( !v19 || !v29 )
      goto LABEL_40;
    v20 = *v29;
    v21 = *(int (__cdecl ***)(int, int, int, int, int))(*v29 + 4);
    v28 = *v29;
    if ( v21 != &off_101614B0 && (!v21 || *v21 != off_101614B0) )
    {
      v19 = (*(int (__cdecl **)(int, int *, int, _DWORD *, unsigned int *))(*(_DWORD *)(v20 + 4) + 8))(
              a1,
              v29,
              a3,
              a4,
              a5);
      goto LABEL_40;
    }
    if ( *(int **)(v20 + 16) == v29 )
    {
      v26 = a3;
LABEL_39:
      v27 = *sub_10039580(v20, v26, 0) & 0xFFFFFFFE;
    }
LABEL_40:
    sub_10015110(v31, a1, (int)&v34, 1, v33);
    if ( !v19 || *a5 )
      return v19;
    if ( v27 )
    {
      v9 = v28;
      v10 = v27;
LABEL_52:
      *a4 = *(_DWORD *)(v9 + 16);
      *a5 = v10;
      return 1;
    }
    v8 = a2;
LABEL_44:
    v23 = **(_DWORD **)(v8 + 4) & 0xFFFFFFF8;
    if ( !v23 )
      goto LABEL_53;
    v24 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v23 + 4);
    if ( v24 != &off_101614B0 && (!v24 || *v24 != off_101614B0) )
      return (*(int (__cdecl **)(int, unsigned int, int, _DWORD *, unsigned int *))(*(_DWORD *)(*(_DWORD *)v23 + 4) + 8))(
               a1,
               v23,
               a3,
               a4,
               a5);
    a2 = **(_DWORD **)(v8 + 4) & 0xFFFFFFF8;
    v8 = **(_DWORD **)(v8 + 4) & 0xFFFFFFF8;
  }
}
// 100D1E4C: using guessed type int dword_100D1E4C[];
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10016010) --------------------------------------------------------
signed int __cdecl sub_10016010(int a1, int a2, unsigned int *a3, unsigned int *a4, _DWORD *a5)
{
  int v5; // ebp@1
  int v6; // ebx@1
  unsigned int v7; // esi@1
  int v8; // edi@1
  int v9; // edx@2
  _DWORD *v10; // eax@5
  int v11; // edx@9
  unsigned int v12; // eax@10
  _DWORD *v13; // ecx@11
  unsigned int *v15; // ecx@12
  _DWORD *v16; // edx@12
  unsigned int v17; // ecx@14
  int (__cdecl **v18)(int, int, int, int, int); // eax@14
  int v19; // eax@18
  int v20; // edi@18
  int v21; // eax@18
  int v22; // edi@18
  unsigned int v23; // [sp+10h] [bp-Ch]@8
  int v24; // [sp+14h] [bp-8h]@18
  int v25; // [sp+18h] [bp-4h]@18

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 24);
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52);
  v8 = a2;
  while ( 1 )
  {
    v9 = *(_DWORD *)(*(_DWORD *)v7 + 4);
    if ( (int (__cdecl **)(int, int, int, int, int))v9 == &off_101614B0
      || v9 && *(int (__cdecl **)(int, int, int, int, int))v9 == off_101614B0 )
    {
      v10 = *(_DWORD **)(v6 + 8 * (((unsigned __int16)v8 ^ (unsigned __int16)(v7 >> 3)) & 0x3FF) + 592);
      if ( v10 )
      {
        if ( *(_DWORD *)(v6 + 8 * (((unsigned __int16)v8 ^ (unsigned __int16)(v7 >> 3)) & 0x3FF) + 588) == v7
          && *v10 == v8 )
        {
          v15 = a4;
          *a3 = v7;
          v16 = a5;
          *v15 = v7;
          *v16 = v10;
          return 1;
        }
      }
    }
    if ( !(*(int (__cdecl **)(int, unsigned int, int, unsigned int *, int *))(v9 + 8))(v5, v7, v8, &v23, &a1) )
      return 0;
    v11 = a1;
    if ( a1 )
      break;
    v12 = v7;
    v7 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4) & 0xFFFFFFF8;
    if ( !v7 )
    {
      v13 = a5;
      *a3 = v12;
      *a4 = 0;
      *v13 = 0;
      return 1;
    }
  }
  v17 = v23;
  v18 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v23 + 4);
  if ( (v18 == &off_101614B0 || v18 && *v18 == off_101614B0) && !*(_DWORD *)(v6 + 8784) )
  {
    v19 = ((unsigned __int16)v8 ^ (unsigned __int16)(v23 >> 3)) & 0x3FF;
    v20 = *(_DWORD *)(v6 + 8 * v19 + 588);
    v21 = v6 + 8 * v19 + 588;
    v24 = v20;
    v22 = *(_DWORD *)(v21 + 4);
    *(_DWORD *)(v6 + 8780) = 0;
    *(_DWORD *)v21 = v17;
    *(_DWORD *)(v21 + 4) = v11;
    v11 = a1;
    v17 = v23;
    v25 = v22;
  }
  *a3 = v7;
  *a4 = v17;
  *a5 = v11;
  return 1;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10016170) --------------------------------------------------------
int __cdecl sub_10016170(int a1, int a2)
{
  void (__cdecl *v3)(int, int, int); // eax@4
  int v4; // eax@7
  char v5; // al@9
  int v6; // [sp+8h] [bp-Ch]@1
  int v7; // [sp+Ch] [bp-8h]@1
  int v8; // [sp+10h] [bp-4h]@1

  if ( !sub_10016010(a1, a2, (unsigned int *)&v6, (unsigned int *)&v8, &v7) )
    return 0;
  if ( v7 )
  {
    v3 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v8 + 4) + 52);
    if ( v3 )
    {
      v3(a1, v8, v7);
      return v6;
    }
  }
  else if ( *(_BYTE *)(a1 + 300) & 1 )
  {
    v4 = a2;
    if ( !(a2 & 1) )
      v4 = *(_DWORD *)(a2 + 8);
    v5 = (unsigned int)sub_10010FF0(v4 & 0xFFFFFFF8);
    if ( !sub_10011140(a1, 5, (int)sub_1003ED50, 0, 156, v5) )
      return 0;
  }
  return v6;
}

//----- (10016210) --------------------------------------------------------
int __cdecl sub_10016210(int a1, unsigned int a2, int a3, _DWORD *a4)
{
  int v4; // ebx@1
  unsigned int v5; // esi@3
  _WORD *v6; // edi@3
  int v7; // ebp@3
  int v8; // ecx@10
  int v9; // eax@11
  int v10; // eax@16
  char *v11; // eax@17
  char v12; // al@18
  int v13; // ecx@20
  _BYTE *v14; // eax@20
  unsigned int v15; // ecx@20
  int v16; // eax@24
  _BYTE *v17; // eax@26
  char v18; // al@27
  int v20; // eax@29
  int v21; // edx@29
  int v22; // edx@29
  void (__cdecl *v23)(int, unsigned int, int); // edx@32
  int v24; // esi@35
  int v25; // eax@43
  unsigned int v26; // edx@44
  int v27; // ecx@44
  int v28; // esi@44
  int v29; // ecx@44
  int v30; // esi@44
  int v31; // esi@48
  int (__cdecl *v32)(int, unsigned int); // eax@52
  unsigned int v33; // eax@53
  unsigned int v34; // [sp+10h] [bp-14h]@9
  int v35; // [sp+14h] [bp-10h]@9
  int v36; // [sp+18h] [bp-Ch]@35
  int v37; // [sp+1Ch] [bp-8h]@29
  int v38; // [sp+20h] [bp-4h]@44

  v4 = a3;
  if ( !(a3 & 1) || a3 == -2147483647 )
  {
    v5 = *(_DWORD *)(a3 + 8) & 0xFFFFFFF8;
    v6 = *(_WORD **)(v5 + 4);
    v7 = *v6 == 45;
    if ( *v6 == 45 )
      ++v6;
    if ( *v6 < 0x80u && isdigit(*v6) && (unsigned int)(*(_DWORD *)v5 - v7) <= 0xA )
    {
      a3 = sub_10015B30(v6, a3, v7);
      v4 = a3;
    }
  }
  if ( !sub_10015D00(a1, a2, v4, &v34, (unsigned int *)&v35) )
    return 0;
  v8 = v35;
  if ( !v35 )
  {
    v9 = a3;
    *a4 = -2147483647;
    if ( !(a3 & 1) )
      v9 = *(_DWORD *)(a3 + 8);
    if ( !(*(int (__cdecl **)(int, unsigned int, int, _DWORD *))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE) + 16))(
            a1,
            a2,
            v9,
            a4) )
      return 0;
    if ( *(_BYTE *)(a1 + 300) & 1 )
    {
      if ( *a4 == -2147483647 )
      {
        v10 = *(_DWORD *)(a1 + 56);
        if ( v10 )
        {
          v11 = *(char **)(v10 + 56);
          if ( v11 )
          {
            v12 = *v11;
            if ( v12 == 53 || v12 == 55 )
            {
              v13 = *(_DWORD *)(a1 + 56);
              v14 = (_BYTE *)(byte_100D1E48[16 * **(_BYTE **)(v13 + 56)] + *(_DWORD *)(v13 + 56));
              v15 = **(_DWORD **)(v13 + 12) + *(_DWORD *)(*(_DWORD *)(v13 + 12) + 4);
              if ( (unsigned int)v14 < v15 )
              {
                while ( *v14 != 39 )
                {
                  if ( *v14 == -125 && (unsigned int)++v14 < v15 )
                    continue;
                  goto LABEL_24;
                }
                return 1;
              }
LABEL_24:
              v16 = a3;
              if ( !(a3 & 1) )
                v16 = *(_DWORD *)(a3 + 8);
              v17 = sub_1004F8E0(a1, 0, v16, 0);
              if ( !v17 )
                return 0;
              v18 = (unsigned int)sub_10010FF0((unsigned int)v17);
              if ( !sub_10011140(a1, 5, (int)sub_1003ED50, 0, 162, v18) )
                return 0;
            }
          }
        }
      }
    }
    return 1;
  }
  v20 = v34;
  v21 = *(_DWORD *)v34;
  v37 = v21;
  v22 = *(_DWORD *)(v21 + 4);
  if ( (int (__cdecl **)(int, int, int, int, int))v22 == &off_101614B0
    || v22 && *(int (__cdecl **)(int, int, int, int, int))v22 == off_101614B0 )
  {
    v36 = *(_DWORD *)(v35 + 12);
    v24 = v36;
    if ( v36 == -1 )
    {
      *a4 = -2147483647;
    }
    else
    {
      *a4 = *(_DWORD *)(*(_DWORD *)(v34 + 4) + 4 * v36);
      if ( !*(_DWORD *)(v8 + 4) )
        return 1;
    }
    if ( *(_BYTE *)(v8 + 16) & 0x10 )
    {
      if ( !sub_10030390(a1, a2, *(_DWORD *)v8, *(_DWORD *)(v8 + 4), 4, 0, 0, (int)a4) )
        return 0;
    }
    else
    {
      if ( !*(_DWORD *)(v8 + 4) )
        goto LABEL_42;
      if ( *(_BYTE *)(v8 + 17) & 8 )
      {
        v31 = 2 * *(_WORD *)(v8 + 18) | 1;
      }
      else if ( *(_DWORD *)v8 & 1 )
      {
        v31 = *(_DWORD *)v8;
      }
      else
      {
        v31 = *(_DWORD *)(*(_DWORD *)v8 + 8);
      }
      v32 = *(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 48);
      if ( v32 )
      {
        v33 = v32(a1, a2);
        v8 = v35;
      }
      else
      {
        v33 = a2;
      }
      if ( !(*(int (__cdecl **)(int, unsigned int, int, _DWORD *))(v8 + 4))(a1, v33, v31, a4) )
        return 0;
      v24 = v36;
    }
    v20 = v34;
    v8 = v35;
LABEL_42:
    if ( *(_DWORD *)(v8 + 12) < *(_DWORD *)(v37 + 12) )
    {
      *(_DWORD *)(*(_DWORD *)(v20 + 4) + 4 * v24) = *a4;
      v25 = *(_DWORD *)(a1 + 24) + 588;
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 24) + 8784) )
      {
        v26 = v34;
        v27 = ((unsigned __int16)a3 ^ (unsigned __int16)(v34 >> 3)) & 0x3FF;
        v28 = *(_DWORD *)(v25 + 8 * v27);
        v29 = v25 + 8 * v27;
        v37 = v28;
        v38 = *(_DWORD *)(v29 + 4);
        v30 = v35;
        *(_DWORD *)(v25 + 0x2000) = 0;
        *(_DWORD *)v29 = v26;
        *(_DWORD *)(v29 + 4) = v30;
      }
    }
    return 1;
  }
  v23 = *(void (__cdecl **)(int, unsigned int, int))(v22 + 52);
  if ( v23 )
  {
    v23(a1, v34, v35);
    v20 = v34;
  }
  return (*(int (__cdecl **)(int, int, int, _DWORD *))(*(_DWORD *)(*(_DWORD *)v20 + 4) + 16))(a1, v20, a3, a4);
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10016530) --------------------------------------------------------
int __cdecl sub_10016530(int a1, unsigned int a2, int a3, _DWORD *a4)
{
  int v4; // ebx@1
  unsigned int v5; // esi@3
  _WORD *v6; // edi@3
  int v7; // ebp@3
  int v8; // ecx@10
  int v9; // eax@11
  void (__cdecl *v10)(int, int, int); // eax@14
  unsigned int v11; // esi@17
  signed int (*v12)(); // eax@17
  signed int (*v13)(); // edx@17
  int v14; // ebx@17
  int v15; // ebp@17
  _DWORD *v16; // ebp@18
  char v17; // dl@18
  int v18; // eax@18
  int v19; // eax@18
  signed int v20; // eax@22
  int result; // eax@24
  int v22; // esi@33
  int (__cdecl *v23)(int, unsigned int); // eax@36
  unsigned int v24; // eax@37
  int v25; // edx@42
  signed int (*v26)(); // eax@42
  signed int (*v27)(); // ecx@42
  int v28; // eax@46
  _BYTE *v29; // eax@48
  char v30; // al@49
  unsigned int v31; // eax@54
  int v32; // eax@56
  unsigned int v33; // eax@62
  int v34; // edx@64
  int v35; // eax@65
  int v36; // esi@65
  int v37; // eax@65
  int v38; // esi@65
  int v39; // ebx@66
  char v40; // al@68
  int v41; // eax@69
  int v42; // esi@74
  int (__cdecl *v43)(int, unsigned int); // eax@77
  unsigned int v44; // eax@78
  int v45; // [sp+10h] [bp-20h]@9
  _DWORD *v46; // [sp+14h] [bp-1Ch]@18
  int v47; // [sp+18h] [bp-18h]@9
  int v48; // [sp+1Ch] [bp-14h]@17
  signed int (*v49)(); // [sp+20h] [bp-10h]@17
  signed int (*v50)(); // [sp+24h] [bp-Ch]@17
  int v51; // [sp+28h] [bp-8h]@18
  int v52; // [sp+2Ch] [bp-4h]@65

  v4 = a3;
  if ( !(a3 & 1) || a3 == -2147483647 )
  {
    v5 = *(_DWORD *)(a3 + 8) & 0xFFFFFFF8;
    v6 = *(_WORD **)(v5 + 4);
    v7 = *v6 == 45;
    if ( *v6 == 45 )
      ++v6;
    if ( *v6 < 0x80u && isdigit(*v6) && (unsigned int)(*(_DWORD *)v5 - v7) <= 0xA )
    {
      a3 = sub_10015B30(v6, a3, v7);
      v4 = a3;
    }
  }
  if ( !sub_10015D00(a1, a2, v4, &v47, (unsigned int *)&v45) )
    return 0;
  v8 = v45;
  if ( v45 )
  {
    v9 = *(_DWORD *)(*(_DWORD *)v47 + 4);
    if ( (int (__cdecl **)(int, int, int, int, int))v9 != &off_101614B0
      && (!v9 || *(int (__cdecl **)(int, int, int, int, int))v9 != off_101614B0) )
    {
      v10 = *(void (__cdecl **)(int, int, int))(v9 + 52);
      if ( v10 )
        v10(a1, v47, v45);
      v8 = 0;
      v45 = 0;
    }
  }
  v11 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE;
  v12 = *(signed int (**)())(v11 + 16);
  v13 = *(signed int (**)())(v11 + 20);
  v14 = 0;
  v15 = 1;
  v48 = 0;
  v50 = v12;
  v49 = v13;
  if ( !v8 )
    goto LABEL_44;
  v16 = *(_DWORD **)v47;
  v17 = *(_BYTE *)(v8 + 16);
  v18 = *(_BYTE *)(v8 + 16);
  v51 = v18;
  v19 = v18 & 2;
  v46 = v16;
  if ( v19 )
    goto LABEL_21;
  if ( *((_BYTE *)v16 + 20) & 2 )
  {
    if ( v47 == a2 )
    {
LABEL_21:
      if ( v19 )
      {
        v20 = *(_DWORD *)(a1 + 16);
        if ( v20 )
        {
          if ( v20 >= 130 )
            return 1;
          goto LABEL_46;
        }
        return 1;
      }
LABEL_46:
      v28 = a3;
      if ( !(a3 & 1) )
        v28 = *(_DWORD *)(a3 + 8);
      v29 = sub_1004F8E0(a1, 0, v28, 0);
      if ( v29 )
      {
        v30 = (unsigned int)sub_10010FF0((unsigned int)v29);
        sub_100110F0(a1, (int)sub_1003ED50, 0, 19, v30);
      }
      return 0;
    }
  }
  else if ( v47 == a2 )
  {
    goto LABEL_66;
  }
  if ( !(v51 & 0x40) )
  {
    v15 = 1;
    if ( *(_BYTE *)(v8 + 17) & 8 )
    {
      v25 = *(_WORD *)(v8 + 18);
      v26 = *(signed int (**)())(v8 + 4);
      v27 = *(signed int (**)())(v8 + 8);
      v14 = 8;
      v48 = v25;
      v50 = v26;
      v49 = v27;
    }
    v45 = 0;
LABEL_44:
    if ( *(_BYTE *)(*(_DWORD *)a2 + 20) & 2 && *(_DWORD *)(*(_DWORD *)a2 + 16) == a2 )
      goto LABEL_46;
    v46 = sub_10039ED0(a1, a2);
    if ( !v46 )
      return 0;
    if ( *(_BYTE *)(v11 + 4) & 0x10 )
      v15 = 65;
    v31 = sub_10039FC0(a1, (int)v46, a3, v50, v49, -1, v15, v14, v48);
    v45 = v31;
    if ( !v31 )
      return 0;
    if ( *(_BYTE *)(v31 + 17) & 8 )
    {
      v32 = 2 * *(_WORD *)(v31 + 18) | 1;
    }
    else
    {
      v32 = *(_DWORD *)v31;
      if ( !(v32 & 1) )
        v32 = *(_DWORD *)(v32 + 8);
    }
    if ( !(*(int (__cdecl **)(int, unsigned int, int, _DWORD *))(v11 + 8))(a1, a2, v32, a4) )
    {
      sub_1003A590(a1, (int)v46, a3);
      return 0;
    }
    v8 = v45;
    v33 = *(_DWORD *)(v45 + 12);
    if ( v33 < v46[3] )
    {
      *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v33) = -2147483647;
      v8 = v45;
    }
    v34 = *(_DWORD *)(a1 + 24) + 588;
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 24) + 8784) )
    {
      v35 = ((unsigned __int16)a3 ^ (unsigned __int16)(a2 >> 3)) & 0x3FF;
      v36 = *(_DWORD *)(v34 + 8 * v35);
      v37 = v34 + 8 * v35;
      v51 = v36;
      v38 = *(_DWORD *)(v37 + 4);
      *(_DWORD *)(v34 + 0x2000) = 0;
      *(_DWORD *)v37 = a2;
      *(_DWORD *)(v37 + 4) = v8;
      v8 = v45;
      v52 = v38;
    }
LABEL_66:
    v39 = *(_DWORD *)(v8 + 12);
    if ( v39 != -1 && !*(_DWORD *)(v8 + 8) )
      goto LABEL_84;
    v40 = *(_BYTE *)(v8 + 16);
    if ( v40 & 0x20 )
    {
      v41 = sub_10030390(a1, a2, *(_DWORD *)v8, *(_DWORD *)(v8 + 8), 8, 1, (int)a4, (int)a4);
    }
    else
    {
      if ( v40 & 0x10 )
      {
        sub_100110F0(a1, (int)sub_1003ED50, 0, 160, 0);
        return 0;
      }
      if ( !*(_DWORD *)(v8 + 8) )
      {
LABEL_83:
        if ( *(_DWORD *)(v8 + 12) >= v46[3] )
          return 1;
LABEL_84:
        *(_BYTE *)(*(_DWORD *)(a1 + 24) + 96) = 1;
        *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v39) = *a4;
        return 1;
      }
      if ( *(_BYTE *)(v8 + 17) & 8 )
      {
        v42 = 2 * *(_WORD *)(v8 + 18) | 1;
      }
      else
      {
        v42 = *(_DWORD *)v8;
        if ( !(*(_DWORD *)v8 & 1) )
          v42 = *(_DWORD *)(*(_DWORD *)v8 + 8);
      }
      v43 = *(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 48);
      if ( v43 )
      {
        v44 = v43(a1, a2);
        v8 = v45;
      }
      else
      {
        v44 = a2;
      }
      v41 = (*(int (__cdecl **)(int, unsigned int, int, _DWORD *))(v8 + 8))(a1, v44, v42, a4);
    }
    if ( !v41 )
      return 0;
    v8 = v45;
    goto LABEL_83;
  }
  if ( v17 & 0x20 )
    return sub_10030390(a1, a2, *(_DWORD *)v8, *(_DWORD *)(v8 + 8), 8, 1, (int)a4, (int)a4);
  if ( v17 & 0x10 )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 160, 0);
    return 0;
  }
  if ( !*(_DWORD *)(v8 + 8) )
    return 1;
  if ( *(_BYTE *)(v8 + 17) & 8 )
  {
    v22 = 2 * *(_WORD *)(v8 + 18) | 1;
  }
  else
  {
    v22 = *(_DWORD *)v8;
    if ( !(*(_DWORD *)v8 & 1) )
      v22 = *(_DWORD *)(*(_DWORD *)v8 + 8);
  }
  v23 = *(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 48);
  if ( v23 )
  {
    v24 = v23(a1, a2);
    v8 = v45;
  }
  else
  {
    v24 = a2;
  }
  result = (*(int (__cdecl **)(int, unsigned int, int, _DWORD *))(v8 + 8))(a1, v24, v22, a4);
  if ( result )
    return 1;
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (100169C0) --------------------------------------------------------
int __cdecl sub_100169C0(int a1, unsigned int a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax@1
  unsigned int v6; // edx@1
  int v7; // ebx@1
  int v8; // edi@2
  int result; // eax@2
  int v10; // ecx@5
  int v11; // edi@8
  void (__cdecl *v12)(int, unsigned int, int); // eax@8
  void (__cdecl *v13)(int, unsigned int, int); // ecx@12

  v5 = a4;
  v6 = a2;
  v7 = a4 == 0;
  if ( a4 )
    goto LABEL_17;
  v8 = a3;
  result = sub_10015D00(a1, a2, a3, &a2, (unsigned int *)&a4);
  if ( !result )
    return result;
  v5 = a4;
  if ( !a4 )
  {
    *a5 = 0;
    return 1;
  }
  v6 = a2;
  v10 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  if ( (int (__cdecl **)(int, int, int, int, int))v10 == &off_101614B0
    || v10 && *(int (__cdecl **)(int, int, int, int, int))v10 == off_101614B0 )
  {
LABEL_17:
    *a5 = *(_BYTE *)(v5 + 16);
    if ( v7 )
    {
      v13 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)v6 + 4) + 52);
      if ( v13 )
        v13(a1, v6, v5);
    }
    result = 1;
  }
  else
  {
    v11 = (*(int (__cdecl **)(int, unsigned int, int, int, _DWORD *))(v10 + 24))(a1, a2, v8, a4, a5);
    v12 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 52);
    if ( v12 )
      v12(a1, a2, a4);
    result = v11;
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10016AA0) --------------------------------------------------------
int __cdecl sub_10016AA0(int a1, unsigned int a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax@1
  int v6; // edi@1
  int v7; // ebx@2
  int result; // eax@2
  unsigned int v9; // edx@5
  int v10; // ecx@5
  int v11; // edi@8
  void (__cdecl *v12)(int, unsigned int, int); // eax@8
  _DWORD *v13; // ebx@12
  void (__cdecl *v14)(int, unsigned int, int); // eax@13

  v5 = a4;
  v6 = a4 == 0;
  if ( a4 )
  {
    v9 = a2;
  }
  else
  {
    v7 = a3;
    result = sub_10015D00(a1, a2, a3, &a2, (unsigned int *)&a4);
    if ( !result )
      return result;
    v5 = a4;
    if ( !a4 )
      return 1;
    v9 = a2;
    v10 = *(_DWORD *)(*(_DWORD *)a2 + 4);
    if ( (int (__cdecl **)(int, int, int, int, int))v10 != &off_101614B0
      && (!v10 || *(int (__cdecl **)(int, int, int, int, int))v10 != off_101614B0) )
    {
      v11 = (*(int (__cdecl **)(int, unsigned int, int, int, _DWORD *))(v10 + 28))(a1, a2, v7, a4, a5);
      v12 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 52);
      if ( v12 )
        v12(a1, a2, a4);
      return v11;
    }
  }
  v13 = sub_10015C70(a1, v9, v5, *a5 & 0xFFFFFFCF, 0, *(signed int (**)())(v5 + 4), *(signed int (**)())(v5 + 8));
  if ( v6 )
  {
    v14 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 52);
    if ( v14 )
      v14(a1, a2, a4);
  }
  return v13 != 0;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10016BA0) --------------------------------------------------------
int __cdecl sub_10016BA0(int a1, unsigned int a2, int a3, signed int *a4)
{
  int v4; // eax@1
  bool v5; // sf@2
  unsigned __int8 v6; // of@2
  signed int v7; // eax@2
  int v8; // ebx@4
  bool v9; // zf@4
  unsigned int v10; // esi@6
  _WORD *v11; // edi@6
  int v12; // ebp@6
  int v13; // eax@13
  int v14; // edi@14
  void (__cdecl *v15)(int, unsigned int, int); // ecx@16
  int v16; // esi@17
  signed int v17; // eax@19
  _BYTE *v18; // eax@23
  char v19; // al@24
  int result; // eax@25
  int v21; // eax@29
  void (__cdecl *v22)(int, unsigned int, int); // eax@33
  int v23; // ebp@36
  int v24; // ecx@38
  int v25; // eax@39
  int v26; // edx@39
  int v27; // eax@39
  signed int v28; // ebx@40
  void (__cdecl *v29)(int, unsigned int, int); // eax@40
  int (__cdecl **v30)(int, int, int, int, int); // ecx@43
  void (__cdecl *v31)(int, int, int); // ecx@48
  int v32; // [sp+0h] [bp-Ch]@12
  int v33; // [sp+4h] [bp-8h]@15
  int v34; // [sp+8h] [bp-4h]@39

  v4 = *(_DWORD *)(a1 + 16);
  if ( !v4 || (v6 = __OFSUB__(v4, 130), v5 = v4 - 130 < 0, v7 = -2147483647, !(v5 ^ v6)) )
    v7 = 14;
  v8 = a3;
  v9 = (a3 & 1) == 0;
  *a4 = v7;
  if ( v9 || v8 == -2147483647 )
  {
    v10 = *(_DWORD *)(v8 + 8) & 0xFFFFFFF8;
    v11 = *(_WORD **)(v10 + 4);
    v12 = *v11 == 45;
    if ( *v11 == 45 )
      ++v11;
    if ( *v11 < 0x80u && isdigit(*v11) && (unsigned int)(*(_DWORD *)v10 - v12) <= 0xA )
      v8 = sub_10015B30(v11, v8, v12);
  }
  if ( !sub_10015D00(a1, a2, v8, &v32, (unsigned int *)&a3) )
    return 0;
  v13 = a3;
  if ( !a3 )
  {
LABEL_51:
    if ( !(v8 & 1) )
      v8 = *(_DWORD *)(v8 + 8);
    return (*(int (__cdecl **)(int, unsigned int, int, signed int *))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE)
                                                                    + 12))(
             a1,
             a2,
             v8,
             a4);
  }
  v14 = v32;
  if ( v32 != a2 )
  {
    v30 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v32 + 4);
    if ( (v30 == &off_101614B0 || v30 && *v30 == off_101614B0) && !(~*(_BYTE *)(a3 + 16) & 0x44) )
      *a4 = 6;
    v31 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v14 + 4) + 52);
    if ( v31 )
      v31(a1, v14, v13);
    if ( *a4 == 6 )
      return 1;
    goto LABEL_51;
  }
  v9 = (*(_BYTE *)(a3 + 16) & 4) == 0;
  v33 = a3;
  if ( !v9 )
  {
    v15 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 52);
    if ( v15 )
    {
      v16 = a1;
      v15(a1, a2, a3);
    }
    else
    {
      v16 = a1;
    }
    v17 = *(_DWORD *)(v16 + 16);
    if ( v17 && v17 < 130 )
    {
      if ( !(v8 & 1) )
        v8 = *(_DWORD *)(v8 + 8);
      v18 = sub_1004F8E0(v16, 0, v8, 0);
      if ( v18 )
      {
        v19 = (unsigned int)sub_10010FF0((unsigned int)v18);
        sub_100110F0(v16, (int)sub_1003ED50, 0, 37, v19);
      }
      return 0;
    }
    *a4 = 6;
    return 1;
  }
  if ( *(_BYTE *)(a3 + 17) & 8 )
  {
    v21 = 2 * *(_WORD *)(a3 + 18) | 1;
  }
  else
  {
    v21 = *(_DWORD *)a3;
    if ( !(*(_DWORD *)a3 & 1) )
      v21 = *(_DWORD *)(v21 + 8);
  }
  if ( (*(int (__cdecl **)(int, unsigned int, int, signed int *))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE)
                                                                + 12))(
         a1,
         a2,
         v21,
         a4) )
  {
    v23 = *(_DWORD *)a2;
    if ( *(_DWORD *)(v33 + 12) < *(_DWORD *)(*(_DWORD *)a2 + 12) )
      *(_BYTE *)(*(_DWORD *)(a1 + 24) + 96) = 1;
    v24 = *(_DWORD *)(a1 + 24) + 588;
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 24) + 8784) )
    {
      v25 = ((unsigned __int16)v8 ^ (unsigned __int16)(a2 >> 3)) & 0x3FF;
      v26 = *(_DWORD *)(v24 + 8 * v25);
      v27 = v24 + 8 * v25;
      v33 = v26;
      v34 = *(_DWORD *)(v27 + 4);
      *(_DWORD *)(v24 + 0x2000) = 0;
      *(_DWORD *)v27 = a2;
      *(_DWORD *)(v27 + 4) = 0;
    }
    v28 = sub_1003A590(a1, v23, v8);
    v29 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 52);
    if ( v29 )
      v29(a1, a2, a3);
    result = v28;
  }
  else
  {
    v22 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 52);
    if ( v22 )
      v22(a1, a2, a3);
    result = 0;
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10016E50) --------------------------------------------------------
int *__cdecl sub_10016E50(int a1, int a2)
{
  int *result; // eax@1

  result = (int *)sub_10011830(a1, 4 * a2 + 4);
  if ( result )
    *result = a2;
  return result;
}

//----- (10016E80) --------------------------------------------------------
_DWORD *__cdecl sub_10016E80(int a1, void *a2, int a3)
{
  _DWORD *result; // eax@1

  result = sub_10011870(a1, a2, 4 * a3 + 4);
  if ( result )
    *result = a3;
  return result;
}

//----- (10016EB0) --------------------------------------------------------
int __cdecl sub_10016EB0(int a1, int a2, int a3, int *a4, int *a5)
{
  int v5; // esi@1
  unsigned int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int *, int *); // ecx@1
  unsigned int v9; // eax@7
  _DWORD *v10; // ecx@7
  unsigned int v11; // esi@9
  int v12; // ebp@11
  int v13; // ebx@11
  _DWORD *v14; // eax@11
  int *v15; // edi@13
  int v16; // esi@15
  int v17; // edi@15
  int *v18; // eax@23
  int *v19; // ebx@25
  int v20; // eax@33
  int v21; // [sp+Ch] [bp+8h]@11

  v5 = a2;
  v6 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE;
  v7 = *(int (__cdecl **)(int, int, int, int *, int *))(v6 + 24);
  if ( *(_BYTE *)(v6 + 4) & 2 )
    return v7(a1, a2, a3, a4, a5);
  if ( !a3 )
  {
    if ( ((int (__cdecl *)(int, int))v7)(a1, a2) )
    {
      v12 = *(_DWORD *)a2;
      v13 = 0;
      v14 = (_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
      v21 = 0;
      if ( **(_DWORD **)(v5 + 4) & 0xFFFFFFF8 && v12 == *v14 )
      {
        v15 = sub_10016E50(a1, 0);
        if ( !v15 )
          goto LABEL_35;
      }
      else
      {
        v16 = *(_DWORD *)(v12 + 36);
        v17 = *(_DWORD *)(v12 + 36);
        if ( v16 )
        {
          do
          {
            if ( *(_BYTE *)(v17 + 16) & 1
              && !(*(_BYTE *)(v17 + 17) & 4)
              && (!(*(_BYTE *)(v12 + 20) & 1) || (*sub_10039580(v12, *(_DWORD *)v17, 0) & 0xFFFFFFFE) == v17) )
            {
              ++v13;
            }
            v17 = *(_DWORD *)(v17 + 20);
          }
          while ( v17 );
          v21 = v13;
        }
        v18 = sub_10016E50(a1, v13);
        v15 = v18;
        if ( !v18 )
          goto LABEL_35;
        if ( v16 )
        {
          v19 = &v18[v13 + 1];
          do
          {
            if ( *(_BYTE *)(v16 + 16) & 1
              && !(*(_BYTE *)(v16 + 17) & 4)
              && (!(*(_BYTE *)(v12 + 20) & 1) || (*sub_10039580(v12, *(_DWORD *)v16, 0) & 0xFFFFFFFE) == v16) )
            {
              --v19;
              *v19 = *(_DWORD *)v16;
            }
            v16 = *(_DWORD *)(v16 + 20);
          }
          while ( v16 );
          v13 = v21;
        }
      }
      v20 = sub_10011830(a1, 8u);
      if ( v20 )
      {
        *(_DWORD *)(v20 + 4) = v15;
        *(_DWORD *)v20 = 0;
        *a4 = v20 | 1;
        if ( a5 )
          *a5 = 2 * v13 | 1;
        return 1;
      }
      sub_10010480(a1, v15);
    }
LABEL_35:
    *a4 = 0;
    return 0;
  }
  if ( a3 == 1 )
  {
    v9 = *a4 & 0xFFFFFFFE;
    v10 = *(_DWORD **)(v9 + 4);
    if ( *(_DWORD *)v9 != *v10 )
    {
      *a5 = v10[(*(_DWORD *)v9)++ + 1];
      return 1;
    }
  }
  else if ( a3 != 2 )
  {
    return 0;
  }
  v11 = *a4 & 0xFFFFFFFE;
  sub_10010480(a1, *(_DWORD *)(v11 + 4));
  sub_10010340(a1, v11);
  *a4 = 0;
  return 1;
}
// 10010480: using guessed type _DWORD __cdecl sub_10010480(_DWORD, _DWORD);

//----- (10017090) --------------------------------------------------------
int __cdecl sub_10017090(int a1, unsigned int a2, int a3, int a4, signed int *a5, int *a6)
{
  int v6; // ebx@1
  int result; // eax@1
  int v8; // edi@2
  int (__cdecl *v9)(int, unsigned int, int, int, signed int *); // eax@3
  int v10; // ecx@4
  int v11; // ecx@8
  int v12; // eax@8
  void (__cdecl *v13)(int, int, int); // eax@12
  unsigned int v14; // eax@15
  signed int v15; // eax@16
  int (__cdecl *v16)(int, unsigned int, int, int, signed int *); // eax@18
  int v17; // ecx@19
  int v18; // eax@21
  signed int v19; // esi@21
  void (__cdecl *v20)(int, int, int); // eax@23
  int v21; // [sp+Ch] [bp-8h]@1
  int v22; // [sp+10h] [bp-4h]@1

  v6 = a3;
  result = sub_10015D00(a1, a2, a3, &v21, (unsigned int *)&v22);
  if ( !result )
    return result;
  v8 = v22;
  if ( !v22 )
  {
    *a5 = -2147483647;
    *a6 = v8;
    v9 = *(int (__cdecl **)(int, unsigned int, int, int, signed int *))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE)
                                                                      + 44);
    if ( !v9 )
      goto LABEL_28;
    v10 = a3;
    if ( !(a3 & 1) )
      v10 = *(_DWORD *)(a3 + 8);
    result = v9(a1, a2, v10, a4, a5);
    if ( result )
LABEL_28:
      result = 1;
    return result;
  }
  v11 = v21;
  v12 = *(_DWORD *)(*(_DWORD *)v21 + 4);
  if ( (int (__cdecl **)(int, int, int, int, int))v12 != &off_101614B0 )
  {
    if ( !v12 )
    {
LABEL_12:
      v13 = *(void (__cdecl **)(int, int, int))(v12 + 52);
      if ( v13 )
      {
        v13(a1, v21, v22);
        v11 = v21;
      }
      return (*(int (__cdecl **)(int, int, int, int, signed int *, int *))(*(_DWORD *)(*(_DWORD *)v11 + 4) + 44))(
               a1,
               v11,
               v6,
               a4,
               a5,
               a6);
    }
    if ( *(int (__cdecl **)(int, int, int, int, int))v12 != off_101614B0 )
    {
      v6 = a3;
      goto LABEL_12;
    }
  }
  v14 = *(_DWORD *)(v22 + 12);
  if ( v14 >= *(_DWORD *)(*(_DWORD *)v21 + 12) )
    v15 = -2147483647;
  else
    v15 = *(_DWORD *)(*(_DWORD *)(v21 + 4) + 4 * v14);
  *a5 = v15;
  *a6 = *(_BYTE *)(v8 + 16);
  v16 = *(int (__cdecl **)(int, unsigned int, int, int, signed int *))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE)
                                                                     + 44);
  if ( v16 )
  {
    v17 = a3;
    if ( !(a3 & 1) )
      v17 = *(_DWORD *)(a3 + 8);
    v18 = v16(a1, a2, v17, a4, a5);
    v8 = v22;
    v11 = v21;
    v19 = v18;
  }
  else
  {
    v19 = 1;
  }
  v20 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v11 + 4) + 52);
  if ( v20 )
    v20(a1, v11, v8);
  return v19;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10017200) --------------------------------------------------------
_BYTE *__usercall sub_10017200@<eax>(char a1@<dl>, int a2@<edi>, int *a3)
{
  int v3; // esi@1
  _BYTE *result; // eax@3

  v3 = *(_DWORD *)(a2 + 56);
  if ( *(_DWORD *)(v3 + 44) )
  {
    *(_DWORD *)(v3 + 80) = *(_DWORD *)(a2 + 284);
    *(_DWORD *)(a2 + 284) = v3;
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(v3 + 44);
  }
  result = sub_100284B0(a2, a3, a1);
  if ( *(_DWORD *)(v3 + 44) )
  {
    *(_DWORD *)(a2 + 284) = *(_DWORD *)(v3 + 80);
    *(_DWORD *)(v3 + 80) = 0;
    *(_DWORD *)(a2 + 56) = v3;
  }
  return result;
}

//----- (10017250) --------------------------------------------------------
int __cdecl sub_10017250(int a1, int a2, int a3, int a4)
{
  int (__thiscall *v4)(int); // eax@1
  int result; // eax@2

  v4 = *(int (__thiscall **)(int))((*(_DWORD *)(*(_DWORD *)((*(_DWORD *)(a4 - 8) & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE)
                                 + 48);
  if ( v4 )
  {
    result = v4(a4 - 8);
  }
  else
  {
    sub_10017200(0, a1, (int *)(a4 - 8));
    result = 0;
  }
  return result;
}

//----- (10017290) --------------------------------------------------------
int __cdecl sub_10017290(int a1, int a2, int a3, int a4)
{
  int (__thiscall *v4)(int); // eax@1
  int result; // eax@2

  v4 = *(int (__thiscall **)(int))((*(_DWORD *)(*(_DWORD *)((*(_DWORD *)(a4 - 8) & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE)
                                 + 52);
  if ( v4 )
  {
    result = v4(a4 - 8);
  }
  else
  {
    sub_10017200(1, a1, (int *)(a4 - 8));
    result = 0;
  }
  return result;
}

//----- (100172D0) --------------------------------------------------------
int __cdecl sub_100172D0(int a1, int a2, int a3, _DWORD *a4)
{
  int (*v4)(void); // eax@1
  int result; // eax@2

  v4 = *(int (**)(void))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE) + 60);
  if ( v4 )
  {
    result = v4();
  }
  else
  {
    *a4 = 0;
    result = 1;
  }
  return result;
}

//----- (10017300) --------------------------------------------------------
signed int __cdecl sub_10017300(int a1, int a2, int a3, _DWORD *a4)
{
  unsigned int v4; // eax@3

  *a4 = 0;
  if ( !(a3 & 7) )
  {
    if ( a3 )
    {
      v4 = **(_DWORD **)((a3 & 0xFFFFFFF8) + 4) & 0xFFFFFFF8;
      if ( v4 )
      {
        while ( v4 != a2 )
        {
          v4 = **(_DWORD **)(v4 + 4) & 0xFFFFFFF8;
          if ( !v4 )
            return 1;
        }
        *a4 = 1;
      }
    }
  }
  return 1;
}

//----- (10017350) --------------------------------------------------------
signed int __usercall sub_10017350@<eax>(int a1@<eax>, const char *a2@<edx>, unsigned int a3, unsigned int *a4)
{
  int v4; // ebx@1
  signed int result; // eax@2
  int v6; // eax@3
  int v7; // [sp+4h] [bp-4h]@1

  v4 = a1;
  if ( !sub_100158E0(a3, a2, a1, &v7) )
    return 0;
  v6 = v7;
  if ( v7 & 7 )
    goto LABEL_13;
  if ( v7 & 0xFFFFFFF8 && (char **)(*(_DWORD *)(*(_DWORD *)((v7 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) == &off_101621B8 )
  {
    if ( !(*(int (__cdecl **)(int, unsigned int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)(v7 & 0xFFFFFFF8) + 4) + 16))(
            v4,
            v7 & 0xFFFFFFF8,
            *(_DWORD *)(*(_DWORD *)(v4 + 24) + 232),
            &v7) )
      return 0;
    v6 = v7;
  }
  if ( v6 & 7 )
  {
LABEL_13:
    *a4 = 0;
    result = 1;
  }
  else
  {
    *a4 = v6 & 0xFFFFFFF8;
    result = 1;
  }
  return result;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (100173E0) --------------------------------------------------------
int __cdecl sub_100173E0(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = (*(int (__cdecl **)(int, int, _DWORD, int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 12))(
             a1,
             a2,
             *(_DWORD *)(*(_DWORD *)(a1 + 24) + 232),
             a3,
             0,
             0,
             a4,
             0);
  if ( result )
    result = (*(int (__cdecl **)(int, int, _DWORD, int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)a3 + 4)
                                                                                       + 12))(
               a1,
               a3,
               *(_DWORD *)(*(_DWORD *)(a1 + 24) + 236),
               a2,
               0,
               0,
               0,
               0);
  return result;
}

//----- (10017450) --------------------------------------------------------
signed int __cdecl sub_10017450(int a1, signed int a2, unsigned int *a3)
{
  int v3; // ecx@3
  unsigned int v4; // esi@4
  int v6; // eax@8

  if ( a2 && a2 != -2147483647 )
  {
    v3 = a2 & 7;
    if ( !(a2 & 7) )
    {
      v4 = a2 & 0xFFFFFFF8;
      if ( (*(int (__cdecl **)(int, unsigned int, signed int, signed int *))(*(_DWORD *)(*(_DWORD *)(a2 & 0xFFFFFFF8) + 4)
                                                                           + 36))(
             a1,
             a2 & 0xFFFFFFF8,
             1,
             &a2) )
      {
        if ( !(a2 & 7) )
        {
          *a3 = a2 & 0xFFFFFFF8;
          return 1;
        }
        goto LABEL_17;
      }
      return 0;
    }
    if ( v3 == 4 )
    {
      v6 = sub_1001AC80(a1, a2 & 0xFFFFFFF8);
    }
    else if ( a2 & 1 )
    {
      v6 = sub_1001F680(a1, (double)(a2 >> 1));
    }
    else if ( v3 == 2 )
    {
      v6 = sub_1001F680(a1, *(double *)(a2 & 0xFFFFFFF8));
    }
    else
    {
      v6 = sub_1002D340(a1, a2 >> 3);
    }
    v4 = v6;
    if ( !v6 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
LABEL_17:
  *a3 = v4;
  return 1;
}

//----- (10017540) --------------------------------------------------------
_BYTE *__cdecl sub_10017540(int a1, signed int a2)
{
  _BYTE *result; // eax@1
  _BYTE *v3; // ebx@2
  _BYTE *v4; // eax@3
  char v5; // al@4
  _BYTE *v6; // [sp+8h] [bp-4h]@1

  result = (_BYTE *)sub_10017450(a1, a2, (unsigned int *)&v6);
  if ( result )
  {
    v3 = v6;
    if ( !v6 )
    {
      v4 = sub_1004F8E0(a1, 1, a2, v6);
      if ( v4 )
      {
        v5 = (unsigned int)sub_10010FF0((unsigned int)v4);
        sub_100110F0(a1, (int)sub_1003ED50, (int)v3, 39, v5);
      }
    }
    result = v3;
  }
  return result;
}

//----- (100175A0) --------------------------------------------------------
signed int __cdecl sub_100175A0(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // ebx@1
  int v7; // edi@4
  signed int result; // eax@4
  int v9; // [sp+Ch] [bp-4h]@1

  v6 = sub_10011190(a1, 0);
  if ( (*(int (__cdecl **)(int, int, int, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(a1, a2, a3, &v9)
    && !(v9 & 7)
    && v9 )
  {
    v7 = sub_100302A0(a1, a2, v9, 0, a4, a5, a6);
    sub_10011190(a1, v6);
    result = v7;
  }
  else
  {
    sub_10011190(a1, v6);
    result = 1;
  }
  return result;
}

//----- (10017630) --------------------------------------------------------
unsigned int __cdecl sub_10017630(int a1, int a2, int a3)
{
  int v3; // ebp@1
  int i; // esi@1
  int v5; // eax@4
  char v6; // al@8
  void (__cdecl *v7)(int, int, int); // eax@14
  unsigned int result; // eax@17

  v3 = *(_DWORD *)a2;
  for ( i = *(_DWORD *)(*(_DWORD *)a2 + 36); i; i = *(_DWORD *)(i + 20) )
  {
    if ( !(*(_BYTE *)(v3 + 20) & 1) || (*sub_10039580(v3, *(_DWORD *)i, 0) & 0xFFFFFFFE) == i )
    {
      v5 = *(_DWORD *)i;
      *(_BYTE *)(i + 17) |= 1u;
      if ( (!(v5 & 1) || v5 == -2147483647) && !(*(_BYTE *)(v5 + 16) & 4) )
        sub_1003AB90(a1, v5);
      v6 = *(_BYTE *)(i + 16);
      if ( v6 & 0x30 )
      {
        if ( v6 & 0x10 )
          sub_1003A9D0(a1, *(_DWORD *)(i + 4) & 0xFFFFFFF8, 0);
        if ( *(_BYTE *)(i + 16) & 0x20 )
          sub_1003A9D0(a1, *(_DWORD *)(i + 8) & 0xFFFFFFF8, 0);
      }
    }
  }
  v7 = *(void (__cdecl **)(int, int, int))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE) + 64);
  if ( v7 )
    v7(a1, a2, a3);
  if ( *(_DWORD *)(v3 + 16) == a2 )
  {
    result = *(_DWORD *)(*(_DWORD *)a2 + 8);
    if ( *(_DWORD *)(*(_DWORD *)a2 + 12) < result )
      result = *(_DWORD *)(*(_DWORD *)a2 + 12);
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(a2 + 4) - 4);
  }
  return result;
}

//----- (10017710) --------------------------------------------------------
void __cdecl sub_10017710(int a1, unsigned int a2)
{
  int v2; // ebx@1
  int v3; // ebp@2
  int i; // esi@2
  unsigned int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@6
  int v8; // edx@6
  unsigned int v9; // eax@8
  unsigned int v10; // ecx@8
  unsigned int j; // eax@8

  v2 = *(_DWORD *)a2;
  if ( *(_DWORD *)(*(_DWORD *)a2 + 16) == a2 )
  {
    v3 = *(_DWORD *)(a1 + 24);
    for ( i = *(_DWORD *)(v2 + 36); i; i = *(_DWORD *)(i + 20) )
    {
      if ( (!(*(_BYTE *)(v2 + 20) & 1) || (*sub_10039580(v2, *(_DWORD *)i, 0) & 0xFFFFFFFE) == i)
        && !*(_DWORD *)(v3 + 8784) )
      {
        v5 = (*(_DWORD *)i ^ (a2 >> 3)) & 0x3FF;
        v6 = *(_DWORD *)(v3 + 8 * v5 + 588);
        v7 = v3 + 8 * v5 + 588;
        v8 = *(_DWORD *)(v7 + 4);
        *(_DWORD *)(v3 + 8780) = 0;
        *(_DWORD *)v7 = a2;
        *(_DWORD *)(v7 + 4) = 0;
      }
    }
    sub_10039C90(a1, v2);
    v9 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE;
    v10 = *(_BYTE *)(v9 + 5) + ((*(_DWORD *)(v9 + 4) & 1) != 0) + 3;
    for ( j = *(_DWORD *)(v2 + 8) - 1; j >= v10; --j )
      *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * j) = -2147483647;
    *(_DWORD *)(v2 + 12) = v10;
  }
}

//----- (100177F0) --------------------------------------------------------
signed int __cdecl sub_100177F0(int a1, int a2, unsigned int a3)
{
  int v3; // eax@1
  signed int result; // eax@2

  v3 = *(_DWORD *)(a2 + 4);
  if ( a3 >= *(_DWORD *)(v3 - 4) )
    result = -2147483647;
  else
    result = *(_DWORD *)(v3 + 4 * a3);
  return result;
}

//----- (10017810) --------------------------------------------------------
unsigned int *__cdecl sub_10017810(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // eax@1
  unsigned int v5; // esi@1
  unsigned int v6; // ebx@2
  unsigned int *result; // eax@4
  unsigned int *v8; // edx@4
  unsigned int v9; // eax@5

  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(v4 - 4);
  if ( a3 < v5 )
  {
LABEL_10:
    result = (unsigned int *)a3;
    *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * a3) = a4;
    return result;
  }
  v6 = *(_BYTE *)((*(_DWORD *)(v4 + 8) & 0xFFFFFFFE) + 5)
     + ((*(_DWORD *)((*(_DWORD *)(v4 + 8) & 0xFFFFFFFE) + 4) & 1) != 0)
     + 3;
  if ( v6 > v5 )
    v5 = *(_BYTE *)((*(_DWORD *)(v4 + 8) & 0xFFFFFFFE) + 5)
       + ((*(_DWORD *)((*(_DWORD *)(v4 + 8) & 0xFFFFFFFE) + 4) & 1) != 0)
       + 3;
  result = (unsigned int *)sub_10011870(a1, (void *)(v4 - 4), 4 * v5 + 4);
  v8 = result;
  if ( result )
  {
    v9 = *result + 1;
    if ( v9 <= v6 )
      memset32(&v8[v9], -2147483647, v6 - v9 + 1);
    *v8 = v5;
    if ( *(_DWORD *)(*(_DWORD *)a2 + 16) == a2 )
      *(_DWORD *)(*(_DWORD *)a2 + 8) = v5;
    *(_DWORD *)(a2 + 4) = v8 + 1;
    goto LABEL_10;
  }
  return result;
}

//----- (100178B0) --------------------------------------------------------
_DWORD *__cdecl sub_100178B0(int a1, int a2, int a3, _DWORD **a4)
{
  _DWORD **v4; // eax@1
  _DWORD *v5; // edx@5
  int (__cdecl **v6)(int, int, int, int, int); // eax@5
  unsigned int v7; // edi@8
  int (__cdecl **v8)(int, int, int, int, int); // eax@11
  int v9; // edx@16
  int v10; // ecx@16
  _DWORD *result; // eax@17

  v4 = a4;
  if ( !a4 )
  {
LABEL_4:
    if ( a3
      || (v5 = *(_DWORD **)a2, v6 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)a2 + 4),
                               v6 != &off_101614B0)
      && (!v6 || *v6 != off_101614B0) )
    {
      *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * a3) = a4;
      return (_DWORD *)1;
    }
    v7 = **(_DWORD **)(a2 + 4) & 0xFFFFFFF8;
    if ( v7 && *(_DWORD **)v7 == v5 )
    {
      if ( a4
        && ((v8 = (int (__cdecl **)(int, int, int, int, int))(*a4)[1], v8 == &off_101614B0) || v8 && *v8 == off_101614B0)
        && !((a4[1][2] ^ *(_DWORD *)(*(_DWORD *)(v7 + 4) + 8)) & 0xFFFFFFFE) )
      {
        if ( *a4 != v5 )
        {
          *(_DWORD *)a2 = sub_10015880(a1, *a4);
          sub_10015890(v10, v9, a2);
        }
      }
      else
      {
        result = sub_10039ED0(a1, a2);
        if ( !result )
          return result;
      }
    }
    **(_DWORD **)(a2 + 4) = a4;
    return (_DWORD *)1;
  }
  while ( v4 != (_DWORD **)a2 )
  {
    v4 = (_DWORD **)(v4[1][a3] & 0xFFFFFFF8);
    if ( !v4 )
      goto LABEL_4;
  }
  sub_100110F0(a1, (int)sub_1003ED50, 0, 36, (unsigned int)(&off_10161558)[16 * a3]);
  return 0;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);
// 10161558: using guessed type char *off_10161558;

//----- (100179C0) --------------------------------------------------------
signed int __cdecl sub_100179C0(int a1, int a2, int a3, int *a4, int *a5)
{
  int v5; // ecx@0
  signed int result; // eax@1
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  result = sub_10017300(a1, a2, *a4, &v7);
  if ( result )
  {
    *a5 = 8 * v7 | 6;
    result = 1;
  }
  return result;
}

//----- (10017A00) --------------------------------------------------------
int __cdecl sub_10017A00(int a1, unsigned int a2, int a3, int *a4, unsigned int *a5)
{
  int result; // eax@2
  unsigned int v6; // ecx@4
  int v7; // edi@5
  int (__cdecl **v8)(int, int, int, int, int); // eax@5
  signed int (*v9)(); // eax@8
  int v10; // esi@11
  int v11; // eax@12
  void (__cdecl *v12)(int, int, unsigned int); // eax@17

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
  {
    result = (*(int (__cdecl **)(int, unsigned int, int, int *, unsigned int *))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8)
                                                                                           + 4)
                                                                               + 8))(
               a1,
               **(_DWORD **)(a2 + 4) & 0xFFFFFFF8,
               a3,
               a4,
               a5);
    if ( result )
    {
      v6 = *a5;
      if ( *a5 )
      {
        v7 = *a4;
        v8 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)*a4 + 4);
        if ( v8 == &off_101614B0 || v8 && *v8 == off_101614B0 )
        {
          v9 = *(signed int (**)())(v6 + 4);
          if ( v9 == sub_1002FB00 || v9 == sub_1002FB80 )
          {
            if ( *(_BYTE *)(v6 + 16) & 0x40 )
            {
              v10 = *(_DWORD *)(a1 + 56);
              if ( v10 )
              {
                while ( 1 )
                {
                  v11 = *(_DWORD *)(v10 + 16);
                  if ( v11 )
                  {
                    if ( !*(_DWORD *)(v11 + 8) )
                      break;
                  }
                  v10 = *(_DWORD *)(v10 + 44);
                  if ( !v10 )
                    return 1;
                }
                if ( *(_DWORD *)(v10 + 16) == sub_10010550(a1, v7) )
                {
                  v12 = *(void (__cdecl **)(int, int, unsigned int))(*(_DWORD *)(*(_DWORD *)v7 + 4) + 52);
                  if ( v12 )
                    v12(a1, v7, *a5);
                  *a4 = 0;
                  *a5 = 0;
                }
              }
            }
          }
        }
      }
      result = 1;
    }
  }
  else
  {
    result = sub_10015D00(a1, a2, a3, a4, a5);
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10017AF0) --------------------------------------------------------
int __cdecl sub_10017AF0(int a1, unsigned int a2, int a3, _DWORD *a4)
{
  int result; // eax@2

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
    result = (*(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4)
                                                   + 16))(
               a1,
               **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
  else
    result = sub_10016210(a1, a2, a3, a4);
  return result;
}

//----- (10017B20) --------------------------------------------------------
int __cdecl sub_10017B20(int a1, unsigned int a2, int a3, _DWORD *a4)
{
  int result; // eax@2

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
    result = (*(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4)
                                                   + 20))(
               a1,
               **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
  else
    result = sub_10016530(a1, a2, a3, a4);
  return result;
}

//----- (10017B50) --------------------------------------------------------
int __cdecl sub_10017B50(int a1, unsigned int a2, int a3, int a4, _DWORD *a5)
{
  int result; // eax@2

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
    result = (*(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4)
                                                   + 24))(
               a1,
               **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
  else
    result = sub_100169C0(a1, a2, a3, a4, a5);
  return result;
}

//----- (10017B80) --------------------------------------------------------
int __cdecl sub_10017B80(int a1, unsigned int a2, int a3, int a4, _DWORD *a5)
{
  int result; // eax@2

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
    result = (*(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4)
                                                   + 28))(
               a1,
               **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
  else
    result = sub_10016AA0(a1, a2, a3, a4, a5);
  return result;
}

//----- (10017BB0) --------------------------------------------------------
int __cdecl sub_10017BB0(int a1, unsigned int a2, int a3, signed int *a4)
{
  int result; // eax@2

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
    result = (*(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4)
                                                   + 32))(
               a1,
               **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
  else
    result = sub_10016BA0(a1, a2, a3, a4);
  return result;
}

//----- (10017BE0) --------------------------------------------------------
int __cdecl sub_10017BE0(int a1, int a2, int a3, int *a4, int *a5)
{
  int result; // eax@2

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
    result = (*(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4)
                                                   + 40))(
               a1,
               **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
  else
    result = sub_10016EB0(a1, a2, a3, a4, a5);
  return result;
}

//----- (10017C10) --------------------------------------------------------
int __cdecl sub_10017C10(int a1, unsigned int a2, int a3, int a4, signed int *a5, int *a6)
{
  int result; // eax@2

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
    result = (*(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4)
                                                   + 44))(
               a1,
               **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
  else
    result = sub_10017090(a1, a2, a3, a4, a5, a6);
  return result;
}

//----- (10017C40) --------------------------------------------------------
int __cdecl sub_10017C40(int a1, int a2, int a3, unsigned int a4)
{
  int result; // eax@1
  int v5; // ebp@1
  unsigned int v6; // ebx@3
  int (__cdecl *v7)(int, int); // eax@6
  int (__cdecl **v8)(int, int, int, int, int); // eax@7
  int v9; // ebx@10
  unsigned int v10; // ebx@17
  int v11; // eax@18
  unsigned int *v12; // edx@20
  int v13; // eax@23
  unsigned int v14; // ecx@23
  int v15; // edx@23
  int v16; // eax@25
  void (__cdecl *v17)(int, int, signed int, _DWORD); // ecx@25
  int v18; // [sp+8h] [bp-4h]@13

  result = sub_1003B230(a1, 0);
  v5 = result;
  if ( !result )
    return result;
  if ( !a3 )
  {
    v6 = a4;
    if ( !sub_10017350(a1, *(const char **)a2, a4, (unsigned int *)&a3)
      || !a3 && !sub_10017350(a1, "Object", v6, (unsigned int *)&a3) )
    {
      goto LABEL_22;
    }
  }
  v7 = *(int (__cdecl **)(int, int))(a2 + 40);
  if ( v7 )
    v8 = (int (__cdecl **)(int, int, int, int, int))v7(a1, a2);
  else
    v8 = &off_101614B0;
  if ( !a3
    || (v9 = *(_DWORD *)a3, *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)a3 + 4) != v8)
    || (*(_DWORD *)(a2 + 4) ^ *(_DWORD *)((*(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) & 0xFFFFFFFE) + 4)) & 0xFF01 )
  {
    v11 = (*v8)(a1, 1, v8, a2, v5);
    if ( v11 )
    {
      *(_DWORD *)v5 = v11;
      v10 = *(_DWORD *)(v11 + 8);
      goto LABEL_20;
    }
    goto LABEL_22;
  }
  if ( !a4 )
  {
    if ( (*(int (__cdecl **)(int, int, _DWORD, int *))(*(_DWORD *)(v9 + 4) + 16))(
           a1,
           a3,
           *(_DWORD *)(*(_DWORD *)(a1 + 24) + 236),
           &v18) )
    {
      if ( !(v18 & 7) && v18 & 0xFFFFFFF8 )
        a4 = *(_DWORD *)(*(_DWORD *)((v18 & 0xFFFFFFF8) + 4) + 4) & 0xFFFFFFF8;
      goto LABEL_17;
    }
LABEL_22:
    *(_DWORD *)(a1 + 92) = 0;
    return 0;
  }
LABEL_17:
  *(_DWORD *)v5 = sub_10015880(a1, (_DWORD *)v9);
  v10 = 5;
LABEL_20:
  v12 = (unsigned int *)sub_10011830(a1, 4 * v10 + 4);
  if ( !v12 )
  {
    sub_10015890(a1, *(_DWORD *)v5, v5);
    *(_DWORD *)v5 = 0;
    goto LABEL_22;
  }
  v13 = a3;
  v14 = a4;
  *v12 = v10;
  v15 = (int)(v12 + 1);
  *(_DWORD *)v15 = v13;
  *(_DWORD *)(v15 + 4) = v14;
  *(_DWORD *)(v15 + 8) = a2 | 1;
  if ( v10 > 3 )
    memset32((void *)(v15 + 12), -2147483647, v10 - 3);
  *(_DWORD *)(v5 + 4) = v15;
  v16 = *(_DWORD *)(a1 + 24);
  v17 = *(void (__cdecl **)(int, int, signed int, _DWORD))(v16 + 548);
  if ( v17 )
    v17(a1, v5, 1, *(_DWORD *)(v16 + 552));
  return v5;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10017DE0) --------------------------------------------------------
unsigned int __cdecl sub_10017DE0(int a1, const char **a2, int a3, unsigned int a4, int a5, int a6)
{
  unsigned int v6; // esi@1
  unsigned int v7; // eax@4
  int v8; // edi@6
  unsigned int v9; // esi@10
  unsigned int result; // eax@13
  int v11; // [sp+Ch] [bp-8h]@7
  int v12; // [sp+10h] [bp-4h]@1

  v6 = a4;
  if ( !sub_100158E0(a4, *a2, a1, &v12) )
    return 0;
  if ( v12 & 7 || !v12 )
  {
    sub_100284B0(a1, &v12, 3);
    return 0;
  }
  v7 = v12 & 0xFFFFFFF8;
  if ( !a4 )
    v6 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4) & 0xFFFFFFF8;
  v8 = a3;
  if ( !a3 )
  {
    if ( !(*(int (__cdecl **)(int, unsigned int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)v7 + 4) + 16))(
            a1,
            v7,
            *(_DWORD *)(*(_DWORD *)(a1 + 24) + 232),
            &v11) )
      return 0;
    if ( !(v11 & 7) )
      v8 = v11 & 0xFFFFFFF8;
  }
  v9 = sub_10017C40(a1, (int)a2, v8, v6);
  if ( !v9 )
    return 0;
  if ( !sub_100302A0(a1, v9, v12, 1, a5, a6, &v11) )
  {
    *(_DWORD *)(a1 + 92) = 0;
    return 0;
  }
  if ( v11 & 7 )
    result = v9;
  else
    result = v11 & 0xFFFFFFF8;
  return result;
}

//----- (10017EF0) --------------------------------------------------------
signed int __cdecl sub_10017EF0(int a1, unsigned int a2, int a3, int a4, signed int (*a5)(), signed int (*a6)(), int a7, int a8, int a9, unsigned int **a10)
{
  unsigned int v10; // esi@3
  _WORD *v11; // edi@3
  int v12; // ebp@3
  int v13; // ebx@9
  char v14; // dl@13
  signed int (*v15)(); // ebp@14
  signed int (*v16)(); // ecx@16
  unsigned int *v17; // eax@18
  void (__cdecl *v18)(int, unsigned int, int); // ecx@20
  unsigned int v19; // eax@23
  signed int (*v20)(); // ebx@25
  _DWORD *v21; // ebp@27
  unsigned int v22; // eax@30
  int v23; // eax@32
  int v24; // ecx@33
  unsigned int v26; // ecx@38
  int v27; // edx@40
  int v28; // ecx@41
  unsigned int v29; // edi@41
  int v30; // ecx@41
  int v31; // edi@41
  int v32; // [sp+10h] [bp-Ch]@10
  unsigned int v33; // [sp+14h] [bp-8h]@10
  int v34; // [sp+18h] [bp-4h]@41

  if ( !(a3 & 1) || a3 == -2147483647 )
  {
    v10 = *(_DWORD *)(a3 + 8) & 0xFFFFFFF8;
    v11 = *(_WORD **)(v10 + 4);
    v12 = *v11 == 45;
    if ( *v11 == 45 )
      ++v11;
    if ( *v11 < 0x80u && isdigit(*v11) && (unsigned int)(*(_DWORD *)v10 - v12) <= 0xA )
      a3 = sub_10015B30(v11, a3, v12);
  }
  v13 = a7;
  if ( !(a7 & 0x30) )
    goto LABEL_23;
  if ( !sub_10015D00(a1, a2, a3, &v33, (unsigned int *)&v32) )
    return 0;
  if ( !v32 )
  {
LABEL_23:
    v19 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE;
    v33 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE;
    if ( !a5 )
      a5 = *(signed int (**)())(v19 + 16);
    v20 = a6;
    if ( !a6 )
      v20 = *(signed int (**)())(v19 + 20);
    v21 = sub_10039ED0(a1, a2);
    if ( v21 )
    {
      if ( *(_BYTE *)(v33 + 4) & 0x10 )
        a7 |= 0x40u;
      v22 = sub_10039FC0(a1, (int)v21, a3, a5, v20, -1, a7, a8, a9);
      v32 = v22;
      if ( v22 )
      {
        if ( *(_BYTE *)(v22 + 17) & 8 )
        {
          v23 = 2 * *(_WORD *)(v22 + 18) | 1;
        }
        else
        {
          v24 = *(_DWORD *)v22;
          v23 = *(_DWORD *)v22;
          if ( !(v23 & 1) )
            v23 = *(_DWORD *)(v24 + 8);
        }
        if ( (*(int (__cdecl **)(int, unsigned int, int, int *))(v33 + 8))(a1, a2, v23, &a4) )
        {
          v17 = (unsigned int *)v32;
          v26 = *(_DWORD *)(v32 + 12);
          if ( v26 < v21[3] )
          {
            *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v26) = a4;
            v17 = (unsigned int *)v32;
          }
          goto LABEL_40;
        }
        sub_1003A590(a1, (int)v21, a3);
      }
    }
    return 0;
  }
  if ( v33 != a2 || (v14 = *(_BYTE *)(v32 + 16), !(v14 & 0x30)) )
  {
    v18 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)v33 + 4) + 52);
    if ( v18 )
      v18(a1, v33, v32);
    v32 = 0;
    goto LABEL_23;
  }
  v15 = a6;
  if ( !(v13 & 0x20) )
    v15 = *(signed int (**)())(v32 + 8);
  v16 = a5;
  if ( !(v13 & 0x10) )
    v16 = *(signed int (**)())(v32 + 4);
  v17 = sub_1003A470(a1, *(_DWORD *)a2, v32, v13, v14, v16, v15);
  v32 = (int)v17;
  if ( !v17 )
    return 0;
LABEL_40:
  v27 = *(_DWORD *)(a1 + 24) + 588;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 24) + 8784) )
  {
    v28 = ((unsigned __int16)a3 ^ (unsigned __int16)(a2 >> 3)) & 0x3FF;
    v29 = *(_DWORD *)(v27 + 8 * v28);
    v30 = v27 + 8 * v28;
    v33 = v29;
    v31 = *(_DWORD *)(v30 + 4);
    *(_DWORD *)(v27 + 0x2000) = 0;
    *(_DWORD *)v30 = a2;
    *(_DWORD *)(v30 + 4) = v17;
    v17 = (unsigned int *)v32;
    v34 = v31;
  }
  if ( a10 )
    *a10 = v17;
  return 1;
}

//----- (10018130) --------------------------------------------------------
char *__cdecl sub_10018130(int a1, int a2, int a3, int *a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@3
  signed int v7; // eax@5
  char *result; // eax@10
  const char *v9; // eax@19
  unsigned int v10; // esi@19
  int v11; // eax@20
  _BYTE *v12; // eax@32
  char *v13; // ecx@34
  char v14; // al@35

  v4 = a3;
  v5 = a2;
  if ( a3 == 3 )
  {
    if ( sub_100175A0(a1, a2, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 300), 0, 0, &a2) )
    {
      v6 = a2;
      if ( a2 & 7 )
        goto LABEL_38;
      if ( !a2 )
        goto LABEL_25;
      if ( (*(int (__cdecl **)(int, int, signed int, int *))((*(_DWORD *)(*(_DWORD *)(v5 + 4) + 8) & 0xFFFFFFFE) + 32))(
             a1,
             v5,
             3,
             &a2) )
      {
        v6 = a2;
        if ( a2 & 7 )
          goto LABEL_38;
        if ( !a2 || *(_DWORD *)(a1 + 16) != 120 )
          goto LABEL_25;
        v9 = (const char *)sub_10050AE0("[object %s]", *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 8) & 0xFFFFFFFE));
        v10 = (unsigned int)v9;
        if ( v9 )
        {
          v11 = sub_10010EB0(a1, (unsigned int)v9, strlen(v9));
          if ( v11 )
          {
            *a4 = v11 | 4;
            return (char *)1;
          }
          sub_10053E10(v10, dword_10658DEC);
        }
      }
    }
    return 0;
  }
  if ( !(*(int (__cdecl **)(int, int, int, int *))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE) + 32))(
          a1,
          a2,
          a3,
          &a2) )
    return 0;
  v6 = a2;
  if ( a2 & 7 )
  {
LABEL_38:
    *a4 = v6;
    return (char *)1;
  }
  if ( !a2 )
    goto LABEL_25;
  v7 = sub_100101E0(a1, a2);
  if ( v7 == v4 || v7 == 2 && v4 == 1 || *(_DWORD *)(a1 + 16) == 120 && v4 == 5 )
  {
    v6 = a2;
    goto LABEL_38;
  }
  result = (char *)sub_100175A0(a1, v5, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 300), 0, 0, &a2);
  if ( !result )
    return result;
  v6 = a2;
LABEL_25:
  if ( v6 & 7 || !v6 )
    goto LABEL_38;
  if ( v4 == 3 )
  {
    result = sub_10010F90(a1, *(const char **)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 8) & 0xFFFFFFFE));
    if ( !result )
      return result;
    v6 = a2;
  }
  else
  {
    result = 0;
  }
  *a4 = v5;
  v12 = sub_1004F8E0(a1, 1, v6, result);
  if ( v12 )
  {
    if ( v4 )
      v13 = off_10162AE0[v4];
    v14 = (unsigned int)sub_10010FF0((unsigned int)v12);
    sub_100110F0(a1, (int)sub_1003ED50, 0, 38, v14);
  }
  return 0;
}
// 10162AE0: using guessed type char *off_10162AE0[8];
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10018350) --------------------------------------------------------
signed int __cdecl sub_10018350(int a1, const char *a2, unsigned int *a3)
{
  return sub_10017350(a1, a2, 0, a3);
}

//----- (10018370) --------------------------------------------------------
signed int __cdecl sub_10018370(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // ecx@1
  int v5; // eax@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 24);
  a1 = *(_DWORD *)(*(_DWORD *)(v5 + 4 * a3 + 124) + 8);
  return sub_100175A0(v4, a2, *(_DWORD *)(v5 + 304), 1, (int)&a1, a4);
}

//----- (100183B0) --------------------------------------------------------
int __cdecl sub_100183B0(int a1, int a2)
{
  bool v2; // zf@1
  unsigned int v3; // esi@2
  int v5; // ebx@9
  int (__cdecl *v6)(int, int); // eax@14
  unsigned int v7; // [sp+10h] [bp-24h]@2
  const char *v8; // [sp+14h] [bp-20h]@2
  int v9; // [sp+18h] [bp-1Ch]@1
  int v10; // [sp+1Ch] [bp-18h]@2
  int v11; // [sp+20h] [bp-14h]@12
  char v12; // [sp+24h] [bp-10h]@17

  v2 = *(_DWORD *)a1 == 0;
  v9 = *(_DWORD *)(a1 + 8);
  if ( v2 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + 8) & 0xFFFFFFFE;
    v8 = *(const char **)v3;
    v7 = sub_10052C00(a1, v8);
    v10 = v7 == 0;
    if ( v7 == 0 && !sub_10052B60(a1, (int *)v3, &v7) )
      return 0;
  }
  else
  {
    v10 = 0;
    v8 = 0;
    v3 = 0;
  }
  if ( !sub_10052520(a1, &v10) || v10 && !sub_100525F0((char *)a1, (unsigned int *)&v8) )
    return 0;
  v5 = sub_10052520(a1, (int *)&v7);
  if ( v5 )
  {
    if ( !*(_DWORD *)a1 )
      goto LABEL_14;
    if ( v10 )
    {
      v5 = sub_10018350(v9, v8, (unsigned int *)&v11);
      if ( !v5 )
        goto LABEL_19;
      v3 = *(_DWORD *)(*(_DWORD *)(v11 + 4) + 8) & 0xFFFFFFFE;
      v5 = sub_10052B60(a1, (int *)v3, &v7);
      if ( !v5 )
        goto LABEL_19;
      goto LABEL_14;
    }
    v3 = sub_10052CE0(a1, v7);
    if ( v3 )
    {
LABEL_14:
      v6 = *(int (__cdecl **)(int, int))(v3 + 56);
      if ( v6 )
      {
        v5 = v6(a1, a2);
      }
      else
      {
        sub_100110F0(v9, (int)sub_1003ED50, 0, 41, *(_DWORD *)v3);
        v5 = 0;
      }
      goto LABEL_19;
    }
    sub_10050B00((int)&v12, 12, (char *)&unk_100CC178, v7);
    sub_100110F0(v9, (int)sub_1003ED50, 0, 40, (unsigned int)&v12);
    v5 = 0;
  }
LABEL_19:
  if ( *(_DWORD *)a1 )
  {
    if ( v8 )
      sub_10010340(v9, (unsigned int)v8);
  }
  return v5;
}

//----- (10018570) --------------------------------------------------------
_DWORD *__cdecl sub_10018570(int a1, int a2, signed int a3, _DWORD *a4)
{
  _DWORD *result; // eax@2
  _DWORD **v5; // [sp+0h] [bp-8h]@3
  char v6; // [sp+4h] [bp-4h]@5

  if ( *a4 & 7 )
  {
    result = (_DWORD *)1;
  }
  else
  {
    v5 = (_DWORD **)(*a4 & 0xFFFFFFF8);
    if ( !(*(_BYTE *)(a1 + 300) & 1) || (result = (_DWORD *)sub_10014130(a3 >> 1, a1)) != 0 )
    {
      result = (_DWORD *)(*(int (__cdecl **)(int, int, signed int, signed int, _DWORD *, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4)
                                                                                                + 44))(
                           a1,
                           a2,
                           a3,
                           8,
                           a4,
                           &v6);
      if ( result )
        result = sub_100178B0(a1, a2, a3 >> 1, v5);
    }
  }
  return result;
}

//----- (10018600) --------------------------------------------------------
signed int __cdecl sub_10018600(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  int v7; // eax@1
  int v8; // esi@1
  _BYTE *v9; // eax@2
  signed int v10; // eax@5
  int v12; // ebx@10
  bool v13; // zf@14
  unsigned int v14; // eax@16
  int v15; // ebx@16
  int v16; // eax@17
  int v17; // ebx@24
  unsigned int v18; // eax@28
  int v19; // edi@28
  int v20; // ecx@31
  int v21; // eax@32
  int v22; // edi@37
  int v23; // ebx@38
  int v24; // eax@41
  signed int v25; // [sp+10h] [bp-1Ch]@3
  int v26; // [sp+10h] [bp-1Ch]@25
  int v27; // [sp+14h] [bp-18h]@25
  int v28; // [sp+18h] [bp-14h]@25
  signed int v29; // [sp+1Ch] [bp-10h]@1
  int v30; // [sp+20h] [bp-Ch]@1
  signed int v31; // [sp+24h] [bp-8h]@1
  int v32; // [sp+28h] [bp-4h]@1

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 56);
  v30 = 0;
  v32 = 0;
  v29 = 0;
  v31 = 0;
  v7 = sub_10051900(a1, *(_DWORD *)(a1 + 56));
  v8 = v7;
  if ( !v7 || (v9 = *(_BYTE **)(v7 + 56)) == 0 || (v25 = 1, *v9 == 121) )
    v25 = 0;
  v10 = *(_DWORD *)(v5 + 16);
  if ( (!v10 || v10 >= 130) && v25 && !sub_10011140(v5, 5, (int)sub_1003ED50, 0, 146, (unsigned int)"eval") )
    return 0;
  v12 = a4;
  if ( (*(_DWORD *)a4 & 7) != 4 )
  {
    *a5 = *(_DWORD *)a4;
    return 1;
  }
  a1 = 0;
  if ( a3 < 2 )
    goto LABEL_51;
  if ( !sub_10017450(v5, *(_DWORD *)(a4 + 4), (unsigned int *)&a1) )
    return 0;
  v13 = a1 == 0;
  *(_DWORD *)(v12 + 4) = a1;
  if ( v13 )
  {
LABEL_51:
    if ( !v25 )
    {
LABEL_22:
      if ( v8 )
        a1 = *(_DWORD *)(v8 + 52);
      goto LABEL_24;
    }
    v14 = *(_DWORD *)(v8 + 52);
    v15 = a2;
    v30 = *(_DWORD *)(v8 + 52);
    if ( a2 == v14 )
    {
LABEL_19:
      v32 = *(_DWORD *)(v8 + 8);
      if ( v15 != *(_DWORD *)(v8 + 8) )
      {
        *(_DWORD *)(v6 + 8) = v15;
        *(_DWORD *)(v8 + 8) = v15;
        v31 = 1;
      }
      v12 = a4;
      goto LABEL_22;
    }
    v16 = sub_10017C40(v5, (int)&off_101616B0, a2, v14);
    a1 = v16;
    if ( v16 )
    {
      *(_DWORD *)(v6 + 52) = v16;
      *(_DWORD *)(v8 + 52) = v16;
      v29 = 1;
      goto LABEL_19;
    }
    return 0;
  }
LABEL_24:
  v17 = *(_DWORD *)v12 & 0xFFFFFFF8;
  if ( v8 )
  {
    v27 = *(_DWORD *)(*(_DWORD *)(v8 + 12) + 24);
    v26 = sub_10021490(v5, *(_DWORD *)(v8 + 12), *(_DWORD *)(v8 + 56));
    v28 = sub_10051980(v5, v6, v8);
  }
  else
  {
    v27 = 0;
    v26 = 0;
    v28 = 0;
  }
  do
  {
    *(_DWORD *)(v6 + 76) |= 0x20u;
    v6 = *(_DWORD *)(v6 + 44);
  }
  while ( v6 != v8 );
  v18 = *(_DWORD *)v17;
  v19 = *(_DWORD *)v17;
  if ( *(_DWORD *)v17 & 0x40000000 )
    v19 = v18 & ((v19 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( *(_DWORD *)v17 & 0x40000000 )
  {
    v20 = *(_DWORD *)(v17 + 4);
    if ( *(_DWORD *)v20 & 0x40000000 )
    {
      v21 = sub_1001A200(v17);
    }
    else if ( (v18 & 0x80000000) == 0 )
    {
      v21 = *(_DWORD *)(v20 + 4) + 2 * ((v18 >> 15) & 0x7FFF);
    }
    else
    {
      v21 = *(_DWORD *)(v20 + 4);
    }
  }
  else
  {
    v21 = *(_DWORD *)(v17 + 4);
  }
  v22 = sub_10010CF0(v5, a1, v28, v21, v19, v27, v26);
  if ( v22 )
  {
    if ( a3 < 2 && v8 )
      v24 = *(_DWORD *)(v8 + 52);
    else
      v24 = a1;
    v23 = sub_10038170(v5, v24, v22, v8, 32, a5);
    sub_10010D60(v5, v22);
  }
  else
  {
    v23 = 0;
  }
  if ( v29 )
    *(_DWORD *)(v8 + 52) = v30;
  if ( v31 )
    *(_DWORD *)(v8 + 8) = v32;
  return v23;
}
// 10010D60: using guessed type _DWORD __cdecl sub_10010D60(_DWORD, _DWORD);
// 101616B0: using guessed type char *off_101616B0;

//----- (10018870) --------------------------------------------------------
signed int __cdecl sub_10018870(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int v6; // eax@4

  if ( a3 )
  {
    if ( !sub_10017450(a1, *a4, (unsigned int *)&a2) )
      return 0;
    v6 = a2;
    if ( a2 )
      goto LABEL_7;
  }
  if ( !(*(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1) )
  {
    v6 = sub_10017C40(a1, (int)&off_10161510, 0, 0);
    if ( !v6 )
      return 0;
LABEL_7:
    *a5 = v6;
  }
  return 1;
}
// 10161510: using guessed type char *off_10161510;

//----- (100188D0) --------------------------------------------------------
char *__cdecl sub_100188D0(int a1, int a2, int a3, int *a4)
{
  char *result; // eax@2

  if ( **(_DWORD **)(a2 + 4) & 0xFFFFFFF8 )
    result = (char *)(*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a2 + 4) & 0xFFFFFFF8) + 4)
                                                        + 36))(
                       a1,
                       **(_DWORD **)(a2 + 4) & 0xFFFFFFF8);
  else
    result = sub_10018130(a1, a2, a3, a4);
  return result;
}

//----- (10018900) --------------------------------------------------------
_DWORD *__cdecl sub_10018900(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  _DWORD *result; // eax@1
  int v6; // edi@3
  int v7; // [sp+4h] [bp-Ch]@8
  int v8; // [sp+8h] [bp-8h]@6
  int v9; // [sp+Ch] [bp-4h]@7

  result = (_DWORD *)sub_10011140(a1, 5, (int)sub_1003ED50, 0, 158, (char)off_101616B0);
  if ( result )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1 )
    {
      v6 = a2;
    }
    else
    {
      result = (_DWORD *)sub_10017C40(a1, (int)&off_101616B0, 0, 0);
      v6 = (int)result;
      if ( !result )
        return result;
      *a5 = result;
    }
    v8 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52);
    if ( !a3
      || sub_10017450(a1, *(_DWORD *)a4, (unsigned int *)&v9)
      && (v7 = v9, sub_10018570(a1, v6, 1, &v7))
      && (a3 <= 1 || sub_10017450(a1, *(_DWORD *)(a4 + 4), (unsigned int *)&v8)) )
    {
      v7 = v8;
      result = sub_10018570(a1, v6, 3, &v7);
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 101616B0: using guessed type char *off_101616B0;

//----- (10018A00) --------------------------------------------------------
unsigned int __cdecl sub_10018A00(int a1, unsigned int a2)
{
  char *v2; // edi@1
  unsigned int result; // eax@2
  int v4; // [sp+Ch] [bp-4h]@4

  v2 = sub_10012240(
         a1,
         a2,
         0,
         (int *)&off_10161510,
         (int)sub_10018870,
         1,
         (int *)&off_10161558,
         (const char **)&off_10161598,
         0,
         0);
  if ( v2
    && sub_10012240(a1, a2, 0, (int *)&off_101616B0, (int)sub_10018900, 0, 0, 0, 0, 0)
    && (*(int (__cdecl **)(int, char *, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)v2 + 4) + 16))(
         a1,
         v2,
         *(_DWORD *)(*(_DWORD *)(a1 + 24) + 244),
         &v4) )
  {
    result = (*(int (__cdecl **)(int, unsigned int, _DWORD, int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4)
                                                                                                + 12))(
               a1,
               a2,
               *(_DWORD *)(*(_DWORD *)(a1 + 24) + 244),
               v4,
               0,
               0,
               0,
               0) != 0 ? (unsigned int)v2 : 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10161510: using guessed type char *off_10161510;
// 10161558: using guessed type char *off_10161558;
// 10161598: using guessed type char *off_10161598;
// 101616B0: using guessed type char *off_101616B0;

//----- (10018AC0) --------------------------------------------------------
signed int __cdecl sub_10018AC0(int a1, unsigned int a2, int a3, int a4, signed int (*a5)(), signed int (*a6)(), int a7, unsigned int **a8)
{
  return sub_10017EF0(a1, a2, a3, a4, a5, a6, a7, 0, 0, a8);
}

//----- (10018B00) --------------------------------------------------------
void __usercall sub_10018B00(int a1@<edi>, unsigned int *a2)
{
  unsigned int v2; // ebx@2
  int v3; // esi@9
  unsigned int i; // eax@10

  if ( a2 )
  {
    v2 = *a2;
    if ( *a2 )
    {
      if ( *(_DWORD *)(v2 + 16) )
        sub_10010340(a1, *(_DWORD *)(v2 + 16));
      if ( *(_DWORD *)v2 )
        sub_10010340(a1, *(_DWORD *)v2);
      if ( *(_DWORD *)(v2 + 32) )
        sub_10010340(a1, *(_DWORD *)(v2 + 32));
      v3 = *(_DWORD *)(v2 + 36);
      if ( v3 )
      {
        for ( i = *(_DWORD *)v3; i; v3 += 4 )
        {
          sub_10010340(a1, i);
          i = *(_DWORD *)(v3 + 4);
        }
        sub_10010340(a1, *(_DWORD *)(v2 + 36));
      }
      sub_10010340(a1, v2);
    }
    sub_10010340(a1, (unsigned int)a2);
  }
}

//----- (10018B90) --------------------------------------------------------
unsigned int *__cdecl sub_10018B90(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int *v3; // eax@1
  unsigned int *result; // eax@2
  int v5; // eax@3
  int v6; // esi@3
  void *v7; // eax@5
  unsigned int v8; // edi@9
  void *v9; // eax@9
  unsigned int v10; // edi@13
  void *v11; // eax@13
  _DWORD *v12; // eax@14
  int i; // ecx@15
  int v14; // eax@17
  _DWORD *v15; // eax@18
  int v16; // ebx@19
  unsigned int v17; // edi@20
  void **v18; // eax@20
  int v19; // [sp+Ch] [bp-8h]@18
  unsigned int *v20; // [sp+10h] [bp-4h]@1

  v2 = a1;
  v3 = (unsigned int *)sub_10011830(a1, 4u);
  v20 = v3;
  if ( !v3 )
    return 0;
  *v3 = 0;
  v5 = sub_10011830(a1, 0x28u);
  v6 = v5;
  if ( !v5 )
    goto LABEL_24;
  *(_DWORD *)v5 = 0;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 28) = 0;
  *(_DWORD *)(v5 + 32) = 0;
  *(_DWORD *)(v5 + 36) = 0;
  *v20 = v5;
  if ( *(_DWORD *)a2 )
  {
    v7 = sub_100118A0(a1, *(void **)a2);
    *(_DWORD *)v6 = v7;
    if ( !v7 )
      goto LABEL_24;
  }
  else
  {
    *(_DWORD *)v5 = 0;
  }
  *(_DWORD *)(v6 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 16) )
  {
    v8 = 2 * (sub_1001AFC0(*(_WORD **)(a2 + 16)) + 1);
    v9 = (void *)sub_10011830(a1, v8);
    *(_DWORD *)(v6 + 16) = v9;
    if ( !v9 )
      goto LABEL_24;
    memcpy(v9, *(const void **)(a2 + 16), v8);
    *(_DWORD *)(v6 + 20) = *(_DWORD *)(v6 + 16) + 2 * ((*(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 16)) >> 1);
  }
  else
  {
    *(_DWORD *)(v6 + 20) = 0;
    *(_DWORD *)(v6 + 16) = 0;
  }
  if ( !*(_DWORD *)(a2 + 32) )
  {
    *(_DWORD *)(v6 + 32) = 0;
    goto LABEL_26;
  }
  v10 = 2 * (sub_1001AFC0(*(_WORD **)(a2 + 32)) + 1);
  v11 = (void *)sub_10011830(a1, v10);
  *(_DWORD *)(v6 + 32) = v11;
  if ( !v11 )
  {
LABEL_24:
    sub_10018B00(v2, v20);
    return 0;
  }
  memcpy(v11, *(const void **)(a2 + 32), v10);
  v12 = *(_DWORD **)(a2 + 36);
  if ( !v12 )
  {
LABEL_26:
    *(_DWORD *)(v6 + 36) = 0;
    goto LABEL_27;
  }
  for ( i = 0; *v12; ++i )
    ++v12;
  v14 = sub_10011830(a1, 4 * i + 4);
  *(_DWORD *)(v6 + 36) = v14;
  if ( !v14 )
    goto LABEL_24;
  v15 = *(_DWORD **)(a2 + 36);
  v19 = 0;
  if ( *v15 )
  {
    v16 = 0;
    while ( 1 )
    {
      v17 = 2 * (sub_1001AFC0((_WORD *)v15[v16]) + 1);
      *(_DWORD *)(v16 * 4 + *(_DWORD *)(v6 + 36)) = sub_10011830(a1, v17);
      v18 = (void **)(v16 * 4 + *(_DWORD *)(v6 + 36));
      if ( !*v18 )
        break;
      memcpy(*v18, *(const void **)(v16 * 4 + *(_DWORD *)(a2 + 36)), v17);
      v15 = *(_DWORD **)(a2 + 36);
      v16 = v19++ + 1;
      if ( !v15[v16] )
        goto LABEL_22;
    }
    v2 = a1;
    goto LABEL_24;
  }
LABEL_22:
  *(_DWORD *)(*(_DWORD *)(v6 + 36) + 4 * v19) = 0;
LABEL_27:
  result = v20;
  *(_DWORD *)(v6 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(v6 + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

//----- (10018DA0) --------------------------------------------------------
void __cdecl sub_10018DA0(int a1, int a2)
{
  int v2; // eax@1
  unsigned int *v3; // eax@2

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
  if ( v2 != -2147483647 )
  {
    v3 = (unsigned int *)(v2 & 0xFFFFFFFE);
    if ( v3 )
      sub_10018B00(a1, v3);
  }
}

//----- (10018DD0) --------------------------------------------------------
int __cdecl sub_10018DD0(int a1, int a2)
{
  int v2; // eax@3
  int v3; // eax@4
  int *v4; // eax@5
  int result; // eax@6

  if ( !(a2 & 7)
    && a2
    && (v2 = *(_DWORD *)((a2 & 0xFFFFFFF8) + 4), (char **)(*(_DWORD *)(v2 + 8) & 0xFFFFFFFE) == &off_10161720)
    && (v3 = *(_DWORD *)(v2 + 12), v3 != -2147483647)
    && (v4 = (int *)(v3 & 0xFFFFFFFE)) != 0 )
  {
    result = *v4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10161720: using guessed type char *off_10161720;

//----- (10018E10) --------------------------------------------------------
char *__usercall sub_10018E10@<eax>(unsigned int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  unsigned int v5; // ebx@1
  int v6; // esi@1
  int v8; // ecx@7
  int v9; // esi@7
  void *v10; // ebx@7
  unsigned int v11; // edi@7
  unsigned int v12; // ebp@7
  int v13; // eax@12
  int v14; // eax@13
  int v15; // eax@18
  int v16; // eax@19
  int *v17; // eax@20
  int v18; // eax@20
  int v19; // esi@20
  char v20; // al@23
  void *v21; // eax@23
  unsigned int v22; // eax@25
  int v23; // ecx@26
  const void *v24; // eax@27
  void *v25; // eax@37
  int v26; // eax@39
  int v27; // eax@40
  int v28; // eax@44
  int v29; // ebp@44
  char *v30; // eax@45
  void *v31; // eax@54
  int v32; // esi@57
  char v33; // al@60
  void *v34; // eax@60
  unsigned int v35; // eax@62
  int v36; // ecx@63
  const void *v37; // eax@64
  bool v38; // cf@69
  void *v39; // eax@74
  void *v40; // eax@81
  int v41; // eax@83
  _BYTE *v42; // eax@84
  _BYTE *i; // esi@85
  void *v44; // eax@90
  void *v45; // eax@97
  int v46; // eax@99
  int v47; // ecx@100
  char v48; // al@101
  char *v49; // esi@101
  void *v50; // eax@106
  void *v51; // eax@114
  void *v52; // eax@121
  int v53; // eax@135
  void *v54; // eax@139
  int v55; // [sp+Ch] [bp-A4h]@1
  int v56; // [sp+10h] [bp-A0h]@7
  int v57; // [sp+14h] [bp-9Ch]@39
  int v58; // [sp+18h] [bp-98h]@7
  int v59; // [sp+1Ch] [bp-94h]@20
  int v60; // [sp+1Ch] [bp-94h]@39
  int v61; // [sp+20h] [bp-90h]@15
  int (__cdecl *v62)(int, _DWORD, int, signed int, int *); // [sp+24h] [bp-8Ch]@5
  int v63; // [sp+28h] [bp-88h]@59
  signed int *v64; // [sp+2Ch] [bp-84h]@6
  int v65; // [sp+30h] [bp-80h]@6
  unsigned int v66; // [sp+34h] [bp-7Ch]@1
  int v67; // [sp+38h] [bp-78h]@7
  char v68; // [sp+3Ch] [bp-74h]@101
  char v69; // [sp+48h] [bp-68h]@46

  v5 = a1;
  v6 = a2;
  v55 = a2;
  v66 = a1;
  if ( !sub_10010860(a2, a1, (int)aMessage, a3 | 4, 0, 0, 1)
    || !sub_10010860(v6, v5, (int)aFilename, a4 | 4, 0, 0, 1)
    || !sub_10010860(v6, v5, (int)aLinenumber, 2 * a5 | 1, 0, 0, 1) )
  {
    return 0;
  }
  v62 = *(int (__cdecl **)(int, _DWORD, int, signed int, int *))(*(_DWORD *)(v6 + 24) + 8792);
  if ( v62 )
  {
    v65 = sub_10011190(v6, 0);
    v64 = sub_10011D20(v6);
  }
  v8 = *(_DWORD *)(*(_DWORD *)(v6 + 24) + 228);
  v9 = *(_DWORD *)(v6 + 56);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v67 = *(_DWORD *)(v8 + 8);
  v56 = 1;
  v58 = v9;
  if ( v9 )
  {
    while ( 1 )
    {
      if ( v62 )
      {
        if ( *(_DWORD *)(v9 + 16) && (v13 = *(_DWORD *)(v9 + 28)) != 0 )
          v14 = *(_DWORD *)(v13 - 8);
        else
          v14 = 0;
        v61 = v14;
        if ( !(v14 & 7) )
        {
          if ( v14 )
          {
            v56 = v62(v55, *(_DWORD *)(*(_DWORD *)(v9 + 16) + 4), v67, 4, &v61);
            if ( !v56 )
            {
              v56 = 1;
              break;
            }
          }
        }
      }
      v15 = *(_DWORD *)(v9 + 16);
      if ( v15 )
      {
        v16 = *(_DWORD *)(v15 + 24);
        if ( v16 )
        {
          v17 = (int *)(*(_DWORD *)(v16 + 8) & 0xFFFFFFF8);
          v59 = (int)v17;
          v18 = *v17;
          v19 = v18;
          if ( v18 & 0x40000000 )
            v19 = v18 & ((v18 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
          if ( v19 + v12 > v11 )
          {
            v20 = sub_10052D80(v19 + v12);
            v11 = 1 << v20;
            v21 = sub_10011870(v55, v10, 2 * (1 << v20) + 2);
            if ( !v21 )
              goto LABEL_127;
            v10 = v21;
          }
          v22 = *(_DWORD *)v59;
          if ( *(_DWORD *)v59 & 0x40000000 )
          {
            v23 = *(_DWORD *)(v59 + 4);
            if ( *(_DWORD *)v23 & 0x40000000 )
            {
              v24 = (const void *)sub_1001A200(v59);
            }
            else if ( (v22 & 0x80000000) == 0 )
            {
              v24 = (const void *)(*(_DWORD *)(v23 + 4) + 2 * ((v22 >> 15) & 0x7FFF));
            }
            else
            {
              v24 = *(const void **)(v23 + 4);
            }
          }
          else
          {
            v24 = *(const void **)(v59 + 4);
          }
          memcpy((char *)v10 + 2 * v12, v24, 2 * v19);
          v12 += v19;
          v9 = v58;
        }
        if ( v12 == v11 )
        {
          if ( v11 )
            v11 *= 2;
          else
            v11 = 64;
          v25 = sub_10011870(v55, v10, 2 * v11 + 2);
          if ( !v25 )
          {
LABEL_127:
            v56 = 0;
            break;
          }
          v10 = v25;
        }
        *((_WORD *)v10 + v12) = 40;
        v26 = 0;
        v57 = ++v12;
        v60 = 0;
        if ( *(_DWORD *)(v9 + 24) )
        {
          do
          {
            v27 = *(_DWORD *)(*(_DWORD *)(v58 + 28) + 4 * v26);
            v61 = v27;
            if ( v27 & 7 || !v27 )
            {
              v30 = sub_1001AD70(v55, v27);
            }
            else if ( v27 & 0xFFFFFFF8
                   && (char **)(*(_DWORD *)(*(_DWORD *)((v27 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) == &off_101621B8 )
            {
              v28 = sub_100101A0(v55, v27);
              v29 = sub_10010B60(v28);
              if ( v29 )
                goto LABEL_49;
              v30 = sub_1001AD70(v55, v61);
            }
            else
            {
              sub_10050B00(
                (int)&v69,
                100,
                "[object %s]",
                *(_DWORD *)(*(_DWORD *)(*(_DWORD *)((v27 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE));
              v30 = (char *)sub_10010F20(v55, &v69);
            }
            v29 = (int)v30;
            if ( !v30 )
              goto LABEL_126;
LABEL_49:
            if ( v60 )
            {
              if ( v57 == v11 )
              {
                if ( v11 )
                  v11 *= 2;
                else
                  v11 = 64;
                v31 = sub_10011870(v55, v10, 2 * v11 + 2);
                if ( !v31 )
                {
LABEL_126:
                  v12 = v57;
                  goto LABEL_127;
                }
                v10 = v31;
              }
              *((_WORD *)v10 + v57++) = 44;
            }
            v32 = *(_DWORD *)v29;
            if ( *(_DWORD *)v29 & 0x40000000 )
              v32 = *(_DWORD *)v29 & ((v32 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
            v63 = v32 + v57;
            if ( v32 + v57 > v11 )
            {
              v33 = sub_10052D80(v32 + v57);
              v11 = 1 << v33;
              v34 = sub_10011870(v55, v10, 2 * (1 << v33) + 2);
              if ( !v34 )
                goto LABEL_126;
              v10 = v34;
            }
            v35 = *(_DWORD *)v29;
            if ( *(_DWORD *)v29 & 0x40000000 )
            {
              v36 = *(_DWORD *)(v29 + 4);
              if ( *(_DWORD *)v36 & 0x40000000 )
              {
                v37 = (const void *)sub_1001A200(v29);
              }
              else if ( (v35 & 0x80000000) == 0 )
              {
                v37 = (const void *)(*(_DWORD *)(v36 + 4) + 2 * ((v35 >> 15) & 0x7FFF));
              }
              else
              {
                v37 = *(const void **)(v36 + 4);
              }
            }
            else
            {
              v37 = *(const void **)(v29 + 4);
            }
            memcpy((char *)v10 + 2 * v57, v37, 2 * v32);
            v12 = v63;
            v26 = v60 + 1;
            v38 = (unsigned int)(v60 + 1) < *(_DWORD *)(v58 + 24);
            v57 = v63;
            ++v60;
          }
          while ( v38 );
        }
        if ( v12 == v11 )
        {
          if ( v11 )
            v11 *= 2;
          else
            v11 = 64;
          v39 = sub_10011870(v55, v10, 2 * v11 + 2);
          if ( !v39 )
            goto LABEL_127;
          v10 = v39;
        }
        v9 = v58;
        *((_WORD *)v10 + v12++) = 41;
      }
      if ( v12 == v11 )
      {
        if ( v11 )
          v11 *= 2;
        else
          v11 = 64;
        v40 = sub_10011870(v55, v10, 2 * v11 + 2);
        if ( !v40 )
          goto LABEL_127;
        v10 = v40;
      }
      *((_WORD *)v10 + v12) = 64;
      v41 = *(_DWORD *)(v9 + 12);
      ++v12;
      if ( v41 )
      {
        v42 = *(_BYTE **)(v41 + 24);
        if ( v42 )
        {
          for ( i = v42; *i; ++v12 )
          {
            if ( v12 == v11 )
            {
              if ( v11 )
                v11 *= 2;
              else
                v11 = 64;
              v44 = sub_10011870(v55, v10, 2 * v11 + 2);
              if ( !v44 )
                goto LABEL_127;
              v10 = v44;
            }
            *((_WORD *)v10 + v12) = *i++;
          }
        }
      }
      if ( v12 == v11 )
      {
        if ( v11 )
          v11 *= 2;
        else
          v11 = 64;
        v45 = sub_10011870(v55, v10, 2 * v11 + 2);
        if ( !v45 )
          goto LABEL_127;
        v10 = v45;
      }
      *((_WORD *)v10 + v12) = 58;
      v46 = *(_DWORD *)(v58 + 12);
      ++v12;
      if ( v46 && (v47 = *(_DWORD *)(v58 + 56)) != 0 )
      {
        v48 = sub_10021490(v55, v46, v47);
        sub_10050B00((int)&v68, 11, "%u", v48);
        v49 = &v68;
        if ( v68 )
        {
          do
          {
            if ( v12 == v11 )
            {
              if ( v11 )
                v11 *= 2;
              else
                v11 = 64;
              v50 = sub_10011870(v55, v10, 2 * v11 + 2);
              if ( !v50 )
                goto LABEL_127;
              v10 = v50;
            }
            *((_WORD *)v10 + v12++) = (unsigned __int8)*v49++;
          }
          while ( *v49 );
        }
      }
      else
      {
        if ( v12 == v11 )
        {
          if ( v11 )
            v11 *= 2;
          else
            v11 = 64;
          v51 = sub_10011870(v55, v10, 2 * v11 + 2);
          if ( !v51 )
            goto LABEL_127;
          v10 = v51;
        }
        *((_WORD *)v10 + v12++) = 48;
      }
      if ( v12 == v11 )
      {
        if ( v11 )
          v11 *= 2;
        else
          v11 = 64;
        v52 = sub_10011870(v55, v10, 2 * v11 + 2);
        if ( !v52 )
          goto LABEL_127;
        v10 = v52;
      }
      *((_WORD *)v10 + v12++) = 10;
      v58 = *(_DWORD *)(v58 + 44);
      if ( !v58 )
        break;
      v9 = v58;
    }
  }
  if ( v62 )
  {
    if ( v56 )
      sub_10011D70(v55, (int)v64);
    else
      sub_100112B0(v55, (unsigned int)v64);
    sub_10011190(v55, v65);
  }
  if ( v56 )
  {
    if ( !v10 )
    {
      v53 = *(_DWORD *)(*(_DWORD *)(v55 + 24) + 480);
      return sub_10010860(v55, v66, (int)aStack_0, v53 | 4, 0, 0, 1);
    }
    if ( v12 < v11 )
    {
      v54 = sub_10053FC0(v10, 2 * v12 + 2, dword_10658DEC);
      if ( v54 )
        v10 = v54;
    }
    *((_WORD *)v10 + v12) = 0;
    v53 = sub_1001AB10(v55, (int)v10, v12, 0);
    if ( v53 )
      return sub_10010860(v55, v66, (int)aStack_0, v53 | 4, 0, 0, 1);
  }
  sub_10010340(v55, (unsigned int)v10);
  return 0;
}
// 101621B8: using guessed type char *off_101621B8;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10019530) --------------------------------------------------------
int __cdecl sub_10019530(int a1, unsigned int a2, unsigned int a3, int a4, int *a5)
{
  int v5; // esi@1
  int result; // eax@2
  int v7; // eax@3
  int v8; // ebx@3
  int v9; // eax@9
  unsigned int v10; // edi@11
  int v11; // ebp@12
  int v12; // edi@15
  int v13; // [sp+4h] [bp-4h]@4

  v5 = a1;
  if ( *(_BYTE *)(a1 + 293) )
    return 0;
  v7 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 293) = 1;
  v8 = a4;
  if ( *(_BYTE *)(v7 + 76) & 1 )
  {
    result = a2;
  }
  else
  {
    result = (*(int (__cdecl **)(int, unsigned int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a4 - 8) & 0xFFFFFFF8)
                                                                              + 4)
                                                                  + 16))(
               v5,
               *(_DWORD *)(a4 - 8) & 0xFFFFFFF8,
               *(_DWORD *)(*(_DWORD *)(v5 + 24) + 232),
               &v13);
    if ( !result )
      goto LABEL_24;
    result = sub_10017C40(v5, (int)&off_10161720, v13 & 0xFFFFFFF8, 0);
    a2 = result;
    if ( !result )
    {
      *(_BYTE *)(v5 + 293) = 0;
      return result;
    }
    *a5 = result;
  }
  v9 = *(_DWORD *)(result + 4);
  if ( (char **)(*(_DWORD *)(v9 + 8) & 0xFFFFFFFE) == &off_10161720 )
    *(_DWORD *)(v9 + 12) = -2147483647;
  v10 = a3;
  if ( a3 )
  {
    result = sub_1001ACB0(v5, *(_DWORD *)v8);
    v11 = result;
    if ( !result )
    {
      *(_BYTE *)(v5 + 293) = 0;
      return result;
    }
    if ( v10 > 1 )
    {
      result = sub_1001ACB0(v5, *(_DWORD *)(v8 + 4));
      v12 = result;
      if ( !result )
      {
        *(_BYTE *)(v5 + 293) = 0;
        return result;
      }
      goto LABEL_16;
    }
  }
  else
  {
    v11 = *(_DWORD *)(*(_DWORD *)(v5 + 24) + 480);
  }
  v12 = *(_DWORD *)(*(_DWORD *)(v5 + 24) + 480);
LABEL_16:
  if ( a3 <= 2 )
  {
    a1 = 0;
LABEL_23:
    result = (int)sub_10018E10(a2, v5, v11, v12, a1);
    goto LABEL_24;
  }
  result = sub_10020220(v5, *(_DWORD *)(v8 + 8), &a1);
  if ( result )
    goto LABEL_23;
LABEL_24:
  *(_BYTE *)(v5 + 293) = 0;
  return result;
}
// 10161720: using guessed type char *off_10161720;

//----- (10019680) --------------------------------------------------------
int *__cdecl sub_10019680(int a1, signed int a2, int a3, int a4, int *a5)
{
  int v5; // esi@1
  int *result; // eax@1
  int *v7; // edi@2
  int *v8; // eax@4
  int v9; // ebp@4
  int v10; // ecx@5
  int v11; // edx@5
  int v12; // eax@5
  int v13; // esi@8
  int v14; // edi@10
  void *v15; // ebx@12
  unsigned int v16; // eax@13
  int v17; // ecx@14
  const void *v18; // eax@15
  size_t v19; // esi@20
  char *v20; // esi@20
  unsigned int v21; // eax@20
  void *v22; // esi@20
  int v23; // ecx@21
  const void *v24; // eax@22
  size_t v25; // edi@27
  int v26; // eax@27
  int v27; // [sp+8h] [bp-8h]@2
  unsigned int v28; // [sp+Ch] [bp-4h]@12

  v5 = a2;
  result = (int *)(*(int (__cdecl **)(int, signed int, _DWORD, signed int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(
                    a1,
                    a2,
                    *(_DWORD *)(*(_DWORD *)(a1 + 24) + 268),
                    &a2);
  if ( result )
  {
    result = (int *)sub_1001ACB0(a1, a2);
    v7 = result;
    v27 = (int)result;
    if ( result )
    {
      if ( !sub_100108D0(a1, v5, aMessage, (int)&a2) )
        return 0;
      v8 = (int *)sub_1001ACB0(a1, a2);
      v9 = (int)v8;
      if ( !v8 )
        return 0;
      v10 = *v8;
      v11 = *v8 & 0x40000000;
      v12 = *v8;
      if ( *(_DWORD *)v9 & 0x40000000 )
        v12 = v10 & ((v12 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      if ( v12 )
      {
        v13 = *v7;
        if ( *v7 & 0x40000000 )
          v13 = *v7 & ((v13 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        v14 = *(_DWORD *)v9;
        if ( v11 )
          v14 = v10 & ((v10 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        v28 = v14 + v13 + 2;
        v15 = (void *)sub_10011830(a1, 2 * v28 + 2);
        if ( !v15 )
          return 0;
        v16 = *(_DWORD *)v27;
        if ( *(_DWORD *)v27 & 0x40000000 )
        {
          v17 = *(_DWORD *)(v27 + 4);
          if ( *(_DWORD *)v17 & 0x40000000 )
          {
            v18 = (const void *)sub_1001A200(v27);
          }
          else if ( (v16 & 0x80000000) == 0 )
          {
            v18 = (const void *)(*(_DWORD *)(v17 + 4) + 2 * ((v16 >> 15) & 0x7FFF));
          }
          else
          {
            v18 = *(const void **)(v17 + 4);
          }
        }
        else
        {
          v18 = *(const void **)(v27 + 4);
        }
        v19 = 2 * v13;
        memcpy(v15, v18, v19);
        v20 = (char *)v15 + v19;
        *(_WORD *)v20 = 58;
        v20 += 2;
        *(_WORD *)v20 = 32;
        v21 = *(_DWORD *)v9;
        v22 = v20 + 2;
        if ( *(_DWORD *)v9 & 0x40000000 )
        {
          v23 = *(_DWORD *)(v9 + 4);
          if ( *(_DWORD *)v23 & 0x40000000 )
          {
            v24 = (const void *)sub_1001A200(v9);
          }
          else if ( (v21 & 0x80000000) == 0 )
          {
            v24 = (const void *)(*(_DWORD *)(v23 + 4) + 2 * ((v21 >> 15) & 0x7FFF));
          }
          else
          {
            v24 = *(const void **)(v23 + 4);
          }
        }
        else
        {
          v24 = *(const void **)(v9 + 4);
        }
        v25 = 2 * v14;
        memcpy(v22, v24, v25);
        *(_WORD *)((char *)v22 + v25) = 0;
        v26 = sub_1001AB10(a1, (int)v15, v28, 0);
        if ( !v26 )
        {
          sub_10010340(a1, (unsigned int)v15);
          return 0;
        }
      }
      else
      {
        v26 = (int)v7;
      }
      *a5 = v26 | 4;
      result = (int *)1;
    }
  }
  return result;
}

//----- (10019890) --------------------------------------------------------
int __cdecl sub_10019890(int a1, signed int a2, int a3, int a4, int *a5)
{
  int v5; // edi@1
  int result; // eax@1
  int *v7; // ebp@2
  int *v8; // eax@10
  int *v9; // edx@10
  int v10; // eax@11
  int v11; // ecx@11
  int v12; // edi@15
  int v13; // ebx@17
  int v14; // ebp@19
  int v15; // eax@22
  int v16; // eax@23
  int v17; // eax@27
  int v18; // ecx@28
  _WORD *v19; // esi@28
  unsigned int v20; // eax@28
  void *v21; // esi@28
  int v22; // edx@29
  const void *v23; // eax@30
  size_t v24; // edi@35
  char *v25; // esi@35
  char *v26; // esi@35
  unsigned int v27; // eax@36
  int v28; // edx@37
  const void *v29; // eax@38
  size_t v30; // ebx@43
  _WORD *v31; // esi@45
  unsigned int v32; // eax@45
  void *v33; // esi@45
  int v34; // edx@46
  const void *v35; // eax@47
  size_t v36; // ebp@52
  int v37; // ecx@52
  _WORD *v38; // esi@54
  _WORD *v39; // esi@56
  unsigned int v40; // eax@56
  void *v41; // esi@56
  int v42; // edx@57
  const void *v43; // eax@58
  int v44; // esi@64
  unsigned int v45; // esi@64
  int v46; // eax@64
  unsigned int v47; // [sp+8h] [bp-20h]@19
  int v48; // [sp+Ch] [bp-1Ch]@12
  int *v49; // [sp+10h] [bp-18h]@10
  char *v50; // [sp+14h] [bp-14h]@4
  char *v51; // [sp+18h] [bp-10h]@6
  int v52; // [sp+1Ch] [bp-Ch]@8
  int *v53; // [sp+20h] [bp-8h]@2
  int v54; // [sp+24h] [bp-4h]@27

  v5 = a2;
  result = (*(int (__cdecl **)(int, signed int, _DWORD, signed int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(
             a1,
             a2,
             *(_DWORD *)(*(_DWORD *)(a1 + 24) + 268),
             &a2);
  if ( !result )
    return result;
  v7 = (int *)sub_1001ACB0(a1, a2);
  v53 = v7;
  if ( !v7 )
    return 0;
  if ( !sub_100108D0(a1, v5, aMessage, (int)&a2) )
    return 0;
  v50 = sub_1001AD70(a1, a2);
  if ( !v50 )
    return 0;
  if ( !sub_100108D0(a1, v5, aFilename, (int)&a2) )
    return 0;
  v51 = sub_1001AD70(a1, a2);
  if ( !v51 || !sub_100108D0(a1, v5, aLinenumber, (int)&a2) || !sub_10020220(a1, a2, &v52) )
    return 0;
  if ( v52 )
  {
    v8 = (int *)sub_1001ACB0(a1, a2);
    v9 = v8;
    v49 = v8;
    if ( !v8 )
      return 0;
    v10 = *v8;
    v11 = *v9;
    if ( *v9 & 0x40000000 )
    {
      v11 = v10 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      v48 = v11;
    }
    else
    {
      v48 = *v9;
    }
  }
  else
  {
    v9 = 0;
    v49 = 0;
    v48 = 0;
    v11 = 0;
  }
  v12 = *v7;
  if ( *v7 & 0x40000000 )
    v12 = *v7 & ((v12 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  v13 = *(_DWORD *)v50;
  if ( *(_DWORD *)v50 & 0x40000000 )
    v13 = *(_DWORD *)v50 & ((v13 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  v47 = v13 + v12 + 8;
  v14 = *(_DWORD *)v51;
  if ( *(_DWORD *)v51 & 0x40000000 )
    v14 = *(_DWORD *)v51 & ((v14 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( v14 )
  {
    v15 = v47 + v14 + 2;
    v47 += v14 + 2;
    if ( !v9 )
      goto LABEL_27;
    v16 = v15 + v11 + 2;
  }
  else
  {
    if ( !v9 )
      goto LABEL_27;
    v16 = v47 + v11 + 6;
  }
  v47 = v16;
LABEL_27:
  v17 = sub_10011830(a1, 2 * v47 + 2);
  v54 = v17;
  if ( !v17 )
    return 0;
  v18 = (int)v53;
  *(_WORD *)v17 = 40;
  *(_WORD *)(v17 + 2) = 110;
  *(_WORD *)(v17 + 4) = 101;
  *(_WORD *)(v17 + 6) = 119;
  v19 = (_WORD *)(v17 + 8);
  *v19 = 32;
  v20 = *(_DWORD *)v18;
  v21 = v19 + 1;
  if ( *(_DWORD *)v18 & 0x40000000 )
  {
    v22 = *(_DWORD *)(v18 + 4);
    if ( *(_DWORD *)v22 & 0x40000000 )
    {
      v23 = (const void *)sub_1001A200(v18);
    }
    else if ( (v20 & 0x80000000) == 0 )
    {
      v23 = (const void *)(*(_DWORD *)(v22 + 4) + 2 * ((v20 >> 15) & 0x7FFF));
    }
    else
    {
      v23 = *(const void **)(v22 + 4);
    }
  }
  else
  {
    v23 = *(const void **)(v18 + 4);
  }
  v24 = 2 * v12;
  memcpy(v21, v23, v24);
  v25 = (char *)v21 + v24;
  *(_WORD *)v25 = 40;
  v26 = v25 + 2;
  if ( v13 )
  {
    v27 = *(_DWORD *)v50;
    if ( *(_DWORD *)v50 & 0x40000000 )
    {
      v28 = *((_DWORD *)v50 + 1);
      if ( *(_DWORD *)v28 & 0x40000000 )
      {
        v29 = (const void *)sub_1001A200((int)v50);
      }
      else if ( (v27 & 0x80000000) == 0 )
      {
        v29 = (const void *)(*(_DWORD *)(v28 + 4) + 2 * ((v27 >> 15) & 0x7FFF));
      }
      else
      {
        v29 = *(const void **)(v28 + 4);
      }
    }
    else
    {
      v29 = (const void *)*((_DWORD *)v50 + 1);
    }
    v30 = 2 * v13;
    memcpy(v26, v29, v30);
    v26 += v30;
  }
  if ( v14 )
  {
    *(_WORD *)v26 = 44;
    v31 = v26 + 2;
    *v31 = 32;
    v32 = *(_DWORD *)v51;
    v33 = v31 + 1;
    if ( *(_DWORD *)v51 & 0x40000000 )
    {
      v34 = *((_DWORD *)v51 + 1);
      if ( *(_DWORD *)v34 & 0x40000000 )
      {
        v35 = (const void *)sub_1001A200((int)v51);
      }
      else if ( (v32 & 0x80000000) == 0 )
      {
        v35 = (const void *)(*(_DWORD *)(v34 + 4) + 2 * ((v32 >> 15) & 0x7FFF));
      }
      else
      {
        v35 = *(const void **)(v34 + 4);
      }
    }
    else
    {
      v35 = (const void *)*((_DWORD *)v51 + 1);
    }
    v36 = 2 * v14;
    memcpy(v33, v35, v36);
    v37 = (int)v49;
    v26 = (char *)v33 + v36;
LABEL_55:
    if ( v37 )
    {
      *(_WORD *)v26 = 44;
      v39 = v26 + 2;
      *v39 = 32;
      v40 = *(_DWORD *)v37;
      v41 = v39 + 1;
      if ( *(_DWORD *)v37 & 0x40000000 )
      {
        v42 = *(_DWORD *)(v37 + 4);
        if ( *(_DWORD *)v42 & 0x40000000 )
        {
          v43 = (const void *)sub_1001A200(v37);
        }
        else if ( (v40 & 0x80000000) == 0 )
        {
          v43 = (const void *)(*(_DWORD *)(v42 + 4) + 2 * ((v40 >> 15) & 0x7FFF));
        }
        else
        {
          v43 = *(const void **)(v42 + 4);
        }
      }
      else
      {
        v43 = *(const void **)(v37 + 4);
      }
      memcpy(v41, v43, 2 * v48);
      v26 = (char *)v41 + 2 * v48;
    }
    goto LABEL_64;
  }
  v37 = (int)v49;
  if ( v49 )
  {
    *(_WORD *)v26 = 44;
    v38 = v26 + 2;
    *v38 = 32;
    ++v38;
    *v38 = 34;
    ++v38;
    *v38 = 34;
    v26 = (char *)(v38 + 1);
    goto LABEL_55;
  }
LABEL_64:
  *(_WORD *)v26 = 41;
  v44 = (int)(v26 + 2);
  *(_WORD *)v44 = 41;
  *(_WORD *)(v44 + 2) = 0;
  v45 = v54;
  v46 = sub_1001AB10(a1, v54, v47, 0);
  if ( !v46 )
  {
    sub_10010340(a1, v45);
    return 0;
  }
  *a5 = v46 | 4;
  return 1;
}

//----- (10019CE0) --------------------------------------------------------
unsigned int __cdecl sub_10019CE0(int a1, unsigned int a2)
{
  unsigned int v2; // ebx@1
  int v3; // eax@2
  int v4; // eax@3
  int v5; // eax@5
  unsigned int v6; // edi@5
  char *v7; // eax@6
  int v8; // eax@7
  int v9; // eax@9
  int v10; // ebx@11
  unsigned int v11; // edi@12
  int v13; // [sp+10h] [bp-24h]@1
  int v14[8]; // [sp+14h] [bp-20h]@3

  v2 = 0;
  v13 = 0;
  if ( "Error" )
  {
    while ( 1 )
    {
      v3 = dword_100CC788[v2 / 4];
      v4 = v3 == -1 ? 0 : v14[v3];
      v5 = sub_10017C40(a1, (int)&off_10161720, v4, a2);
      v6 = v5;
      v14[v13] = v5;
      if ( !v5 )
        break;
      *(_DWORD *)(*(_DWORD *)(v5 + 4) + 12) = -2147483647;
      v7 = sub_10038950(a1, (int)(&off_100CC78C)[v2], strlen((&off_100CC78C)[v2]), 0);
      if ( !v7 )
        break;
      v8 = sub_10028A40(a1, a2, (int)v7, *(int *)((char *)&off_100CC790 + v2), 3, 0);
      if ( !v8 )
        break;
      *(_DWORD *)(v8 + 28) = &off_10161720;
      if ( !sub_100173E0(a1, *(_DWORD *)(v8 + 4), v6, 6) )
        break;
      v9 = sub_10010F20(a1, (&off_100CC78C)[v2]);
      if ( !v9 || !sub_10010860(a1, v6, (int)"name", v9 | 4, 0, 0, 1) )
        break;
      v10 = v13 + 1;
      v13 = v10;
      v2 = 12 * v10;
      if ( !(&off_100CC78C)[v2] )
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    v11 = v14[0];
    if ( sub_10010860(a1, v14[0], (int)aMessage, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480) | 4, 0, 0, 1)
      && sub_10010860(a1, v11, (int)aFilename, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480) | 4, 0, 0, 1)
      && sub_10010860(a1, v11, (int)aLinenumber, 1, 0, 0, 1) )
    {
      return sub_10011BE0(a1, v11, (const char **)&off_10161768) != 0 ? v11 : 0;
    }
  }
  return 0;
}
// 100CC788: using guessed type int dword_100CC788[];
// 100CC78C: using guessed type char *off_100CC78C;
// 100CC790: using guessed type int (__cdecl *off_100CC790)(int, int, int, int, int);
// 10161720: using guessed type char *off_10161720;
// 10161768: using guessed type char *off_10161768;
// 10019CE0: using guessed type int var_20[8];

//----- (10019EA0) --------------------------------------------------------
char *__cdecl sub_10019EA0(int a1, const char *a2, int a3)
{
  int v3; // esi@1
  int v4; // ebp@1
  int v5; // eax@3
  char *v6; // edi@5
  int v7; // eax@8
  unsigned int v8; // ebp@8
  char *result; // eax@9
  int v10; // edi@10
  int v11; // eax@11
  unsigned int *v12; // eax@13
  int v13; // [sp+Ch] [bp-4h]@5
  int v14; // [sp+14h] [bp+4h]@5

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 56);
  if ( v4 )
  {
    if ( !(*(_BYTE *)(a3 + 24) & 1) )
    {
      v5 = dword_10161790[*(_DWORD *)(a3 + 28)];
      if ( v5 != -1 && !*(_BYTE *)(a1 + 293) )
      {
        *(_BYTE *)(a1 + 293) = 1;
        v14 = *(_DWORD *)(v4 + 56);
        *(_DWORD *)(v4 + 56) = 0;
        v6 = (char *)sub_10018350(v3, (&off_100CC78C)[12 * v5], (unsigned int *)&v13);
        if ( v14 )
          *(_DWORD *)(v4 + 56) = v14;
        if ( !v6 )
          goto LABEL_15;
        v7 = sub_10017C40(v3, (int)&off_10161720, v13, 0);
        v8 = v7;
        if ( v7 )
        {
          sub_10011270(v3, v7);
          v10 = sub_10010F20(v3, a2);
          if ( v10 )
          {
            v11 = sub_10010F20(v3, *(const char **)a3);
            if ( v11 )
            {
              v6 = sub_10018E10(v8, v3, v10, v11, *(_DWORD *)(a3 + 4));
              if ( !v6 )
              {
LABEL_15:
                result = v6;
                *(_BYTE *)(v3 + 293) = 0;
                return result;
              }
              v12 = sub_10018B90(v3, a3);
              if ( v12 )
              {
                *(_DWORD *)(*(_DWORD *)(v8 + 4) + 12) = (unsigned int)v12 | 1;
                *(_DWORD *)(a3 + 24) |= 2u;
                goto LABEL_15;
              }
            }
          }
        }
        result = 0;
        *(_BYTE *)(v3 + 293) = 0;
        return result;
      }
    }
  }
  return 0;
}
// 100CC78C: using guessed type char *off_100CC78C;
// 10161720: using guessed type char *off_10161720;
// 10161790: using guessed type int dword_10161790[];

//----- (10019FD0) --------------------------------------------------------
signed int __cdecl sub_10019FD0(int a1)
{
  int v1; // edx@3
  int v3; // edi@9
  signed int v4; // edx@9
  int v5; // eax@9
  const char *v6; // eax@10
  unsigned int v7; // [sp+4h] [bp-8h]@5
  int v8; // [sp+8h] [bp-4h]@2

  if ( !sub_10011230(a1) || !sub_10011240(a1, &v8) )
    return 0;
  v1 = v8;
  if ( v8 & 7 || !v8 )
  {
    v7 = 0;
  }
  else
  {
    v7 = v8 & 0xFFFFFFF8;
    if ( !sub_1003AB10(a1, (int)&v7, (unsigned int)"exn.report.root") )
      return 0;
    v1 = v8;
  }
  v3 = sub_10018DD0(a1, v1);
  v5 = sub_1001ACB0(a1, v4);
  if ( v5 )
    v6 = (const char *)sub_1001B200(v5);
  else
    v6 = "null";
  if ( v3 )
  {
    *(_DWORD *)(v3 + 24) |= 2u;
    sub_1003ECD0(a1, (void *)v6, v3);
  }
  else
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 147, (char)v6);
  }
  if ( v7 )
    sub_1003A860(*(_DWORD *)(a1 + 24), (int)&v7);
  return 1;
}

//----- (1001A130) --------------------------------------------------------
unsigned int __cdecl sub_1001A130(int a1, signed int a2, _DWORD *a3)
{
  int v3; // edi@1
  unsigned int v4; // esi@1
  bool v5; // sf@1
  int v6; // ecx@1
  unsigned int v7; // esi@2
  unsigned int v8; // eax@4
  unsigned int v9; // eax@6
  int v10; // eax@8
  unsigned int result; // eax@15

  v3 = a1;
  v4 = *(_DWORD *)a1;
  v5 = *(_DWORD *)a1 < 0;
  v6 = *(_DWORD *)(a1 + 4);
  a1 = *(_DWORD *)(a1 + 4);
  if ( v5 )
    v7 = 0;
  else
    v7 = (v4 >> 15) & 0x7FFF;
  v8 = *(_DWORD *)v6;
  if ( !(*(_DWORD *)v6 & 0x40000000) )
    goto LABEL_15;
  if ( a2 >= 100 )
  {
    do
    {
      if ( (v8 & 0x80000000) == 0 )
        v10 = (v8 >> 15) & 0x7FFF;
      else
        v10 = 0;
      v6 = *(_DWORD *)(v6 + 4);
      v7 += v10;
      a1 = v6;
      v8 = *(_DWORD *)v6;
    }
    while ( *(_DWORD *)v6 & 0x40000000 );
  }
  else
  {
    v9 = sub_1001A130(v6, a2 + 1, &a1);
    v6 = a1;
    v7 += v9;
  }
  if ( !v7 )
  {
LABEL_14:
    *(_DWORD *)(v3 + 4) = v6;
LABEL_15:
    result = v7;
    *a3 = v6;
    return result;
  }
  if ( v7 <= 0x7FFF )
  {
    *(_DWORD *)v3 = ((v7 | 0x8000) << 15) | *(_DWORD *)v3 & ((*(_DWORD *)v3 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    goto LABEL_14;
  }
  *a3 = v6;
  return v7;
}

//----- (1001A200) --------------------------------------------------------
unsigned int __cdecl sub_1001A200(int a1)
{
  int v1; // ecx@0
  unsigned int v2; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v1;
  v2 = sub_1001A130(a1, 0, &v4);
  return *(_DWORD *)(v4 + 4) + 2 * v2;
}

//----- (1001A220) --------------------------------------------------------
void *__cdecl sub_1001A220(int a1, int a2)
{
  int v2; // esi@2
  void *result; // eax@3
  void *v4; // edi@5
  int v5; // ecx@6
  const void *v6; // eax@7
  int v7; // eax@9

  if ( !(*(_DWORD *)a2 & 0x40000000) )
    return *(void **)(a2 + 4);
  v2 = *(_DWORD *)a2 & ((*(_DWORD *)a2 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( a1 )
    result = (void *)sub_10011830(a1, 2 * v2 + 2);
  else
    result = (void *)sub_10053CF0(2 * v2 + 2, dword_10658DEC);
  v4 = result;
  if ( result )
  {
    v5 = *(_DWORD *)(a2 + 4);
    if ( *(_DWORD *)v5 & 0x40000000 )
    {
      v6 = (const void *)sub_1001A200(a2);
    }
    else
    {
      if ( *(_DWORD *)a2 >= 0 )
        v7 = (*(_DWORD *)a2 >> 15) & 0x7FFF;
      else
        v7 = 0;
      v6 = (const void *)(*(_DWORD *)(v5 + 4) + 2 * v7);
    }
    memcpy(v4, v6, 2 * v2);
    *((_WORD *)v4 + v2) = 0;
    *(_DWORD *)a2 = v2;
    *(_DWORD *)(a2 + 4) = v4;
    return *(void **)(a2 + 4);
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1001A2D0) --------------------------------------------------------
signed int __cdecl sub_1001A2D0(int a1, int a2, int a3, int *a4, int *a5)
{
  signed int result; // eax@1

  result = sub_100123C0(a1, a2, (int *)&off_10161AC0, (int)a4);
  if ( result )
  {
    if ( (*(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) & 7) == 4 )
    {
      *a5 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
      result = 1;
    }
    else
    {
      result = sub_10014F50(a1, a2, a3, a4, a5);
    }
  }
  return result;
}
// 10161AC0: using guessed type char *off_10161AC0;

//----- (1001A330) --------------------------------------------------------
signed int __cdecl sub_1001A330(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  signed int result; // eax@1

  result = sub_100123C0(a1, a2, (int *)&off_10161AC0, a4);
  if ( result )
  {
    *a5 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
    result = 1;
  }
  return result;
}
// 10161AC0: using guessed type char *off_10161AC0;

//----- (1001A370) --------------------------------------------------------
int __cdecl sub_1001A370(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // eax@1
  unsigned __int16 v7; // cx@2
  char v8; // dl@3
  int i; // edx@4
  int v10; // ecx@5
  int j; // eax@5
  int result; // eax@9
  unsigned __int16 v13; // ax@10
  int v14; // eax@11
  char v15[256]; // [sp+8h] [bp-104h]@1

  memset(v15, a4, 0x100u);
  v5 = a4 - 1;
  v6 = 0;
  if ( a4 - 1 <= 0 )
  {
LABEL_4:
    for ( i = v5 + a5; i < a2; i += v14 )
    {
      v10 = i;
      for ( j = a4 - 1; ; --j )
      {
        if ( j < 0 )
          return v10 + 1;
        if ( *(_WORD *)(a1 + 2 * v10) != *(_WORD *)(a3 + 2 * j) )
          break;
        --v10;
      }
      v13 = *(_WORD *)(a1 + 2 * i);
      if ( v13 < 0x100u )
        v14 = (unsigned __int8)v15[v13];
      else
        v14 = a4;
    }
    result = -1;
  }
  else
  {
    while ( 1 )
    {
      v7 = *(_WORD *)(a3 + 2 * v6);
      if ( v7 >= 0x100u )
        break;
      v8 = v5 - v6++;
      v15[v7] = v8;
      if ( v6 >= v5 )
        goto LABEL_4;
    }
    result = -2;
  }
  return result;
}
// 1001A370: using guessed type char var_104[256];

//----- (1001A470) --------------------------------------------------------
int *__cdecl sub_1001A470(int a1, unsigned int a2, int a3, int *a4)
{
  int v4; // ebx@1
  signed int v5; // eax@1
  int v6; // ecx@3
  unsigned int v7; // eax@3
  int v8; // edx@4
  unsigned int v9; // eax@5
  unsigned int v10; // ecx@10
  int *result; // eax@12
  unsigned __int16 v12; // si@14
  __int16 *v13; // edi@14
  int v14; // ebx@15
  signed int v15; // eax@16
  unsigned __int16 v16; // ax@19
  unsigned int i; // esi@19
  int v18; // ebx@21
  unsigned __int16 v19; // ax@26
  int v20; // ebx@28
  unsigned int v21; // esi@32
  int v22; // esi@43
  unsigned int v23; // eax@43
  int v24; // ecx@44
  unsigned int v25; // eax@45
  unsigned int v26; // eax@50
  int v27; // ecx@51
  unsigned int v28; // eax@52

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 16);
  if ( v5 && v5 <= 140 )
  {
    v6 = *(_DWORD *)(a3 + 20);
    v7 = *(_DWORD *)v6;
    if ( *(_DWORD *)v6 & 0x40000000 )
    {
      v8 = *(_DWORD *)(v6 + 4);
      if ( *(_DWORD *)v8 & 0x40000000 )
      {
        v9 = sub_1001A200(*(_DWORD *)(a3 + 20));
      }
      else if ( (v7 & 0x80000000) == 0 )
      {
        v9 = *(_DWORD *)(v8 + 4) + 2 * ((v7 >> 15) & 0x7FFF);
      }
      else
      {
        v9 = *(_DWORD *)(v8 + 4);
      }
    }
    else
    {
      v9 = *(_DWORD *)(v6 + 4);
    }
    v10 = a2;
    if ( a2 > v9 && *(_WORD *)(a2 - 2) == 92 )
      return 0;
  }
  else
  {
    v10 = a2;
  }
  v12 = *(_WORD *)(v10 + 2);
  v13 = (__int16 *)(v10 + 2);
  if ( v12 < 0x80u )
  {
    v14 = v12;
    if ( isdigit(v12) )
    {
      v15 = *(_DWORD *)(a1 + 16);
      if ( v15 && v15 <= 140 )
      {
        if ( v12 != 48 )
        {
          v16 = *v13;
          for ( i = 0; *v13; v16 = *v13 )
          {
            if ( v16 >= 0x80u )
              break;
            v18 = v16;
            if ( !isdigit(v16) )
              break;
            if ( v18 + 10 * i - 48 < i )
              break;
            ++v13;
            i = v18 + 10 * i - 48;
          }
LABEL_32:
          v21 = i - 1;
          *a4 = (signed int)((signed int)v13 - a2) >> 1;
          if ( v21 >= *(_DWORD *)(a1 + 136) )
          {
            result = &dword_10161A98;
          }
          else if ( v21 >= 9 )
          {
            result = (int *)(*(_DWORD *)(a1 + 216) + 8 * v21 - 72);
          }
          else
          {
            result = (int *)(a1 + 8 * v21 + 144);
          }
          return result;
        }
      }
      else
      {
        i = v12 - 48;
        if ( (unsigned int)(v14 - 48) <= *(_DWORD *)(a1 + 136) )
        {
          v19 = *(_WORD *)(a2 + 4);
          v13 = (__int16 *)(a2 + 4);
          if ( v19 )
          {
            if ( v19 < 0x80u )
            {
              v20 = v19;
              if ( isdigit(v19) )
              {
                if ( v20 + 10 * i - 48 <= *(_DWORD *)(a1 + 136) )
                {
                  v13 = (__int16 *)(a2 + 6);
                  i = v20 + 10 * i - 48;
                }
              }
            }
          }
          if ( i )
            goto LABEL_32;
        }
      }
      return 0;
    }
    v10 = a2;
    v4 = a1;
  }
  *a4 = 2;
  switch ( v12 )
  {
    case 0x24u:
      result = (int *)(a3 + 48);
      *(_DWORD *)(a3 + 52) = v10;
      *(_DWORD *)(a3 + 48) = 1;
      break;
    case 0x26u:
      result = (int *)(v4 + 220);
      break;
    case 0x2Bu:
      result = (int *)(v4 + 228);
      break;
    case 0x60u:
      if ( *(_DWORD *)(v4 + 16) == 120 )
      {
        v22 = *(_DWORD *)(a3 + 8);
        v23 = *(_DWORD *)v22;
        if ( *(_DWORD *)v22 & 0x40000000 )
        {
          v24 = *(_DWORD *)(v22 + 4);
          if ( *(_DWORD *)v24 & 0x40000000 )
          {
            v25 = sub_1001A200(*(_DWORD *)(a3 + 8));
          }
          else if ( (v23 & 0x80000000) == 0 )
          {
            v25 = *(_DWORD *)(v24 + 4) + 2 * ((v23 >> 15) & 0x7FFF);
          }
          else
          {
            v25 = *(_DWORD *)(v24 + 4);
          }
        }
        else
        {
          v25 = *(_DWORD *)(v22 + 4);
        }
        *(_DWORD *)(v4 + 240) = v25;
        v26 = *(_DWORD *)v22;
        if ( *(_DWORD *)v22 & 0x40000000 )
        {
          v27 = *(_DWORD *)(v22 + 4);
          if ( *(_DWORD *)v27 & 0x40000000 )
          {
            v28 = sub_1001A200(v22);
          }
          else if ( (v26 & 0x80000000) == 0 )
          {
            v28 = *(_DWORD *)(v27 + 4) + 2 * ((v26 >> 15) & 0x7FFF);
          }
          else
          {
            v28 = *(_DWORD *)(v27 + 4);
          }
        }
        else
        {
          v28 = *(_DWORD *)(v22 + 4);
        }
        *(_DWORD *)(v4 + 236) = (signed int)(*(_DWORD *)(v4 + 224) - v28) >> 1;
      }
      result = (int *)(v4 + 236);
      break;
    case 0x27u:
      result = (int *)(v4 + 244);
      break;
    default:
      return 0;
  }
  return result;
}
// 10161A98: using guessed type int dword_10161A98;

//----- (1001A770) --------------------------------------------------------
unsigned int __cdecl sub_1001A770(int a1, int a2, int a3, unsigned int *a4, int a5)
{
  unsigned int *v5; // ebp@1
  unsigned int v6; // ecx@1
  unsigned int v7; // esi@1
  unsigned int v8; // eax@1
  unsigned int result; // eax@4
  int v10; // eax@6
  _WORD *v11; // ebx@7
  unsigned int v12; // edi@12
  signed int v13; // ecx@14
  int v14; // edx@16
  int v15; // eax@16
  unsigned int v16; // ecx@20
  unsigned int i; // edx@26
  int v18; // ecx@35
  bool v19; // zf@35
  int v20; // ebp@49
  int v21; // ecx@55
  int v22; // edx@56
  int v23; // [sp+8h] [bp-4h]@33

  v5 = (unsigned int *)a2;
  v6 = *(_DWORD *)a2;
  v7 = *a4;
  v8 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 & 0x40000000 )
    v8 = v6 & ((v8 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( v7 > v8 )
    return -1;
  if ( *(_DWORD *)a2 & 0x40000000 )
  {
    v10 = *(_DWORD *)(a2 + 4);
    if ( *(_DWORD *)v10 & 0x40000000 )
    {
      v11 = (_WORD *)sub_1001A200(a2);
    }
    else if ( (v6 & 0x80000000) == 0 )
    {
      v11 = (_WORD *)(*(_DWORD *)(v10 + 4) + 2 * ((v6 >> 15) & 0x7FFF));
    }
    else
    {
      v11 = *(_WORD **)(v10 + 4);
    }
  }
  else
  {
    v11 = *(_WORD **)(a2 + 4);
  }
  v12 = *v5;
  if ( *v5 & 0x40000000 )
    v12 = *v5 & ((*v5 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  v13 = *(_DWORD *)(a1 + 16);
  if ( v13 == 120 )
  {
    if ( !a3 )
    {
      v14 = a5;
      v15 = *(_DWORD *)(a5 + 4);
      if ( *(_WORD *)v15 == 32 && !*(_WORD *)(v15 + 2) )
      {
        if ( !v7 )
        {
          if ( (*(_DWORD *)&dword_100CED28[4
                                         * (unsigned __int8)byte_100CCEA8[*v11 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v11 >> 6] << 6)]] & 0x70000) == 0x40000 )
          {
            do
              v16 = v11[v7++ + 1];
            while ( (*(_DWORD *)&dword_100CED28[4
                                              * (unsigned __int8)byte_100CCEA8[v16 & 0x3F | ((unsigned __int8)byte_100CCAA8[v16 >> 6] << 6)]] & 0x70000) == 0x40000 );
          }
          *a4 = v7;
        }
        if ( v7 != v12 )
        {
          for ( ; v7 < v12; ++v7 )
          {
            if ( (*(_DWORD *)&dword_100CED28[4
                                           * (unsigned __int8)byte_100CCEA8[v11[v7] & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)v11[v7] >> 6] << 6)]] & 0x70000) == 0x40000 )
              break;
          }
          for ( i = v7; i < v12; ++i )
          {
            if ( (*(_DWORD *)&dword_100CED28[4
                                           * (unsigned __int8)byte_100CCEA8[v11[i] & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)v11[i] >> 6] << 6)]] & 0x70000) != 0x40000 )
              break;
          }
          *(_DWORD *)a5 = i - v7;
          return v7;
        }
        return -1;
      }
      goto LABEL_45;
    }
LABEL_33:
    a2 = v7;
    if ( sub_10024C00(a1, a3, (int)v5, &a2, 1, &v23) )
    {
      while ( 1 )
      {
        if ( v23 != 14 )
        {
          result = v12;
          *(_DWORD *)a5 = 1;
          return result;
        }
        v18 = a5;
        *(_DWORD *)a5 = *(_DWORD *)(a1 + 220);
        v19 = *(_DWORD *)v18 == 0;
        *(_DWORD *)(v18 + 4) = *(_DWORD *)(a1 + 224);
        result = a2;
        if ( !v19 || a2 != *a4 )
          return a2 - *(_DWORD *)v18;
        if ( a2 == v12 )
          break;
        ++a2;
        if ( !sub_10024C00(a1, a3, (int)v5, &a2, 1, &v23) )
          goto LABEL_39;
      }
      if ( *(_DWORD *)(a1 + 16) != 120 )
        return -1;
      *(_DWORD *)v18 = 1;
    }
    else
    {
LABEL_39:
      result = -2;
    }
    return result;
  }
  if ( a3 )
    goto LABEL_33;
  v14 = a5;
LABEL_45:
  if ( v13 && v13 < 130 && !v12 )
    return -1;
  v20 = *(_DWORD *)v14;
  if ( !*(_DWORD *)v14 )
  {
    if ( v13 == 120 )
    {
      if ( v7 == v12 )
      {
        result = v7;
        *(_DWORD *)v14 = 1;
        return result;
      }
    }
    else if ( v7 == v12 )
    {
      return -1;
    }
    return v7 + 1;
  }
  v21 = 0;
  result = v7;
  if ( v7 < v12 )
  {
    v22 = *(_DWORD *)(v14 + 4);
    do
    {
      if ( v11[result] == *(_WORD *)(v22 + 2 * v21) )
      {
        if ( ++v21 == v20 )
          return v7;
      }
      else
      {
        ++v7;
        v21 = 0;
      }
      result = v21 + v7;
    }
    while ( v21 + v7 < v12 );
  }
  return result;
}

//----- (1001AAB0) --------------------------------------------------------
signed int sub_1001AAB0()
{
  return 1;
}

//----- (1001AAE0) --------------------------------------------------------
signed int __cdecl sub_1001AAE0(int a1)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 24);
  result = sub_1003A950(*(_DWORD *)(a1 + 24), *(_DWORD *)(v1 + 480));
  *(_DWORD *)(v1 + 480) = 0;
  return result;
}

//----- (1001AB10) --------------------------------------------------------
int __cdecl sub_1001AB10(int a1, int a2, unsigned int a3, char a4)
{
  int result; // eax@3

  if ( a3 > 0x3FFFFFFF )
  {
    sub_10011170(a1);
    return 0;
  }
  result = sub_1003B230(a1, a4 | 1);
  if ( !result )
    return 0;
  *(_DWORD *)result = a3;
  *(_DWORD *)(result + 4) = a2;
  return result;
}

//----- (1001AB60) --------------------------------------------------------
char *__cdecl sub_1001AB60(int a1, void *a2, int a3, int a4)
{
  size_t v4; // edi@1
  char *result; // eax@1
  char *v6; // esi@1
  char *v7; // edi@2

  v4 = 2 * a3;
  result = (char *)sub_10011830(a1, 2 * a3 + 2);
  v6 = result;
  if ( result )
  {
    memcpy(result, a2, v4);
    *(_WORD *)&v6[v4] = 0;
    v7 = (char *)sub_1001AB10(a1, (int)v6, a3, a4);
    if ( !v7 )
      sub_10010340(a1, (unsigned int)v6);
    result = v7;
  }
  return result;
}

//----- (1001ABD0) --------------------------------------------------------
unsigned int __cdecl sub_1001ABD0(unsigned int a1)
{
  return a1 >> 3;
}

//----- (1001ABE0) --------------------------------------------------------
void __cdecl sub_1001ABE0(unsigned int a1)
{
  int v1; // eax@2
  int v2; // ecx@2
  int *v3; // edi@2
  int v4; // esi@2

  if ( dword_1057267C )
  {
    v1 = sub_1001ABD0(a1);
    v3 = sub_10051360(v2, v1, a1);
    v4 = *v3;
    if ( *v3 )
    {
      sub_10053E10(*(_DWORD *)(v4 + 12), dword_10658DEC);
      sub_100514E0(dword_1057267C, v3, (_DWORD *)v4);
    }
  }
}
// 1057267C: using guessed type int dword_1057267C;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1001AC30) --------------------------------------------------------
void __cdecl sub_1001AC30(int a1, unsigned int a2)
{
  unsigned int v2; // eax@2

  if ( *(_DWORD *)a2 & 0x40000000 )
    goto LABEL_4;
  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 )
  {
    sub_10053E10(v2, dword_10658DEC);
LABEL_4:
    sub_1001ABE0(a2);
    *(_DWORD *)(a2 + 4) = 0;
  }
  *(_DWORD *)a2 = 0;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1001AC80) --------------------------------------------------------
int __cdecl sub_1001AC80(int a1, int a2)
{
  int result; // eax@1

  result = sub_10017C40(a1, (int)&off_10161AC0, 0, 0);
  if ( result )
    *(_DWORD *)(*(_DWORD *)(result + 4) + 12) = a2 | 4;
  return result;
}
// 10161AC0: using guessed type char *off_10161AC0;

//----- (1001ACB0) --------------------------------------------------------
int __cdecl sub_1001ACB0(int a1, signed int a2)
{
  signed int v2; // eax@1
  int result; // eax@3
  int v4; // ecx@6

  v2 = a2;
  if ( !(a2 & 7) )
  {
    if ( !(a2 & 0xFFFFFFF8) )
      return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 156) + 8) & 0xFFFFFFF8;
    result = (*(int (__cdecl **)(int, unsigned int, signed int, signed int *))(*(_DWORD *)(*(_DWORD *)(a2 & 0xFFFFFFF8)
                                                                                         + 4)
                                                                             + 36))(
               a1,
               a2 & 0xFFFFFFF8,
               3,
               &a2);
    if ( !result )
      return result;
    v2 = a2;
  }
  v4 = v2 & 7;
  if ( v4 != 4 )
  {
    if ( v2 & 1 && v2 != -2147483647 )
      return sub_1001F6E0(a1, (double)(v2 >> 1));
    if ( v4 == 2 )
      return sub_1001F6E0(a1, *(double *)(v2 & 0xFFFFFFF8));
    if ( v4 == 6 )
      return sub_1002D370(a1, v2 >> 3);
    v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 124) + 8);
  }
  return v2 & 0xFFFFFFF8;
}

//----- (1001AD70) --------------------------------------------------------
char *__cdecl sub_1001AD70(int a1, signed int a2)
{
  signed int v2; // eax@1
  int v3; // ecx@1
  char *result; // eax@2

  v2 = a2;
  v3 = a2 & 7;
  if ( v3 == 4 )
    return (char *)sub_1004C310(a1, a2 & 0xFFFFFFF8, 34);
  if ( a2 & 7 || !a2 )
  {
    if ( v3 == 2 && *(_DWORD *)((a2 & 0xFFFFFFF8) + 4) == 0x80000000 && !*(_DWORD *)(a2 & 0xFFFFFFF8) )
      return sub_1001AB60(a1, "-", 2, 0);
    goto LABEL_12;
  }
  result = (char *)sub_100175A0(a1, a2 & 0xFFFFFFF8, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 296), 0, 0, &a2);
  if ( result )
  {
    v2 = a2;
LABEL_12:
    result = (char *)sub_1001ACB0(a1, v2);
  }
  return result;
}

//----- (1001AE10) --------------------------------------------------------
unsigned int __cdecl sub_1001AE10(int a1)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@1
  int v3; // ecx@2
  _WORD *v4; // eax@3
  int v5; // ecx@8

  v1 = *(_DWORD *)a1;
  v2 = 0;
  if ( *(_DWORD *)a1 & 0x40000000 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)v3 & 0x40000000 )
    {
      v4 = (_WORD *)sub_1001A200(a1);
    }
    else if ( (v1 & 0x80000000) == 0 )
    {
      v4 = (_WORD *)(*(_DWORD *)(v3 + 4) + 2 * ((v1 >> 15) & 0x7FFF));
    }
    else
    {
      v4 = *(_WORD **)(v3 + 4);
    }
  }
  else
  {
    v4 = *(_WORD **)(a1 + 4);
  }
  v5 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & 0x40000000 )
    v5 = *(_DWORD *)a1 & ((v5 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  for ( ; v5; --v5 )
  {
    v2 = 16 * v2 ^ (v2 >> 28) ^ *v4;
    ++v4;
  }
  return v2;
}

//----- (1001AEA0) --------------------------------------------------------
int __cdecl sub_1001AEA0(int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edi@1
  unsigned int v4; // esi@3
  int v5; // ecx@6
  unsigned int v6; // ebp@7
  unsigned int v7; // eax@12
  int v8; // ecx@13
  unsigned int v9; // eax@14
  unsigned int v10; // ebx@19
  unsigned int v11; // edx@21
  int v12; // eax@22
  char *v13; // ecx@22
  int result; // eax@24
  int i; // [sp+18h] [bp+8h]@22

  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & 0x40000000 )
    v3 = v2 & ((v3 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  v4 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 & 0x40000000 )
    v4 = *(_DWORD *)a2 & ((v4 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( *(_DWORD *)a1 & 0x40000000 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)v5 & 0x40000000 )
    {
      v6 = sub_1001A200(a1);
    }
    else if ( (v2 & 0x80000000) == 0 )
    {
      v6 = *(_DWORD *)(v5 + 4) + 2 * ((v2 >> 15) & 0x7FFF);
    }
    else
    {
      v6 = *(_DWORD *)(v5 + 4);
    }
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 4);
  }
  v7 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 & 0x40000000 )
  {
    v8 = *(_DWORD *)(a2 + 4);
    if ( *(_DWORD *)v8 & 0x40000000 )
    {
      v9 = sub_1001A200(a2);
    }
    else if ( (v7 & 0x80000000) == 0 )
    {
      v9 = *(_DWORD *)(v8 + 4) + 2 * ((v7 >> 15) & 0x7FFF);
    }
    else
    {
      v9 = *(_DWORD *)(v8 + 4);
    }
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 4);
  }
  v10 = v3;
  if ( v3 >= v4 )
    v10 = v4;
  v11 = 0;
  if ( v10 )
  {
    v12 = v9 - v6;
    v13 = (char *)v6;
    for ( i = v12; ; v12 = i )
    {
      result = *(_WORD *)v13 - *(_WORD *)&v13[v12];
      if ( result )
        break;
      ++v11;
      v13 += 2;
      if ( v11 >= v10 )
        goto LABEL_26;
    }
  }
  else
  {
LABEL_26:
    result = v3 - v4;
  }
  return result;
}

//----- (1001AFC0) --------------------------------------------------------
int __cdecl sub_1001AFC0(_WORD *a1)
{
  _WORD *i; // eax@1

  for ( i = a1; *i; ++i )
    ;
  return i - a1;
}

//----- (1001AFE0) --------------------------------------------------------
_WORD *__cdecl sub_1001AFE0(_WORD *a1, __int16 a2)
{
  _WORD *result; // eax@1
  __int16 v3; // cx@1

  result = a1;
  v3 = *a1;
  if ( *a1 )
  {
    while ( v3 != a2 )
    {
      v3 = result[1];
      ++result;
      if ( !v3 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (1001B010) --------------------------------------------------------
_WORD *__cdecl sub_1001B010(_WORD *a1, __int16 a2, unsigned int a3)
{
  _WORD *result; // eax@1

  result = a1;
  if ( (unsigned int)a1 >= a3 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( *result != a2 )
    {
      ++result;
      if ( (unsigned int)result >= a3 )
        goto LABEL_4;
    }
  }
  return result;
}

//----- (1001B030) --------------------------------------------------------
_WORD *__cdecl sub_1001B030(_WORD *a1)
{
  _WORD *result; // eax@1
  unsigned int v2; // ecx@2

  result = a1;
  if ( (*(_DWORD *)&dword_100CED28[4
                                 * (unsigned __int8)byte_100CCEA8[*a1 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*a1 >> 6] << 6)]] & 0x70000) == 0x40000 )
  {
    do
    {
      v2 = result[1];
      ++result;
    }
    while ( (*(_DWORD *)&dword_100CED28[4
                                      * (unsigned __int8)byte_100CCEA8[v2 & 0x3F | ((unsigned __int8)byte_100CCAA8[v2 >> 6] << 6)]] & 0x70000) == 0x40000 );
  }
  return result;
}

//----- (1001B0A0) --------------------------------------------------------
unsigned int __cdecl sub_1001B0A0(_WORD *a1, int a2, unsigned int a3)
{
  unsigned int result; // eax@1

  result = 0;
  if ( a3 )
  {
    do
    {
      a1[result] = *(_BYTE *)(result + a2);
      ++result;
    }
    while ( result < a3 );
    a1[result] = 0;
  }
  else
  {
    *a1 = 0;
  }
  return result;
}

//----- (1001B0E0) --------------------------------------------------------
int __cdecl sub_1001B0E0(int a1, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // ecx@2

  result = sub_10011830(a1, 2 * a3 + 2);
  if ( result )
  {
    v4 = 0;
    if ( a3 )
    {
      do
      {
        *(_WORD *)(result + 2 * v4) = *(_BYTE *)(v4 + a2);
        ++v4;
      }
      while ( v4 < a3 );
    }
    *(_WORD *)(result + 2 * v4) = 0;
  }
  return result;
}

//----- (1001B130) --------------------------------------------------------
int __cdecl sub_1001B130(int a1, int a2, unsigned int a3)
{
  int result; // eax@2
  unsigned int v4; // ecx@5

  if ( a1 )
    result = sub_10011830(a1, a3 + 1);
  else
    result = sub_10053CF0(a3 + 1, dword_10658DEC);
  if ( result )
  {
    v4 = 0;
    if ( a3 )
    {
      do
      {
        *(_BYTE *)(v4 + result) = *(_BYTE *)(a2 + 2 * v4);
        ++v4;
      }
      while ( v4 < a3 );
    }
    *(_BYTE *)(v4 + result) = 0;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1001B190) --------------------------------------------------------
int sub_1001B190()
{
  int result; // eax@1

  result = dword_1057267C;
  if ( !dword_1057267C )
  {
    result = sub_100511F0(
               8u,
               (int)sub_1001ABD0,
               (int)sub_100516C0,
               (int)sub_100516C0,
               (int (__cdecl **)(int, int))dword_1057267C,
               dword_1057267C);
    dword_1057267C = result;
  }
  return result;
}
// 1057267C: using guessed type int dword_1057267C;

//----- (1001B1C0) --------------------------------------------------------
int __cdecl sub_1001B1C0(unsigned int a1, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  int v4; // eax@2
  int v5; // edi@2
  _DWORD *v6; // eax@2

  result = sub_1001B190();
  v3 = result;
  if ( result )
  {
    v4 = sub_1001ABD0(a1);
    v5 = v4;
    v6 = sub_10051360(v3, v4, a1);
    result = sub_100513D0(v3, v6, v5, a1, a2) != 0;
  }
  return result;
}

//----- (1001B200) --------------------------------------------------------
int __cdecl sub_1001B200(unsigned int a1)
{
  int result; // eax@1
  int v2; // eax@2
  int v3; // ebx@2
  int v4; // ecx@2
  _DWORD *v5; // eax@2
  _DWORD *v6; // ebp@2
  int v7; // eax@2
  unsigned int v8; // eax@4
  int v9; // esi@4
  int v10; // ecx@7
  int v11; // eax@8
  int v12; // eax@13
  unsigned int v13; // esi@13
  int v14; // [sp+0h] [bp-4h]@1

  result = sub_1001B190();
  v14 = result;
  if ( result )
  {
    v2 = sub_1001ABD0(a1);
    v3 = v2;
    v5 = sub_10051360(v4, v2, a1);
    v6 = v5;
    v7 = *v5;
    if ( v7 )
    {
      result = *(_DWORD *)(v7 + 12);
    }
    else
    {
      v8 = *(_DWORD *)a1;
      v9 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 & 0x40000000 )
        v9 = v8 & ((v8 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      if ( *(_DWORD *)a1 & 0x40000000 )
      {
        v10 = *(_DWORD *)(a1 + 4);
        if ( *(_DWORD *)v10 & 0x40000000 )
        {
          v11 = sub_1001A200(a1);
        }
        else if ( (v8 & 0x80000000) == 0 )
        {
          v11 = *(_DWORD *)(v10 + 4) + 2 * ((v8 >> 15) & 0x7FFF);
        }
        else
        {
          v11 = *(_DWORD *)(v10 + 4);
        }
      }
      else
      {
        v11 = *(_DWORD *)(a1 + 4);
      }
      v12 = sub_1001B130(0, v11, v9);
      v13 = v12;
      if ( !v12 || sub_100513D0(v14, v6, v3, a1, v12) )
      {
        result = v13;
      }
      else
      {
        sub_10053E10(v13, dword_10658DEC);
        result = 0;
      }
    }
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1001B2F0) --------------------------------------------------------
void *__usercall sub_1001B2F0@<eax>(int a1@<edi>, int a2@<esi>, int a3, void *a4)
{
  void *v4; // ecx@1
  int v5; // eax@1
  void *result; // eax@3

  v4 = *(void **)(a2 + 4);
  v5 = *(_DWORD *)a2;
  if ( v4 && ((v5 + a1 + 64) & 0xFFFFFFC0) <= ((v5 + 64) & 0xFFFFFFC0)
    || (result = sub_10011870(a3, v4, (unsigned int)(v5 + a1 + 64) >> 6 << 7), (*(_DWORD *)(a2 + 4) = result) != 0) )
  {
    memcpy((void *)(*(_DWORD *)(a2 + 4) + 2 * *(_DWORD *)a2), a4, 2 * a1);
    *(_DWORD *)a2 += a1;
    *(_WORD *)(*(_DWORD *)(a2 + 4) + 2 * *(_DWORD *)a2) = 0;
    result = (void *)1;
  }
  return result;
}

//----- (1001B360) --------------------------------------------------------
signed int __usercall sub_1001B360@<eax>(unsigned int a1@<edx>, _BYTE *a2@<edi>)
{
  signed int result; // eax@1
  unsigned int v3; // ecx@2
  signed int i; // esi@2
  int v5; // ecx@4

  result = 1;
  if ( a1 >= 0x80 )
  {
    v3 = a1 >> 11;
    for ( i = 2; v3; ++i )
      v3 >>= 5;
    v5 = i - 1;
    if ( i != 1 )
    {
      do
      {
        a2[v5] = a1 & 0x3F | 0x80;
        a1 >>= 6;
        --v5;
      }
      while ( v5 );
    }
    LOBYTE(a1) = a1 - (1 << (8 - i));
    result = i;
  }
  *a2 = a1;
  return result;
}

//----- (1001B3B0) --------------------------------------------------------
unsigned int __usercall sub_1001B3B0@<eax>(int a1@<eax>, _BYTE *a2@<edx>)
{
  int v2; // esi@1
  unsigned int result; // eax@2
  unsigned int v4; // edi@3
  _BYTE *v5; // edx@3
  int i; // esi@3

  v2 = a1;
  if ( a1 == 1 )
  {
    result = *a2;
  }
  else
  {
    v4 = dword_100CEFCC[a1];
    result = *a2 & ((1 << (7 - a1)) - 1);
    v5 = a2 + 1;
    for ( i = v2 - 1; i; --i )
      result = *v5++ & 0x3F | (result << 6);
    if ( result < v4 || result == 65534 || result == 0xFFFF )
      result = 65533;
  }
  return result;
}
// 100CEFCC: using guessed type int dword_100CEFCC[];

//----- (1001B420) --------------------------------------------------------
void *__cdecl sub_1001B420(unsigned int a1)
{
  void *result; // eax@2
  _BYTE *v2; // eax@3

  if ( !(*(_DWORD *)a1 & 0x40000000) || (result = sub_1001A220(0, a1)) != 0 )
  {
    v2 = (_BYTE *)sub_1003A730(a1);
    *v2 &= 0xFDu;
    result = *(void **)(a1 + 4);
  }
  return result;
}

//----- (1001B450) --------------------------------------------------------
void *__cdecl sub_1001B450(int a1, int a2, void *a3)
{
  unsigned int v3; // eax@1
  int v4; // edx@2
  int v5; // ebx@2
  unsigned int v6; // eax@3
  unsigned int v8; // esi@13
  unsigned int v9; // ebp@14
  void *v10; // edi@14
  unsigned int v11; // eax@15
  unsigned int v12; // eax@18
  int v13; // ecx@23
  unsigned int v14; // eax@24
  int v15; // ebx@33
  void *v16; // eax@36
  char *v17; // [sp+8h] [bp-8h]@5
  int v18; // [sp+Ch] [bp-4h]@17
  void *v19; // [sp+1Ch] [bp+Ch]@14
  void *v20; // [sp+1Ch] [bp+Ch]@17

  v3 = *(_DWORD *)a3;
  if ( !(*(_DWORD *)a3 & 0x40000000) )
  {
    v5 = *(_DWORD *)a3;
    v6 = *((_DWORD *)a3 + 1);
    goto LABEL_8;
  }
  v4 = *((_DWORD *)a3 + 1);
  v5 = v3 & ((v3 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( *(_DWORD *)v4 & 0x40000000 )
  {
    v6 = sub_1001A200((int)a3);
LABEL_8:
    v17 = (char *)v6;
    goto LABEL_9;
  }
  if ( v3 & 0x80000000 )
    v17 = *(char **)(v4 + 4);
  else
    v17 = (char *)(*(_DWORD *)(v4 + 4) + 2 * ((v3 >> 15) & 0x7FFF));
LABEL_9:
  if ( !v5 )
    return (void *)a2;
  if ( *(_DWORD *)a2 & 0x40000000 || !(*(_BYTE *)sub_1003A730(a2) & 2) )
  {
    v12 = *(_DWORD *)a2;
    v8 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 & 0x40000000 )
      v8 = v12 & ((v8 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    if ( !v8 )
      return a3;
    if ( *(_DWORD *)a2 & 0x40000000 )
    {
      v13 = *(_DWORD *)(a2 + 4);
      if ( !(*(_DWORD *)v13 & 0x40000000) )
      {
        if ( (v12 & 0x80000000) == 0 )
          v20 = (void *)(*(_DWORD *)(v13 + 4) + 2 * ((v12 >> 15) & 0x7FFF));
        else
          v20 = *(void **)(v13 + 4);
LABEL_30:
        v9 = v8 + v5;
        v10 = (void *)sub_10011830(a1, 2 * (v8 + v5) + 2);
        if ( v10 )
        {
          memcpy(v10, v20, 2 * v8);
          v18 = 0;
          goto LABEL_33;
        }
        return 0;
      }
      v14 = sub_1001A200(a2);
    }
    else
    {
      v14 = *(_DWORD *)(a2 + 4);
    }
    v20 = (void *)v14;
    goto LABEL_30;
  }
  v8 = *(_DWORD *)a2;
  if ( !*(_DWORD *)a2 )
    return a3;
  v9 = v8 + v5;
  v19 = *(void **)(a2 + 4);
  v10 = sub_10011870(a1, v19, 2 * (v8 + v5) + 2);
  if ( !v10 )
    return 0;
  v11 = (v17 - (_BYTE *)v19) >> 1;
  if ( v11 < v8 )
    v17 = (char *)v10 + 2 * v11;
  v20 = v10;
  *(_DWORD *)(a2 + 4) = v10;
  v18 = a2;
LABEL_33:
  memcpy((char *)v10 + 2 * v8, v17, 2 * v5);
  *((_WORD *)v10 + v9) = 0;
  v15 = sub_1001AB10(a1, (int)v10, v9, 2);
  if ( v15 )
  {
    if ( v18 )
    {
      *(_DWORD *)v18 = v8 | 0xC0000000;
      *(_DWORD *)(v18 + 4) = v15;
    }
  }
  else
  {
    if ( !v18 )
    {
      sub_10010340(a1, (unsigned int)v10);
      return 0;
    }
    v16 = sub_10011870(a1, v20, 2 * v8 + 2);
    if ( v16 )
    {
      *(_DWORD *)(a2 + 4) = v16;
      return 0;
    }
  }
  return (void *)v15;
}

//----- (1001B690) --------------------------------------------------------
int __cdecl sub_1001B690(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  int result; // eax@7
  int v6; // esi@8
  unsigned int v7; // eax@9
  int v8; // ecx@10
  unsigned int v9; // eax@11
  int v10; // esi@17
  int v11; // edi@17
  unsigned int v12; // ebx@19
  unsigned int v13; // ecx@19
  unsigned __int16 v14; // ax@20
  unsigned __int16 *v15; // eax@28
  unsigned int v16; // ebp@28
  unsigned int v17; // esi@29
  unsigned __int16 v18; // cx@30
  __int16 v19; // dx@36
  int v20; // eax@37
  __int16 v21; // dx@37
  _WORD *v22; // eax@38
  int v23; // eax@41
  signed int v24; // [sp+8h] [bp-34h]@1
  int v25; // [sp+Ch] [bp-30h]@13
  int v26; // [sp+14h] [bp-28h]@19
  double v27; // [sp+20h] [bp-1Ch]@2
  char v28; // [sp+28h] [bp-14h]@1
  char v29; // [sp+29h] [bp-13h]@1
  char v30; // [sp+2Ah] [bp-12h]@1
  char v31; // [sp+2Bh] [bp-11h]@1
  char v32; // [sp+2Ch] [bp-10h]@1
  char v33; // [sp+2Dh] [bp-Fh]@1
  char v34; // [sp+2Eh] [bp-Eh]@1
  char v35; // [sp+2Fh] [bp-Dh]@1
  char v36; // [sp+30h] [bp-Ch]@1
  char v37; // [sp+31h] [bp-Bh]@1
  char v38; // [sp+32h] [bp-Ah]@1
  char v39; // [sp+33h] [bp-9h]@1
  char v40; // [sp+34h] [bp-8h]@1
  char v41; // [sp+35h] [bp-7h]@1
  char v42; // [sp+36h] [bp-6h]@1
  char v43; // [sp+37h] [bp-5h]@1

  v28 = 48;
  v29 = 49;
  v30 = 50;
  v31 = 51;
  v32 = 52;
  v33 = 53;
  v34 = 54;
  v35 = 55;
  v36 = 56;
  v37 = 57;
  v38 = 65;
  v39 = 66;
  v40 = 67;
  v41 = 68;
  v42 = 69;
  v43 = 70;
  v24 = 7;
  if ( a3 > 1 )
  {
    if ( !sub_10020030(a1, *(_DWORD *)(a4 + 4), &v27) )
      return 0;
    if ( (HIDWORD(v27) & 0x7FF00000) == 2146435072
      || (v24 = (signed int)v27, (double)(signed int)v27 != v27)
      || v24 & 0xFFFFFFF8 )
    {
      sub_10050B00((int)&v28, 12, (char *)&unk_100CEFE8, v24);
      sub_100110F0(a1, (int)sub_1003ED50, 0, 61, (unsigned int)&v28);
      return 0;
    }
  }
  result = sub_1001ACB0(a1, *(_DWORD *)a4);
  v6 = result;
  if ( !result )
    return result;
  *(_DWORD *)a4 = result | 4;
  v7 = *(_DWORD *)result;
  if ( *(_DWORD *)v6 & 0x40000000 )
  {
    v8 = *(_DWORD *)(v6 + 4);
    if ( !(*(_DWORD *)v8 & 0x40000000) )
    {
      if ( (v7 & 0x80000000) == 0 )
        v25 = *(_DWORD *)(v8 + 4) + 2 * ((v7 >> 15) & 0x7FFF);
      else
        v25 = *(_DWORD *)(v8 + 4);
      goto LABEL_17;
    }
    v9 = sub_1001A200(v6);
  }
  else
  {
    v9 = *(_DWORD *)(v6 + 4);
  }
  v25 = v9;
LABEL_17:
  v10 = *(_DWORD *)v6;
  v11 = v10;
  if ( v10 & 0x40000000 )
    v11 = v10 & ((v10 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  v12 = v11;
  v13 = 0;
  v26 = v11;
  if ( v11 )
  {
    do
    {
      v14 = *(_WORD *)(v25 + 2 * v13);
      if ( v14 >= 0x80u || !((unsigned __int8)v24 & (unsigned __int8)byte_100CC948[(unsigned __int8)v14]) )
      {
        if ( v14 >= 0x100u )
        {
          v11 += 5;
        }
        else if ( v24 != 2 || v14 != 32 )
        {
          v11 += 2;
        }
      }
      ++v13;
    }
    while ( v13 < v12 );
  }
  v15 = (unsigned __int16 *)sub_10011830(a1, 2 * v11 + 2);
  v16 = (unsigned int)v15;
  if ( !v15 )
    return 0;
  v17 = 0;
  if ( v12 )
  {
    while ( 1 )
    {
      v18 = *(_WORD *)(v25 + 2 * v17);
      if ( v18 < 0x80u )
      {
        v12 = v26;
        if ( (unsigned __int8)v24 & (unsigned __int8)byte_100CC948[(unsigned __int8)v18] )
          goto LABEL_39;
      }
      if ( v18 >= 0x100u )
        break;
      if ( v24 != 2 || v18 != 32 )
      {
        v19 = (unsigned __int8)*(&v28 + ((unsigned int)v18 >> 4));
        *v15 = 37;
LABEL_38:
        v22 = v15 + 1;
        *v22 = v19;
        v15 = v22 + 1;
        v18 = (unsigned __int8)*(&v28 + (v18 & 0xF));
LABEL_39:
        *v15 = v18;
        goto LABEL_40;
      }
      *v15 = 43;
LABEL_40:
      ++v17;
      ++v15;
      if ( v17 >= v12 )
        goto LABEL_41;
    }
    *v15 = 37;
    v20 = (int)(v15 + 1);
    v21 = (unsigned __int8)*(&v28 + ((unsigned int)v18 >> 12));
    *(_WORD *)v20 = 117;
    *(_WORD *)(v20 + 2) = v21;
    v15 = (unsigned __int16 *)(v20 + 4);
    *v15 = (unsigned __int8)*(&v28 + (((unsigned int)v18 >> 8) & 0xF));
    v19 = (unsigned __int8)*(&v28 + (((unsigned int)v18 >> 4) & 0xF));
    goto LABEL_38;
  }
LABEL_41:
  *(_WORD *)(v16 + 2 * v11) = 0;
  v23 = sub_1001AB10(a1, v16, v11, 0);
  if ( !v23 )
  {
    sub_10010340(a1, v16);
    return 0;
  }
  *a5 = v23 | 4;
  return 1;
}

//----- (1001B9E0) --------------------------------------------------------
int __cdecl sub_1001B9E0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@1
  int v6; // esi@1
  unsigned int v7; // eax@2
  int v8; // ecx@3
  unsigned int v9; // ebx@4
  unsigned int v10; // esi@9
  int v11; // ebp@9
  int v12; // esi@12
  unsigned int v13; // edi@13
  signed int v14; // eax@14
  _WORD *v15; // ebp@14
  int v16; // esi@16
  unsigned int v17; // eax@16
  unsigned __int16 v18; // ax@18
  unsigned __int16 v19; // ax@20
  int v20; // esi@23
  int v21; // eax@26
  unsigned __int16 v22; // ax@31
  int v23; // esi@40
  int v24; // eax@43
  int v25; // ebp@46
  int v26; // eax@49
  int v27; // eax@54
  _WORD *v28; // [sp+8h] [bp-24h]@14
  _WORD *v29; // [sp+Ch] [bp-20h]@14
  unsigned int v30; // [sp+10h] [bp-1Ch]@14
  signed int v31; // [sp+14h] [bp-18h]@16
  unsigned int v32; // [sp+18h] [bp-14h]@10
  _WORD *v33; // [sp+1Ch] [bp-10h]@16
  int v34; // [sp+20h] [bp-Ch]@13
  int v35; // [sp+24h] [bp-8h]@45
  int v36; // [sp+28h] [bp-4h]@12

  result = sub_1001ACB0(a1, *a4);
  v6 = result;
  if ( result )
  {
    *a4 = result | 4;
    v7 = *(_DWORD *)result;
    if ( *(_DWORD *)v6 & 0x40000000 )
    {
      v8 = *(_DWORD *)(v6 + 4);
      if ( *(_DWORD *)v8 & 0x40000000 )
        v9 = sub_1001A200(v6);
      else
        v9 = (v7 & 0x80000000) == 0 ? *(_DWORD *)(v8 + 4) + 2 * ((v7 >> 15) & 0x7FFF) : *(_DWORD *)(v8 + 4);
    }
    else
    {
      v9 = *(_DWORD *)(v6 + 4);
    }
    v10 = *(_DWORD *)v6;
    v11 = v10;
    if ( v10 & 0x40000000 )
    {
      v11 = v10 & ((v10 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      v32 = v10 & ((v10 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    }
    else
    {
      v32 = v10;
    }
    v12 = sub_10011830(a1, 2 * v11 + 2);
    result = 0;
    v36 = v12;
    if ( v12 )
    {
      v13 = 0;
      v34 = 0;
      if ( v11 )
      {
        v30 = 4;
        v14 = 1;
        v28 = (_WORD *)(v9 + 8);
        v29 = (_WORD *)(v9 + 6);
        v15 = (_WORD *)(v9 + 4);
        while ( 1 )
        {
          LOWORD(v16) = *(_WORD *)(v9 + 2 * v13);
          ++v30;
          ++v29;
          ++v28;
          v17 = v14 + 1;
          ++v15;
          ++v13;
          v31 = v17;
          v33 = v15;
          if ( (_WORD)v16 == 37 )
          {
            if ( v17 < v32
              && (v18 = *(_WORD *)(v9 + 2 * v13), v18 < 0x80u)
              && isxdigit(v18)
              && (v19 = *(_WORD *)(v9 + 2 * v13 + 2), v19 < 0x80u)
              && isxdigit(v19) )
            {
              if ( isdigit(*(_WORD *)(v9 + 2 * v13)) )
                v20 = *(_WORD *)(v9 + 2 * v13) - 48;
              else
                v20 = tolower(*(_WORD *)(v9 + 2 * v13)) - 87;
              if ( isdigit(*(_WORD *)(v9 + 2 * v13 + 2)) )
                v21 = *(_WORD *)(v9 + 2 * v13 + 2) - 48;
              else
                v21 = tolower(*(_WORD *)(v9 + 2 * v13 + 2)) - 87;
              v16 = v21 + 16 * v20;
              v31 += 2;
              v29 += 2;
              v28 += 2;
              v13 += 2;
              v15 += 2;
              v30 += 2;
            }
            else if ( v30 < v32 && *(_WORD *)(v9 + 2 * v13) == 117 )
            {
              v22 = *(_WORD *)(v9 + 2 * v13 + 2);
              if ( v22 < 0x80u
                && isxdigit(v22)
                && *v15 < 0x80u
                && isxdigit(*v15)
                && *v29 < 0x80u
                && isxdigit(*v29)
                && *v28 < 0x80u
                && isxdigit(*v28) )
              {
                if ( isdigit(*(_WORD *)(v9 + 2 * v13 + 2)) )
                  v23 = *(_WORD *)(v9 + 2 * v13 + 2) - 48;
                else
                  v23 = tolower(*(_WORD *)(v9 + 2 * v13 + 2)) - 87;
                if ( isdigit(*v15) )
                  v24 = *v15 - 48;
                else
                  v24 = tolower(*v15) - 87;
                v35 = v24;
                if ( isdigit(*v29) )
                  v25 = *v29 - 48;
                else
                  v25 = tolower(*v29) - 87;
                if ( isdigit(*v28) )
                  v26 = *v28 - 48;
                else
                  v26 = tolower(*v28) - 87;
                v31 += 5;
                v16 = v26 + 16 * (v25 + 16 * (v35 + 16 * v23));
                v29 += 5;
                v28 += 5;
                v15 = v33 + 5;
                v13 += 5;
                v30 += 5;
              }
            }
          }
          *(_WORD *)(v36 + 2 * v34) = v16;
          result = v34++ + 1;
          if ( v13 >= v32 )
            break;
          v14 = v31;
        }
        v12 = v36;
      }
      *(_WORD *)(v12 + 2 * result) = 0;
      v27 = sub_1001AB10(a1, v12, result, 0);
      if ( v27 )
      {
        *a5 = v27 | 4;
        result = 1;
      }
      else
      {
        sub_10010340(a1, v12);
        result = 0;
      }
    }
  }
  return result;
}

//----- (1001BDE0) --------------------------------------------------------
signed int __cdecl sub_1001BDE0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  signed int result; // eax@1

  result = (signed int)sub_1001AD70(a1, *a4);
  if ( result )
  {
    *a5 = result | 4;
    result = 1;
  }
  return result;
}

//----- (1001BE10) --------------------------------------------------------
int *__cdecl sub_1001BE10(int a1, signed int a2, int a3, int *a4)
{
  int *result; // eax@3
  int v5; // ecx@5
  int v6; // eax@5

  if ( a3 & 1 && a3 != -2147483647 )
  {
    result = (int *)sub_1001ACB0(a1, a2);
    if ( !result )
      return result;
    if ( (a3 & 0xFFFFFFFE) == -2 )
    {
      v5 = *result;
      v6 = *result;
      if ( v6 & 0x40000000 )
        v6 = v5 & ((v6 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      *a4 = 2 * v6 | 1;
    }
  }
  return (int *)1;
}

//----- (1001BE80) --------------------------------------------------------
signed int __cdecl sub_1001BE80(int a1, signed int a2, int a3, int a4, int *a5)
{
  int v5; // eax@1
  signed int result; // eax@2
  int v7; // eax@3

  v5 = sub_1001ACB0(a1, a2);
  if ( v5 && (v7 = sub_1004C310(a1, v5, 34)) != 0 )
  {
    *a5 = v7 | 4;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001BEC0) --------------------------------------------------------
unsigned int __cdecl sub_1001BEC0(int a1, int a2, int a3, int *a4, int *a5)
{
  unsigned int result; // eax@3
  int v6; // esi@4
  int v7; // eax@5
  int v8; // ecx@5
  unsigned int v9; // ebx@5
  unsigned int v10; // eax@5
  unsigned int v11; // esi@12
  unsigned int v12; // edi@12
  unsigned int v13; // ebp@14
  int v14; // esi@14
  unsigned int v15; // ecx@17
  unsigned int v16; // eax@19
  int v17; // eax@19
  unsigned int v18; // [sp+10h] [bp-20h]@7
  char v19[16]; // [sp+1Ch] [bp-14h]@5

  if ( !sub_100123C0(a1, a2, (int *)&off_10161AC0, (int)a4) )
    return 0;
  if ( (*(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) & 7) != 4 )
    return sub_10014780(a1, a2, a3, a4, a5);
  v6 = sub_1004C310(a1, *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) & 0xFFFFFFF8, 34);
  if ( !v6 )
    return 0;
  v7 = sub_10050B00((int)v19, 16, "(new %s(", (char)off_10161AC0);
  v8 = *(_DWORD *)(v6 + 4);
  v9 = v7;
  v10 = *(_DWORD *)v6;
  if ( *(_DWORD *)v6 & 0x40000000 )
  {
    if ( *(_DWORD *)v8 & 0x40000000 )
    {
      v18 = sub_1001A200(v6);
    }
    else if ( (v10 & 0x80000000) == 0 )
    {
      v18 = *(_DWORD *)(v8 + 4) + 2 * ((v10 >> 15) & 0x7FFF);
    }
    else
    {
      v18 = *(_DWORD *)(v8 + 4);
    }
  }
  else
  {
    v18 = *(_DWORD *)(v6 + 4);
  }
  v11 = *(_DWORD *)v6;
  v12 = v11;
  if ( v11 & 0x40000000 )
    v12 = v11 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  v13 = v12 + v9 + 2;
  v14 = sub_10011830(a1, 2 * v13 + 2);
  result = 0;
  if ( v14 )
  {
    if ( v9 )
    {
      do
      {
        *(_WORD *)(v14 + 2 * result) = (unsigned __int8)v19[result];
        ++result;
      }
      while ( result < v9 );
    }
    v15 = 0;
    if ( v12 )
    {
      do
        *(_WORD *)(v14 + 2 * result++) = *(_WORD *)(v18 + 2 * v15++);
      while ( v15 < v12 );
    }
    *(_WORD *)(v14 + 2 * result) = 41;
    v16 = result + 1;
    *(_WORD *)(v14 + 2 * v16) = 41;
    *(_WORD *)(v14 + 2 * v16 + 2) = 0;
    v17 = sub_1001AB10(a1, v14, v13, 0);
    if ( !v17 )
    {
      sub_10010340(a1, v14);
      return 0;
    }
    *a5 = v17 | 4;
    result = 1;
  }
  return result;
}
// 10161AC0: using guessed type char *off_10161AC0;
// 1001BEC0: using guessed type char var_14[16];

//----- (1001C0B0) --------------------------------------------------------
int *__cdecl sub_1001C0B0(int a1, signed int a2, int a3, int a4, int *a5)
{
  int v5; // ebx@1
  int *result; // eax@1
  int *v7; // edi@1
  int v8; // eax@2
  int v9; // esi@2
  int v10; // ebp@4
  unsigned int v11; // eax@5
  int v12; // ecx@6
  char *v13; // eax@7
  int v14; // edi@13
  int v15; // ebx@13
  __int16 v16; // cx@15
  int v17; // eax@19
  int v18; // [sp+8h] [bp-4h]@4

  v5 = a1;
  result = (int *)sub_1001ACB0(a1, a2);
  v7 = result;
  if ( result )
  {
    v8 = *result;
    v9 = v8;
    if ( *v7 & 0x40000000 )
      v9 = v8 & ((v8 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v10 = sub_10011830(a1, 2 * v9 + 2);
    v18 = v10;
    if ( !v10 )
      return 0;
    v11 = *v7;
    if ( *v7 & 0x40000000 )
    {
      v12 = v7[1];
      if ( *(_DWORD *)v12 & 0x40000000 )
      {
        v13 = (char *)sub_1001A200((int)v7);
      }
      else if ( (v11 & 0x80000000) == 0 )
      {
        v13 = (char *)(*(_DWORD *)(v12 + 4) + 2 * ((v11 >> 15) & 0x7FFF));
      }
      else
      {
        v13 = *(char **)(v12 + 4);
      }
    }
    else
    {
      v13 = (char *)v7[1];
    }
    if ( v9 )
    {
      v14 = v10 - (_DWORD)v13;
      v15 = v9;
      do
      {
        if ( *(_DWORD *)&dword_100CED28[4
                                      * (unsigned __int8)byte_100CCEA8[*(_WORD *)v13 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*(_WORD *)v13 >> 6] << 6)]] & 0x200000 )
        {
          v10 = v18;
          v16 = *(_WORD *)v13
              + (*(_DWORD *)&dword_100CED28[4
                                          * (unsigned __int8)byte_100CCEA8[*(_WORD *)v13 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*(_WORD *)v13 >> 6] << 6)]] >> 22);
        }
        else
        {
          v16 = *(_WORD *)v13;
        }
        *(_WORD *)&v13[v14] = v16;
        v13 += 2;
        --v15;
      }
      while ( v15 );
      v5 = a1;
    }
    *(_WORD *)(v10 + 2 * v9) = 0;
    v17 = sub_1001AB10(v5, v10, v9, 0);
    if ( !v17 )
    {
      sub_10010340(v5, v10);
      return 0;
    }
    *a5 = v17 | 4;
    result = (int *)1;
  }
  return result;
}

//----- (1001C210) --------------------------------------------------------
int *__cdecl sub_1001C210(int a1, signed int a2, int a3, int a4, int *a5)
{
  int v5; // eax@1
  int *result; // eax@3

  v5 = *(_DWORD *)(a1 + 304);
  if ( v5 && *(_DWORD *)(v5 + 4) )
  {
    result = (int *)sub_1001ACB0(a1, a2);
    if ( result )
      result = (int *)(*(int (__cdecl **)(int, int *, int *))(*(_DWORD *)(a1 + 304) + 4))(a1, result, a5);
  }
  else
  {
    result = sub_1001C0B0(a1, a2, 0, a4, a5);
  }
  return result;
}

//----- (1001C270) --------------------------------------------------------
int *__cdecl sub_1001C270(int a1, signed int a2, int a3, int a4, int *a5)
{
  int v5; // ebp@1
  int *result; // eax@1
  int *v7; // edi@1
  int v8; // eax@2
  int v9; // esi@2
  int v10; // ebx@4
  unsigned int v11; // eax@5
  int v12; // ecx@6
  char *v13; // eax@7
  int v14; // edx@13
  int v15; // edi@13
  unsigned int v16; // ecx@14
  int v17; // eax@18
  int v18; // [sp+8h] [bp-4h]@4

  v5 = a1;
  result = (int *)sub_1001ACB0(a1, a2);
  v7 = result;
  if ( result )
  {
    v8 = *result;
    v9 = v8;
    if ( *v7 & 0x40000000 )
      v9 = v8 & ((v8 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v10 = sub_10011830(a1, 2 * v9 + 2);
    v18 = v10;
    if ( !v10 )
      return 0;
    v11 = *v7;
    if ( *v7 & 0x40000000 )
    {
      v12 = v7[1];
      if ( *(_DWORD *)v12 & 0x40000000 )
      {
        v13 = (char *)sub_1001A200((int)v7);
      }
      else if ( (v11 & 0x80000000) == 0 )
      {
        v13 = (char *)(*(_DWORD *)(v12 + 4) + 2 * ((v11 >> 15) & 0x7FFF));
      }
      else
      {
        v13 = *(char **)(v12 + 4);
      }
    }
    else
    {
      v13 = (char *)v7[1];
    }
    if ( v9 )
    {
      v14 = v10 - (_DWORD)v13;
      v15 = v9;
      do
      {
        v16 = *(_WORD *)v13;
        if ( *(_DWORD *)&dword_100CED28[4
                                      * (unsigned __int8)byte_100CCEA8[v16 & 0x3F | ((unsigned __int8)byte_100CCAA8[v16 >> 6] << 6)]] & 0x100000 )
        {
          LOWORD(v16) = v16
                      - (*(_DWORD *)&dword_100CED28[4
                                                  * (unsigned __int8)byte_100CCEA8[v16 & 0x3F | ((unsigned __int8)byte_100CCAA8[v16 >> 6] << 6)]] >> 22);
          v10 = v18;
        }
        *(_WORD *)&v13[v14] = v16;
        v13 += 2;
        --v15;
      }
      while ( v15 );
      v5 = a1;
    }
    *(_WORD *)(v10 + 2 * v9) = 0;
    v17 = sub_1001AB10(v5, v10, v9, 0);
    if ( !v17 )
    {
      sub_10010340(v5, v10);
      return 0;
    }
    *a5 = v17 | 4;
    result = (int *)1;
  }
  return result;
}

//----- (1001C3D0) --------------------------------------------------------
int *__cdecl sub_1001C3D0(int a1, signed int a2, int a3, int a4, int *a5)
{
  _DWORD *v5; // eax@1
  int *result; // eax@3

  v5 = *(_DWORD **)(a1 + 304);
  if ( v5 && *v5 )
  {
    result = (int *)sub_1001ACB0(a1, a2);
    if ( result )
      result = (int *)(**(int (__cdecl ***)(int, int *, int *))(a1 + 304))(a1, result, a5);
  }
  else
  {
    result = sub_1001C270(a1, a2, 0, a4, a5);
  }
  return result;
}

//----- (1001C430) --------------------------------------------------------
int __cdecl sub_1001C430(int a1, signed int a2, int a3, signed int *a4, int *a5)
{
  int v5; // edi@1
  int result; // eax@2
  int v7; // eax@5
  int v8; // ecx@6
  int (__cdecl *v9)(int, int, int, int *); // ecx@7

  v5 = sub_1001ACB0(a1, a2);
  if ( !v5 )
    return 0;
  *(a4 - 1) = v5 | 4;
  if ( a3 )
  {
    v7 = sub_1001ACB0(a1, *a4);
    if ( !v7 )
      return 0;
    v8 = *(_DWORD *)(a1 + 304);
    if ( v8 && (v9 = *(int (__cdecl **)(int, int, int, int *))(v8 + 8)) != 0 )
    {
      result = v9(a1, v5, v7, a5);
    }
    else
    {
      *a5 = 2 * sub_1001AEA0(v5, v7) | 1;
      result = 1;
    }
  }
  else
  {
    *a5 = 1;
    result = 1;
  }
  return result;
}

//----- (1001C4D0) --------------------------------------------------------
signed int __cdecl sub_1001C4D0(__int64 a1, int a2, signed int *a3, int *a4)
{
  int v4; // esi@1
  double v6; // st7@4
  unsigned int v7; // ecx@7
  int v8; // eax@7
  int v9; // eax@10
  int v10; // edi@10
  int v11; // ecx@14
  double v12; // [sp+1Ch] [bp-8h]@4

  v4 = sub_1001ACB0(a1, SHIDWORD(a1));
  if ( !v4 )
    return 0;
  *(a3 - 1) = v4 | 4;
  if ( a2 )
  {
    if ( !sub_10020030(a1, *a3, &v12) )
      return 0;
    v6 = sub_1001F900(v12);
    v12 = v6;
    if ( v6 < 0.0 )
      goto LABEL_18;
  }
  else
  {
    v6 = 0.0;
    v12 = 0.0;
  }
  v7 = *(_DWORD *)v4;
  v8 = *(_DWORD *)v4;
  if ( *(_DWORD *)v4 & 0x40000000 )
    v8 = v7 & ((v8 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( (double)(unsigned int)v8 <= v6 )
  {
LABEL_18:
    *a4 = sub_10010160(a1);
    return 1;
  }
  v9 = *(_DWORD *)(v4 + 4);
  v10 = (signed __int64)v6;
  if ( *(_DWORD *)v4 & 0x40000000 )
  {
    if ( *(_DWORD *)v9 & 0x40000000 )
    {
      *a4 = 2 * *(_WORD *)(sub_1001A200(v4) + 2 * v10) | 1;
      return 1;
    }
    if ( (v7 & 0x80000000) == 0 )
      v11 = (v7 >> 15) & 0x7FFF;
    else
      v11 = 0;
    v9 = *(_DWORD *)(v9 + 4) + 2 * v11;
  }
  *a4 = 2 * *(_WORD *)(v9 + 2 * v10) | 1;
  return 1;
}

//----- (1001C630) --------------------------------------------------------
int __cdecl sub_1001C630(int a1, signed int a2, unsigned int a3, int a4, int *a5)
{
  int result; // eax@1
  int v6; // esi@1
  unsigned int v7; // eax@2
  int v8; // ecx@2
  int v9; // esi@9
  int v10; // ebx@9
  int v11; // eax@12
  int v12; // esi@12
  unsigned int v13; // eax@13
  int v14; // ecx@14
  int v15; // ebp@15
  int v16; // eax@21
  int v17; // esi@21
  double v18; // st7@26
  int v19; // edi@27
  int v20; // eax@35
  int v21; // ecx@36
  int v22; // [sp+18h] [bp-14h]@4
  int v23; // [sp+1Ch] [bp-10h]@15
  int v24; // [sp+20h] [bp-Ch]@10
  double v25; // [sp+24h] [bp-8h]@24

  result = sub_1001ACB0(a1, a2);
  v6 = result;
  if ( !result )
    return result;
  *(_DWORD *)(a4 - 4) = result | 4;
  v7 = *(_DWORD *)result;
  v8 = *(_DWORD *)(v6 + 4);
  if ( *(_DWORD *)v6 & 0x40000000 )
  {
    if ( *(_DWORD *)v8 & 0x40000000 )
    {
      v22 = sub_1001A200(v6);
    }
    else if ( (v7 & 0x80000000) == 0 )
    {
      v22 = *(_DWORD *)(v8 + 4) + 2 * ((v7 >> 15) & 0x7FFF);
    }
    else
    {
      v22 = *(_DWORD *)(v8 + 4);
    }
  }
  else
  {
    v22 = *(_DWORD *)(v6 + 4);
  }
  v9 = *(_DWORD *)v6;
  v10 = v9;
  if ( v9 & 0x40000000 )
  {
    v10 = v9 & ((v9 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v24 = v9 & ((v9 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  }
  else
  {
    v24 = v9;
  }
  v11 = sub_1001ACB0(a1, *(_DWORD *)a4);
  v12 = v11;
  if ( !v11 )
    return 0;
  *(_DWORD *)a4 = v11 | 4;
  v13 = *(_DWORD *)v11;
  if ( *(_DWORD *)v12 & 0x40000000 )
  {
    v14 = *(_DWORD *)(v12 + 4);
    if ( *(_DWORD *)v14 & 0x40000000 )
    {
      v15 = sub_1001A200(v12);
      v23 = v15;
      goto LABEL_21;
    }
    if ( (v13 & 0x80000000) == 0 )
      v15 = *(_DWORD *)(v14 + 4) + 2 * ((v13 >> 15) & 0x7FFF);
    else
      v15 = *(_DWORD *)(v14 + 4);
  }
  else
  {
    v15 = *(_DWORD *)(v12 + 4);
  }
  v23 = v15;
LABEL_21:
  v16 = *(_DWORD *)v12;
  v17 = *(_DWORD *)v12;
  if ( v17 & 0x40000000 )
    v17 = v16 & ((v17 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( a3 <= 1 )
    goto LABEL_46;
  if ( !sub_10020030(a1, *(_DWORD *)(a4 + 4), &v25) )
    return 0;
  v18 = sub_1001F900(v25);
  v25 = v18;
  if ( v18 >= 0.0 )
  {
    if ( (double)v24 >= v18 )
      v19 = (signed int)v18;
    else
      v19 = v10;
  }
  else
  {
LABEL_46:
    v19 = 0;
  }
  if ( v17 )
  {
    if ( (unsigned int)(v17 - 2) > 0xFD || v10 < 512 || (v20 = sub_1001A370(v22, v10, v15, v17, v19), v20 == -2) )
    {
      v20 = -1;
      v21 = 0;
      if ( v19 < v10 )
      {
        do
        {
          if ( *(_WORD *)(v22 + 2 * (v21 + v19)) == *(_WORD *)(v23 + 2 * v21) )
          {
            if ( ++v21 == v17 )
            {
              v20 = v19;
              break;
            }
          }
          else
          {
            ++v19;
            v21 = 0;
          }
        }
        while ( v21 + v19 < v10 );
      }
    }
    *a5 = 2 * v20 | 1;
    result = 1;
  }
  else
  {
    *a5 = 2 * v19 | 1;
    result = 1;
  }
  return result;
}

//----- (1001C870) --------------------------------------------------------
int __cdecl sub_1001C870(int a1, signed int a2, unsigned int a3, int a4, int *a5)
{
  int result; // eax@1
  int v6; // esi@1
  unsigned int v7; // eax@2
  int v8; // ecx@2
  int v9; // esi@9
  int v10; // edi@9
  int v11; // eax@11
  int v12; // esi@11
  unsigned int v13; // eax@12
  int v14; // ecx@13
  unsigned int v15; // ebp@14
  int v16; // eax@19
  int v17; // esi@19
  double v18; // st7@27
  int v19; // eax@28
  int v20; // ecx@34
  unsigned int v21; // [sp+18h] [bp-10h]@4
  double v22; // [sp+20h] [bp-8h]@22

  result = sub_1001ACB0(a1, a2);
  v6 = result;
  if ( result )
  {
    *(_DWORD *)(a4 - 4) = result | 4;
    v7 = *(_DWORD *)result;
    v8 = *(_DWORD *)(v6 + 4);
    if ( *(_DWORD *)v6 & 0x40000000 )
    {
      if ( *(_DWORD *)v8 & 0x40000000 )
      {
        v21 = sub_1001A200(v6);
      }
      else if ( (v7 & 0x80000000) == 0 )
      {
        v21 = *(_DWORD *)(v8 + 4) + 2 * ((v7 >> 15) & 0x7FFF);
      }
      else
      {
        v21 = *(_DWORD *)(v8 + 4);
      }
    }
    else
    {
      v21 = *(_DWORD *)(v6 + 4);
    }
    v9 = *(_DWORD *)v6;
    v10 = v9;
    if ( v9 & 0x40000000 )
      v10 = v9 & ((v9 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v11 = sub_1001ACB0(a1, *(_DWORD *)a4);
    v12 = v11;
    if ( !v11 )
      return 0;
    *(_DWORD *)a4 = v11 | 4;
    v13 = *(_DWORD *)v11;
    if ( *(_DWORD *)v12 & 0x40000000 )
    {
      v14 = *(_DWORD *)(v12 + 4);
      if ( *(_DWORD *)v14 & 0x40000000 )
      {
        v15 = sub_1001A200(v12);
      }
      else if ( (v13 & 0x80000000) == 0 )
      {
        v15 = *(_DWORD *)(v14 + 4) + 2 * ((v13 >> 15) & 0x7FFF);
      }
      else
      {
        v15 = *(_DWORD *)(v14 + 4);
      }
    }
    else
    {
      v15 = *(_DWORD *)(v12 + 4);
    }
    v16 = *(_DWORD *)v12;
    v17 = *(_DWORD *)v12;
    if ( v17 & 0x40000000 )
      v17 = v16 & ((v17 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    if ( a3 <= 1 )
      goto LABEL_44;
    if ( !sub_10020030(a1, *(_DWORD *)(a4 + 4), &v22) )
      return 0;
    if ( (HIDWORD(v22) & 0x7FF00000) == 2146435072 && (LODWORD(v22) || HIDWORD(v22) & 0xFFFFF) )
    {
LABEL_44:
      v19 = v10;
    }
    else
    {
      v18 = sub_1001F900(v22);
      v22 = v18;
      if ( v18 >= 0.0 )
      {
        if ( (double)(v10 - v17) >= v18 )
          v19 = (signed int)v18;
        else
          v19 = v10 - v17;
      }
      else
      {
        v19 = 0;
      }
    }
    if ( v17 )
    {
      v20 = 0;
      while ( v19 >= 0 )
      {
        if ( v20 + v19 >= v10 || *(_WORD *)(v21 + 2 * (v20 + v19)) != *(_WORD *)(v15 + 2 * v20) )
        {
          --v19;
          v20 = 0;
        }
        else if ( ++v20 == v17 )
        {
          break;
        }
      }
    }
    *a5 = 2 * v19 | 1;
    result = 1;
  }
  return result;
}

//----- (1001CA80) --------------------------------------------------------
int __usercall sub_1001CA80@<eax>(signed int a1@<eax>, signed int *a2@<ecx>, int a3@<edi>, unsigned int a4, int (__cdecl *a5)(int, int, int), int a6, int *a7)
{
  signed int *v7; // esi@1
  int result; // eax@1
  signed int v9; // eax@2
  int v10; // esi@5
  unsigned int v11; // ebp@5
  int v12; // ebx@6
  int v13; // ebx@13
  int v14; // ecx@15
  signed int v15; // eax@15
  unsigned __int16 **v16; // esi@16
  signed int v17; // eax@18
  unsigned int v18; // ebx@29
  unsigned int v19; // [sp+14h] [bp-10h]@15
  unsigned int *v20; // [sp+18h] [bp-Ch]@1
  int i; // [sp+1Ch] [bp-8h]@31
  unsigned int v22; // [sp+20h] [bp-4h]@5

  v7 = a2;
  result = sub_1001ACB0(a3, a1);
  v20 = (unsigned int *)result;
  if ( !result )
    return result;
  *(v7 - 1) = result | 4;
  *(_DWORD *)(a6 + 8) = result;
  v9 = *v7;
  if ( *v7 & 7
    || !(v9 & 0xFFFFFFF8)
    || (char **)(*(_DWORD *)(*(_DWORD *)((v9 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_10162008 )
  {
    v12 = sub_1001ACB0(a3, *v7);
    if ( !v12 )
      return 0;
    if ( *(_DWORD *)(a6 + 4) >= a4 )
    {
      result = 0;
    }
    else
    {
      *v7 = v12 | 4;
      result = sub_1001ACB0(a3, v7[*(_DWORD *)(a6 + 4)]);
      if ( !result )
        return result;
    }
    v11 = sub_10026830(a3, 0, v12, result, (*(_DWORD *)a6 >> 2) & 1);
    if ( !v11 )
      return 0;
    v22 = 0;
    v10 = 0;
  }
  else
  {
    v10 = v9 & 0xFFFFFFF8;
    v22 = v9 & 0xFFFFFFF8;
    v11 = sub_10010550(a3, v9 & 0xFFFFFFF8);
  }
  v13 = a6;
  *(_DWORD *)(a6 + 12) = v11;
  if ( *(_BYTE *)(v11 + 7) & 2 )
    *(_DWORD *)a6 |= 0x10u;
  v14 = *(_DWORD *)a6;
  v15 = *(_DWORD *)a6 & 3;
  v19 = 0;
  if ( v15 != 2 )
  {
    if ( !(v14 & 0x10) )
    {
      if ( v15 != 1 )
      {
        switch ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a3 + 56) + 44) + 56) + 3) )
        {
          case 7:
          case 8:
          case 0x51:
          case 0x8C:
          case 0x8D:
            v15 = 1;
            break;
          default:
            v15 = 0;
            break;
        }
      }
      v16 = sub_10024C00(a3, v11, (int)v20, (int *)&v19, v15, a7);
      goto LABEL_22;
    }
    if ( v10 )
    {
      v16 = (unsigned __int16 **)sub_100257D0(a3, v10, 0.0);
      if ( !v16 )
        return 0;
    }
    else
    {
      v16 = (unsigned __int16 **)1;
    }
    v18 = *v20;
    if ( *v20 & 0x40000000 )
      v18 = *v20 & ((v18 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    for ( i = 0; v19 <= v18; ++i )
    {
      v16 = sub_10024C00(a3, v11, (int)v20, (int *)&v19, 1, a7);
      if ( !v16 )
        break;
      if ( *a7 != 14 )
        break;
      v16 = (unsigned __int16 **)a5(a3, i, a6);
      if ( !v16 )
        break;
      if ( !*(_DWORD *)(a3 + 220) )
      {
        if ( v19 == v18 )
          goto LABEL_21;
        ++v19;
      }
    }
    goto LABEL_21;
  }
  v16 = sub_10024C00(a3, v11, (int)v20, (int *)&v19, 1, a7);
  if ( v16 )
  {
    if ( *a7 == 14 )
      v17 = 2 * *(_DWORD *)(a3 + 236) | 1;
    else
      v17 = -1;
    *a7 = v17;
  }
LABEL_21:
  v13 = a6;
LABEL_22:
  if ( v22 )
  {
    *(_DWORD *)v13 &= 0xFFFFFFF7;
    result = (int)v16;
  }
  else
  {
    if ( !(*(_BYTE *)v13 & 8) )
    {
      *(_DWORD *)(v13 + 12) = 0;
      sub_100236A0(a3, v11);
    }
    result = (int)v16;
  }
  return result;
}
// 10162008: using guessed type char *off_10162008;

//----- (1001CDC0) --------------------------------------------------------
int __cdecl sub_1001CDC0(int a1, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // esi@1
  unsigned int v5; // eax@2
  char *v7; // eax@5

  v3 = a3;
  v4 = **(_DWORD **)(a3 + 16) & 0xFFFFFFF8;
  if ( !v4 )
  {
    v5 = sub_10017DE0(a1, (const char **)&off_10162958, 0, 0, 0, 0);
    v4 = v5;
    if ( !v5 )
      return 0;
    **(_DWORD **)(v3 + 16) = v5;
  }
  v7 = sub_1001AB60(a1, *(void **)(a1 + 224), *(_DWORD *)(a1 + 220), 0);
  if ( !v7 )
    return 0;
  a3 = (unsigned int)v7 | 4;
  return sub_10016530(a1, v4, 2 * a2 | 1, &a3);
}
// 10162958: using guessed type char *off_10162958;

//----- (1001CE40) --------------------------------------------------------
int __cdecl sub_1001CE40(int a1, signed int a2, unsigned int a3, signed int *a4, int *a5)
{
  signed int *v5; // eax@1
  int result; // eax@1
  int v7; // [sp+8h] [bp-14h]@1
  int v8; // [sp+Ch] [bp-10h]@1
  int *v9; // [sp+18h] [bp-4h]@1

  v5 = a4 + 2;
  v9 = v5;
  v7 = 0;
  v8 = 1;
  *v5 = 0;
  result = sub_1001CA80(a2, a4, a1, a3, sub_1001CDC0, (int)&v7, a5);
  if ( result )
  {
    if ( *v9 )
      *a5 = *v9;
  }
  return result;
}

//----- (1001CEA0) --------------------------------------------------------
int __cdecl sub_1001CEA0(int a1, signed int a2, unsigned int a3, signed int *a4, int *a5)
{
  int v6; // [sp+4h] [bp-10h]@1
  int v7; // [sp+8h] [bp-Ch]@1

  v6 = 2;
  v7 = 1;
  return sub_1001CA80(a2, a4, a1, a3, 0, (int)&v6, a5);
}

//----- (1001CEE0) --------------------------------------------------------
int __usercall sub_1001CEE0@<eax>(int a1@<ebx>, int a2, int *a3)
{
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // ebp@2
  int v6; // ecx@2
  unsigned int v7; // ebp@2
  int result; // eax@2
  unsigned int *v9; // esi@3
  char *v10; // eax@3
  int v11; // esi@4
  unsigned int v12; // eax@5
  char *v13; // esi@5
  unsigned int v14; // edi@5
  void **v15; // ebp@8
  char *v16; // eax@9
  int v17; // ebp@13
  char *v18; // eax@14
  unsigned int v19; // ebp@18
  int v20; // ecx@19
  int *v21; // esi@19
  int v22; // edi@19
  int v23; // ebp@19
  signed int v24; // eax@19
  int *v25; // eax@20
  int v26; // ecx@21
  int v27; // eax@21
  int v28; // ecx@24
  int v29; // eax@25
  int v30; // edi@25
  _WORD *v31; // esi@27
  int *v32; // eax@28
  _WORD *v33; // esi@29
  unsigned int v34; // [sp+Ch] [bp-1Ch]@5
  unsigned int v35; // [sp+10h] [bp-18h]@5
  unsigned int v36; // [sp+14h] [bp-14h]@2
  unsigned int v37; // [sp+18h] [bp-10h]@2
  unsigned int i; // [sp+1Ch] [bp-Ch]@2
  int v39; // [sp+20h] [bp-8h]@2
  int v40; // [sp+24h] [bp-4h]@2

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 16);
  if ( v4 )
  {
    v5 = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4);
    v6 = *(_DWORD *)(a1 + 248);
    v39 = *(_DWORD *)(a1 + 244);
    v7 = v5 & 0xFFFFFF;
    v40 = v6;
    v37 = v7 + 3;
    v36 = v7;
    result = sub_1002F880(a1, v7 + 5, &i);
    if ( !result )
      return result;
    *(_DWORD *)result = v4;
    *(_DWORD *)(result + 4) = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 4) & 0xFFFFFFF8;
    v9 = (unsigned int *)(result + 8);
    v10 = sub_1001AB60(a1, *(void **)(a1 + 224), *(_DWORD *)(a1 + 220), 0);
    if ( v10 )
    {
      *v9 = (unsigned int)v10 | 4;
      v12 = *(_DWORD *)(a1 + 136);
      v13 = (char *)(v9 + 1);
      v14 = 0;
      v35 = *(_DWORD *)(a1 + 136);
      v34 = v12;
      if ( v12 >= 9 )
        v34 = 9;
      if ( v34 <= 0 )
      {
LABEL_12:
        if ( v14 >= v12 )
        {
LABEL_17:
          if ( v14 < v7 )
          {
            v19 = v7 - v14;
            memset32(v13, -2147483647, v19);
            v13 += 4 * v19;
          }
          v20 = a2;
          *(_DWORD *)v13 = 2 * *(_DWORD *)(a1 + 236) | 1;
          v21 = (int *)(v13 + 4);
          *v21 = *(_DWORD *)(v20 + 8) | 4;
          v22 = *(_DWORD *)(a1 + 56);
          v23 = *(_DWORD *)(v22 + 60);
          *(_DWORD *)(v22 + 60) = v21 + 1;
          v11 = sub_1002FC40(a1, v37, 2);
          v24 = *(_DWORD *)(*(_DWORD *)(v22 + 60) - 4);
          *(_DWORD *)(v22 + 60) = v23;
          if ( !v11 )
            goto LABEL_24;
          v25 = (int *)sub_1001ACB0(a1, v24);
          if ( v25 )
          {
            *(_DWORD *)(a2 + 20) = v25;
            v26 = *v25;
            v27 = *v25;
            if ( v27 & 0x40000000 )
              v27 = v26 & ((v27 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
            *a3 = v27;
            goto LABEL_24;
          }
        }
        else
        {
          v17 = 0;
          while ( 1 )
          {
            v18 = sub_1001AB60(
                    a1,
                    *(void **)(*(_DWORD *)(a1 + 216) + v17 + 4),
                    *(_DWORD *)(*(_DWORD *)(a1 + 216) + v17),
                    0);
            if ( !v18 )
              break;
            *(_DWORD *)v13 = (unsigned int)v18 | 4;
            ++v14;
            v13 += 4;
            v17 += 8;
            if ( v14 >= v35 )
            {
              v7 = v36;
              goto LABEL_17;
            }
          }
        }
      }
      else
      {
        v15 = (void **)(a1 + 148);
        while ( 1 )
        {
          v16 = sub_1001AB60(a1, *v15, (int)*(v15 - 1), 0);
          if ( !v16 )
            break;
          *(_DWORD *)v13 = (unsigned int)v16 | 4;
          ++v14;
          v13 += 4;
          v15 += 2;
          if ( v14 >= v34 )
          {
            v12 = v35;
            v7 = v36;
            goto LABEL_12;
          }
        }
      }
    }
    v11 = 0;
LABEL_24:
    sub_1002F930(a1, i);
    v28 = v40;
    *(_DWORD *)(a1 + 244) = v39;
    result = v11;
    *(_DWORD *)(a1 + 248) = v28;
    return result;
  }
  v29 = **(_DWORD **)(a2 + 20);
  v30 = **(_DWORD **)(a2 + 20);
  if ( v29 & 0x40000000 )
    v30 = v29 & ((v30 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  v31 = *(_WORD **)(a2 + 24);
  for ( i = *(_DWORD *)(a2 + 28); v31; v31 = sub_1001B010(v33, 36, i) )
  {
    v32 = sub_1001A470(a1, (unsigned int)v31, v3, &a2);
    if ( v32 )
    {
      v30 += *v32 - a2;
      v33 = &v31[a2];
    }
    else
    {
      v33 = v31 + 1;
    }
  }
  *a3 = v30;
  return 1;
}

//----- (1001D170) --------------------------------------------------------
void *__cdecl sub_1001D170(int a1, int a2, void *a3)
{
  int v3; // edx@1
  int v4; // ebx@1
  unsigned int v5; // eax@1
  bool v6; // zf@1
  char *v7; // ebp@1
  int v8; // ecx@2
  unsigned int v9; // eax@3
  _BYTE *v10; // edi@3
  _WORD *v11; // esi@8
  unsigned int v12; // edx@8
  size_t v13; // ebx@9
  int *v14; // eax@9
  int v15; // edi@10
  _WORD *v16; // esi@10
  int v17; // ebx@14
  int v18; // eax@14
  int v20; // [sp+Ch] [bp-10h]@9
  unsigned int v21; // [sp+10h] [bp-Ch]@8
  int v22; // [sp+14h] [bp-8h]@1
  _BYTE *v23; // [sp+18h] [bp-4h]@8

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)v4;
  v6 = (*(_DWORD *)v4 & 0x40000000) == 0;
  v7 = (char *)a3;
  v22 = *(_DWORD *)(a2 + 20);
  if ( v6 )
  {
    v10 = *(_BYTE **)(v4 + 4);
  }
  else
  {
    v8 = *(_DWORD *)(v4 + 4);
    if ( *(_DWORD *)v8 & 0x40000000 )
    {
      v9 = sub_1001A200(v4);
      v3 = a2;
      v10 = (_BYTE *)v9;
    }
    else if ( (v5 & 0x80000000) == 0 )
    {
      v10 = (_BYTE *)(*(_DWORD *)(v8 + 4) + 2 * ((v5 >> 15) & 0x7FFF));
    }
    else
    {
      v10 = *(_BYTE **)(v8 + 4);
    }
  }
  v11 = *(_WORD **)(v3 + 24);
  v12 = *(_DWORD *)(v3 + 28);
  v23 = v10;
  v21 = v12;
  if ( v11 )
  {
    do
    {
      v13 = 2 * (((char *)v11 - v10) >> 1);
      memcpy(v7, v10, v13);
      v7 += v13;
      v10 = v11;
      v14 = sub_1001A470(a1, (unsigned int)v11, a2, &v20);
      if ( v14 )
      {
        v15 = 2 * *v14;
        memcpy(v7, (const void *)v14[1], 2 * *v14);
        v7 += v15;
        v10 = &v11[v20];
        v16 = &v11[v20];
      }
      else
      {
        v16 = v11 + 1;
      }
      v11 = sub_1001B010(v16, 36, v21);
    }
    while ( v11 );
    v4 = v22;
  }
  v17 = *(_DWORD *)v4;
  v18 = v17;
  if ( v17 & 0x40000000 )
    v18 = v17 & ((v17 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  return memcpy(v7, v10, 2 * (v18 - ((v10 - v23) >> 1)));
}

//----- (1001D290) --------------------------------------------------------
signed int __cdecl sub_1001D290(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  int v7; // ecx@2
  unsigned int v8; // eax@3
  int v9; // eax@8
  signed int v10; // ebp@8
  unsigned int v11; // eax@8
  signed int v12; // ebp@8
  int v13; // ecx@9
  unsigned int v14; // eax@10
  int v15; // ecx@15
  void *v16; // eax@16
  int v17; // edi@16
  char *v18; // eax@17
  int v20; // ecx@22
  size_t v21; // ebp@22
  char *v22; // eax@22
  void *v23; // [sp+10h] [bp-4h]@8

  v3 = a3;
  v4 = *(_DWORD *)(a3 + 44);
  v5 = *(_DWORD *)(a3 + 8);
  v6 = *(_DWORD *)v5;
  if ( *(_DWORD *)v5 & 0x40000000 )
  {
    v7 = *(_DWORD *)(v5 + 4);
    if ( *(_DWORD *)v7 & 0x40000000 )
    {
      v8 = sub_1001A200(*(_DWORD *)(a3 + 8));
    }
    else if ( (v6 & 0x80000000) == 0 )
    {
      v8 = *(_DWORD *)(v7 + 4) + 2 * ((v6 >> 15) & 0x7FFF);
    }
    else
    {
      v8 = *(_DWORD *)(v7 + 4);
    }
  }
  else
  {
    v8 = *(_DWORD *)(v5 + 4);
  }
  v9 = v8 + 2 * v4;
  v10 = *(_DWORD *)(a1 + 224) - v9;
  v23 = (void *)v9;
  v11 = *(_DWORD *)v5;
  v12 = v10 >> 1;
  if ( *(_DWORD *)v5 & 0x40000000 )
  {
    v13 = *(_DWORD *)(v5 + 4);
    if ( *(_DWORD *)v13 & 0x40000000 )
    {
      v14 = sub_1001A200(v5);
    }
    else if ( (v11 & 0x80000000) == 0 )
    {
      v14 = *(_DWORD *)(v13 + 4) + 2 * ((v11 >> 15) & 0x7FFF);
    }
    else
    {
      v14 = *(_DWORD *)(v13 + 4);
    }
  }
  else
  {
    v14 = *(_DWORD *)(v5 + 4);
  }
  v15 = (signed int)(*(_DWORD *)(a1 + 224) - v14) >> 1;
  *(_DWORD *)(v3 + 44) = v15;
  *(_DWORD *)(v3 + 44) = v15 + *(_DWORD *)(a1 + 220);
  if ( !sub_1001CEE0(a1, v3, &a3) )
    return 0;
  v16 = *(void **)(v3 + 32);
  v17 = a3 + v12;
  if ( v16 )
    v18 = (char *)sub_10011870(a1, v16, 2 * (v17 + *(_DWORD *)(v3 + 36)) + 2);
  else
    v18 = (char *)sub_10011830(a1, 2 * v17 + 2);
  if ( !v18 )
  {
    sub_10010340(a1, *(_DWORD *)(v3 + 32));
    *(_DWORD *)(v3 + 32) = 0;
    return 0;
  }
  v20 = *(_DWORD *)(v3 + 40);
  *(_DWORD *)(v3 + 36) += v17;
  v21 = 2 * v12;
  *(_DWORD *)(v3 + 32) = v18;
  v22 = &v18[2 * v20];
  a3 = (int)v22;
  *(_DWORD *)(v3 + 40) = v17 + v20;
  memcpy(v22, v23, v21);
  sub_1001D170(a1, v3, (void *)(a3 + v21));
  return 1;
}

//----- (1001D3F0) --------------------------------------------------------
_WORD *__cdecl sub_1001D3F0(int a1, signed int a2, unsigned int a3, int a4, int *a5)
{
  signed int *v5; // esi@1
  unsigned int v6; // eax@2
  int v7; // esi@2
  _WORD *result; // eax@3
  signed int v9; // ecx@5
  unsigned int v10; // eax@9
  int v11; // ecx@10
  unsigned int v12; // eax@11
  int v13; // ecx@16
  unsigned int v14; // eax@18
  int v15; // ecx@19
  _WORD *v16; // eax@20
  void *v17; // esi@29
  int v18; // esi@32
  int v19; // ebp@33
  void *v20; // eax@33
  int v21; // ebx@35
  int v22; // ebp@36
  unsigned int v23; // ebx@36
  char *v24; // esi@36
  int v25; // eax@40
  int v26; // [sp+Ch] [bp-40h]@32
  int v27; // [sp+10h] [bp-3Ch]@32
  int v28; // [sp+14h] [bp-38h]@5
  int v29; // [sp+18h] [bp-34h]@8
  int v30; // [sp+1Ch] [bp-30h]@39
  unsigned int v31; // [sp+20h] [bp-2Ch]@44
  unsigned int v32; // [sp+24h] [bp-28h]@8
  int v33; // [sp+28h] [bp-24h]@8
  _WORD *v34; // [sp+2Ch] [bp-20h]@25
  unsigned int v35; // [sp+30h] [bp-1Ch]@18
  unsigned int v36; // [sp+34h] [bp-18h]@27
  int v37; // [sp+38h] [bp-14h]@27
  int v38; // [sp+3Ch] [bp-10h]@27
  int v39; // [sp+40h] [bp-Ch]@27
  int v40; // [sp+5Ch] [bp+10h]@27

  v5 = (signed int *)(a4 + 4);
  if ( sub_100101E0(a1, *(_DWORD *)(a4 + 4)) == 2 )
  {
    v6 = *v5 & 0xFFFFFFF8;
    v7 = 0;
  }
  else
  {
    result = sub_10011380(a1, *v5, 3, v5);
    if ( !result )
      return result;
    v7 = *v5 & 0xFFFFFFF8;
    v6 = 0;
  }
  v9 = *(_DWORD *)(a1 + 16);
  v28 = 9;
  if ( !v9 || v9 > 140 )
    v28 = 13;
  v29 = 2;
  v32 = v6;
  v33 = v7;
  if ( v7 )
  {
    v10 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 & 0x40000000 )
    {
      v11 = *(_DWORD *)(v7 + 4);
      if ( *(_DWORD *)v11 & 0x40000000 )
      {
        v12 = sub_1001A200(v7);
      }
      else if ( (v10 & 0x80000000) == 0 )
      {
        v12 = *(_DWORD *)(v11 + 4) + 2 * ((v10 >> 15) & 0x7FFF);
      }
      else
      {
        v12 = *(_DWORD *)(v11 + 4);
      }
    }
    else
    {
      v12 = *(_DWORD *)(v7 + 4);
    }
    v13 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 & 0x40000000 )
      v13 = *(_DWORD *)v7 & ((v13 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v35 = v12 + 2 * v13;
    v14 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 & 0x40000000 )
    {
      v15 = *(_DWORD *)(v7 + 4);
      if ( *(_DWORD *)v15 & 0x40000000 )
      {
        v16 = (_WORD *)sub_1001A200(v7);
      }
      else if ( (v14 & 0x80000000) == 0 )
      {
        v16 = (_WORD *)(*(_DWORD *)(v15 + 4) + 2 * ((v14 >> 15) & 0x7FFF));
      }
      else
      {
        v16 = *(_WORD **)(v15 + 4);
      }
    }
    else
    {
      v16 = *(_WORD **)(v7 + 4);
    }
    v34 = sub_1001B010(v16, 36, v35);
  }
  else
  {
    v35 = 0;
    v34 = 0;
  }
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = sub_1001CA80(a2, (signed int *)a4, a1, a3, sub_1001D290, (int)&v28, a5);
  if ( !v40 )
    return 0;
  v17 = (void *)v36;
  if ( v36 )
  {
LABEL_36:
    v22 = *(_DWORD *)(a1 + 244);
    v23 = v37 + v22;
    v24 = (char *)sub_10011870(a1, v17, 2 * (v37 + v22) + 2);
    if ( v24 )
    {
      memcpy(&v24[2 * v37], *(const void **)(a1 + 248), 2 * v22);
      *(_WORD *)&v24[2 * v23] = 0;
      v25 = sub_1001AB10(a1, (int)v24, v23, 0);
      if ( v25 )
      {
        *a5 = v25 | 4;
        goto LABEL_43;
      }
      sub_10010340(a1, (unsigned int)v24);
    }
    else
    {
      sub_10010340(a1, v36);
    }
    v40 = 0;
    goto LABEL_43;
  }
  if ( v28 & 0x10 || *a5 != 14 )
  {
    *a5 = v30 | 4;
    goto LABEL_43;
  }
  v18 = *(_DWORD *)(a1 + 236);
  v27 = *(_DWORD *)(a1 + 236);
  v40 = sub_1001CEE0(a1, (int)&v28, &v26);
  if ( v40 )
  {
    v19 = v18 + v26;
    v20 = (void *)sub_10011830(a1, 2 * (v18 + v26) + 2);
    v17 = v20;
    if ( !v20 )
    {
      v40 = 0;
      goto LABEL_43;
    }
    v21 = 2 * v27;
    memcpy(v20, *(const void **)(a1 + 240), 2 * v27);
    sub_1001D170(a1, (int)&v28, (char *)v17 + v21);
    v36 = (unsigned int)v17;
    v37 = v19;
    goto LABEL_36;
  }
LABEL_43:
  if ( v28 & 8 )
    sub_100236A0(a1, v31);
  return (_WORD *)v40;
}

//----- (1001D6D0) --------------------------------------------------------
int __cdecl sub_1001D6D0(int a1, signed int a2, unsigned int a3, int a4, int *a5)
{
  int result; // eax@1
  int v6; // esi@1
  int v7; // edi@2
  int v8; // eax@3

  result = sub_1001ACB0(a1, a2);
  v6 = result;
  if ( result )
  {
    v7 = 0;
    *(_DWORD *)(a4 - 4) = result | 4;
    if ( a3 )
    {
      while ( 1 )
      {
        v8 = sub_1001ACB0(a1, *(_DWORD *)(a4 + 4 * v7));
        if ( !v8 )
          break;
        *(_DWORD *)(a4 + 4 * v7) = v8 | 4;
        v6 = (int)sub_1001B450(a1, v6, (void *)v8);
        if ( !v6 )
          break;
        if ( ++v7 >= a3 )
          goto LABEL_6;
      }
      result = 0;
    }
    else
    {
LABEL_6:
      *a5 = v6 | 4;
      result = 1;
    }
  }
  return result;
}

//----- (1001D750) --------------------------------------------------------
unsigned int __usercall sub_1001D750@<eax>(signed int a1@<eax>, int a2, int a3, int a4, void *a5, int a6, int a7)
{
  unsigned int result; // eax@1
  int v8; // ebp@1
  unsigned int v9; // ebx@4
  int v10; // esi@4
  unsigned int v11; // edx@6
  int v12; // eax@6
  _WORD *v13; // edi@8
  int v14; // esi@9
  int v15; // esi@12
  int v16; // esi@12
  unsigned int v17; // eax@13
  int v18; // esi@13
  int v19; // ebx@13
  int v20; // ecx@16
  const void *v21; // eax@17
  int v22; // eax@22
  int v23; // esi@24
  int v24; // esi@24
  unsigned int v25; // eax@24
  int v26; // eax@26
  int v27; // [sp+8h] [bp-Ch]@4
  unsigned int v28; // [sp+Ch] [bp-8h]@6
  unsigned int v29; // [sp+10h] [bp-4h]@8

  result = sub_1001ACB0(a2, a1);
  v8 = result;
  if ( result )
  {
    *(_DWORD *)(a3 - 4) = result | 4;
    if ( !a6 )
      a6 = a4;
    v9 = strlen((const char *)a4);
    v10 = v9 + 2;
    v27 = 0;
    if ( a5 )
    {
      v27 = sub_1001AFC0(a5);
      v10 += v27 + 3;
    }
    v11 = strlen((const char *)a6);
    v28 = v11;
    v12 = *(_DWORD *)v8;
    if ( *(_DWORD *)v8 & 0x40000000 )
      v12 = *(_DWORD *)v8 & ((*(_DWORD *)v8 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v29 = v10 + v11 + v12 + 3;
    v13 = (_WORD *)sub_10011830(a2, 2 * v29 + 2);
    result = 0;
    if ( v13 )
    {
      *v13 = 60;
      v14 = 1;
      if ( v9 )
      {
        do
          v13[v14++] = *(_BYTE *)(result++ + a4);
        while ( result < v9 );
      }
      if ( a5 )
      {
        v13[v14] = 61;
        v15 = v14 + 1;
        v13[v15++] = 34;
        memcpy(&v13[v15], a5, 2 * v27);
        v16 = v27 + v15;
        v13[v16] = 34;
        v14 = v16 + 1;
      }
      v13[v14] = 62;
      v17 = *(_DWORD *)v8;
      v18 = v14 + 1;
      v19 = *(_DWORD *)v8;
      if ( *(_DWORD *)v8 & 0x40000000 )
        v19 = v17 & ((v19 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      if ( *(_DWORD *)v8 & 0x40000000 )
      {
        v20 = *(_DWORD *)(v8 + 4);
        if ( *(_DWORD *)v20 & 0x40000000 )
        {
          v21 = (const void *)sub_1001A200(v8);
        }
        else if ( (v17 & 0x80000000) == 0 )
        {
          v21 = (const void *)(*(_DWORD *)(v20 + 4) + 2 * ((v17 >> 15) & 0x7FFF));
        }
        else
        {
          v21 = *(const void **)(v20 + 4);
        }
      }
      else
      {
        v21 = *(const void **)(v8 + 4);
      }
      memcpy(&v13[v18], v21, 2 * v19);
      v22 = *(_DWORD *)v8;
      if ( *(_DWORD *)v8 & 0x40000000 )
        v22 = *(_DWORD *)v8 & ((v22 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      v23 = v22 + v18;
      v13[v23++] = 60;
      v13[v23] = 47;
      v24 = v23 + 1;
      v25 = 0;
      if ( v28 )
      {
        do
          v13[v24++] = *(_BYTE *)(v25++ + a6);
        while ( v25 < v28 );
      }
      v13[v24] = 62;
      v13[v24 + 1] = 0;
      v26 = sub_1001AB10(a2, (int)v13, v29, 0);
      if ( v26 )
      {
        *(_DWORD *)a7 = v26 | 4;
        result = 1;
      }
      else
      {
        sub_10053E10((unsigned int)v13, dword_10658DEC);
        result = 0;
      }
    }
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1001D9B0) --------------------------------------------------------
int __usercall sub_1001D9B0@<eax>(int a1@<edi>, signed int *a2@<esi>, signed int a3, int a4, int a5, int a6)
{
  int result; // eax@1
  unsigned int v7; // ecx@2
  int v8; // edx@3
  void *v9; // eax@4

  result = sub_1001ACB0(a1, *a2);
  if ( result )
  {
    *a2 = result | 4;
    v7 = *(_DWORD *)result;
    if ( *(_DWORD *)result & 0x40000000 )
    {
      v8 = *(_DWORD *)(result + 4);
      if ( *(_DWORD *)v8 & 0x40000000 )
      {
        v9 = (void *)sub_1001A200(result);
      }
      else if ( (v7 & 0x80000000) == 0 )
      {
        v9 = (void *)(*(_DWORD *)(v8 + 4) + 2 * ((v7 >> 15) & 0x7FFF));
      }
      else
      {
        v9 = *(void **)(v8 + 4);
      }
    }
    else
    {
      v9 = *(void **)(result + 4);
    }
    result = sub_1001D750(a3, a1, (int)a2, a4, v9, a5, a6);
  }
  return result;
}

//----- (1001DA30) --------------------------------------------------------
unsigned int __cdecl sub_1001DA30(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)&unk_100CF000, 0, 0, a5);
}

//----- (1001DA60) --------------------------------------------------------
unsigned int __cdecl sub_1001DA60(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)"i", 0, 0, a5);
}

//----- (1001DA90) --------------------------------------------------------
unsigned int __cdecl sub_1001DA90(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)&unk_100CF004, 0, 0, a5);
}

//----- (1001DAC0) --------------------------------------------------------
int __cdecl sub_1001DAC0(int a1, signed int a2, int a3, signed int *a4, int a5)
{
  return sub_1001D9B0(a1, a4, a2, (int)"font size", (int)"font", a5);
}

//----- (1001DAF0) --------------------------------------------------------
int __cdecl sub_1001DAF0(int a1, signed int a2, int a3, signed int *a4, int a5)
{
  return sub_1001D9B0(a1, a4, a2, (int)"font color", (int)"font", a5);
}

//----- (1001DB20) --------------------------------------------------------
int __cdecl sub_1001DB20(int a1, signed int a2, int a3, signed int *a4, int a5)
{
  return sub_1001D9B0(a1, a4, a2, (int)"a href", (int)"a", a5);
}

//----- (1001DB50) --------------------------------------------------------
int __cdecl sub_1001DB50(int a1, signed int a2, int a3, signed int *a4, int a5)
{
  return sub_1001D9B0(a1, a4, a2, (int)"a name", (int)"a", a5);
}

//----- (1001DB80) --------------------------------------------------------
unsigned int __cdecl sub_1001DB80(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)"strike", 0, 0, a5);
}

//----- (1001DBB0) --------------------------------------------------------
unsigned int __cdecl sub_1001DBB0(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)"small", 0, 0, a5);
}

//----- (1001DBE0) --------------------------------------------------------
unsigned int __cdecl sub_1001DBE0(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)"big", 0, 0, a5);
}

//----- (1001DC10) --------------------------------------------------------
unsigned int __cdecl sub_1001DC10(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)"blink", 0, 0, a5);
}

//----- (1001DC40) --------------------------------------------------------
unsigned int __cdecl sub_1001DC40(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)"sup", 0, 0, a5);
}

//----- (1001DC70) --------------------------------------------------------
unsigned int __cdecl sub_1001DC70(int a1, signed int a2, int a3, int a4, int a5)
{
  return sub_1001D750(a2, a1, a4, (int)"sub", 0, 0, a5);
}

//----- (1001DCA0) --------------------------------------------------------
int __cdecl sub_1001DCA0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@2
  int v6; // eax@5

  if ( a3 )
  {
    result = sub_1001ACB0(a1, *a4);
    if ( !result )
      return result;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480);
  }
  v6 = result | 4;
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1 )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) = v6;
    result = 1;
  }
  else
  {
    *a5 = v6;
    result = 1;
  }
  return result;
}

//----- (1001DD00) --------------------------------------------------------
int __cdecl sub_1001DD00(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  unsigned int v5; // ebx@1
  int result; // eax@1
  int v7; // edi@1
  unsigned int v8; // esi@2
  __int64 v9; // ST04_8@3
  int v10; // eax@5

  v5 = a3;
  result = sub_10011830(a1, 2 * a3 + 2);
  v7 = result;
  if ( result )
  {
    v8 = 0;
    if ( v5 )
    {
      do
      {
        HIDWORD(v9) = *(_DWORD *)(a4 + 4 * v8);
        LODWORD(v9) = a1;
        if ( !sub_10020310(v9, &a3) )
          goto LABEL_6;
        *(_WORD *)(v7 + 2 * v8++) = a3;
      }
      while ( v8 < v5 );
    }
    *(_WORD *)(v7 + 2 * v8) = 0;
    v10 = sub_1001AB10(a1, v7, v5, 0);
    if ( !v10 )
    {
LABEL_6:
      sub_10010340(a1, v7);
      return 0;
    }
    *a5 = v10 | 4;
    result = 1;
  }
  return result;
}

//----- (1001DDA0) --------------------------------------------------------
signed int __cdecl sub_1001DDA0(int a1)
{
  int v1; // ebx@1
  char *v2; // eax@1
  char *v3; // esi@1
  signed int result; // eax@2

  v1 = *(_DWORD *)(a1 + 24);
  v2 = sub_1001AB60(a1, &word_1068B4AC, 0, 32);
  v3 = v2;
  if ( v2 && sub_10038890(a1, (int)v2, 1) )
  {
    *(_DWORD *)(v1 + 480) = v3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1068B4AC: using guessed type __int16 word_1068B4AC;

//----- (1001DDF0) --------------------------------------------------------
char *__cdecl sub_1001DDF0(int a1, unsigned int a2)
{
  char *result; // eax@2

  if ( sub_10011BE0(a1, a2, (const char **)&off_10161A38)
    && (result = sub_10012240(
                   a1,
                   a2,
                   0,
                   (int *)&off_10161AC0,
                   (int)sub_1001DCA0,
                   1,
                   (int *)&off_10161AA0,
                   (const char **)&off_10161B08,
                   0,
                   (const char **)&off_10161CAC)) != 0 )
  {
    *(_DWORD *)(*((_DWORD *)result + 1) + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480) | 4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10161A38: using guessed type char *off_10161A38;
// 10161AA0: using guessed type char *off_10161AA0;
// 10161AC0: using guessed type char *off_10161AC0;
// 10161B08: using guessed type char *off_10161B08;
// 10161CAC: using guessed type char *off_10161CAC;

//----- (1001DE60) --------------------------------------------------------
_DWORD *__cdecl sub_1001DE60(int a1, int a2, unsigned int a3, unsigned int a4, int a5)
{
  _DWORD *result; // eax@2
  unsigned int v6; // eax@10
  int v7; // edx@11
  unsigned int v8; // eax@12

  if ( a4 )
  {
    if ( a3 > 0x7FFF || a3 && a4 > 0x7FFF )
    {
      v6 = *(_DWORD *)a2;
      if ( *(_DWORD *)a2 & 0x40000000 )
      {
        v7 = *(_DWORD *)(a2 + 4);
        if ( *(_DWORD *)v7 & 0x40000000 )
        {
          v8 = sub_1001A200(a2);
        }
        else if ( (v6 & 0x80000000) == 0 )
        {
          v8 = *(_DWORD *)(v7 + 4) + 2 * ((v6 >> 15) & 0x7FFF);
        }
        else
        {
          v8 = *(_DWORD *)(v7 + 4);
        }
      }
      else
      {
        v8 = *(_DWORD *)(a2 + 4);
      }
      result = sub_1001AB60(a1, (void *)(v8 + 2 * a3), a4, a5);
    }
    else
    {
      result = (_DWORD *)sub_1003B230(a1, a5 | 3);
      if ( result )
      {
        if ( a3 )
        {
          *result = a4 | ((a3 | 0x8000) << 15);
          result[1] = a2;
        }
        else
        {
          *result = a4 | 0xC0000000;
          result[1] = a2;
        }
      }
    }
  }
  else
  {
    result = *(_DWORD **)(*(_DWORD *)(a1 + 24) + 480);
  }
  return result;
}

//----- (1001DF40) --------------------------------------------------------
void *__cdecl sub_1001DF40(int a1, void *a2, int a3)
{
  int v3; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // ebx@1
  void *result; // eax@1
  int v7; // esi@1
  void *v8; // edi@2

  v3 = sub_1001AFC0(a2);
  v4 = v3;
  v5 = 2 * v3 + 2;
  result = (void *)sub_10011830(a1, v5);
  v7 = (int)result;
  if ( result )
  {
    memcpy(result, a2, v5);
    v8 = (void *)sub_1001AB10(a1, v7, v4, a3);
    if ( !v8 )
      sub_10010340(a1, v7);
    result = v8;
  }
  return result;
}

//----- (1001DFA0) --------------------------------------------------------
void __cdecl sub_1001DFA0(int a1, unsigned int a2)
{
  sub_1001AC30(*(_DWORD *)(a1 + 24), a2);
}

//----- (1001DFB0) --------------------------------------------------------
void *__usercall sub_1001DFB0@<eax>(_WORD *a1@<edx>, _WORD *a2@<ecx>, int a3, int a4, int *a5)
{
  int v5; // edi@1
  unsigned int v6; // eax@2
  bool v7; // zf@2
  unsigned int v8; // ecx@2
  unsigned int v9; // esi@9
  unsigned int v10; // ebx@9
  int v11; // esi@12
  void *v12; // eax@13
  void *result; // eax@15
  __int16 v14; // di@17
  __int16 v15; // ST10_2@17
  int v16; // esi@23
  __int16 v17; // ax@24
  unsigned int v18; // edx@25
  int v19; // ebx@27
  __int16 v20; // ax@28
  int v21; // [sp+14h] [bp-34h]@10
  int v22; // [sp+18h] [bp-30h]@12
  unsigned int v23; // [sp+1Ch] [bp-2Ch]@4
  int v24; // [sp+20h] [bp-28h]@1
  int v25; // [sp+24h] [bp-24h]@17
  _WORD *v26; // [sp+28h] [bp-20h]@1
  int *v27; // [sp+2Ch] [bp-1Ch]@1
  _WORD *v28; // [sp+30h] [bp-18h]@1
  __int16 v29; // [sp+34h] [bp-14h]@2
  __int16 v30; // [sp+36h] [bp-12h]@28
  __int16 v31; // [sp+38h] [bp-10h]@28
  __int16 v32; // [sp+3Ah] [bp-Eh]@2
  char v33[8]; // [sp+3Ch] [bp-Ch]@27

  v26 = a2;
  v28 = a1;
  v27 = a5;
  v5 = sub_1001AB10(a3, 0, 0, 0);
  v24 = v5;
  if ( !v5 )
    return 0;
  v6 = *(_DWORD *)a4;
  v7 = (*(_DWORD *)a4 & 0x40000000) == 0;
  v8 = *(_DWORD *)(a4 + 4);
  v29 = 37;
  v32 = 0;
  if ( v7 )
  {
    v23 = v8;
  }
  else if ( *(_DWORD *)v8 & 0x40000000 )
  {
    v23 = sub_1001A200(a4);
  }
  else if ( (v6 & 0x80000000) == 0 )
  {
    v23 = *(_DWORD *)(v8 + 4) + 2 * ((v6 >> 15) & 0x7FFF);
  }
  else
  {
    v23 = *(_DWORD *)(v8 + 4);
  }
  v9 = *(_DWORD *)a4;
  v10 = *(_DWORD *)a4;
  if ( *(_DWORD *)a4 & 0x40000000 )
  {
    v10 = v9 & ((v9 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v21 = v9 & ((v9 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  }
  else
  {
    v21 = *(_DWORD *)a4;
  }
  v11 = 0;
  v22 = 0;
  if ( !v10 )
  {
LABEL_13:
    v12 = sub_10011870(a3, *(void **)(v5 + 4), 2 * *(_DWORD *)v5 + 2);
    if ( v12 )
      *(_DWORD *)(v5 + 4) = v12;
    *v27 = v5 | 4;
    return (void *)1;
  }
  while ( 1 )
  {
    v14 = *(_WORD *)(v23 + 2 * v11);
    v15 = *(_WORD *)(v23 + 2 * v11);
    v25 = *(_WORD *)(v23 + 2 * v11);
    if ( !sub_1001AFE0(v26, v15) && (!v28 || !sub_1001AFE0(v28, v14)) )
      break;
    result = sub_1001B2F0(1, v24, a3, &v25);
    if ( !result )
      return result;
LABEL_31:
    if ( ++v22 >= v10 )
    {
      v5 = v24;
      goto LABEL_13;
    }
    v11 = v22;
  }
  if ( (unsigned __int16)v14 >= 0xDC00u && (unsigned __int16)v14 <= 0xDFFFu )
  {
    sub_100110F0(a3, (int)sub_1003ED50, 0, 159, 0);
    return 0;
  }
  if ( (unsigned __int16)(v14 + 10240) > 0x3FFu )
  {
    v18 = (unsigned __int16)v14;
  }
  else
  {
    v16 = v11 + 1;
    v22 = v16;
    if ( v16 == v10 )
    {
      sub_100110F0(a3, (int)sub_1003ED50, 0, 159, 0);
      return 0;
    }
    v17 = *(_WORD *)(v23 + 2 * v16);
    if ( (unsigned __int16)(v17 + 9216) > 0x3FFu )
    {
      sub_100110F0(a3, (int)sub_1003ED50, 0, 159, 0);
      return 0;
    }
    v18 = *(_WORD *)(v23 + 2 * v16) + (((unsigned __int16)v14 - 55287) << 10);
  }
  v19 = 0;
  v25 = sub_1001B360(v18, v33);
  if ( !v25 )
  {
LABEL_30:
    v10 = v21;
    goto LABEL_31;
  }
  while ( 1 )
  {
    v20 = (unsigned __int8)byte_100CEFC0[v33[v19] & 0xF];
    v30 = (unsigned __int8)byte_100CEFC0[(unsigned int)(unsigned __int8)v33[v19] >> 4];
    v31 = v20;
    if ( !sub_1001B2F0(3, v24, a3, &v29) )
      return 0;
    if ( ++v19 >= (unsigned int)v25 )
      goto LABEL_30;
  }
}
// 1001DFB0: using guessed type char var_C[8];

//----- (1001E2B0) --------------------------------------------------------
int __usercall sub_1001E2B0@<eax>(int a1@<edx>, int *a2@<ecx>, char a3@<bpl>, int a4, _WORD *a5)
{
  int v5; // edi@1
  int result; // eax@1
  int v7; // esi@1
  unsigned int v8; // eax@2
  unsigned int v9; // ecx@2
  unsigned int v10; // ebp@4
  unsigned int v11; // ebx@9
  unsigned int v12; // eax@9
  int v13; // ebx@12
  void *v14; // eax@13
  __int16 v15; // cx@17
  int v16; // esi@18
  unsigned __int16 v17; // ax@19
  _WORD *v18; // ebx@19
  unsigned __int16 v19; // ax@21
  int v20; // edi@24
  unsigned int v21; // eax@27
  int v22; // edi@29
  int v23; // ecx@30
  int v24; // esi@36
  int v25; // ebx@37
  _WORD *v26; // esi@37
  unsigned __int16 v27; // ax@38
  int v28; // edi@43
  int v29; // eax@46
  int v30; // edi@48
  int v31; // ecx@49
  unsigned int v32; // eax@52
  __int16 v33; // bp@53
  _WORD *v34; // eax@56
  void *v35; // eax@57
  char v36; // [sp-4h] [bp-40h]@2
  int v37; // [sp+Ch] [bp-30h]@17
  unsigned int v38; // [sp+10h] [bp-2Ch]@4
  int v39; // [sp+14h] [bp-28h]@1
  unsigned int v40; // [sp+18h] [bp-24h]@10
  int v41; // [sp+1Ch] [bp-20h]@1
  int v42; // [sp+20h] [bp-1Ch]@32
  _WORD *v43; // [sp+24h] [bp-18h]@1
  int *v44; // [sp+28h] [bp-14h]@1
  int v45; // [sp+2Ch] [bp-10h]@18
  char v46[8]; // [sp+30h] [bp-Ch]@34

  v5 = a1;
  v39 = a1;
  v43 = a5;
  v44 = a2;
  result = sub_1001AB10(a1, 0, 0, 0);
  v7 = result;
  v41 = result;
  if ( !result )
    return result;
  v8 = *(_DWORD *)a4;
  v9 = *(_DWORD *)(a4 + 4);
  v36 = a3;
  if ( *(_DWORD *)a4 & 0x40000000 )
  {
    if ( *(_DWORD *)v9 & 0x40000000 )
    {
      v10 = sub_1001A200(a4);
      v38 = v10;
    }
    else if ( (v8 & 0x80000000) == 0 )
    {
      v38 = *(_DWORD *)(v9 + 4) + 2 * ((v8 >> 15) & 0x7FFF);
      v10 = v38;
    }
    else
    {
      v38 = *(_DWORD *)(v9 + 4);
      v10 = v38;
    }
  }
  else
  {
    v38 = *(_DWORD *)(a4 + 4);
    v10 = v9;
  }
  v11 = *(_DWORD *)a4;
  v12 = *(_DWORD *)a4;
  if ( *(_DWORD *)a4 & 0x40000000 )
  {
    v12 = v11 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v40 = v11 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  }
  else
  {
    v40 = *(_DWORD *)a4;
  }
  v13 = 0;
  if ( !v12 )
  {
LABEL_13:
    v14 = sub_10011870(v5, *(void **)(v7 + 4), 2 * *(_DWORD *)v7 + 2);
    if ( v14 )
      *(_DWORD *)(v7 + 4) = v14;
    *v44 = v7 | 4;
    return 1;
  }
  while ( 1 )
  {
    v15 = *(_WORD *)(v10 + 2 * v13);
    v37 = *(_WORD *)(v10 + 2 * v13);
    if ( v15 != 37 )
    {
      if ( !sub_1001B2F0(1, v7, v5, &v37) )
        return 0;
      goto LABEL_62;
    }
    v16 = v13 + 2;
    v45 = v13;
    if ( v13 + 2 >= v12 )
      goto LABEL_65;
    v17 = *(_WORD *)(v10 + 2 * v13 + 2);
    v18 = (_WORD *)(v10 + 2 * v13 + 2);
    if ( v17 >= 0x80u )
      goto LABEL_65;
    if ( !isxdigit(v17) )
      goto LABEL_65;
    v19 = *(_WORD *)(v10 + 2 * v16);
    if ( v19 >= 0x80u || !isxdigit(v19) )
      goto LABEL_65;
    if ( isdigit(*v18) )
      v20 = *v18 - 48;
    else
      v20 = tolower(*v18) - 87;
    if ( isdigit(*(_WORD *)(v10 + 2 * v16)) )
      v21 = *(_WORD *)(v10 + 2 * v16) - 48;
    else
      v21 = tolower(*(_WORD *)(v10 + 2 * v16)) - 87;
    v22 = v21 + 16 * v20;
    LOWORD(v21) = v22;
    v13 = v16;
    if ( (char)v22 >= 0 )
      goto LABEL_55;
    v23 = 1;
    if ( !(v22 & 0x40) )
      goto LABEL_64;
    do
      ++v23;
    while ( (128 >> v23) & v22 );
    v42 = v23;
    if ( v23 == 1 )
      goto LABEL_64;
    if ( v23 > 6 )
      goto LABEL_64;
    v46[0] = v22;
    if ( v23 - 1 + v16 + 2 * (v23 - 1) >= v40 )
      goto LABEL_64;
    v37 = 1;
    if ( v23 > 1 )
      break;
LABEL_51:
    v21 = sub_1001B3B0(v23, v46);
    if ( v21 >= 0x10000 )
    {
      v32 = v21 - 0x10000;
      if ( v32 > 0xFFFFF )
        goto LABEL_64;
      v33 = (v32 & 0x3FF) - 9216;
      v37 = (unsigned __int16)v33;
      v42 = (unsigned __int16)((v32 >> 10) - 10240);
      if ( !sub_1001B2F0(1, v41, v39, &v42) )
        return 0;
      goto LABEL_56;
    }
LABEL_55:
    v33 = v21;
    v37 = (unsigned __int16)v21;
LABEL_56:
    v34 = sub_1001AFE0(v43, v33);
    v7 = v41;
    if ( v34 )
      v35 = sub_1001B2F0(v13 - v45 + 1, v41, v39, (void *)(v38 + 2 * v45));
    else
      v35 = sub_1001B2F0(1, v41, v39, &v37);
    if ( !v35 )
      return 0;
    v10 = v38;
LABEL_62:
    v5 = v39;
    if ( ++v13 >= v40 )
      goto LABEL_13;
    v12 = v40;
  }
  v24 = v10 + 2 * v16 + 4;
  while ( 1 )
  {
    v25 = v13 + 1;
    v26 = (_WORD *)(v24 + 2);
    if ( *(_WORD *)(v10 + 2 * v25) != 37 )
      break;
    v27 = *(_WORD *)(v10 + 2 * v25 + 2);
    if ( v27 >= 0x80u || !isxdigit(v27) || *v26 >= 0x80u || !isxdigit(*v26) )
      break;
    v28 = isdigit(*(_WORD *)(v10 + 2 * v25 + 2)) ? *(_WORD *)(v10 + 2 * v25 + 2) - 48 : tolower(*(_WORD *)(v10 + 2 * v25 + 2))
                                                                                      - 87;
    v29 = isdigit(*v26) ? *v26 - 48 : tolower(*v26) - 87;
    v30 = v29 + 16 * v28;
    if ( (v30 & 0xC0) != -128 )
      break;
    v31 = v37;
    v46[v37] = v30;
    v13 = v25 + 2;
    v24 = (int)(v26 + 2);
    v37 = v31 + 1;
    if ( v31 + 1 >= v42 )
    {
      v23 = v42;
      goto LABEL_51;
    }
  }
LABEL_64:
  v5 = v39;
LABEL_65:
  sub_100110F0(v5, (int)sub_1003ED50, 0, 159, v36);
  return 0;
}
// 1001E2B0: could not find valid save-restore pair for ebp
// 1001E2B0: using guessed type char var_C[8];

//----- (1001E710) --------------------------------------------------------
int __usercall sub_1001E710@<eax>(char a1@<bpl>, int a2, int a3, int a4, signed int *a5, int *a6)
{
  int result; // eax@1

  result = sub_1001ACB0(a2, *a5);
  if ( result )
    result = sub_1001E2B0(a2, a6, a1, result, L";/?:@&=+$,#");
  return result;
}
// 100CEF18: using guessed type wchar_t a__[12];

//----- (1001E750) --------------------------------------------------------
int __usercall sub_1001E750@<eax>(char a1@<bpl>, int a2, int a3, int a4, signed int *a5, int *a6)
{
  int result; // eax@1

  result = sub_1001ACB0(a2, *a5);
  if ( result )
    result = sub_1001E2B0(a2, a6, a1, result, &word_1068B4AC);
  return result;
}
// 1068B4AC: using guessed type __int16 word_1068B4AC;

//----- (1001E790) --------------------------------------------------------
void *__cdecl sub_1001E790(int a1, int a2, int a3, signed int *a4, int *a5)
{
  void *result; // eax@1

  result = (void *)sub_1001ACB0(a1, *a4);
  if ( result )
    result = sub_1001DFB0(
               L"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_.!~*'()",
               L";/?:@&=+$,#",
               a1,
               (int)result,
               a5);
  return result;
}
// 100CEF18: using guessed type wchar_t a__[12];
// 100CEF30: using guessed type wchar_t a0123456789ab_1[72];

//----- (1001E7D0) --------------------------------------------------------
void *__cdecl sub_1001E7D0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  void *result; // eax@1

  result = (void *)sub_1001ACB0(a1, *a4);
  if ( result )
    result = sub_1001DFB0(
               0,
               L"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_.!~*'()",
               a1,
               (int)result,
               a5);
  return result;
}
// 100CEF30: using guessed type wchar_t a0123456789ab_1[72];

//----- (1001E810) --------------------------------------------------------
unsigned int *__cdecl sub_1001E810(int a1, signed int a2)
{
  unsigned int *result; // eax@1
  unsigned int v3; // ebp@2
  unsigned int v4; // esi@4
  _DWORD *v5; // eax@7
  unsigned int *v6; // [sp+8h] [bp-4h]@1

  result = (unsigned int *)sub_1001ACB0(a1, a2);
  v6 = result;
  if ( result )
  {
    v3 = *result;
    if ( *result & 0x40000000 )
      v3 = *result & ((*result & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v4 = 0;
    if ( v3 )
    {
      while ( 1 )
      {
        v5 = sub_1001DE60(a1, (int)result, v4, 1u, 0);
        if ( !v5
          || !(*(int (__cdecl **)(int, signed int, unsigned int, unsigned int, _DWORD, _DWORD, signed int, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 12))(
                a1,
                a2,
                2 * v4 | 1,
                (unsigned int)v5 | 4,
                0,
                0,
                7,
                0) )
        {
          break;
        }
        if ( ++v4 >= v3 )
          return (unsigned int *)1;
        result = v6;
      }
      result = 0;
    }
    else
    {
      result = (unsigned int *)1;
    }
  }
  return result;
}

//----- (1001E8C0) --------------------------------------------------------
unsigned int *__cdecl sub_1001E8C0(int a1, signed int a2, signed int a3)
{
  unsigned int *result; // eax@3
  unsigned int v4; // ebx@4
  unsigned int v5; // ecx@4
  _DWORD *v6; // eax@7

  if ( a3 & 1 && a3 != -2147483647 )
  {
    result = (unsigned int *)sub_1001ACB0(a1, a2);
    if ( result )
    {
      v4 = a3 >> 1;
      v5 = *result;
      if ( *result & 0x40000000 )
        v5 = *result & ((*result & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      result = (unsigned int *)(v4 >= v5
                             || (v6 = sub_1001DE60(a1, (int)result, v4, 1u, 0)) != 0
                             && (*(int (__cdecl **)(int, signed int, unsigned int, unsigned int, _DWORD, _DWORD, signed int, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 12))(
                                  a1,
                                  a2,
                                  2 * v4 | 1,
                                  (unsigned int)v6 | 4,
                                  0,
                                  0,
                                  7,
                                  0));
    }
  }
  else
  {
    result = (unsigned int *)1;
  }
  return result;
}

//----- (1001E980) --------------------------------------------------------
signed int __cdecl sub_1001E980(__int64 a1, int a2, int a3, int *a4)
{
  int v4; // eax@1
  int v5; // esi@1
  int v7; // eax@5
  double v8; // st7@7
  double v9; // st6@8
  double v10; // [sp+30h] [bp-18h]@7
  double v11; // [sp+38h] [bp-10h]@4
  double v12; // [sp+40h] [bp-8h]@7

  v4 = sub_1001ACB0(a1, SHIDWORD(a1));
  v5 = v4;
  if ( !v4 )
    return 0;
  *(_DWORD *)(a3 - 4) = v4 | 4;
  if ( a2 )
  {
    if ( sub_10020030(a1, *(_DWORD *)a3, &v11) )
    {
      v7 = *(_DWORD *)v5;
      if ( *(_DWORD *)v5 & 0x40000000 )
        v7 = *(_DWORD *)v5 & ((v7 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      v10 = (double)(unsigned int)v7;
      v8 = sub_1001F900(v11);
      v12 = v8;
      if ( v8 >= 0.0 )
      {
        v9 = v10;
        if ( v10 < v8 )
        {
          v12 = v10;
          v8 = v10;
        }
      }
      else
      {
        v8 = 0.0;
        v12 = 0.0;
        v9 = v10;
      }
      if ( a2 != 1 )
      {
        if ( !sub_10020030(a1, *(_DWORD *)(a3 + 4), &v11) )
          return 0;
        v8 = sub_1001F900(v11);
        if ( v8 >= 0.0 )
        {
          if ( v10 < v8 )
            v8 = v10;
        }
        else
        {
          v8 = 0.0;
        }
        v9 = v12;
        if ( v12 <= v8 )
        {
          v9 = v8;
          v8 = v12;
        }
        else if ( *(_DWORD *)(a1 + 16) == 120 )
        {
          v8 = v12;
        }
      }
      *(_QWORD *)&v12 = (signed __int64)v8;
      v5 = (int)sub_1001DE60(a1, v5, (signed __int64)v8, (signed __int64)(v9 - v8), 0);
      if ( v5 )
        goto LABEL_22;
    }
    return 0;
  }
LABEL_22:
  *a4 = v5 | 4;
  return 1;
}

//----- (1001EB40) --------------------------------------------------------
signed int __cdecl sub_1001EB40(__int64 a1, int a2, signed int *a3, _DWORD *a4)
{
  int v4; // esi@1
  double v6; // st7@4
  int v7; // eax@7
  _DWORD *v8; // eax@10
  double v9; // [sp+1Ch] [bp-8h]@4

  v4 = sub_1001ACB0(a1, SHIDWORD(a1));
  if ( !v4 )
    return 0;
  *(a3 - 1) = v4 | 4;
  if ( !a2 )
  {
    v6 = 0.0;
    v9 = 0.0;
LABEL_7:
    v7 = *(_DWORD *)v4;
    if ( *(_DWORD *)v4 & 0x40000000 )
      v7 = *(_DWORD *)v4 & ((v7 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    if ( (double)(unsigned int)v7 > v6 )
    {
      v8 = sub_1001DE60(a1, v4, (signed __int64)v6, 1u, 0);
      if ( v8 )
      {
        *a4 = (unsigned int)v8 | 4;
        return 1;
      }
      return 0;
    }
    goto LABEL_12;
  }
  if ( !sub_10020030(a1, *a3, &v9) )
    return 0;
  v6 = sub_1001F900(v9);
  v9 = v6;
  if ( v6 >= 0.0 )
    goto LABEL_7;
LABEL_12:
  *a4 = sub_10010180(a1);
  return 1;
}

//----- (1001EC60) --------------------------------------------------------
int __cdecl sub_1001EC60(int a1, signed int a2, unsigned int a3, int a4, int *a5)
{
  int result; // eax@1
  int v6; // ebp@1
  int v7; // eax@2
  signed int v8; // eax@5
  int v9; // eax@9
  unsigned int v10; // ecx@10
  int v11; // edx@10
  int v12; // edx@14
  bool v13; // zf@22
  unsigned int v14; // ecx@27
  unsigned int v15; // eax@27
  int v16; // eax@30
  int *v17; // edi@33
  unsigned int v18; // ebp@33
  unsigned int v19; // ebx@33
  _DWORD *v20; // eax@36
  unsigned int v21; // eax@40
  unsigned int v22; // edi@40
  signed int v23; // ebx@41
  int v24; // ebp@41
  int *v25; // eax@46
  char *v26; // eax@49
  signed int v27; // eax@54
  int v28; // eax@57
  unsigned int v29; // [sp+1Ch] [bp-30h]@24
  unsigned int v30; // [sp+20h] [bp-2Ch]@4
  unsigned int v31; // [sp+24h] [bp-28h]@33
  int v32; // [sp+28h] [bp-24h]@22
  int v33; // [sp+2Ch] [bp-20h]@8
  int i; // [sp+30h] [bp-1Ch]@33
  int v35; // [sp+34h] [bp-18h]@2
  int *v36; // [sp+38h] [bp-14h]@1
  unsigned int v37; // [sp+3Ch] [bp-10h]@11
  unsigned int v38; // [sp+40h] [bp-Ch]@8
  double v39; // [sp+44h] [bp-8h]@25

  result = sub_1001ACB0(a1, a2);
  v6 = result;
  v36 = (int *)result;
  if ( !result )
    return result;
  *(_DWORD *)(a4 - 4) = result | 4;
  v7 = sub_10017DE0(a1, (const char **)&off_10162958, 0, 0, 0, 0);
  v35 = v7;
  if ( !v7 )
    return 0;
  *a5 = v7;
  if ( !a3 )
  {
    v30 = v6 | 4;
    return sub_10010A30(a1, v7, 0);
  }
  v8 = *(_DWORD *)a4;
  if ( *(_DWORD *)a4 & 7
    || !(v8 & 0xFFFFFFF8)
    || (char **)(*(_DWORD *)(*(_DWORD *)((v8 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_10162008 )
  {
    v9 = sub_1001ACB0(a1, *(_DWORD *)a4);
    if ( !v9 )
      return 0;
    *(_DWORD *)a4 = v9 | 4;
    v10 = *(_DWORD *)v9;
    v11 = *(_DWORD *)v9 & 0x40000000;
    v37 = v11 ? v10 & ((v10 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF) : *(_DWORD *)v9;
    if ( v11 )
    {
      v12 = *(_DWORD *)(v9 + 4);
      if ( *(_DWORD *)v12 & 0x40000000 )
        v38 = sub_1001A200(v9);
      else
        v38 = (v10 & 0x80000000) == 0 ? *(_DWORD *)(v12 + 4) + 2 * ((v10 >> 15) & 0x7FFF) : *(_DWORD *)(v12 + 4);
    }
    else
    {
      v38 = *(_DWORD *)(v9 + 4);
    }
    v33 = 0;
  }
  else
  {
    v33 = sub_10010550(a1, v8 & 0xFFFFFFF8);
    v38 = 0;
  }
  if ( a3 <= 1 || (v13 = *(_DWORD *)(a4 + 4) == -2147483647, v32 = 1, v13) )
    v32 = 0;
  v29 = 0;
  if ( !v32 )
    goto LABEL_33;
  if ( !sub_10020030(a1, *(_DWORD *)(a4 + 4), &v39) || !sub_1001F840(a1, v39, &v29) )
    return 0;
  v14 = *(_DWORD *)v6;
  v15 = *(_DWORD *)v6;
  if ( *(_DWORD *)v6 & 0x40000000 )
    v15 = v14 & ((v15 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( v29 > v15 )
  {
    v16 = *(_DWORD *)v6;
    if ( *(_DWORD *)v6 & 0x40000000 )
      v16 = v14 & ((v14 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v29 = v16 + 1;
  }
LABEL_33:
  v31 = 0;
  v17 = v36;
  v18 = 0;
  v19 = sub_1001A770(a1, (int)v36, v33, &v31, (int)&v37);
  for ( i = v19; i >= 0; v19 = i )
  {
    if ( v32 && v18 >= v29 )
      break;
    v20 = sub_1001DE60(a1, (int)v17, v31, v19 - v31, 0);
    if ( !v20 )
      return 0;
    v30 = (unsigned int)v20 | 4;
    if ( !sub_10010A30(a1, v35, v18) )
      return 0;
    v31 = ++v18;
    if ( v33 && v38 )
    {
      v21 = *(_DWORD *)(a1 + 136);
      v22 = 0;
      if ( v21 )
      {
        v23 = -72;
        v24 = a1 + 144;
        do
        {
          if ( v32 && v31 >= v29 )
            break;
          if ( v22 >= v21 )
          {
            v25 = &dword_10161A98;
          }
          else if ( v22 >= 9 )
          {
            v25 = (int *)(v23 + *(_DWORD *)(a1 + 216));
          }
          else
          {
            v25 = (int *)v24;
          }
          v26 = sub_1001AB60(a1, (void *)v25[1], *v25, 0);
          if ( !v26 )
            return 0;
          v30 = (unsigned int)v26 | 4;
          if ( !sub_10010A30(a1, v35, v31) )
            return 0;
          v21 = *(_DWORD *)(a1 + 136);
          ++v31;
          ++v22;
          v24 += 8;
          v23 += 8;
        }
        while ( v22 < v21 );
        v18 = v31;
        v19 = i;
      }
      v17 = v36;
      v38 = 0;
    }
    v27 = *(_DWORD *)(a1 + 16);
    v31 = v19 + v37;
    if ( v27 )
    {
      if ( v27 < 130 && !v32 )
      {
        v28 = *v17;
        if ( *v17 & 0x40000000 )
          v28 = *v17 & ((v28 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        if ( v19 + v37 == v28 )
          break;
      }
    }
    i = sub_1001A770(a1, (int)v17, v33, &v31, (int)&v37);
  }
  return v19 != -2;
}
// 10161A98: using guessed type int dword_10161A98;
// 10162008: using guessed type char *off_10162008;
// 10162958: using guessed type char *off_10162958;

//----- (1001F050) --------------------------------------------------------
signed int __cdecl sub_1001F050(__int64 a1, int a2, int a3, int *a4)
{
  int v4; // esi@1
  int v6; // eax@5
  double v7; // st7@7
  double v8; // st6@7
  double v9; // st5@8
  double v10; // st7@8
  double v11; // st7@16
  double v12; // [sp+30h] [bp-18h]@7
  double v13; // [sp+38h] [bp-10h]@4
  double v14; // [sp+40h] [bp-8h]@7

  v4 = sub_1001ACB0(a1, SHIDWORD(a1));
  if ( !v4 )
    return 0;
  if ( a2 )
  {
    if ( sub_10020030(a1, *(_DWORD *)a3, &v13) )
    {
      v6 = *(_DWORD *)v4;
      if ( *(_DWORD *)v4 & 0x40000000 )
        v6 = *(_DWORD *)v4 & ((v6 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      v14 = (double)(unsigned int)v6;
      v7 = sub_1001F900(v13);
      v12 = v7;
      v8 = 0.0;
      if ( v7 >= 0.0 )
      {
        v8 = v14;
        if ( v14 >= v7 )
        {
          v8 = v7;
          v10 = v14;
        }
        else
        {
          v10 = v14;
          v12 = v14;
        }
      }
      else
      {
        v9 = v7 + v14;
        v10 = v14;
        v12 = v9;
        if ( v9 >= 0.0 )
          v8 = v9;
        else
          v12 = 0.0;
      }
      if ( a2 != 1 )
      {
        if ( !sub_10020030(a1, *(_DWORD *)(a3 + 4), &v13) )
          return 0;
        v11 = sub_1001F900(v13);
        if ( v11 < 0.0 )
          v11 = 0.0;
        v8 = v12;
        v10 = v11 + v12;
        if ( v14 < v10 )
          v10 = v14;
      }
      *(_QWORD *)&v14 = (signed __int64)v8;
      v4 = (int)sub_1001DE60(a1, v4, (signed __int64)v8, (signed __int64)(v10 - v8), 0);
      if ( v4 )
        goto LABEL_21;
    }
    return 0;
  }
LABEL_21:
  *a4 = v4 | 4;
  return 1;
}

//----- (1001F210) --------------------------------------------------------
signed int __cdecl sub_1001F210(__int64 a1, int a2, int a3, int *a4)
{
  int v4; // eax@1
  int v5; // esi@1
  int v7; // eax@5
  double v8; // st7@7
  double v9; // st6@7
  double v10; // st5@8
  double v11; // st7@8
  double v12; // st6@17
  double v13; // st6@17
  double v14; // [sp+30h] [bp-18h]@7
  double v15; // [sp+38h] [bp-10h]@7
  double v16; // [sp+40h] [bp-8h]@4

  v4 = sub_1001ACB0(a1, SHIDWORD(a1));
  v5 = v4;
  if ( !v4 )
    return 0;
  *(_DWORD *)(a3 - 4) = v4 | 4;
  if ( a2 )
  {
    if ( !sub_10020030(a1, *(_DWORD *)a3, &v16) )
      return 0;
    v7 = *(_DWORD *)v5;
    if ( *(_DWORD *)v5 & 0x40000000 )
      v7 = *(_DWORD *)v5 & ((v7 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v14 = (double)(unsigned int)v7;
    v8 = sub_1001F900(v16);
    v15 = v8;
    v9 = 0.0;
    if ( v8 >= 0.0 )
    {
      v9 = v14;
      if ( v14 >= v8 )
      {
        v9 = v8;
        v11 = v14;
      }
      else
      {
        v11 = v14;
        v15 = v14;
      }
    }
    else
    {
      v10 = v8 + v14;
      v11 = v14;
      v15 = v10;
      if ( v10 >= 0.0 )
        v9 = v10;
      else
        v15 = 0.0;
    }
    if ( a2 == 1 )
    {
LABEL_20:
      v5 = (int)sub_1001DE60(a1, v5, (signed __int64)v9, (signed __int64)(v11 - v9), 0);
      if ( v5 )
        goto LABEL_21;
      return 0;
    }
    if ( !sub_10020030(a1, *(_DWORD *)(a3 + 4), &v16) )
      return 0;
    v11 = sub_1001F900(v16);
    if ( v11 >= 0.0 )
    {
      v13 = v14;
      if ( v14 >= v11 )
        goto LABEL_18;
    }
    else
    {
      v12 = v11;
      v11 = 0.0;
      v13 = v12 + v14;
      if ( v13 < 0.0 )
        goto LABEL_18;
    }
    v11 = v13;
LABEL_18:
    v9 = v15;
    if ( v15 > v11 )
      v11 = v15;
    goto LABEL_20;
  }
LABEL_21:
  *a4 = v5 | 4;
  return 1;
}

//----- (1001F400) --------------------------------------------------------
signed int __cdecl sub_1001F400(int a1, int a2, int a3, int a4, int *a5)
{
  signed int v5; // eax@2
  double v6; // st7@4
  int v8; // eax@9
  int v9; // [sp+18h] [bp-60h]@6
  char v10; // [sp+34h] [bp-44h]@9

  if ( !sub_100123C0(a1, a2, (int *)&off_10161D08, a4) )
    return 0;
  v5 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
  if ( v5 & 1 && v5 != -2147483647 )
    v6 = (double)(v5 >> 1);
  else
    v6 = *(double *)(v5 & 0xFFFFFFF8);
  if ( !sub_1003DB50((int)&v9, 26, 0, 0, v6) )
  {
    sub_10011170(a1);
    return 0;
  }
  sub_10050B00((int)&v10, 64, "(new %s(%s))", (char)off_10161D08);
  v8 = sub_10010F20(a1, &v10);
  if ( !v8 )
    return 0;
  *a5 = v8 | 4;
  return 1;
}
// 10161D08: using guessed type char *off_10161D08;

//----- (1001F4E0) --------------------------------------------------------
_BYTE *__usercall sub_1001F4E0@<eax>(int a1@<eax>, int a2@<edx>, signed int a3@<edi>)
{
  unsigned int v3; // ecx@1
  _BYTE *v4; // esi@3

  v3 = a3;
  if ( a3 < 0 )
    v3 = -a3;
  v4 = (_BYTE *)(a2 + a1 - 1);
  *v4 = 0;
  do
  {
    *--v4 = v3 % 0xA + 48;
    v3 /= 0xAu;
  }
  while ( v3 );
  if ( a3 < 0 )
    *--v4 = 45;
  return v4;
}

//----- (1001F520) --------------------------------------------------------
signed int __cdecl sub_1001F520(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  signed int result; // eax@1

  result = sub_100123C0(a1, a2, (int *)&off_10161D08, a4);
  if ( result )
  {
    *a5 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
    result = 1;
  }
  return result;
}
// 10161D08: using guessed type char *off_10161D08;

//----- (1001F560) --------------------------------------------------------
int __cdecl sub_1001F560(int a1)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 24);
  sub_1003A950(*(_DWORD *)(a1 + 24), *(_DWORD *)(v1 + 468));
  sub_1003A950(v1, *(_DWORD *)(v1 + 472));
  sub_1003A950(v1, *(_DWORD *)(v1 + 476));
  result = 0;
  *(_DWORD *)(v1 + 468) = 0;
  *(_DWORD *)(v1 + 472) = 0;
  *(_DWORD *)(v1 + 476) = 0;
  return result;
}

//----- (1001F5B0) --------------------------------------------------------
double *__cdecl sub_1001F5B0(int a1, double a2)
{
  double *result; // eax@1

  result = (double *)sub_1003B230(a1, 2);
  if ( result )
    *result = a2;
  return result;
}

//----- (1001F5D0) --------------------------------------------------------
int __cdecl sub_1001F5D0(int a1, double a2, int a3)
{
  int result; // eax@1

  result = (int)sub_1001F5B0(a1, a2);
  if ( result )
  {
    *(_DWORD *)a3 = result | 2;
    result = 1;
  }
  return result;
}

//----- (1001F600) --------------------------------------------------------
int __cdecl sub_1001F600(int a1, double a2, int a3)
{
  signed int v3; // ecx@4
  int result; // eax@7

  if ( (HIDWORD(a2) & 0x7FF00000) != 2146435072 && (HIDWORD(a2) != 0x80000000 || LODWORD(a2)) )
  {
    v3 = (signed int)a2;
    if ( (double)(signed int)a2 == a2 && (unsigned int)(v3 + 0x3FFFFFFF) <= 0x7FFFFFFE )
    {
      *(_DWORD *)a3 = 2 * v3 | 1;
      return 1;
    }
  }
  result = sub_1001F5D0(a1, a2, a3);
  if ( result )
    return 1;
  return result;
}

//----- (1001F680) --------------------------------------------------------
int __cdecl sub_1001F680(int a1, double a2)
{
  int v2; // esi@1
  int result; // eax@4
  int v4; // [sp+14h] [bp-4h]@2

  v2 = sub_10017C40(a1, (int)&off_10161D08, 0, 0);
  if ( !v2 )
    return 0;
  if ( !sub_1001F600(a1, a2, (int)&v4) )
  {
    *(_DWORD *)(a1 + 92) = 0;
    return 0;
  }
  result = v2;
  *(_DWORD *)(*(_DWORD *)(v2 + 4) + 12) = v4;
  return result;
}
// 10161D08: using guessed type char *off_10161D08;

//----- (1001F6E0) --------------------------------------------------------
int __cdecl sub_1001F6E0(int a1, double a2)
{
  const char *v2; // eax@5
  int v4; // [sp+14h] [bp-20h]@5

  if ( (HIDWORD(a2) & 0x7FF00000) != 2146435072
    && (HIDWORD(a2) != 0x80000000 || LODWORD(a2))
    && (double)(signed int)a2 == a2 )
  {
    v2 = sub_1001F4E0(26, (int)&v4, (signed int)a2);
    return sub_10010F20(a1, v2);
  }
  v2 = (const char *)sub_1003DB50((int)&v4, 26, 0, 0, a2);
  if ( v2 )
    return sub_10010F20(a1, v2);
  sub_10011170(a1);
  return 0;
}

//----- (1001F7A0) --------------------------------------------------------
signed int __cdecl sub_1001F7A0(int a1, long double a2, _DWORD *a3)
{
  double v3; // st7@4
  signed int result; // eax@7
  long double v5; // [sp+0h] [bp-8h]@3

  if ( (HIDWORD(a2) & 0x7FF00000) == 2146435072 || a2 == 0.0 )
  {
    *a3 = 0;
    result = 1;
  }
  else
  {
    v5 = fmod(a2, 4294967296.0);
    if ( v5 < 0.0 )
      v3 = ceil(v5) + 4294967296.0;
    else
      v3 = floor(v5);
    if ( v3 < 2147483648.0 )
    {
      *a3 = (signed int)v3;
      result = 1;
    }
    else
    {
      *a3 = (signed int)(v3 - 4294967296.0);
      result = 1;
    }
  }
  return result;
}

//----- (1001F840) --------------------------------------------------------
signed int __cdecl sub_1001F840(int a1, double a2, _DWORD *a3)
{
  double v3; // st7@3
  signed int v4; // esi@4
  double v5; // st7@5
  double v6; // st7@7
  signed int result; // eax@9

  if ( (HIDWORD(a2) & 0x7FF00000) == 2146435072 || a2 == 0.0 )
  {
    *a3 = 0;
    result = 1;
  }
  else
  {
    v3 = a2;
    if ( a2 >= 0.0 )
    {
      v4 = 0;
    }
    else
    {
      v4 = 1;
      v3 = -a2;
    }
    v5 = floor(v3);
    if ( v4 )
      v5 = -v5;
    v6 = fmod(v5, 4294967296.0);
    if ( v6 < 0.0 )
      v6 = v6 + 4294967296.0;
    result = 1;
    *a3 = (signed __int64)v6;
  }
  return result;
}

//----- (1001F900) --------------------------------------------------------
double __cdecl sub_1001F900(double a1)
{
  double result; // st7@1
  double v2; // st7@7
  signed int v3; // esi@8

  result = 0.0;
  if ( a1 == 0.0 )
    return a1;
  if ( (HIDWORD(a1) & 0x7FF00000) == 2146435072 )
  {
    if ( !LODWORD(a1) && !(HIDWORD(a1) & 0xFFFFF) )
      return a1;
  }
  else
  {
    v2 = a1;
    if ( a1 >= 0.0 )
    {
      v3 = 0;
    }
    else
    {
      v3 = 1;
      v2 = -a1;
    }
    result = floor(v2);
    if ( v3 )
      result = -result;
  }
  return result;
}

//----- (1001F970) --------------------------------------------------------
char *__cdecl sub_1001F970(int a1, _WORD *a2, int a3, double *a4)
{
  _WORD *v4; // ebx@1
  unsigned int v5; // edi@1
  char *result; // eax@2
  char *v7; // esi@2
  int v8; // eax@5
  const char *v9; // ebp@10
  int v10; // edi@10
  double v11; // st7@15
  double *v12; // eax@23
  int v13; // edi@28
  _WORD *v14; // eax@30
  _DWORD *v15; // ecx@32
  const char *v16; // [sp+10h] [bp-40h]@15
  double v17; // [sp+14h] [bp-3Ch]@17
  _WORD *v18; // [sp+1Ch] [bp-34h]@1
  double *v19; // [sp+20h] [bp-30h]@1
  int v20; // [sp+24h] [bp-2Ch]@17
  _DWORD *v21; // [sp+28h] [bp-28h]@1
  char v22; // [sp+2Ch] [bp-24h]@4

  v18 = a2;
  v21 = (_DWORD *)a3;
  v19 = a4;
  v4 = sub_1001B030(a2);
  v5 = sub_1001AFC0(v4);
  if ( v5 < 0x20 )
  {
    v7 = &v22;
  }
  else
  {
    result = (char *)sub_10011830(a1, v5 + 1);
    v7 = result;
    if ( !result )
      return result;
  }
  v8 = 0;
  while ( !(v4[v8] & 0xFF00) )
  {
    v7[v8] = v4[v8];
    if ( ++v8 > v5 )
      goto LABEL_10;
  }
  v7[v8] = 0;
LABEL_10:
  v9 = v7;
  v10 = *v7 == 45;
  if ( *v7 == 45 || *v7 == 43 )
    v9 = v7 + 1;
  if ( !strncmp(v9, "Infinity", 8u) )
  {
    if ( v10 )
    {
      v11 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 472);
      v16 = v9 + 8;
    }
    else
    {
      v11 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 476);
      v16 = v9 + 8;
    }
    goto LABEL_27;
  }
  v11 = sub_1003BE10(v7, &v16, &v20);
  v17 = v11;
  if ( v20 != 2 )
  {
    if ( v20 == 1 )
    {
      if ( dbl_10163450 == v11 )
      {
        v12 = *(double **)(*(_DWORD *)(a1 + 24) + 476);
LABEL_26:
        v11 = *v12;
LABEL_27:
        v17 = v11;
        goto LABEL_28;
      }
      if ( -dbl_10163450 == v11 )
      {
        v12 = *(double **)(*(_DWORD *)(a1 + 24) + 472);
        goto LABEL_26;
      }
    }
LABEL_28:
    v13 = v16 - v7;
    if ( v7 != &v22 )
    {
      sub_10010340(a1, (unsigned int)v7);
      v11 = v17;
    }
    v14 = &v4[v13];
    if ( !v13 )
      v14 = v18;
    v15 = v21;
    *v19 = v11;
    *v15 = v14;
    return (char *)1;
  }
  sub_10011170(a1);
  if ( v7 != &v22 )
    sub_10010340(a1, (unsigned int)v7);
  return 0;
}
// 10163450: using guessed type double dbl_10163450;

//----- (1001FB60) --------------------------------------------------------
signed int __thiscall sub_1001FB60(int this)
{
  _WORD *v1; // edx@2
  signed int result; // eax@3
  int v3; // eax@4
  int v4; // eax@5
  unsigned int v5; // edx@10

  if ( !*(_DWORD *)(this + 8) )
  {
    v1 = *(_WORD **)(this + 12);
    if ( v1 == *(_WORD **)(this + 16) )
      return -1;
    v3 = *v1;
    *(_DWORD *)(this + 12) = v1 + 1;
    if ( (unsigned int)(v3 - 48) > 9 )
    {
      if ( (unsigned int)(v3 - 97) > 0x19 )
        v4 = v3 - 55;
      else
        v4 = v3 - 87;
    }
    else
    {
      v4 = v3 - 48;
    }
    *(_DWORD *)(this + 4) = v4;
    *(_DWORD *)(this + 8) = *(_DWORD *)this >> 1;
  }
  v5 = *(_DWORD *)(this + 8);
  result = (v5 & *(_DWORD *)(this + 4)) != 0;
  *(_DWORD *)(this + 8) = v5 >> 1;
  return result;
}

//----- (1001FBC0) --------------------------------------------------------
signed int __cdecl sub_1001FBC0(int a1, _WORD *a2, int *a3, signed int a4, double *a5)
{
  __int16 *v5; // eax@1
  int v6; // ebx@1
  __int16 v7; // ax@1
  unsigned int v8; // ecx@4
  __int16 v9; // ax@6
  __int16 v10; // ax@13
  double v11; // st7@16
  int v12; // edx@16
  double v13; // st6@16
  unsigned __int16 v14; // ax@17
  unsigned int v15; // eax@18
  int v16; // esi@27
  _BYTE *v17; // edi@27
  int v18; // eax@27
  double v19; // st7@30
  signed int result; // eax@32
  signed int v21; // eax@41
  signed int v22; // esi@43
  int v23; // ecx@44
  signed int v24; // edi@44
  int v25; // ecx@46
  signed int v26; // ebp@46
  double v27; // st4@47
  signed int i; // eax@47
  double v29; // st7@51
  int v30; // [sp+10h] [bp-28h]@16
  int v31; // [sp+14h] [bp-24h]@1
  unsigned int v32; // [sp+18h] [bp-20h]@24
  double v33; // [sp+1Ch] [bp-1Ch]@30
  unsigned int v34; // [sp+24h] [bp-14h]@40
  int v35; // [sp+2Ch] [bp-Ch]@40
  int v36; // [sp+30h] [bp-8h]@40
  int v37; // [sp+34h] [bp-4h]@40

  v5 = sub_1001B030(a2);
  v6 = (int)v5;
  v7 = *v5;
  v31 = v7 == 45;
  if ( v7 == 45 || v7 == 43 )
    v6 += 2;
  v8 = a4;
  if ( a4 )
  {
    if ( a4 != 16 )
      goto LABEL_16;
    if ( *(_WORD *)v6 != 48 )
      goto LABEL_16;
    v10 = *(_WORD *)(v6 + 2);
    if ( v10 != 88 && v10 != 120 )
      goto LABEL_16;
    goto LABEL_15;
  }
  if ( *(_WORD *)v6 != 48 )
  {
    v8 = 10;
    a4 = 10;
    goto LABEL_16;
  }
  v9 = *(_WORD *)(v6 + 2);
  if ( v9 == 88 || v9 == 120 )
  {
    v8 = 16;
    a4 = 16;
LABEL_15:
    v6 += 4;
    goto LABEL_16;
  }
  v8 = 8;
  a4 = 8;
LABEL_16:
  v11 = 0.0;
  v12 = v6;
  v30 = v6;
  v13 = 0.0;
  while ( 1 )
  {
    v14 = *(_WORD *)v6;
    if ( (unsigned __int16)(*(_WORD *)v6 - 48) > 9u )
    {
      if ( (unsigned __int16)(v14 - 97) > 0x19u )
      {
        if ( (unsigned __int16)(v14 - 65) > 0x19u )
          break;
        v15 = v14 - 55;
      }
      else
      {
        v15 = v14 - 87;
      }
    }
    else
    {
      v15 = v14 - 48;
    }
    if ( v15 >= v8 )
      break;
    v32 = v15;
    v13 = v13 * (double)a4 + (double)v15;
    v6 += 2;
  }
  if ( v13 >= 9.007199254740992e15 )
  {
    if ( v8 == 10 )
    {
      v16 = (v6 - v12) >> 1;
      v17 = (_BYTE *)sub_10011830(a1, v16 + 1);
      v18 = 0;
      a4 = 0;
      if ( !v17 )
        return 0;
      if ( v16 )
      {
        do
        {
          v17[v18] = *(_BYTE *)(v30 + 2 * v18);
          ++v18;
        }
        while ( v18 != v16 );
      }
      v17[v16] = 0;
      v19 = sub_1003BE10(v17, &v32, &a4);
      v33 = v19;
      if ( a4 == 2 )
      {
        sub_10011170(a1);
        sub_10010340(a1, (unsigned int)v17);
        return 0;
      }
      if ( a4 == 1 && dbl_10163450 == v19 )
        v33 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 476);
      sub_10010340(a1, (unsigned int)v17);
      v13 = v33;
      v11 = 0.0;
    }
    else if ( !((v8 - 1) & v8) )
    {
      v34 = v8;
      v35 = 0;
      v13 = 0.0;
      v36 = v12;
      v37 = v6;
      do
        v21 = sub_1001FB60((int)&v34);
      while ( !v21 );
      if ( v21 == 1 )
      {
        v22 = 52;
        v13 = 1.0;
        while ( 1 )
        {
          v24 = sub_1001FB60((int)&v34);
          a4 = v24;
          if ( v24 < 0 )
            break;
          --v22;
          v13 = v13 * 2.0 + (double)a4;
          if ( !v22 )
          {
            v26 = sub_1001FB60(v23);
            if ( v26 >= 0 )
            {
              v27 = 2.0;
              for ( i = sub_1001FB60(v25); i >= 0; i = sub_1001FB60((int)&v34) )
              {
                v27 = v27 * 2.0;
                v22 |= i;
              }
              v13 = (v13 + (double)(v26 & (v24 | v22))) * v27;
            }
            break;
          }
        }
      }
    }
  }
  if ( v6 == v30 )
  {
    *a5 = v11;
    *a3 = (int)a2;
    result = 1;
  }
  else
  {
    v29 = v13;
    if ( v31 )
      v29 = -v13;
    *a5 = v29;
    *a3 = v6;
    result = 1;
  }
  return result;
}
// 10163450: using guessed type double dbl_10163450;

//----- (1001FE70) --------------------------------------------------------
int __cdecl sub_1001FE70(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@1
  _WORD *v6; // esi@2
  _WORD *v7; // [sp+14h] [bp-Ch]@3
  double v8; // [sp+18h] [bp-8h]@3

  result = sub_1001ACB0(a1, *a4);
  if ( result )
  {
    v6 = sub_1001A220(a1, result);
    if ( v6 && sub_1001F970(a1, v6, (int)&v7, &v8) )
    {
      if ( v7 == v6 )
      {
        *a5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 468) | 2;
        result = 1;
      }
      else
      {
        result = sub_1001F600(a1, v8, (int)a5);
      }
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1001FF10) --------------------------------------------------------
signed int __cdecl sub_1001FF10(int a1)
{
  int v1; // edi@1
  double *v2; // eax@1
  double *v3; // eax@3
  double *v4; // eax@5
  signed int result; // eax@7

  v1 = *(_DWORD *)(a1 + 24);
  _control87(0x9001Fu, 0xB001Fu);
  dbl_10572680 = 3.595386269724631e308/*NaN*/;
  dbl_10161DB0 = 3.595386269724631e308/*NaN*/;
  v2 = sub_1001F5B0(a1, 3.595386269724631e308/*NaN*/);
  *(_DWORD *)(v1 + 468) = v2;
  if ( v2
    && sub_1003AB40(a1, (unsigned int)v2)
    && (dbl_10161DC0 = 1.797693134862316e308/*+Inf*/,
        v3 = sub_1001F5B0(a1, 1.797693134862316e308/*+Inf*/),
        (*(_DWORD *)(v1 + 476) = v3) != 0)
    && sub_1003AB40(a1, (unsigned int)v3)
    && (dbl_10161DD0 = -1.797693134862316e308/*-Inf*/,
        v4 = sub_1001F5B0(a1, -1.797693134862316e308/*-Inf*/),
        (*(_DWORD *)(v1 + 472) = v4) != 0)
    && sub_1003AB40(a1, (unsigned int)v4) )
  {
    result = 1;
    dbl_10161DF0 = COERCE_DOUBLE(1i64);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10161DB0: using guessed type double dbl_10161DB0;
// 10161DC0: using guessed type double dbl_10161DC0;
// 10161DD0: using guessed type double dbl_10161DD0;
// 10161DF0: using guessed type double dbl_10161DF0;
// 10572680: using guessed type double dbl_10572680;

//----- (10020030) --------------------------------------------------------
_WORD *__cdecl sub_10020030(int a1, signed int a2, double *a3)
{
  signed int v3; // eax@1
  _WORD *result; // eax@3
  signed int v5; // eax@8
  int v6; // ecx@9
  double *v7; // ebp@11
  _DWORD *v8; // edi@12
  _WORD *v9; // esi@12
  _WORD *v10; // [sp+4h] [bp-4h]@13

  v3 = a2;
  if ( !(a2 & 7) )
  {
    if ( !(a2 & 0xFFFFFFF8) )
    {
      *a3 = 0.0;
      return (_WORD *)1;
    }
    result = (_WORD *)(*(int (__cdecl **)(int, unsigned int, signed int, signed int *))(*(_DWORD *)(*(_DWORD *)(a2 & 0xFFFFFFF8)
                                                                                                  + 4)
                                                                                      + 36))(
                        a1,
                        a2 & 0xFFFFFFF8,
                        4,
                        &a2);
    if ( !result )
      return result;
    v3 = a2;
  }
  if ( v3 & 1 && v3 != -2147483647 )
  {
    v5 = v3 >> 1;
    a2 = v5;
    *a3 = (double)v5;
    return (_WORD *)1;
  }
  v6 = v3 & 7;
  if ( v6 == 2 )
  {
    *a3 = *(double *)(v3 & 0xFFFFFFF8);
    return (_WORD *)1;
  }
  v7 = a3;
  if ( v6 == 4 )
  {
    v8 = (_DWORD *)(v3 & 0xFFFFFFF8);
    result = sub_1001A220(a1, v3 & 0xFFFFFFF8);
    v9 = result;
    if ( !result )
      return result;
    if ( sub_1001F970(a1, result, (int)&v10, v7) && sub_1001B030(v10) == &v9[*v8]
      || sub_1001FBC0(a1, v9, (int *)&v10, 0, v7) && sub_1001B030(v10) == &v9[*v8] )
    {
      return (_WORD *)1;
    }
    goto LABEL_17;
  }
  if ( v6 != 6 )
  {
LABEL_17:
    *v7 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
    return (_WORD *)1;
  }
  *a3 = (double)((v3 & 0xFFFFFFF8) != 0);
  return (_WORD *)1;
}

//----- (10020180) --------------------------------------------------------
_WORD *__cdecl sub_10020180(__int64 a1, _DWORD *a2)
{
  _WORD *result; // eax@1
  long double v3; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, SHIDWORD(a1), &v3);
  if ( result )
    result = (_WORD *)sub_1001F7A0(a1, v3, a2);
  return result;
}

//----- (100201D0) --------------------------------------------------------
_WORD *__cdecl sub_100201D0(__int64 a1, _DWORD *a2)
{
  _WORD *result; // eax@1
  double v3; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, SHIDWORD(a1), &v3);
  if ( result )
    result = (_WORD *)sub_1001F840(a1, v3, a2);
  return result;
}

//----- (10020220) --------------------------------------------------------
signed int __cdecl sub_10020220(int a1, signed int a2, signed int *a3)
{
  _BYTE *v4; // eax@11
  char v5; // al@12
  double v6; // [sp+10h] [bp-8h]@4

  if ( a2 & 1 && a2 != -2147483647 )
  {
    *a3 = a2 >> 1;
    return 1;
  }
  if ( sub_10020030(a1, a2, &v6) )
  {
    if ( ((HIDWORD(v6) & 0x7FF00000) != 2146435072 || !LODWORD(v6) && !(HIDWORD(v6) & 0xFFFFF))
      && v6 > -2147483649.0
      && v6 < 2147483648.0 )
    {
      *a3 = (signed int)floor(v6 + 0.5);
      return 1;
    }
    v4 = sub_1004F8E0(a1, 1, a2, 0);
    if ( v4 )
    {
      v5 = (unsigned int)sub_10010FF0((unsigned int)v4);
      sub_100110F0(a1, (int)sub_1003ED50, 0, 35, v5);
    }
  }
  return 0;
}

//----- (10020310) --------------------------------------------------------
_WORD *__cdecl sub_10020310(__int64 a1, _WORD *a2)
{
  _WORD *result; // eax@1
  double v3; // st6@2
  double v4; // st7@6
  signed int v5; // esi@7
  double v6; // st7@8
  double v7; // st7@10
  signed __int64 v8; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, SHIDWORD(a1), (double *)&v8);
  if ( result )
  {
    v3 = *(double *)&v8;
    if ( *(double *)&v8 == 0.0 || (HIDWORD(v8) & 0x7FF00000) == 2146435072 )
    {
      *a2 = 0;
      result = (_WORD *)1;
    }
    else
    {
      v8 = (signed __int64)*(double *)&v8;
      LODWORD(v8) = (signed __int64)v3;
      if ( (double)(unsigned int)v8 == v3 )
      {
        *a2 = (signed __int64)v3;
        result = (_WORD *)1;
      }
      else
      {
        v4 = v3;
        if ( v3 >= 0.0 )
        {
          v5 = 0;
        }
        else
        {
          v5 = 1;
          v4 = -v3;
        }
        v6 = floor(v4);
        if ( v5 )
          v6 = -v6;
        v7 = fmod(v6, 65536.0);
        if ( v7 < 0.0 )
          v7 = v7 + 65536.0;
        result = (_WORD *)1;
        LODWORD(v8) = (signed int)v7;
        *a2 = (signed int)v7;
      }
    }
  }
  return result;
}

//----- (10020450) --------------------------------------------------------
_WORD *__cdecl sub_10020450(int a1, int a2, int a3, signed int *a4, int *a5)
{
  _WORD *result; // eax@1
  int v6; // eax@5
  int v7; // [sp+0h] [bp-8h]@1
  int v8; // [sp+4h] [bp-4h]@2

  result = sub_10020030(a1, *a4, (double *)&v7);
  if ( result )
  {
    v6 = (v8 & 0x7FF00000) == 2146435072 && (v7 || v8 & 0xFFFFF);
    *a5 = 8 * v6 | 6;
    result = (_WORD *)1;
  }
  return result;
}

//----- (100204C0) --------------------------------------------------------
_WORD *__cdecl sub_100204C0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  _WORD *result; // eax@1
  char v6; // [sp+0h] [bp-8h]@1
  int v7; // [sp+4h] [bp-4h]@2

  result = sub_10020030(a1, *a4, (double *)&v6);
  if ( result )
  {
    *a5 = 8 * ((v7 & 0x7FF00000) != 2146435072) | 6;
    result = (_WORD *)1;
  }
  return result;
}

//----- (10020510) --------------------------------------------------------
int __cdecl sub_10020510(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  int v5; // edi@1
  int result; // eax@4
  signed int v7; // ebx@5
  _WORD *v8; // edi@6
  _WORD *v9; // [sp+18h] [bp-Ch]@3
  double v10; // [sp+1Ch] [bp-8h]@7

  v5 = sub_1001ACB0(a1, *(_DWORD *)a4);
  if ( !v5 )
    return 0;
  if ( a3 <= 1 )
  {
    v7 = 0;
  }
  else
  {
    if ( !sub_10020180(__PAIR__(*(_DWORD *)(a4 + 4), a1), &v9) )
      return 0;
    v7 = (signed int)v9;
    if ( v9 && ((signed int)v9 < 2 || (signed int)v9 > 36) )
    {
      *a5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 468) | 2;
      return 1;
    }
  }
  v8 = sub_1001A220(a1, v5);
  if ( !v8 || !sub_1001FBC0(a1, v8, (int *)&v9, v7, &v10) )
    return 0;
  if ( v9 == v8 )
  {
    *a5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 468) | 2;
    result = 1;
  }
  else
  {
    result = sub_1001F600(a1, v10, (int)a5);
  }
  return result;
}

//----- (10020600) --------------------------------------------------------
signed int __cdecl sub_10020600(int a1, int a2, int a3, signed int *a4, int *a5)
{
  signed int result; // eax@3
  double v6; // st7@4
  double v7; // [sp+10h] [bp-8h]@2

  if ( a3 )
  {
    if ( !sub_10020030(a1, *a4, &v7) )
      return 0;
    v6 = v7;
  }
  else
  {
    v6 = 0.0;
  }
  if ( !sub_1001F600(a1, v6, (int)&a3) )
    return 0;
  result = 1;
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1 )
    *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) = a3;
  else
    *a5 = a3;
  return result;
}

//----- (10020680) --------------------------------------------------------
signed int __cdecl sub_10020680(int a1, int a2, int a3, _DWORD *a4, int *a5)
{
  signed int v5; // eax@2
  double v6; // st7@4
  __int64 v7; // ST08_8@7
  char v8; // al@10
  int v10; // esi@13
  const char *v11; // eax@14
  unsigned int v12; // edi@14
  int v13; // [sp+18h] [bp-14h]@6
  double v14; // [sp+1Ch] [bp-10h]@6

  if ( !sub_100123C0(a1, a2, (int *)&off_10161D08, (int)a4) )
    return 0;
  v5 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
  if ( v5 & 1 && v5 != -2147483647 )
    v6 = (double)(v5 >> 1);
  else
    v6 = *(double *)(v5 & 0xFFFFFFF8);
  v14 = v6;
  v13 = 10;
  if ( !a3 )
    goto LABEL_21;
  HIDWORD(v7) = *a4;
  LODWORD(v7) = a1;
  if ( !sub_10020180(v7, &v13) )
    return 0;
  if ( v13 < 2 || v13 > 36 )
  {
    v8 = (unsigned int)sub_1001F4E0(12, (int)&v14, v13);
    sub_100110F0(a1, (int)sub_1003ED50, 0, 33, v8);
    return 0;
  }
  if ( v13 != 10 )
  {
    v11 = sub_1003DDC0(v13, v14);
    v12 = (unsigned int)v11;
    if ( !v11 )
    {
      sub_10011170(a1);
      return 0;
    }
    v10 = sub_10010F20(a1, v11);
    sub_10053E10(v12, dword_10658DEC);
  }
  else
  {
LABEL_21:
    v10 = sub_1001F6E0(a1, v14);
  }
  if ( !v10 )
    return 0;
  *a5 = v10 | 4;
  return 1;
}
// 10161D08: using guessed type char *off_10161D08;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100207E0) --------------------------------------------------------
signed int __cdecl sub_100207E0(int a1, int a2, int a3, _DWORD *a4, int *a5)
{
  return sub_10020680(a1, a2, 0, a4, a5);
}

//----- (100207F0) --------------------------------------------------------
signed int __usercall sub_100207F0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int *a4, int a5, int a6, signed int a7, signed int a8, int a9)
{
  signed int *v9; // ebx@1
  int v10; // esi@1
  signed int v11; // eax@2
  double v12; // st7@4
  signed int v13; // ebx@6
  double v14; // st7@7
  int v15; // esi@7
  const char *v16; // eax@12
  int v17; // eax@13
  int v19; // eax@15
  double v20; // [sp+28h] [bp-A0h]@6
  double v21; // [sp+38h] [bp-90h]@8
  int v22; // [sp+40h] [bp-88h]@12

  v9 = (signed int *)a1;
  v10 = a2;
  if ( sub_100123C0(a3, a2, (int *)&off_10161D08, a1) )
  {
    v11 = *(_DWORD *)(*(_DWORD *)(v10 + 4) + 12);
    if ( v11 & 1 && v11 != -2147483647 )
      v12 = (double)(v11 >> 1);
    else
      v12 = *(double *)(v11 & 0xFFFFFFF8);
    v13 = *v9;
    v20 = v12;
    if ( v13 == -2147483647 )
    {
      v14 = 0.0;
      v15 = a5;
      goto LABEL_12;
    }
    if ( sub_10020030(a3, v13, &v21) )
    {
      v14 = sub_1001F900(v21);
      if ( (double)a7 <= v14 && (double)a8 >= v14 )
      {
        v15 = a6;
LABEL_12:
        v16 = (const char *)sub_1003DB50((int)&v22, 125, v15, a9 + (signed int)v14, v20);
        if ( v16 )
        {
          v17 = sub_10010F20(a3, v16);
          if ( v17 )
          {
            *a4 = v17 | 4;
            return 1;
          }
          return 0;
        }
LABEL_16:
        sub_10011170(a3);
        return 0;
      }
      v19 = sub_1003DB50((int)&v22, 125, 0, 0, v14);
      if ( !v19 )
        goto LABEL_16;
      sub_100110F0(a3, (int)sub_1003ED50, 0, 150, v19);
    }
  }
  return 0;
}
// 10161D08: using guessed type char *off_10161D08;

//----- (10020970) --------------------------------------------------------
signed int __cdecl sub_10020970(int a1, int a2, int a3, int a4, int *a5)
{
  return sub_100207F0(a4, a2, a1, a5, 2, 2, -20, 100, 0);
}

//----- (100209A0) --------------------------------------------------------
signed int __cdecl sub_100209A0(int a1, int a2, int a3, int a4, int *a5)
{
  return sub_100207F0(a4, a2, a1, a5, 1, 3, 0, 100, 1);
}

//----- (100209D0) --------------------------------------------------------
signed int __cdecl sub_100209D0(int a1, int a2, int a3, int a4, int *a5)
{
  return sub_100207F0(a4, a2, a1, a5, 0, 4, 1, 100, 0);
}

//----- (10020A00) --------------------------------------------------------
char *__cdecl sub_10020A00(int a1, unsigned int a2)
{
  char *result; // eax@1
  char *v3; // eax@2
  char *v4; // edi@2
  unsigned int v5; // eax@3
  int v6; // ebx@5

  _control87(0x9001Fu, 0xB001Fu);
  result = (char *)sub_10011BE0(a1, a2, (const char **)&off_10161CC8);
  if ( result )
  {
    v3 = sub_10012240(a1, a2, 0, (int *)&off_10161D08, (int)sub_10020600, 1, 0, (const char **)&off_10161D50, 0, 0);
    v4 = v3;
    if ( v3
      && (v5 = sub_100118F0(a1, (int)v3)) != 0
      && (*(_DWORD *)(*((_DWORD *)v4 + 1) + 12) = 1, sub_10010780(a1, v5, (int)&dbl_10161DB0)) )
    {
      v6 = *(_DWORD *)(a1 + 24);
      result = sub_10010860(a1, a2, (int)"NaN", *(_DWORD *)(v6 + 468) | 2, 0, 0, 4);
      if ( result )
        result = (char *)(sub_10010860(a1, a2, (int)"Infinity", *(_DWORD *)(v6 + 476) | 2, 0, 0, 4) != 0 ? (unsigned int)v4 : 0);
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 10161CC8: using guessed type char *off_10161CC8;
// 10161D08: using guessed type char *off_10161D08;
// 10161D50: using guessed type char *off_10161D50;
// 10161DB0: using guessed type double dbl_10161DB0;

//----- (10020AF0) --------------------------------------------------------
unsigned int __cdecl sub_10020AF0(int a1, int a2, int a3, _DWORD *a4, int *a5)
{
  unsigned int result; // eax@1
  int v6; // esi@2
  unsigned int v7; // ebx@2
  unsigned int v8; // edi@3
  __int64 v9; // ST0C_8@5
  int v10; // eax@6
  unsigned int *v11; // eax@7
  int v12; // esi@7
  unsigned int v13; // eax@8
  int v14; // ecx@9
  unsigned int v15; // esi@15
  int v16; // esi@18
  unsigned int v17; // ecx@19
  unsigned int v18; // ecx@21
  unsigned int v19; // eax@23
  int v20; // eax@23
  unsigned int v21; // [sp+Ch] [bp-24h]@2
  unsigned int v22; // [sp+10h] [bp-20h]@4
  int v23; // [sp+14h] [bp-1Ch]@2
  int *v24; // [sp+18h] [bp-18h]@1
  char v25[16]; // [sp+1Ch] [bp-14h]@2

  v24 = a5;
  result = sub_100123C0(a1, a2, (int *)&off_10161E50, (int)a4);
  if ( result )
  {
    v6 = sub_10010550(a1, a2);
    v23 = sub_10050B00((int)v25, 16, "(new %s(", (char)off_10161E50);
    v7 = 0;
    v21 = v23 + 2;
    if ( v6 )
    {
      v22 = 0;
      if ( a3 )
      {
        HIDWORD(v9) = *a4;
        LODWORD(v9) = a1;
        if ( !sub_100201D0(v9, &v22) )
          return 0;
      }
      v10 = sub_10010D70(a1, v6, (int)"Script.prototype.toSource", v22);
      if ( !v10 )
        return 0;
      v11 = (unsigned int *)sub_1004C310(a1, v10, 39);
      v12 = (int)v11;
      if ( !v11 )
        return 0;
      v13 = *v11;
      if ( *(_DWORD *)v12 & 0x40000000 )
      {
        v14 = *(_DWORD *)(v12 + 4);
        if ( *(_DWORD *)v14 & 0x40000000 )
        {
          v7 = sub_1001A200(v12);
        }
        else if ( (v13 & 0x80000000) == 0 )
        {
          v7 = *(_DWORD *)(v14 + 4) + 2 * ((v13 >> 15) & 0x7FFF);
        }
        else
        {
          v7 = *(_DWORD *)(v14 + 4);
        }
      }
      else
      {
        v7 = *(_DWORD *)(v12 + 4);
      }
      v15 = *(_DWORD *)v12;
      v8 = v15;
      if ( v15 & 0x40000000 )
        v8 = v15 & ((v15 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      v21 += v8;
    }
    else
    {
      v8 = 0;
    }
    v16 = sub_10011830(a1, 2 * v21 + 2);
    result = 0;
    if ( !v16 )
      return result;
    v17 = v23;
    if ( v23 )
    {
      do
      {
        *(_WORD *)(v16 + 2 * result) = (unsigned __int8)v25[result];
        ++result;
      }
      while ( result < v17 );
    }
    v18 = 0;
    if ( v8 )
    {
      do
        *(_WORD *)(v16 + 2 * result++) = *(_WORD *)(v7 + 2 * v18++);
      while ( v18 < v8 );
    }
    *(_WORD *)(v16 + 2 * result) = 41;
    v19 = result + 1;
    *(_WORD *)(v16 + 2 * v19) = 41;
    *(_WORD *)(v16 + 2 * v19 + 2) = 0;
    v20 = sub_10010FD0(a1, v16, v21);
    if ( !v20 )
    {
      sub_10010340(a1, v16);
      return 0;
    }
    *v24 = v20 | 4;
    result = 1;
  }
  return result;
}
// 10161E50: using guessed type char *off_10161E50;
// 10020AF0: using guessed type char var_14[16];

//----- (10020D00) --------------------------------------------------------
signed int __cdecl sub_10020D00(int a1, int a2, int a3, _DWORD *a4, int *a5)
{
  signed int result; // eax@2
  int v6; // edi@3
  __int64 v7; // ST04_8@6
  int v8; // eax@7
  unsigned int v9; // [sp+Ch] [bp-4h]@5

  if ( !sub_100123C0(a1, a2, (int *)&off_10161E50, (int)a4) )
    return 0;
  v6 = sub_10010550(a1, a2);
  if ( v6 )
  {
    v9 = 0;
    if ( a3 )
    {
      HIDWORD(v7) = *a4;
      LODWORD(v7) = a1;
      if ( !sub_100201D0(v7, &v9) )
        return 0;
    }
    v8 = sub_10010D70(a1, v6, (int)"Script.prototype.toString", v9);
    if ( !v8 )
      return 0;
    *a5 = v8 | 4;
    result = 1;
  }
  else
  {
    result = 1;
    *a5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480) | 4;
  }
  return result;
}
// 10161E50: using guessed type char *off_10161E50;

//----- (10020DB0) --------------------------------------------------------
signed int __cdecl sub_10020DB0(int a1, int a2, int a3, signed int *a4, _DWORD *a5)
{
  signed int result; // eax@1
  int v6; // ebp@2
  int v7; // eax@7
  int v8; // esi@7
  int v9; // eax@11
  int v10; // [sp+Ch] [bp-4h]@4

  result = sub_100123C0(a1, a2, (int *)&off_10161E50, (int)a4);
  if ( result )
  {
    v6 = sub_10010550(a1, a2);
    if ( !v6 )
      return 1;
    v10 = 0;
    if ( a3 )
    {
      if ( !sub_10017450(a1, *a4, (unsigned int *)&v10) )
        return 0;
      *a4 = v10;
    }
    v7 = sub_10051900(a1, *(_DWORD *)(a1 + 56));
    v8 = v7;
    if ( v7
      && !*(_DWORD *)(v7 + 8)
      && !sub_10027630(
            a1,
            v7,
            *(_DWORD *)(*(_DWORD *)((*(_DWORD *)(*(_DWORD *)(v7 + 28) - 8) & 0xFFFFFFF8) + 4) + 4) & 0xFFFFFFF8) )
    {
      return 0;
    }
    v9 = v10;
    if ( !v10 )
    {
      if ( v8 )
        v9 = *(_DWORD *)(v8 + 52);
      else
        v9 = *(_DWORD *)(a1 + 88);
      v10 = v9;
    }
    result = sub_10038170(a1, v9, v6, v8, 32, a5);
  }
  return result;
}
// 10161E50: using guessed type char *off_10161E50;

//----- (10020E90) --------------------------------------------------------
int __usercall sub_10020E90@<eax>(int a1@<edi>, int a2@<esi>)
{
  int result; // eax@4
  int v3; // eax@7
  int v4; // [sp+0h] [bp-8h]@3
  int v5; // [sp+4h] [bp-4h]@2

  if ( !*(_DWORD *)a2 )
    v5 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8);
  v4 = *(_DWORD *)(a1 + 12);
  result = 0;
  if ( sub_10052520(a2, &v4) )
  {
    *(_DWORD *)(a1 + 12) = v4;
    if ( sub_10052970((_DWORD *)a2, &v5) )
    {
      if ( *(_DWORD *)a2 != 1 || (v3 = sub_10038A60(*(_DWORD *)(a2 + 8), v5, 0), (*(_DWORD *)(a1 + 8) = v3) != 0) )
        result = 1;
    }
  }
  return result;
}

//----- (10020F00) --------------------------------------------------------
int __cdecl sub_10020F00(int a1, int a2)
{
  unsigned int v2; // ebp@1
  int result; // eax@3
  int v4; // ebx@5
  int v5; // eax@5
  int v6; // esi@5
  int v7; // eax@6
  _DWORD *v8; // edi@6
  int v9; // eax@10
  int v10; // edi@12
  int v11; // eax@12
  int v12; // eax@16
  int v13; // ebx@16
  int v14; // ebx@23
  unsigned int v15; // [sp+8h] [bp-18h]@2
  int v16; // [sp+Ch] [bp-14h]@5
  _DWORD *v17; // [sp+10h] [bp-10h]@5
  int v18; // [sp+14h] [bp-Ch]@5
  int v19; // [sp+18h] [bp-8h]@5
  int v20; // [sp+1Ch] [bp-4h]@24

  v2 = 0;
  if ( !*(_DWORD *)a1 )
    v15 = *(_DWORD *)(a2 + 4);
  result = sub_10052520(a1, (int *)&v15);
  if ( result )
  {
    if ( *(_DWORD *)a1 == 1 )
    {
      v4 = *(_DWORD *)(a1 + 8);
      v5 = *(_DWORD *)(v4 + 76);
      v6 = *(_DWORD *)(v5 + 12);
      v16 = *(_DWORD *)(v5 + 12);
      v17 = 0;
      v18 = 0;
      v19 = 0;
      if ( v15 > 0 )
      {
        while ( 1 )
        {
          v7 = *(_DWORD *)(v4 + 76);
          v8 = *(_DWORD **)(v7 + 12);
          if ( (unsigned int)(v8 + 4) <= *(_DWORD *)(v7 + 8) )
            *(_DWORD *)(v7 + 12) = v8 + 4;
          else
            v8 = (_DWORD *)sub_1003E2D0(v4 + 60, 0x10u);
          if ( !v8 )
            break;
          v9 = sub_10020E90((int)v8, a1);
          v6 = v16;
          if ( !v9 )
            goto LABEL_16;
          *v8 = v17;
          ++v19;
          ++v2;
          v17 = v8;
          if ( v2 >= v15 )
            goto LABEL_12;
        }
        sub_10011170(v4);
LABEL_16:
        v12 = *(_DWORD *)(v4 + 76);
        v13 = v4 + 60;
        if ( v12 != v13 && v6 - *(_DWORD *)(v12 + 4) <= (unsigned int)(*(_DWORD *)(v12 + 12) - *(_DWORD *)(v12 + 4)) )
        {
          *(_DWORD *)(v12 + 12) = (v6 + 3) & 0xFFFFFFFC;
          return 0;
        }
        sub_1003E5E0(v13, v6);
        return 0;
      }
LABEL_12:
      v10 = sub_10038E00(v2, v4, a2, (int)&v17);
      v11 = *(_DWORD *)(v4 + 76);
      if ( v11 == v4 + 60 || v6 - *(_DWORD *)(v11 + 4) > (unsigned int)(*(_DWORD *)(v11 + 12) - *(_DWORD *)(v11 + 4)) )
      {
        sub_1003E5E0(v4 + 60, v6);
        result = v10;
      }
      else
      {
        *(_DWORD *)(v11 + 12) = (v6 + 3) & 0xFFFFFFFC;
        result = v10;
      }
    }
    else
    {
      if ( !*(_DWORD *)a1 )
      {
        v14 = 0;
        if ( *(_DWORD *)(a2 + 4) > 0u )
        {
          do
          {
            v19 = *(_DWORD *)(*(_DWORD *)a2 + 4 * v14);
            v20 = v14;
            if ( !sub_10020E90((int)&v17, a1) )
              return 0;
          }
          while ( (unsigned int)++v14 < *(_DWORD *)(a2 + 4) );
        }
      }
      result = 1;
    }
  }
  return result;
}

//----- (100210A0) --------------------------------------------------------
signed int __cdecl sub_100210A0(int a1, int a2, int a3, signed int *a4, _DWORD *a5)
{
  return sub_10020DB0(a1, *(a4 - 2) & 0xFFFFFFF8, a3, a4, a5);
}

//----- (100210C0) --------------------------------------------------------
BOOL __cdecl sub_100210C0(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

//----- (10021100) --------------------------------------------------------
int __cdecl sub_10021100(int a1, const char *a2)
{
  unsigned int v2; // eax@1

  v2 = strlen(a2) + 14;
  if ( v2 <= 0x10 )
    v2 = 16;
  return sub_10053CF0(v2, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10021140) --------------------------------------------------------
int *__cdecl sub_10021140(int a1, unsigned int a2, int a3)
{
  int *result; // eax@2

  if ( a3 == 1 )
    result = sub_10053E10(a2, dword_10658DEC);
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10021160) --------------------------------------------------------
int __cdecl sub_10021160(int a1)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 24);
  result = *(_DWORD *)(v1 + 8864);
  if ( result )
  {
    result = sub_100512D0(*(_DWORD *)(v1 + 8864));
    *(_DWORD *)(v1 + 8864) = 0;
  }
  return result;
}

//----- (10021190) --------------------------------------------------------
int __cdecl sub_10021190(int a1, char *a2)
{
  int v2; // edi@1
  int v3; // eax@1
  int v4; // ebx@1
  _DWORD *v5; // eax@1
  _DWORD *v6; // ecx@1
  int v7; // eax@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8864);
  v3 = sub_10051690(a2);
  v4 = v3;
  v5 = sub_10051360(v2, v3, (int)a2);
  v6 = v5;
  v7 = *v5;
  if ( v7 )
    return v7 + 13;
  v7 = sub_100513D0(v2, v6, v4, (int)a2, 0);
  if ( v7 )
  {
    strcpy((char *)(v7 + 13), a2);
    *(_DWORD *)(v7 + 8) = v7 + 13;
    return v7 + 13;
  }
  sub_10011170(a1);
  return 0;
}

//----- (10021210) --------------------------------------------------------
int __cdecl sub_10021210(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 - 1) = 1;
  return result;
}

//----- (10021220) --------------------------------------------------------
signed int __cdecl sub_10021220(int a1)
{
  signed int result; // eax@2

  if ( *(_BYTE *)(a1 + 12) )
  {
    *(_BYTE *)(a1 + 12) = 0;
    result = 0;
  }
  else
  {
    result = 2;
  }
  return result;
}

//----- (10021240) --------------------------------------------------------
int __cdecl sub_10021240(int a1)
{
  return sub_100515D0(*(_DWORD *)(a1 + 8864), (int (__cdecl *)(_DWORD *, int, int))sub_10021220, a1);
}

//----- (10021260) --------------------------------------------------------
_DWORD *__cdecl sub_10021260(int a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax@3
  _DWORD *v5; // esi@3

  if ( a4 )
    a3 += 3;
  result = (_DWORD *)sub_10011830(a1, a3 + a2 + 4 * (3 * a4 + 12));
  v5 = result;
  if ( result )
  {
    memset(result, 0, 0x30u);
    v5[2] = v5 + 12;
    *v5 = v5 + 12;
    v5[1] = a2;
    v5[3] = *(_DWORD *)(a1 + 16);
    if ( a4 )
      v5[9] = ((unsigned int)v5 + a2 + a3 + 48) & 0xFFFFFFFC;
    result = v5;
  }
  return result;
}

//----- (100212D0) --------------------------------------------------------
int __cdecl sub_100212D0(int a1, int a2, int a3)
{
  int v3; // edi@1
  void (__cdecl *v4)(int, int, int, int, int, int); // ebx@1
  int v5; // ecx@2
  int v6; // ST14_4@2
  int v7; // ST08_4@2
  int v8; // ST04_4@2
  int result; // eax@2
  char v10; // [sp+Ch] [bp-58h]@2
  int v11; // [sp+18h] [bp-4Ch]@2
  int v12; // [sp+38h] [bp-2Ch]@2

  v3 = *(_DWORD *)(a1 + 24);
  v4 = *(void (__cdecl **)(int, int, int, int, int, int))(v3 + 500);
  if ( v4 )
  {
    memset(&v10, 0, 0x58u);
    v5 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 56) = &v10;
    v12 = v5;
    v6 = *(_DWORD *)(v3 + 504);
    v7 = *(_DWORD *)(a2 + 28);
    v8 = *(_DWORD *)(a2 + 24);
    v11 = a2;
    v4(a1, v8, v7, a2, a3, v6);
    result = v12;
    *(_DWORD *)(a1 + 56) = v12;
  }
  return result;
}

//----- (10021340) --------------------------------------------------------
int *__cdecl sub_10021340(int a1, unsigned int a2)
{
  int v2; // eax@1
  void (__cdecl *v3)(int, unsigned int, _DWORD); // ecx@1
  int v4; // edx@4

  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(void (__cdecl **)(int, unsigned int, _DWORD))(v2 + 508);
  if ( v3 )
    v3(a1, a2, *(_DWORD *)(v2 + 512));
  sub_10051760(a1, (int *)a2);
  sub_10038EB0(a1, a2 + 16);
  if ( *(_DWORD *)(a2 + 40) )
  {
    --*(_DWORD *)(*(_DWORD *)(a2 + 40) + 12);
    v4 = *(_DWORD *)(a2 + 40);
    if ( !*(_DWORD *)(v4 + 12) )
      (*(void (__cdecl **)(int, _DWORD))(v4 + 16))(a1, *(_DWORD *)(a2 + 40));
  }
  return sub_10010340(a1, a2);
}

//----- (100213B0) --------------------------------------------------------
int __cdecl sub_100213B0(int a1, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // edi@1
  unsigned int v4; // esi@1
  int v5; // eax@2
  int result; // eax@5

  v2 = *(_DWORD *)(a2 + 16);
  v3 = *(_DWORD *)(a2 + 20);
  v4 = 0;
  if ( v3 )
  {
    do
    {
      v5 = *(_DWORD *)(v2 + 4 * v4);
      if ( !(*(_BYTE *)(v5 + 16) & 4) )
        sub_1003AB90(a1, v5);
      ++v4;
    }
    while ( v4 < v3 );
  }
  result = *(_DWORD *)(a2 + 24);
  if ( result )
    result = sub_10021210(*(_DWORD *)(a2 + 24));
  return result;
}

//----- (10021400) --------------------------------------------------------
unsigned __int8 *__cdecl sub_10021400(int a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned __int8 *v6; // esi@3
  unsigned __int8 v7; // al@3
  int v8; // ebx@3
  unsigned int v9; // ecx@4
  unsigned __int8 v10; // dl@4
  int v11; // eax@5
  signed int v12; // ecx@11
  int v13; // eax@14

  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = a2 - *(_DWORD *)a1;
  if ( v4 >= v3 )
    return 0;
  v6 = (unsigned __int8 *)(v3 + v2);
  v7 = *(_BYTE *)(v3 + v2);
  v8 = 0;
  if ( !v7 )
    return 0;
  while ( 1 )
  {
    v9 = v7;
    v10 = v7 >> 3;
    v11 = (unsigned __int8)(v7 >> 3) < 0x18u ? v7 & 7 : v7 & 0x3F;
    v8 += v11;
    if ( v8 == v4 )
    {
      if ( v10 >= 0x18u )
        goto LABEL_11;
      if ( (signed int)(v9 >> 3) < 22 )
        return v6;
    }
    if ( v10 < 0x18u )
    {
      v12 = v9 >> 3;
      goto LABEL_13;
    }
LABEL_11:
    v12 = 24;
LABEL_13:
    if ( byte_10162B5C[8 * v12] )
      v13 = sub_10041320(v6);
    else
      v13 = 1;
    v6 += v13;
    v7 = *v6;
    if ( !*v6 )
      return 0;
  }
}

//----- (10021490) --------------------------------------------------------
int __cdecl sub_10021490(int a1, int a2, int a3)
{
  unsigned __int16 v3; // cx@2
  int *v4; // eax@2
  int result; // eax@2
  int v6; // ebp@3
  unsigned __int8 *v7; // esi@3
  int v8; // ebx@3
  unsigned __int8 v9; // al@3
  int i; // edi@3
  unsigned int v11; // ecx@4
  unsigned __int8 v12; // dl@4
  int v13; // eax@5
  unsigned int v14; // ecx@8
  unsigned int v15; // eax@16
  int v16; // eax@19

  if ( *(_BYTE *)a3 == 125 )
  {
    HIBYTE(v3) = *(_BYTE *)(a3 + 1);
    LOBYTE(v3) = *(_BYTE *)(a3 + 2);
    v4 = sub_10038D40(a1, a2 + 16, v3);
    result = *(_DWORD *)(*(_DWORD *)(sub_10010550(a1, v4[2] & 0xFFFFFFF8) + 12) + 28);
  }
  else
  {
    v6 = *(_DWORD *)(a2 + 28);
    v7 = (unsigned __int8 *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 4));
    v8 = a3 - *(_DWORD *)a2;
    v9 = *v7;
    for ( i = 0; *v7; v9 = *v7 )
    {
      v11 = v9;
      v12 = v9 >> 3;
      if ( (unsigned __int8)(v9 >> 3) < 0x18u )
        v13 = v9 & 7;
      else
        v13 = v9 & 0x3F;
      i += v13;
      if ( v12 < 0x18u )
      {
        v14 = v11 >> 3;
        if ( v14 == 23 )
        {
          if ( i > v8 )
            break;
          v6 = sub_10041370((int)v7, 0);
        }
        else if ( v14 == 22 )
        {
          if ( i > v8 )
            break;
          ++v6;
        }
      }
      if ( i > v8 )
        break;
      v15 = (*v7 & 0xF8u) < 0xC0 ? (unsigned int)*v7 >> 3 : 24;
      v16 = byte_10162B5C[8 * v15] ? sub_10041320(v7) : 1;
      v7 += v16;
    }
    result = v6;
  }
  return result;
}

//----- (10021580) --------------------------------------------------------
signed int __cdecl sub_10021580(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  signed int result; // eax@1
  int v6; // ebx@4
  int v7; // esi@4
  int v8; // eax@4
  int v9; // ebp@7
  unsigned int v10; // eax@12
  int v11; // esi@12
  int v12; // ecx@15
  int v13; // eax@16
  int v14; // esi@21
  unsigned int v15; // ebx@22
  int v16; // [sp+8h] [bp-10h]@4
  int v17; // [sp+Ch] [bp-Ch]@10
  int v18; // [sp+10h] [bp-8h]@10
  int v19; // [sp+14h] [bp-4h]@3

  result = sub_100123C0(a1, a2, (int *)&off_10161E50, a4);
  if ( result )
  {
    if ( !a3 )
    {
LABEL_28:
      *a5 = a2;
      return 1;
    }
    v19 = sub_1001ACB0(a1, *(_DWORD *)a4);
    if ( v19 )
    {
      v6 = *(_DWORD *)(a1 + 56);
      v7 = sub_10051900(a1, *(_DWORD *)(a1 + 56));
      v8 = 0;
      v16 = 0;
      if ( a3 < 2 )
      {
LABEL_7:
        v9 = 0;
        if ( v7 )
        {
          if ( !v8 )
            v16 = *(_DWORD *)(v7 + 52);
          v9 = *(_DWORD *)(*(_DWORD *)(v7 + 12) + 24);
          v17 = sub_10021490(a1, *(_DWORD *)(v7 + 12), *(_DWORD *)(v7 + 56));
          v18 = sub_10051980(a1, v6, v7);
        }
        else
        {
          v17 = 0;
          v18 = 0;
        }
        *(_DWORD *)(v6 + 76) |= 0x20u;
        v10 = *(_DWORD *)v19;
        v11 = *(_DWORD *)v19;
        if ( *(_DWORD *)v19 & 0x40000000 )
          v11 = v10 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        if ( *(_DWORD *)v19 & 0x40000000 )
        {
          v12 = *(_DWORD *)(v19 + 4);
          if ( *(_DWORD *)v12 & 0x40000000 )
          {
            v13 = sub_1001A200(v19);
          }
          else if ( (v10 & 0x80000000) == 0 )
          {
            v13 = *(_DWORD *)(v12 + 4) + 2 * ((v10 >> 15) & 0x7FFF);
          }
          else
          {
            v13 = *(_DWORD *)(v12 + 4);
          }
        }
        else
        {
          v13 = *(_DWORD *)(v19 + 4);
        }
        v14 = sub_10010CF0(a1, v16, v18, v13, v11, v9, v17);
        if ( !v14 )
          goto LABEL_24;
        v15 = sub_10010550(a1, a2);
        if ( !sub_10010570(a1, a2, v14) )
        {
          sub_10021340(a1, v14);
          goto LABEL_24;
        }
        if ( v15 )
          sub_10021340(a1, v15);
        *(_DWORD *)(v14 + 44) = a2;
        goto LABEL_28;
      }
      if ( sub_10017450(a1, *(_DWORD *)(a4 + 4), (unsigned int *)&v16) )
      {
        v8 = v16;
        *(_DWORD *)(a4 + 4) = v16;
        goto LABEL_7;
      }
    }
LABEL_24:
    result = 0;
  }
  return result;
}
// 10161E50: using guessed type char *off_10161E50;

//----- (10021730) --------------------------------------------------------
signed int __cdecl sub_10021730(int a1, _DWORD **a2, _DWORD *a3)
{
  char *v3; // ebx@1
  int v4; // ebp@1
  bool v5; // zf@1
  _DWORD *v6; // edi@1
  signed int result; // eax@9
  _BYTE *v8; // ebp@14
  _BYTE *v9; // esi@14
  unsigned int v10; // eax@16
  int v11; // eax@19
  int v12; // ecx@22
  int v13; // eax@23
  char **v14; // ebp@46
  int v15; // esi@53
  int v16; // eax@53
  unsigned int v17; // eax@57
  int v18; // esi@59
  int (__cdecl *v19)(char *, int *); // eax@62
  int v20; // esi@68
  size_t v21; // ecx@71
  size_t v22; // ebp@71
  _DWORD *v23; // eax@73
  _DWORD *v24; // esi@73
  void *v25; // edx@74
  int v26; // eax@76
  int v27; // esi@77
  char v28; // [sp+0h] [bp-44h]@0
  unsigned int v29; // [sp+10h] [bp-34h]@2
  int v30; // [sp+14h] [bp-30h]@1
  size_t v31; // [sp+18h] [bp-2Ch]@1
  void *v32; // [sp+1Ch] [bp-28h]@1
  int v33; // [sp+20h] [bp-24h]@14
  int v34; // [sp+24h] [bp-20h]@53
  int v35; // [sp+28h] [bp-1Ch]@53
  int v36; // [sp+2Ch] [bp-18h]@14
  int v37; // [sp+30h] [bp-14h]@14
  int v38; // [sp+34h] [bp-10h]@14
  int v39; // [sp+38h] [bp-Ch]@14
  int v40; // [sp+3Ch] [bp-8h]@77
  int v41; // [sp+40h] [bp-4h]@1

  v3 = (char *)a1;
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)a1 == 0;
  v6 = *a2;
  v30 = *(_DWORD *)(a1 + 8);
  a1 = 0;
  v31 = 0;
  v41 = 0;
  v32 = 0;
  if ( v5 )
    v29 = -559087612;
  if ( !sub_10052520((int)v3, (int *)&v29) )
    return 0;
  if ( v29 == -559087612 || v29 == -559087613 || v29 == -559087614 || v29 == -559087615 )
  {
    if ( a3 )
      *a3 = 1;
    if ( !*(_DWORD *)v3 )
    {
      v33 = v6[1];
      v36 = v6[2] - *v6;
      v37 = v6[3];
      v38 = v6[7];
      v39 = v6[8];
      v8 = (_BYTE *)(v6[1] + *v6);
      v5 = *v8 == 0;
      v32 = (void *)(v6[1] + *v6);
      v9 = v8;
      if ( !v5 )
      {
        do
        {
          if ( (*v9 & 0xF8u) < 0xC0 )
            v10 = (unsigned int)*v9 >> 3;
          else
            v10 = 24;
          if ( byte_10162B5C[8 * v10] )
            v11 = sub_10041320(v9);
          else
            v11 = 1;
          v9 += v11;
        }
        while ( *v9 );
      }
      v31 = v9 - v8 + 1;
      v12 = v6[9];
      if ( v12 )
      {
        v13 = a1;
        if ( *(_DWORD *)(v12 + 12 * a1 + 8) )
        {
          do
            a1 = ++v13;
          while ( *(_DWORD *)(v6[9] + 12 * v13 + 8) );
        }
        a1 = v13 + 1;
      }
    }
    if ( !sub_10052520((int)v3, &v33)
      || v29 >= 0xDEAD0002
      && (!sub_10052520((int)v3, &v36)
       || !sub_10052520((int)v3, &v37)
       || v29 >= 0xDEAD0004 && (!sub_10052520((int)v3, (int *)&v31) || !sub_10052520((int)v3, &a1))) )
    {
      return 0;
    }
    if ( *(_DWORD *)v3 == 1 )
    {
      v6 = sub_10021260(v30, v33, v31, a1);
      if ( !v6 )
        return 0;
      if ( v29 >= 0xDEAD0002 )
      {
        v6[2] += v36;
        v6[3] = v37;
        if ( v29 >= 0xDEAD0004 )
          v32 = (void *)(*v6 + v6[1]);
      }
      *a2 = v6;
    }
    if ( sub_10052560((int)v3, *v6, v33) )
    {
      if ( sub_10020F00((int)v3, (int)(v6 + 4)) )
      {
        if ( v29 >= 0xDEAD0004
          || sub_10052520((int)v3, (int *)&v31) && (*(_DWORD *)v3 != 1 || (v32 = (void *)sub_10011830(v30, v31)) != 0) )
        {
          if ( sub_10052560((int)v3, (int)v32, v31) )
          {
            v14 = (char **)(v6 + 6);
            if ( sub_100526B0(v3, v6 + 6) )
            {
              if ( sub_10052520((int)v3, &v38)
                && sub_10052520((int)v3, &v39)
                && (v29 >= 0xDEAD0004 || sub_10052520((int)v3, &a1)) )
              {
                if ( v29 < 0xDEAD0003 )
                  goto LABEL_66;
                if ( !*(_DWORD *)v3 )
                {
                  v15 = v30;
                  v16 = *(_DWORD *)(v30 + 24);
                  v35 = v6[10];
                  v34 = *(_DWORD *)(v16 + 8796) != 0;
                  if ( !sub_10052520((int)v3, &v34)
                    || v34 && !(*(int (__cdecl **)(char *, int *))(*(_DWORD *)(v15 + 24) + 8796))(v3, &v35) )
                  {
                    goto LABEL_56;
                  }
LABEL_66:
                  if ( *(_DWORD *)v3 == 1 )
                  {
                    if ( *v14 )
                    {
                      v20 = sub_10021190(v30, *v14);
                      if ( !v20 )
                        goto LABEL_56;
                      sub_10010340(v30, (unsigned int)*v14);
                      *v14 = (char *)v20;
                      v41 = 1;
                    }
                    v6[7] = v38;
                    v6[8] = v39;
                    if ( v29 < 0xDEAD0004 )
                    {
                      v21 = v31;
                      v22 = v31;
                      if ( a1 )
                      {
                        v21 = v31 + 3;
                        v31 += 3;
                      }
                      v23 = sub_10011870(v30, v6, v21 + v33 + 4 * (3 * a1 + 12));
                      v24 = v23;
                      if ( !v23 )
                        goto LABEL_56;
                      *a2 = v23;
                      *v23 = v23 + 12;
                      v25 = v32;
                      v23[2] = (char *)v23 + v36 + 48;
                      v6 = v23;
                      memcpy((char *)v23 + v33 + 48, v25, v22);
                      sub_10010340(v30, (unsigned int)v32);
                      v32 = 0;
                      if ( !a1 )
                        return 1;
                      v24[9] = (v31 + *v24 + v24[1]) & 0xFFFFFFFC;
                    }
                  }
                  v26 = a1;
                  if ( a1 )
                  {
                    while ( 1 )
                    {
                      a1 = v26 - 1;
                      v27 = v6[9] + 12 * (v26 - 1);
                      v35 = *(_DWORD *)v27;
                      v34 = *(_DWORD *)(v27 + 4);
                      v40 = *(_DWORD *)(v27 + 8);
                      if ( !sub_10052520((int)v3, &v35) || !sub_10052520((int)v3, &v34) || !sub_10052520((int)v3, &v40) )
                        break;
                      *(_DWORD *)v27 = v35;
                      *(_DWORD *)(v27 + 4) = v34;
                      *(_DWORD *)(v27 + 8) = v40;
                      v26 = a1;
                      if ( !a1 )
                        return 1;
                    }
                    goto LABEL_56;
                  }
                  return 1;
                }
                if ( !sub_10052520((int)v3, &v34) )
                  goto LABEL_56;
                if ( !v34 )
                  goto LABEL_66;
                v19 = *(int (__cdecl **)(char *, int *))(*(_DWORD *)(v30 + 24) + 8796);
                if ( !v19 )
                {
                  sub_100110F0(v30, (int)sub_1003ED50, 0, 167, v28);
                  goto LABEL_56;
                }
                if ( v19(v3, &v35) )
                {
                  v6[10] = v35;
                  goto LABEL_66;
                }
              }
            }
          }
        }
      }
    }
LABEL_56:
    if ( *(_DWORD *)v3 == 1 )
    {
      v17 = v6[6];
      if ( !v17 || v41 )
      {
        v18 = v30;
      }
      else
      {
        v18 = v30;
        sub_10010340(v30, v17);
        v6[6] = 0;
      }
      if ( v32 && v29 < 0xDEAD0004 )
        sub_10010340(v18, (unsigned int)v32);
      sub_10021340(v18, (unsigned int)v6);
      *a2 = 0;
    }
    return 0;
  }
  if ( a3 )
  {
    *a3 = 0;
    result = 1;
  }
  else
  {
    sub_100110F0(v4, (int)sub_1003ED50, 0, 68, v28);
    result = 0;
  }
  return result;
}

//----- (10021D40) --------------------------------------------------------
unsigned int __cdecl sub_10021D40(int a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_10010550(a1, a2);
  if ( result )
    result = (unsigned int)sub_10021340(a1, result);
  return result;
}

//----- (10021D70) --------------------------------------------------------
int __cdecl sub_10021D70(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10010550(a1, a2);
  if ( v2 )
    sub_100213B0(a1, v2);
  return 0;
}

//----- (10021DA0) --------------------------------------------------------
int __cdecl sub_10021DA0(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  int result; // eax@2

  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1 )
  {
    result = a2;
    goto LABEL_5;
  }
  result = sub_10017C40(a1, (int)&off_10161E50, 0, 0);
  if ( result )
LABEL_5:
    result = sub_10021580(a1, result, a3, a4, a5);
  return result;
}
// 10161E50: using guessed type char *off_10161E50;

//----- (10021DF0) --------------------------------------------------------
char *__cdecl sub_10021DF0(int a1, unsigned int a2)
{
  return sub_10012240(a1, a2, 0, (int *)&off_10161E50, (int)sub_10021DA0, 1, 0, (const char **)&off_10161E10, 0, 0);
}
// 10161E10: using guessed type char *off_10161E10;
// 10161E50: using guessed type char *off_10161E50;

//----- (10021E20) --------------------------------------------------------
signed int __cdecl sub_10021E20(int a1)
{
  int v1; // esi@1
  int v2; // eax@2
  signed int result; // eax@3

  v1 = *(_DWORD *)(a1 + 24);
  if ( *(_DWORD *)(v1 + 8864)
    || (v2 = sub_100511F0(0x10u, (int)sub_10051690, (int)sub_100210C0, 0, off_10161E98, 0),
        (*(_DWORD *)(v1 + 8864) = v2) != 0) )
  {
    result = 1;
  }
  else
  {
    sub_10021160(a1);
    result = 0;
  }
  return result;
}
// 10161E98: using guessed type int (__cdecl *off_10161E98[3])(int, int);

//----- (10021E70) --------------------------------------------------------
unsigned int __cdecl sub_10021E70(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // ebp@1
  int v5; // ecx@1
  int v6; // edx@1
  size_t v7; // ebx@1
  int v8; // eax@1
  int v9; // ecx@1
  int v10; // edi@1
  unsigned int v11; // ecx@2
  char v12; // cl@8
  int v13; // ecx@9
  signed int v14; // edx@9
  unsigned int v15; // edx@13
  unsigned int v16; // eax@14
  unsigned int v17; // ecx@14
  int v18; // eax@15
  void **v19; // eax@17
  unsigned int v20; // edi@17
  int v21; // eax@20
  int v22; // eax@21
  int v24; // [sp+18h] [bp+8h]@1

  v3 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8) - **(_DWORD **)(a2 + 112);
  v5 = *(_DWORD *)(a2 + 48);
  v6 = *(_DWORD *)(a2 + 96);
  v7 = *(_DWORD *)(a2 + 56) - v5;
  v8 = *(_DWORD *)(a2 + 56) - *(_DWORD *)(a2 + 72) - v5;
  v9 = *(_DWORD *)(a2 + 64);
  v10 = v8;
  v24 = v9 + v6 + 1;
  if ( v9 && (v11 = *(_DWORD *)(v3 + 120), *(_DWORD *)(v3 + 76) != v11) )
  {
    if ( v8 > 7 )
      v24 += (v8 + 55) / 63;
    v24 += 2 * (v11 > 0x7F) + 2;
  }
  else if ( v8 > 0 )
  {
    if ( v6 )
    {
      v12 = **(_BYTE **)(v3 + 92);
      if ( (v12 & 0xF8u) < 0xC0 )
      {
        v13 = v12 & 7;
        v14 = 7;
      }
      else
      {
        v13 = v12 & 0x3F;
        v14 = 63;
      }
      v10 = v8 - (v14 - v13);
    }
    if ( v10 > 0 )
    {
      v15 = (signed int)(v10 + 62 + ((unsigned __int64)(-2113396605i64 * (v10 + 62)) >> 32)) >> 5;
      v24 += v15 + (v15 >> 31);
    }
  }
  v16 = *(_DWORD *)(v3 + 152);
  v17 = *(_DWORD *)(v3 + 148);
  if ( v16 <= v17 )
    v18 = 0;
  else
    v18 = (signed int)(v16 - v17) / 12 + 1;
  v19 = (void **)sub_10021260(a1, v7 + v4, v24, v18);
  v20 = (unsigned int)v19;
  if ( !v19 )
    return 0;
  v19[2] = (char *)v19[2] + v7;
  memcpy(*v19, *(const void **)(v3 + 48), v7);
  memcpy(*(void **)(v20 + 8), **(const void ***)(v3 + 112), v4);
  if ( !sub_10038E00(v4, a1, v20 + 16, v3 + 128) )
    goto LABEL_31;
  if ( *(_DWORD *)(v3 + 116) )
  {
    v21 = sub_10021190(a1, *(char **)(v3 + 116));
    *(_DWORD *)(v20 + 24) = v21;
    if ( !v21 )
      goto LABEL_31;
  }
  *(_DWORD *)(v20 + 28) = *(_DWORD *)(v3 + 120);
  *(_DWORD *)(v20 + 32) = *(_DWORD *)(v3 + 144);
  v22 = *(_DWORD *)(v3 + 124);
  if ( v22 )
  {
    *(_DWORD *)(v20 + 40) = v22;
    ++*(_DWORD *)(v22 + 12);
  }
  if ( !sub_100420C0(a1, v3, (void *)(*(_DWORD *)v20 + *(_DWORD *)(v20 + 4))) )
  {
LABEL_31:
    sub_10021340(a1, v20);
    return 0;
  }
  if ( *(_DWORD *)(v20 + 36) )
    sub_10041600(a1, v3, *(void **)(v20 + 36));
  sub_100212D0(a1, v20, a3);
  return v20;
}

//----- (10022040) --------------------------------------------------------
unsigned __int16 __usercall sub_10022040@<ax>(unsigned __int16 a1@<si>)
{
  unsigned __int16 v1; // cx@1
  signed int v2; // edx@1
  unsigned __int16 result; // ax@3

  v1 = a1;
  v2 = *(_DWORD *)&dword_100CED28[4
                                * (unsigned __int8)byte_100CCEA8[a1 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)a1 >> 6] << 6)]];
  if ( v2 & 0x100000 )
    v1 = a1 - (v2 >> 22);
  result = v1;
  if ( a1 >= 0x80u && v1 < 0x80u )
    result = a1;
  return result;
}

//----- (10022090) --------------------------------------------------------
unsigned __int16 __usercall sub_10022090@<ax>(unsigned __int16 a1@<si>)
{
  signed int v1; // ecx@1
  unsigned __int16 result; // ax@2

  v1 = *(_DWORD *)&dword_100CED28[4
                                * (unsigned __int8)byte_100CCEA8[a1 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)a1 >> 6] << 6)]];
  if ( v1 & 0x200000 )
    result = a1 + (v1 >> 22);
  else
    result = a1;
  if ( result >= 0x80u && a1 < 0x80u )
    result = a1;
  return result;
}

//----- (100220E0) --------------------------------------------------------
int __usercall sub_100220E0@<eax>(int *a1@<eax>, int a2)
{
  int v2; // esi@1
  int v3; // ecx@1
  int result; // eax@1

  v2 = *a1;
  v3 = *(_DWORD *)(*a1 + 76);
  result = *(_DWORD *)(v3 + 12);
  if ( (unsigned int)(result + 24) <= *(_DWORD *)(v3 + 8) )
    *(_DWORD *)(v3 + 12) = result + 24;
  else
    result = sub_1003E2D0(v2 + 60, 0x18u);
  if ( result )
  {
    *(_DWORD *)result = a2;
    *(_DWORD *)(result + 4) = 0;
    *(_DWORD *)(result + 8) = 0;
  }
  else
  {
    sub_10011170(v2);
    result = 0;
  }
  return result;
}

//----- (10022130) --------------------------------------------------------
signed int __usercall sub_10022130@<eax>(unsigned int a1@<eax>, _DWORD *a2@<ecx>)
{
  signed int result; // eax@3
  unsigned int v3; // eax@4

  a1 = (unsigned __int16)a1;
  if ( (unsigned __int16)a1 < 0x30u )
    goto LABEL_9;
  if ( a1 <= 0x39 )
  {
    *a2 = a1 - 48;
    return 1;
  }
  v3 = a1 | 0x20;
  if ( v3 - 97 > 5 )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    *a2 = v3 - 87;
    result = 1;
  }
  return result;
}

//----- (10022170) --------------------------------------------------------
signed int __usercall sub_10022170@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>, int a4)
{
  int v4; // edi@1
  int v5; // eax@2
  int v6; // ecx@3
  int v7; // edx@3
  int v8; // edi@4
  signed int result; // eax@7
  int v10; // edi@10
  int v11; // edx@14
  int i; // eax@19

  v4 = a1;
  switch ( *(_DWORD *)a2 )
  {
    case 1:
      v5 = sub_100220E0((int *)a3, 1);
      if ( !v5 )
        goto LABEL_23;
      *(_DWORD *)(v5 + 8) = *(_DWORD *)(a4 + 4 * v4 - 8);
      *(_DWORD *)(v5 + 12) = *(_DWORD *)(a4 + 4 * v4 - 4);
      *(_DWORD *)(a4 + 4 * v4 - 8) = v5;
      ++*(_DWORD *)(a3 + 32);
      v6 = *(_DWORD *)(v5 + 8);
      v7 = *(_DWORD *)v6;
      if ( *(_DWORD *)v6 == 14 )
      {
        v8 = *(_DWORD *)(v5 + 12);
        if ( *(_DWORD *)v8 == 14 && !(*(_BYTE *)(a3 + 20) & 1) )
        {
          *(_DWORD *)v5 = 54;
          *(_WORD *)(v5 + 16) = *(_WORD *)(v6 + 12);
          *(_WORD *)(v5 + 18) = *(_WORD *)(v8 + 12);
          *(_DWORD *)(a3 + 28) += 13;
          goto LABEL_7;
        }
      }
      if ( v7 != 22
        || *(_WORD *)(v6 + 18) >= 0x100u
        || (v10 = *(_DWORD *)(v5 + 12), *(_DWORD *)v10 != 14)
        || *(_BYTE *)(a3 + 20) & 1 )
      {
        if ( v7 != 14
          || (v11 = *(_DWORD *)(v5 + 12), *(_DWORD *)v11 != 22)
          || *(_WORD *)(v11 + 18) >= 0x100u
          || *(_BYTE *)(a3 + 20) & 1 )
        {
          *(_DWORD *)(a3 + 28) += 7;
          result = 1;
        }
        else
        {
          *(_DWORD *)v5 = 55;
          *(_WORD *)(v5 + 16) = *(_WORD *)(v6 + 12);
          *(_WORD *)(v5 + 18) = *(_WORD *)(v11 + 18);
          *(_DWORD *)(a3 + 28) += 13;
          result = 1;
        }
      }
      else
      {
        *(_DWORD *)v5 = 55;
        *(_WORD *)(v5 + 16) = *(_WORD *)(v10 + 12);
        *(_WORD *)(v5 + 18) = *(_WORD *)(v6 + 18);
        *(_DWORD *)(a3 + 28) += 13;
        result = 1;
      }
      break;
    default:
LABEL_7:
      result = 1;
      break;
    case 0x39:
      for ( i = *(_DWORD *)(a4 + 4 * a1 - 8); *(_DWORD *)(i + 4); i = *(_DWORD *)(i + 4) )
        ;
      *(_DWORD *)(i + 4) = *(_DWORD *)(a4 + 4 * v4 - 4);
      result = 1;
      break;
    case 0x1D:
    case 0x29:
    case 0x2B:
    case 0x2C:
      sub_10045A60(*(_DWORD *)a3, *(_DWORD *)(a3 + 4), 0, 0, 54, *(_DWORD *)(a2 + 4));
LABEL_23:
      result = 0;
      break;
  }
  return result;
}

//----- (10022310) --------------------------------------------------------
signed int __usercall sub_10022310@<eax>(char bp0@<bpl>, int a1)
{
  char v3; // [sp+4h] [bp-48h]@2
  int v4; // [sp+Ch] [bp-40h]@2
  int v5; // [sp+14h] [bp-38h]@2
  int v6; // [sp+18h] [bp-34h]@2
  unsigned __int16 v7; // [sp+1Ch] [bp-30h]@2
  __int16 v8; // [sp+1Eh] [bp-2Eh]@2
  int v9; // [sp+20h] [bp-2Ch]@2
  int v10; // [sp+24h] [bp-28h]@2
  int v11; // [sp+2Ch] [bp-20h]@2
  int v12; // [sp+34h] [bp-18h]@2
  int v13; // [sp+3Ch] [bp-10h]@2
  int v14; // [sp+44h] [bp-8h]@2

  if ( *(_DWORD *)(a1 + 20) & 0x8000 )
    return -1;
  qmemcpy(&v3, (const void *)a1, 0x48u);
  v6 |= 0x8000u;
  v5 = v4;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( !sub_100260E0(bp0, (int)&v3) )
  {
    *(_DWORD *)(a1 + 20) |= 0x4000u;
    return -1;
  }
  return v7;
}

//----- (10022390) --------------------------------------------------------
unsigned int __usercall sub_10022390@<eax>(int a1@<edi>, unsigned __int16 a2, unsigned int a3, int (__cdecl *a4)(int))
{
  unsigned int v4; // esi@1
  signed int i; // ebp@4
  unsigned __int16 v6; // ax@7
  int v7; // ebx@8
  unsigned int result; // eax@16

  v4 = a2 - 48;
  for ( i = v4 > a3 && (!a4 || v4 > a4(a1)); *(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 12); *(_DWORD *)(a1 + 16) += 2 )
  {
    v6 = **(_WORD **)(a1 + 16);
    if ( v6 >= 0x80u )
      break;
    v7 = v6;
    if ( !isdigit(v6) )
      break;
    v4 = v7 + 10 * v4 - 48;
    if ( !i && v4 > a3 && (!a4 || v4 > a4(a1)) )
      i = 1;
  }
  if ( i )
    result = -1;
  else
    result = v4;
  return result;
}

//----- (10022430) --------------------------------------------------------
signed int __usercall sub_10022430@<eax>(_WORD *a1@<eax>, char a2@<sil>, int a3, int a4, _WORD *a5)
{
  int v5; // ecx@1
  _WORD *v6; // ebx@1
  int v7; // ebp@1
  _WORD *v8; // edi@1
  signed int v9; // edx@1
  bool v10; // zf@1
  signed int result; // eax@1
  unsigned int v12; // esi@8
  __int16 *v13; // ecx@16
  unsigned __int16 v14; // ax@17
  unsigned int v15; // ebx@23
  unsigned int v16; // eax@27
  unsigned __int16 v17; // ax@37
  unsigned int v18; // eax@39
  unsigned __int16 v19; // bx@46
  unsigned int v20; // eax@46
  char v21; // [sp-4h] [bp-20h]@4
  signed int v22; // [sp+Ch] [bp-10h]@1
  unsigned int v23; // [sp+10h] [bp-Ch]@1
  unsigned __int16 v24; // [sp+14h] [bp-8h]@1
  int v25; // [sp+18h] [bp-4h]@27

  v5 = a4;
  v6 = a5;
  v7 = 0;
  v8 = a1;
  v9 = 0;
  v10 = a1 == a5;
  result = 1;
  v23 = 0;
  v22 = 0;
  v24 = 0;
  *(_WORD *)(a4 + 16) = 0;
  *(_DWORD *)(a4 + 20) = 1;
  if ( !v10 )
  {
    if ( *v8 == 94 )
    {
      ++v8;
      *(_DWORD *)(a4 + 20) = 0;
    }
    v21 = a2;
    if ( v8 == a5 )
    {
LABEL_5:
      *(_WORD *)(v5 + 16) = v23;
      return 1;
    }
    while ( 1 )
    {
      v12 = *v8;
      ++v8;
      if ( v12 == 92 )
      {
        v12 = *v8;
        ++v8;
        switch ( v12 )
        {
          case 0x62u:
            v12 = 8;
            goto LABEL_42;
          case 0x66u:
            v12 = 12;
            goto LABEL_42;
          case 0x6Eu:
            v12 = 10;
            goto LABEL_42;
          case 0x72u:
            v12 = 13;
            goto LABEL_42;
          case 0x74u:
            v12 = 9;
            goto LABEL_42;
          case 0x76u:
            v12 = 11;
            goto LABEL_42;
          case 0x63u:
            v13 = v8 + 1;
            if ( v8 + 1 >= v6
              || ((v14 = *v13, (unsigned __int16)*v13 < 0x41u) || v14 > 0x5Au) && (v14 < 0x61u || v14 > 0x7Au) )
            {
              v12 = 92;
            }
            else
            {
              v12 = *(_BYTE *)v8 & 0x1F;
              ++v8;
            }
            goto LABEL_42;
          case 0x78u:
            v15 = 2;
            goto LABEL_25;
          case 0x75u:
            v15 = 4;
LABEL_25:
            v12 = 0;
            if ( !v15 )
              goto LABEL_31;
            while ( 2 )
            {
              if ( v8 < a5 )
              {
                v16 = *v8;
                ++v8;
                if ( sub_10022130(v16, &v25) )
                {
                  v12 = v25 | 16 * v12;
                  if ( ++v7 >= v15 )
                  {
                    v6 = a5;
                    v9 = v22;
                    v7 = 0;
                    goto LABEL_42;
                  }
                  continue;
                }
                v8 = (_WORD *)((char *)v8 + -2 - 2 * v7);
                v12 = 92;
              }
              break;
            }
LABEL_31:
            v6 = a5;
            v9 = v22;
            v7 = 0;
            goto LABEL_42;
          case 0x64u:
            if ( v9 )
            {
              sub_100110F0(*(_DWORD *)a3, (int)sub_1003ED50, 0, 57, v21);
              return 0;
            }
            v12 = 57;
            break;
          case 0x30u:
          case 0x31u:
          case 0x32u:
          case 0x33u:
          case 0x34u:
          case 0x35u:
          case 0x36u:
          case 0x37u:
            v17 = *v8;
            v12 -= 48;
            if ( (unsigned __int16)(*v8 - 48) <= 7u )
            {
              ++v8;
              v12 = v17 + 8 * v12 - 48;
              if ( (unsigned __int16)(*v8 - 48) <= 7u )
              {
                v18 = *v8 + 8 * v12 - 48;
                ++v8;
                if ( v18 > 0xFF )
                  --v8;
                else
                  v12 = v18;
              }
            }
            goto LABEL_42;
          default:
            goto LABEL_42;
          case 0x44u:
          case 0x53u:
          case 0x57u:
          case 0x73u:
          case 0x77u:
            if ( v9 )
            {
              sub_100110F0(*(_DWORD *)a3, (int)sub_1003ED50, 0, 57, v21);
              result = 0;
            }
            else
            {
              *(_WORD *)(v5 + 16) = -1;
              result = 1;
            }
            return result;
        }
      }
      else
      {
LABEL_42:
        if ( v9 )
        {
          if ( v24 > v12 )
          {
            sub_100110F0(*(_DWORD *)a3, (int)sub_1003ED50, 0, 57, v21);
            return 0;
          }
          v22 = 0;
          goto LABEL_45;
        }
      }
      if ( v8 < v6 - 1 && *v8 == 45 )
      {
        ++v8;
        v22 = 1;
        v24 = v12;
        goto LABEL_52;
      }
LABEL_45:
      if ( *(_BYTE *)(a3 + 20) & 1 )
      {
        v19 = sub_10022040(v12);
        LOWORD(v20) = sub_10022090(v12);
        if ( v19 > (unsigned __int16)v20 )
          LOWORD(v20) = v19;
        v20 = (unsigned __int16)v20;
        if ( (unsigned __int16)v20 > v12 )
          v12 = v20;
      }
      v6 = a5;
      if ( v12 > v23 )
        v23 = v12;
LABEL_52:
      v5 = a4;
      if ( v8 == v6 )
        goto LABEL_5;
      v9 = v22;
    }
  }
  return result;
}
// 10022430: could not find valid save-restore pair for esi

//----- (10022770) --------------------------------------------------------
signed int __usercall sub_10022770@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  _WORD *v2; // eax@1
  int v3; // eax@3
  int v4; // eax@5
  int v5; // eax@7
  unsigned __int16 *v6; // eax@9
  unsigned __int16 v7; // si@9
  unsigned int v8; // ebp@11
  _WORD *v9; // eax@11
  unsigned __int16 v10; // si@11
  int v11; // eax@12
  unsigned __int16 *v12; // eax@14
  unsigned int v13; // eax@16
  signed __int16 v14; // bx@16
  signed int result; // eax@21
  int v16; // eax@25
  int v17; // eax@27
  _WORD *v18; // eax@27
  _WORD *v19; // [sp+10h] [bp-8h]@9
  int v20; // [sp+14h] [bp-4h]@1

  v1 = a1;
  v20 = *(_DWORD *)(a1 + 36);
  v2 = *(_WORD **)(a1 + 16);
  if ( (unsigned int)v2 >= *(_DWORD *)(v1 + 12) )
  {
LABEL_32:
    result = 1;
  }
  else
  {
    switch ( *v2 )
    {
      case 0x2B:
        v3 = sub_100220E0((int *)v1, 25);
        *(_DWORD *)(v1 + 36) = v3;
        if ( !v3 )
          return 0;
        *(_WORD *)(v3 + 12) = 1;
        *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) = -1;
        *(_DWORD *)(v1 + 28) += 4;
        goto LABEL_27;
      case 0x2A:
        v4 = sub_100220E0((int *)v1, 25);
        *(_DWORD *)(v1 + 36) = v4;
        if ( !v4 )
          return 0;
        *(_WORD *)(v4 + 12) = 0;
        *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) = -1;
        *(_DWORD *)(v1 + 28) += 4;
        goto LABEL_27;
      case 0x3F:
        v5 = sub_100220E0((int *)v1, 25);
        *(_DWORD *)(v1 + 36) = v5;
        if ( !v5 )
          return 0;
        *(_WORD *)(v5 + 12) = 0;
        *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) = 1;
        *(_DWORD *)(v1 + 28) += 4;
        goto LABEL_27;
      case 0x7B:
        v19 = v2;
        v6 = v2 + 1;
        *(_DWORD *)(v1 + 16) = v6;
        v7 = *v6;
        if ( *v6 >= 0x80u || !isdigit(v7) )
          goto LABEL_31;
        *(_DWORD *)(v1 + 16) += 2;
        v8 = sub_10022390(v1, v7, 0xFFFFu, 0);
        v9 = *(_WORD **)(v1 + 16);
        v10 = *v9;
        if ( v8 == -1 )
        {
          v11 = 47;
LABEL_20:
          sub_10045A60(*(_DWORD *)v1, *(_DWORD *)(v1 + 4), 0, 0, v11, (char)v19);
          return 0;
        }
        if ( v10 == 44 )
        {
          v12 = v9 + 1;
          *(_DWORD *)(v1 + 16) = v12;
          v10 = *v12;
          if ( *v12 < 0x80u && isdigit(v10) )
          {
            *(_DWORD *)(v1 + 16) += 2;
            v13 = sub_10022390(v1, v10, 0xFFFFu, 0);
            v10 = **(_WORD **)(v1 + 16);
            v14 = v13;
            if ( v13 == -1 )
            {
              v11 = 48;
              goto LABEL_20;
            }
            if ( v8 > v13 )
            {
              v11 = 49;
              goto LABEL_20;
            }
          }
          else
          {
            v14 = -1;
          }
        }
        else
        {
          v14 = v8;
        }
        if ( v10 != 125 )
        {
LABEL_31:
          *(_DWORD *)(v1 + 16) = v19;
          goto LABEL_32;
        }
        v16 = sub_100220E0((int *)v1, 25);
        *(_DWORD *)(v1 + 36) = v16;
        if ( !v16 )
          return 0;
        *(_WORD *)(v16 + 12) = v8;
        *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) = v14;
        *(_DWORD *)(v1 + 28) += 8;
LABEL_27:
        *(_DWORD *)(v1 + 16) += 2;
        v17 = *(_DWORD *)(v1 + 36);
        ++*(_DWORD *)(v1 + 32);
        *(_DWORD *)(v17 + 8) = v20;
        v18 = *(_WORD **)(v1 + 16);
        if ( (unsigned int)v18 >= *(_DWORD *)(v1 + 12) || *v18 != 63 )
        {
          *(_DWORD *)(*(_DWORD *)(v1 + 36) + 16) = 1;
          result = 1;
        }
        else
        {
          *(_DWORD *)(v1 + 16) = v18 + 1;
          *(_DWORD *)(*(_DWORD *)(v1 + 36) + 16) = 0;
          result = 1;
        }
        break;
      default:
        goto LABEL_32;
    }
  }
  return result;
}

//----- (10022A00) --------------------------------------------------------
_BYTE *__usercall sub_10022A00@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, int *a4, int a5)
{
  int *v5; // ebx@1
  int v6; // esi@1
  _BYTE *v7; // edi@1
  _BYTE *result; // eax@2
  unsigned int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@7
  _BYTE *v12; // ebp@9
  _BYTE *v13; // ebp@10
  _BYTE *v14; // ebp@11
  int v15; // eax@12
  int v16; // edx@16
  int v17; // edx@18
  int v18; // edi@22
  _BYTE *v19; // ebp@29
  __int16 v20; // ax@31
  int v21; // edi@41
  int v22; // edx@45
  unsigned int v23; // [sp+Ch] [bp-4h]@1

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v23 = 0;
  if ( !a1 || (result = (_BYTE *)sub_10011830(*a4, 24 * a1), (v23 = (unsigned int)result) != 0) )
  {
    v9 = v23;
LABEL_4:
    v10 = *(_DWORD *)v6;
    while ( 1 )
    {
      *v7++ = v10;
      switch ( v10 )
      {
        case 0:
          --v7;
          goto LABEL_46;
        case 54:
        case 55:
          *(_DWORD *)(v9 + 12) = v7;
          v7[2] = *(_BYTE *)(v6 + 17);
          v11 = (int)(v7 + 2);
          *(_BYTE *)(v11 + 1) = *(_BYTE *)(v6 + 16);
          v11 += 2;
          *(_BYTE *)v11 = *(_BYTE *)(v6 + 19);
          *(_BYTE *)(v11 + 1) = *(_BYTE *)(v6 + 18);
          v7 = (_BYTE *)(v11 + 2);
          goto LABEL_8;
        case 1:
LABEL_8:
          *(_DWORD *)(v9 + 4) = v7;
          *(_DWORD *)(v9 + 16) = v6;
          *(_DWORD *)(v9 + 20) = 31;
          v6 = *(_DWORD *)(v6 + 8);
          v7 += 2;
          v9 += 24;
          goto LABEL_4;
        case 31:
          v12 = *(_BYTE **)(v9 + 4);
          *(_DWORD *)(v9 + 8) = v7;
          v7 += 2;
          *v12 = (unsigned __int16)((_WORD)v7 - (_WORD)v12) >> 8;
          *(_BYTE *)(*(_DWORD *)(v9 + 4) + 1) = (_BYTE)v7 - (_BYTE)v12;
          *(_DWORD *)(v9 + 20) = 56;
          v6 = *(_DWORD *)(v6 + 12);
          v9 += 24;
          goto LABEL_4;
        case 56:
          v13 = *(_BYTE **)(v9 + 8);
          *v13 = (unsigned __int16)((_WORD)v7 - (_WORD)v13) >> 8;
          *(_BYTE *)(*(_DWORD *)(v9 + 8) + 1) = (_BYTE)v7 - (_BYTE)v13;
          if ( *(_DWORD *)v6 != 1 )
          {
            v14 = *(_BYTE **)(v9 + 12);
            *v14 = (unsigned __int16)((_WORD)v7 - (_WORD)v14) >> 8;
            *(_BYTE *)(*(_DWORD *)(v9 + 12) + 1) = (_BYTE)v7 - (_BYTE)v14;
          }
          goto LABEL_46;
        case 14:
          v15 = *(_DWORD *)(v6 + 8);
          if ( !v15 )
            goto LABEL_23;
          if ( !*(_DWORD *)(v6 + 4) )
            goto LABEL_20;
          break;
        case 29:
          *v7 = *(_BYTE *)(v6 + 13);
          v7[1] = *(_BYTE *)(v6 + 12);
          *(_DWORD *)(v9 + 16) = v6;
          *(_DWORD *)(v9 + 20) = 30;
          v6 = *(_DWORD *)(v6 + 8);
          v7 += 2;
          v9 += 24;
          goto LABEL_4;
        case 13:
        case 30:
          *v7 = *(_BYTE *)(v6 + 13);
          v7[1] = *(_BYTE *)(v6 + 12);
          v7 += 2;
          goto LABEL_46;
        case 43:
          *(_DWORD *)(v9 + 8) = v7;
          *(_DWORD *)(v9 + 16) = v6;
          *(_DWORD *)(v9 + 20) = 45;
          v6 = *(_DWORD *)(v6 + 8);
          v7 += 2;
          v9 += 24;
          goto LABEL_4;
        case 45:
        case 46:
        case 51:
          v19 = *(_BYTE **)(v9 + 8);
          *v19 = (unsigned __int16)((_WORD)v7 - (_WORD)v19) >> 8;
          *(_BYTE *)(*(_DWORD *)(v9 + 8) + 1) = (_BYTE)v7 - (_BYTE)v19;
          goto LABEL_46;
        case 44:
          *(_DWORD *)(v9 + 8) = v7;
          *(_DWORD *)(v9 + 16) = v6;
          *(_DWORD *)(v9 + 20) = 46;
          v6 = *(_DWORD *)(v6 + 8);
          v7 += 2;
          v9 += 24;
          goto LABEL_4;
        case 25:
          v20 = *(_WORD *)(v6 + 12);
          if ( v20 )
            goto LABEL_36;
          if ( *(_WORD *)(v6 + 14) == -1 )
          {
            *(v7 - 1) = *(_DWORD *)(v6 + 16) != 0 ? 26 : 47;
          }
          else if ( *(_WORD *)(v6 + 14) == 1 )
          {
            *(v7 - 1) = *(_DWORD *)(v6 + 16) != 0 ? 28 : 49;
          }
          else
          {
LABEL_36:
            if ( v20 != 1 || *(_WORD *)(v6 + 14) != -1 )
            {
              if ( !*(_DWORD *)(v6 + 16) )
                *(v7 - 1) = 50;
              *v7 = *(_BYTE *)(v6 + 13);
              v7[1] = *(_BYTE *)(v6 + 12);
              v21 = (int)(v7 + 2);
              *(_BYTE *)v21 = *(_BYTE *)(v6 + 15);
              *(_BYTE *)(v21 + 1) = *(_BYTE *)(v6 + 14);
              v7 = (_BYTE *)(v21 + 2);
            }
            else
            {
              *(v7 - 1) = *(_DWORD *)(v6 + 16) != 0 ? 27 : 48;
            }
          }
          *(_DWORD *)(v9 + 8) = v7;
          *(_DWORD *)(v9 + 16) = v6;
          *(_DWORD *)(v9 + 20) = 51;
          v6 = *(_DWORD *)(v6 + 8);
          v7 += 2;
          v9 += 24;
          goto LABEL_4;
        case 22:
          if ( !*(_DWORD *)(v6 + 20) )
            *(v7 - 1) = 23;
          *v7 = *(_BYTE *)(v6 + 19);
          v7[1] = *(_BYTE *)(v6 + 18);
          v7 += 2;
          v22 = *(_DWORD *)(a5 + 12) + 16 * *(_WORD *)(v6 + 18);
          *(_DWORD *)v22 = 0;
          *(_WORD *)(v22 + 8) = *(_WORD *)(v6 + 16);
          *(_WORD *)(v22 + 12) = *(_WORD *)(v6 + 12);
          *(_WORD *)(v22 + 14) = *(_WORD *)(v6 + 14);
          *(_DWORD *)(v22 + 4) = *(_DWORD *)(v6 + 20);
          goto LABEL_46;
        default:
          goto LABEL_46;
      }
      while ( 1 )
      {
        v16 = *(_DWORD *)(v6 + 4);
        if ( *(_DWORD *)v16 != 14 )
          break;
        if ( v15 + 2 * *(_WORD *)(v6 + 14) != *(_DWORD *)(v16 + 8)
          || (*(_WORD *)(v6 + 14) += *(_WORD *)(v16 + 14), v17 = *(_DWORD *)(v16 + 4), (*(_DWORD *)(v6 + 4) = v17) == 0) )
        {
          v5 = a4;
          break;
        }
        v5 = a4;
      }
LABEL_20:
      if ( v15 && *(_WORD *)(v6 + 14) > 1u )
      {
        v18 = (int)(v7 + 2);
        *(_BYTE *)(v18 - 3) = 2 * ((*((_BYTE *)v5 + 20) & 1) != 0) + 14;
        *(_BYTE *)(v18 - 2) = (*(_DWORD *)(v6 + 8) - v5[2]) >> 9;
        *(_BYTE *)(v18 - 1) = (*(_DWORD *)(v6 + 8) - v5[2]) >> 1;
        *(_BYTE *)v18 = *(_BYTE *)(v6 + 15);
        *(_BYTE *)(v18 + 1) = *(_BYTE *)(v6 + 14);
        v7 = (_BYTE *)(v18 + 2);
      }
      else
      {
LABEL_23:
        if ( *(_WORD *)(v6 + 12) >= 0x100u )
        {
          *(v7 - 1) = *((_BYTE *)v5 + 20) & 1 | 0x12;
          *v7 = *(_BYTE *)(v6 + 13);
          v7[1] = *(_BYTE *)(v6 + 12);
          v7 += 2;
        }
        else
        {
          *(++v7 - 2) = 2 * ((*((_BYTE *)v5 + 20) & 1) != 0) + 15;
          *(v7 - 1) = *(_BYTE *)(v6 + 12);
        }
      }
LABEL_46:
      v6 = *(_DWORD *)(v6 + 4);
      if ( v6 )
        goto LABEL_4;
      if ( v9 == v23 )
        break;
      v6 = *(_DWORD *)(v9 - 8);
      v10 = *(_DWORD *)(v9 - 4);
      v9 -= 24;
    }
    if ( v23 )
      sub_10010340(*v5, v23);
    result = v7;
  }
  return result;
}

//----- (10022E00) --------------------------------------------------------
int __usercall sub_10022E00@<eax>(int a1@<eax>, char a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebp@1
  int v8; // edi@1
  int v9; // esi@1
  signed int v10; // ebx@1
  int v11; // edx@1
  void *v12; // ecx@1
  int v13; // eax@1
  int v14; // edx@2
  int v15; // esi@2
  unsigned int v16; // eax@3
  int *v17; // eax@6
  int result; // eax@10
  int v19; // eax@12
  _DWORD *v20; // eax@14
  int v21; // [sp+10h] [bp-4h]@1
  int v22; // [sp+2Ch] [bp+18h]@2

  v7 = a7;
  v8 = a1;
  v9 = *(_DWORD *)(v8 + 48) + *(_DWORD *)(v8 + 40);
  v10 = *(_DWORD *)(a1 + 44);
  v11 = 8 * a7 + 24 + 20 * *(_WORD *)(a1 + 32);
  v12 = *(void **)(a1 + 36);
  v13 = v9 + v11 - (_DWORD)v12 - v10;
  v21 = v11;
  if ( v13 <= 0 )
    goto LABEL_12;
  v14 = *(_DWORD *)(v8 + 68);
  v22 = v9 - (_DWORD)v12;
  v15 = v10 * ((v13 + v10 - 1) / v10);
  if ( *(void **)(v14 + 12) != (char *)v12 + ((v10 + 3) & 0xFFFFFFFC) )
  {
    v17 = sub_1003E510(v8 + 52, v12, v10, v15);
LABEL_9:
    *(_DWORD *)(v8 + 36) = v17;
    goto LABEL_10;
  }
  v16 = (unsigned int)v12 + ((v15 + v10 + 3) & 0xFFFFFFFC);
  if ( v16 > *(_DWORD *)(v14 + 8) )
  {
    if ( v12 == *(void **)(v14 + 4) )
      v17 = sub_1003E400(v8 + 52, (int)v12, v10, v15);
    else
      v17 = sub_1003E510(v8 + 52, v12, v10, v15);
    goto LABEL_9;
  }
  *(_DWORD *)(v14 + 12) = v16;
LABEL_10:
  result = *(_DWORD *)(v8 + 36);
  if ( !result )
    return result;
  v11 = v21;
  *(_DWORD *)(v8 + 44) = v10 + v15;
  v9 = result + v22;
LABEL_12:
  v19 = *(_DWORD *)(v8 + 48);
  *(_DWORD *)(v8 + 40) = v9;
  *(_DWORD *)v9 = v19;
  *(_DWORD *)(v8 + 48) = v11;
  *(_BYTE *)(v9 + 8) = a2;
  *(_DWORD *)(v9 + 12) = a5;
  *(_DWORD *)(v9 + 4) = a3;
  *(_WORD *)(v9 + 18) = v7;
  LOWORD(v19) = *(_WORD *)(v8 + 32);
  *(_WORD *)(v9 + 20) = v19;
  memcpy((void *)(v9 + 24), *(const void **)(v8 + 28), 20 * (unsigned __int16)v19);
  if ( v7 > 0 )
  {
    *(_WORD *)(v9 + 16) = a6;
    memcpy((void *)(v9 + 20 * *(_WORD *)(v9 + 20) + 24), (const void *)(a4 + 8 * a6 + 4), 8 * v7);
    if ( v7 > 0 )
    {
      v20 = (_DWORD *)(a4 + 8 * a6 + 4);
      do
      {
        *v20 = -1;
        v20 += 2;
        --v7;
      }
      while ( v7 );
    }
  }
  return v9;
}

//----- (10022F50) --------------------------------------------------------
unsigned int *__usercall sub_10022F50@<eax>(unsigned __int16 *a1@<eax>, int a2, unsigned int *a3, int a4)
{
  unsigned int *v4; // edx@1
  int v5; // ebp@1
  unsigned __int16 *v6; // edi@1
  unsigned int v7; // ecx@1
  unsigned int *result; // eax@2
  int v9; // ebx@3
  unsigned int v10; // eax@4
  unsigned int v11; // [sp+Ch] [bp-4h]@1
  unsigned int i; // [sp+14h] [bp+4h]@4
  unsigned __int16 v13; // [sp+1Ch] [bp+Ch]@6

  v4 = a3;
  v5 = a4;
  v6 = a1;
  v7 = *a3 + 2 * a4;
  v11 = *a3 + 2 * a4;
  if ( v7 <= *(_DWORD *)(a2 + 24) )
  {
    v9 = 0;
    if ( a4 <= 0 )
    {
LABEL_9:
      *v4 = v7;
      result = v4;
    }
    else
    {
      v10 = *a3 - (_DWORD)a1;
      for ( i = *a3 - (_DWORD)v6; ; v10 = i )
      {
        v13 = sub_10022040(*(unsigned __int16 *)((char *)v6 + v10));
        if ( sub_10022040(*v6) != v13 )
          break;
        ++v9;
        ++v6;
        if ( v9 >= v5 )
        {
          v7 = v11;
          v4 = a3;
          goto LABEL_9;
        }
      }
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10022FE0) --------------------------------------------------------
unsigned __int16 **__usercall sub_10022FE0@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int16 **a3)
{
  unsigned __int16 **v3; // edx@1
  unsigned __int16 *v4; // ebp@1
  unsigned __int16 *v6; // ebx@3
  unsigned int v7; // edi@3
  unsigned __int16 *v8; // esi@3
  char *v9; // eax@4
  unsigned int v10; // ebp@5
  int v11; // eax@6
  unsigned __int16 v12; // ST12_2@8
  unsigned int v13; // ecx@12
  int v14; // ebx@13
  int i; // [sp+8h] [bp-8h]@6
  unsigned __int16 *v16; // [sp+Ch] [bp-4h]@3

  v3 = a3;
  v4 = a3[2 * a1 + 1];
  if ( v4 == (unsigned __int16 *)-1 )
    return a3;
  v6 = *a3;
  v7 = LOWORD(a3[2 * a1 + 2]);
  v8 = &(*a3)[v7];
  v16 = &(*a3)[v7];
  if ( (unsigned int)v8 > *(_DWORD *)(a2 + 24) )
    return 0;
  v9 = (char *)(*(_DWORD *)(a2 + 20) + 2 * (_DWORD)v4);
  if ( !(*(_BYTE *)(*(_DWORD *)(a2 + 4) + 7) & 1) )
  {
    v13 = 0;
    if ( v7 )
    {
      v14 = (char *)v6 - v9;
      while ( *(_WORD *)v9 == *(_WORD *)&v9[v14] )
      {
        ++v13;
        v9 += 2;
        if ( v13 >= v7 )
        {
          *a3 = v8;
          return a3;
        }
      }
      return 0;
    }
LABEL_11:
    *v3 = v8;
    return v3;
  }
  v10 = 0;
  if ( !v7 )
    goto LABEL_11;
  v11 = v9 - (char *)v6;
  for ( i = v11; ; v11 = i )
  {
    v12 = sub_10022040(*(unsigned __int16 *)((char *)v6 + v11));
    if ( v12 != sub_10022040(*v6) )
      break;
    ++v10;
    ++v6;
    if ( v10 >= v7 )
    {
      v3 = a3;
      v8 = v16;
      goto LABEL_11;
    }
  }
  return 0;
}

//----- (100230B0) --------------------------------------------------------
_BYTE *__fastcall sub_100230B0(unsigned __int16 a1, int a2)
{
  _BYTE *result; // eax@1

  result = (_BYTE *)(*(_DWORD *)(a2 + 12) + ((unsigned int)a1 >> 3));
  *result |= 1 << (a1 & 7);
  return result;
}

//----- (100230D0) --------------------------------------------------------
_BYTE *__usercall sub_100230D0@<eax>(unsigned __int16 a1@<cx>, int a2@<edi>, unsigned __int16 a3)
{
  unsigned int v3; // esi@1
  unsigned int v4; // eax@1
  char v5; // dl@1
  unsigned __int16 v6; // cx@1
  _BYTE *result; // eax@2
  char v8; // dl@3
  unsigned int v9; // ecx@3
  int v10; // [sp+8h] [bp+4h]@1

  v3 = (unsigned int)a1 >> 3;
  v4 = (unsigned int)a3 >> 3;
  v5 = a3 & 7;
  v6 = a1 & 7;
  v10 = a3 & 7;
  if ( v3 == v4 )
  {
    result = (_BYTE *)v6;
    *(_BYTE *)(*(_DWORD *)(a2 + 12) + v3) |= (unsigned __int8)(255 >> (v6 - v5 + 7)) << v6;
  }
  else
  {
    v8 = -1 << v6;
    v9 = v3 + 1;
    *(_BYTE *)(*(_DWORD *)(a2 + 12) + v3) |= v8;
    if ( v3 + 1 < v4 )
    {
      do
        *(_BYTE *)(v9++ + *(_DWORD *)(a2 + 12)) = -1;
      while ( v9 < v4 );
    }
    result = (_BYTE *)(*(_DWORD *)(a2 + 12) + v4);
    *result |= 255 >> (7 - v10);
  }
  return result;
}

//----- (10023150) --------------------------------------------------------
void *__cdecl sub_10023150(int a1, int a2)
{
  int v2; // ecx@1
  unsigned int v3; // eax@1
  int v4; // edx@2
  unsigned int v5; // eax@3
  int v6; // edi@8
  _WORD *v7; // ebx@8
  unsigned int v8; // esi@8
  int v9; // ecx@8
  unsigned int v10; // esi@8
  void *result; // eax@8
  unsigned int v12; // ebp@9
  unsigned __int16 v13; // ax@13
  unsigned __int16 v14; // bp@14
  unsigned __int16 v15; // cx@15
  int v16; // eax@15
  _WORD *v17; // esi@22
  signed int v18; // edi@27
  int v19; // esi@29
  int v20; // ebp@29
  unsigned int v21; // eax@31
  unsigned __int16 v22; // cx@36
  int v23; // eax@36
  int v24; // ecx@38
  int v25; // esi@44
  int v26; // esi@49
  int v27; // esi@54
  int v28; // esi@60
  unsigned __int16 v29; // ST08_2@69
  unsigned __int16 v30; // ax@69
  unsigned __int16 v31; // cx@69
  unsigned __int16 v32; // ax@73
  unsigned __int16 v33; // cx@73
  unsigned __int16 v34; // [sp-4h] [bp-24h]@69
  unsigned __int16 v35; // [sp+10h] [bp-10h]@8
  _WORD *v36; // [sp+14h] [bp-Ch]@8
  signed int v37; // [sp+18h] [bp-8h]@8
  int v38; // [sp+1Ch] [bp-4h]@31

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 16);
  v3 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 & 0x40000000 )
  {
    v4 = *(_DWORD *)(v2 + 4);
    if ( *(_DWORD *)v4 & 0x40000000 )
    {
      v5 = sub_1001A200(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 16));
    }
    else if ( (v3 & 0x80000000) == 0 )
    {
      v5 = *(_DWORD *)(v4 + 4) + 2 * ((v3 >> 15) & 0x7FFF);
    }
    else
    {
      v5 = *(_DWORD *)(v4 + 4);
    }
  }
  else
  {
    v5 = *(_DWORD *)(v2 + 4);
  }
  v6 = a2;
  v7 = (_WORD *)(v5 + 2 * *(_WORD *)(a2 + 12));
  v8 = (unsigned int)*(_WORD *)(a2 + 8) >> 3;
  v9 = (int)&v7[*(_WORD *)(a2 + 14)];
  *(_DWORD *)a2 = 1;
  v10 = v8 + 1;
  v36 = (_WORD *)v9;
  v37 = 0;
  v35 = 0;
  result = (void *)sub_10011830(*(_DWORD *)a1, v10);
  *(_DWORD *)(a2 + 12) = result;
  if ( result )
  {
    memset(result, 0, v10);
    v12 = (unsigned int)v36;
    if ( v7 != v36 )
    {
      if ( *v7 == 94 )
        ++v7;
      for ( ; v7 != v36; v12 = (unsigned int)v36 )
      {
        v13 = *v7;
        ++v7;
        if ( v13 == 92 )
        {
          v15 = *v7;
          v16 = *v7;
          ++v7;
          switch ( v16 )
          {
            case 98:
              v14 = 8;
              goto LABEL_67;
            case 102:
              v14 = 12;
              goto LABEL_67;
            case 110:
              v14 = 10;
              goto LABEL_67;
            case 114:
              v14 = 13;
              goto LABEL_67;
            case 116:
              v14 = 9;
              goto LABEL_67;
            case 118:
              v14 = 11;
              goto LABEL_67;
            case 99:
              v17 = v7 + 1;
              if ( (unsigned int)(v7 + 1) < v12
                && ((574 >> (dword_100CED28[4
                                          * (unsigned __int8)byte_100CCEA8[*v17 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v17 >> 6] << 6)]] & 0x1F)) & 1
                 || *v17 == 95) )
              {
                v14 = *(_BYTE *)v7 & 0x1F;
                ++v7;
              }
              else
              {
                --v7;
                v14 = 92;
              }
              goto LABEL_67;
            case 120:
              v18 = 2;
              goto LABEL_29;
            case 117:
              v18 = 4;
LABEL_29:
              v19 = 0;
              v20 = 0;
              if ( v18 <= 0 )
                goto LABEL_35;
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              v22 = *v7;
              v23 = v16 - 48;
              if ( (unsigned __int16)(*v7 - 48) > 7u )
                goto LABEL_41;
              ++v7;
              v23 = v22 + 8 * v23 - 48;
              if ( (unsigned __int16)(*v7 - 48) > 7u )
                goto LABEL_41;
              v24 = *v7 + 8 * v23 - 48;
              ++v7;
              if ( v24 > 255 )
              {
                --v7;
LABEL_41:
                v14 = v23;
              }
              else
              {
                v14 = v24;
              }
              goto LABEL_67;
            case 100:
              sub_100230D0(0x30u, v6, 0x39u);
              v6 = a2;
              continue;
            case 68:
              sub_100230D0(0, v6, 0x2Fu);
              v6 = a2;
              sub_100230D0(0x3Au, a2, *(_WORD *)(a2 + 8));
              continue;
            case 115:
              v25 = *(_WORD *)(v6 + 8);
              do
              {
                if ( (*(_DWORD *)&dword_100CED28[4
                                               * (unsigned __int8)byte_100CCEA8[v25 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v25 >> 6] << 6)]] & 0x70000) == 0x40000 )
                  sub_100230B0(v25, v6);
                --v25;
              }
              while ( v25 >= 0 );
              continue;
            case 83:
              v26 = *(_WORD *)(v6 + 8);
              do
              {
                if ( (*(_DWORD *)&dword_100CED28[4
                                               * (unsigned __int8)byte_100CCEA8[v26 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v26 >> 6] << 6)]] & 0x70000) != 0x40000 )
                  sub_100230B0(v26, v6);
                --v26;
              }
              while ( v26 >= 0 );
              continue;
            case 119:
              v27 = *(_WORD *)(v6 + 8);
              do
              {
                if ( (574 >> (dword_100CED28[4
                                           * (unsigned __int8)byte_100CCEA8[v27 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v27 >> 6] << 6)]] & 0x1F)) & 1
                  || v27 == 95 )
                {
                  sub_100230B0(v27, v6);
                }
                --v27;
              }
              while ( v27 >= 0 );
              continue;
            case 87:
              v28 = *(_WORD *)(v6 + 8);
              do
              {
                if ( !((574 >> (dword_100CED28[4
                                             * (unsigned __int8)byte_100CCEA8[v28 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v28 >> 6] << 6)]] & 0x1F)) & 1)
                  && v28 != 95 )
                {
                  sub_100230B0(v28, v6);
                }
                --v28;
              }
              while ( v28 >= 0 );
              continue;
            default:
              v14 = v15;
              goto LABEL_67;
          }
          while ( v7 < v36 )
          {
            v21 = *v7;
            ++v7;
            if ( !sub_10022130(v21, &v38) )
            {
              v7 = (_WORD *)((char *)v7 + -2 - 2 * v20);
              LOWORD(v19) = 92;
              break;
            }
            v19 = v38 | 16 * v19;
            if ( ++v20 >= v18 )
            {
              v6 = a2;
              v14 = v19;
              goto LABEL_67;
            }
          }
LABEL_35:
          v6 = a2;
          v14 = v19;
        }
        else
        {
          v14 = v13;
        }
LABEL_67:
        if ( v37 )
        {
          if ( *(_BYTE *)(*(_DWORD *)(a1 + 4) + 7) & 1 )
          {
            v29 = sub_10022040(v14);
            v30 = sub_10022040(v35);
            sub_100230D0(v30, v6, v29);
            v34 = sub_10022090(v14);
            v6 = a2;
            v31 = sub_10022090(v35);
          }
          else
          {
            v31 = v35;
            v34 = v14;
          }
          sub_100230D0(v31, v6, v34);
          v6 = a2;
          v37 = 0;
        }
        else
        {
          if ( *(_BYTE *)(*(_DWORD *)(a1 + 4) + 7) & 1 )
          {
            v32 = sub_10022040(v14);
            sub_100230B0(v32, v6);
            v33 = sub_10022090(v14);
          }
          else
          {
            v33 = v14;
          }
          sub_100230B0(v33, v6);
          if ( v7 < v36 - 1 && *v7 == 45 )
          {
            ++v7;
            v37 = 1;
            v35 = v14;
          }
        }
      }
    }
    result = (void *)1;
  }
  return result;
}

//----- (100236A0) --------------------------------------------------------
void __cdecl sub_100236A0(int a1, unsigned int a2)
{
  bool v2; // zf@1
  unsigned int v3; // ebx@3
  int v4; // edi@4
  int v5; // eax@5

  v2 = (*(_DWORD *)a2)-- == 1;
  if ( v2 )
  {
    if ( *(_DWORD *)(a2 + 12) )
    {
      v3 = 0;
      if ( *(_DWORD *)(a2 + 8) )
      {
        v4 = 0;
        do
        {
          v5 = v4 + *(_DWORD *)(a2 + 12);
          if ( *(_DWORD *)v5 )
            sub_10010340(a1, *(_DWORD *)(v5 + 12));
          *(_DWORD *)(v4 + *(_DWORD *)(a2 + 12) + 12) = 0;
          ++v3;
          v4 += 16;
        }
        while ( v3 < *(_DWORD *)(a2 + 8) );
      }
      sub_10010340(a1, *(_DWORD *)(a2 + 12));
    }
    sub_10010340(a1, a2);
  }
}

//----- (10023720) --------------------------------------------------------
signed int __usercall sub_10023720@<eax>(int a1@<esi>)
{
  char *v1; // ecx@1
  __int16 v2; // bx@1
  size_t v3; // eax@1
  int v4; // edi@1
  unsigned int v5; // edx@2
  int *v6; // eax@5
  signed int result; // eax@10
  int v8; // [sp-4h] [bp-Ch]@4

  v1 = *(char **)(a1 + 28);
  v2 = *(_WORD *)(a1 + 34);
  v3 = 20 * *(_WORD *)(a1 + 34);
  v4 = *(_DWORD *)(a1 + 68);
  if ( *(char **)(v4 + 12) == &v1[(v3 + 3) & 0xFFFFFFFC] )
  {
    v5 = (unsigned int)&v1[(40 * *(_WORD *)(a1 + 34) + 3) & 0xFFFFFFFC];
    if ( v5 <= *(_DWORD *)(v4 + 8) )
    {
      *(_DWORD *)(v4 + 12) = v5;
      goto LABEL_9;
    }
    v8 = 20 * *(_WORD *)(a1 + 34);
    if ( v1 == *(char **)(v4 + 4) )
      v6 = sub_1003E400(a1 + 52, (int)v1, v3, v8);
    else
      v6 = sub_1003E510(a1 + 52, v1, v3, v8);
  }
  else
  {
    v6 = sub_1003E510(a1 + 52, v1, v3, 20 * *(_WORD *)(a1 + 34));
  }
  *(_DWORD *)(a1 + 28) = v6;
LABEL_9:
  if ( *(_DWORD *)(a1 + 28) )
  {
    *(_WORD *)(a1 + 34) = 2 * v2;
    result = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    result = 0;
  }
  return result;
}

//----- (100237B0) --------------------------------------------------------
void *__usercall sub_100237B0@<eax>(int a1@<eax>, unsigned __int16 **a2, int a3, _BYTE **a4, int a5)
{
  unsigned __int16 **v5; // ebp@1
  int v6; // esi@1
  _BYTE *v7; // ebx@1
  unsigned __int16 *v8; // edi@1
  __int16 v9; // ax@5
  void *result; // eax@10
  unsigned __int16 v11; // ax@14
  int v12; // edx@22
  int v13; // eax@27
  int v14; // edx@34
  int v15; // eax@39
  unsigned __int16 v16; // ax@44
  bool v17; // zf@50
  int v18; // edx@66
  __int16 v19; // cx@66
  int v20; // ecx@67
  __int16 v21; // ax@67
  _BYTE *v22; // ebx@67
  __int16 v23; // dx@67
  int v24; // ebp@67
  int v25; // ecx@67
  int v26; // edi@67
  unsigned int v27; // eax@67
  int v28; // edx@68
  unsigned int v29; // eax@69
  int v30; // edx@74
  unsigned __int16 *v31; // eax@74
  unsigned __int16 *v32; // ebp@74
  int v33; // ecx@75
  int v34; // edx@76
  __int16 v35; // cx@80
  int v36; // eax@82
  __int16 v37; // dx@82
  _BYTE *v38; // ebx@82
  __int16 v39; // cx@82
  int v40; // edi@82
  int v41; // ebp@82
  int v42; // ecx@82
  unsigned int v43; // eax@82
  int v44; // ebp@82
  int v45; // edx@83
  unsigned int v46; // eax@84
  unsigned __int16 v47; // cx@90
  unsigned __int16 v48; // si@91
  __int16 v49; // dx@92
  unsigned __int16 v50; // ax@94
  unsigned __int16 v51; // si@95
  int v52; // ecx@96
  __int16 v53; // dx@96
  int v54; // eax@97
  unsigned __int16 v55; // dx@97
  unsigned __int16 v56; // cx@97
  int v57; // edx@101
  __int16 v58; // cx@101
  int v59; // eax@101
  unsigned __int16 v60; // dx@102
  int v61; // eax@102
  unsigned __int16 v62; // cx@102
  unsigned __int16 *v63; // [sp+10h] [bp-4h]@1
  unsigned __int16 v64; // [sp+1Ch] [bp+8h]@91
  unsigned __int16 v65; // [sp+1Ch] [bp+8h]@95

  v5 = a2;
  v6 = a1;
  v7 = *a4;
  v8 = *a2;
  v63 = *a2;
  switch ( a3 )
  {
    case 2:
      if ( v8 == *(unsigned __int16 **)(a1 + 20) )
        goto LABEL_107;
      if ( *(_DWORD *)(*(_DWORD *)a1 + 132) || *(_BYTE *)(*(_DWORD *)(a1 + 4) + 7) & 4 )
      {
        v9 = *(v8 - 1);
        if ( v9 == 10 || v9 == 13 || v9 == 8232 || v9 == 8233 )
          goto LABEL_107;
      }
      goto LABEL_9;
    default:
      goto LABEL_9;
    case 3:
      if ( v8 == *(unsigned __int16 **)(a1 + 24) )
        goto LABEL_107;
      if ( *(_DWORD *)(*(_DWORD *)a1 + 132) || *(_BYTE *)(*(_DWORD *)(a1 + 4) + 7) & 4 )
      {
        v11 = *v8;
        if ( *v8 == 10 || v11 == 13 || v11 == 8232 || v11 == 8233 )
          goto LABEL_107;
      }
      goto LABEL_9;
    case 4:
      v12 = v8 == *(unsigned __int16 **)(a1 + 20)
         || !((574 >> (dword_100CED28[4
                                    * (unsigned __int8)byte_100CCEA8[*(v8 - 1) & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*(v8 - 1) >> 6] << 6)]] & 0x1F)) & 1)
         && *(v8 - 1) != 95;
      v13 = v8 == *(unsigned __int16 **)(a1 + 24)
         || !((574 >> (dword_100CED28[4
                                    * (unsigned __int8)byte_100CCEA8[*v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v8 >> 6] << 6)]] & 0x1F)) & 1)
         && *v8 != 95;
      if ( v13 ^ v12 )
        goto LABEL_107;
      goto LABEL_9;
    case 5:
      v14 = v8 == *(unsigned __int16 **)(a1 + 20)
         || !((574 >> (dword_100CED28[4
                                    * (unsigned __int8)byte_100CCEA8[*(v8 - 1) & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*(v8 - 1) >> 6] << 6)]] & 0x1F)) & 1)
         && *(v8 - 1) != 95;
      v15 = v8 != *(unsigned __int16 **)(a1 + 24)
         && ((574 >> (dword_100CED28[4
                                   * (unsigned __int8)byte_100CCEA8[*v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v8 >> 6] << 6)]] & 0x1F)) & 1
          || *v8 == 95);
      if ( v15 ^ v14 )
        goto LABEL_107;
      goto LABEL_9;
    case 6:
      if ( v8 != *(unsigned __int16 **)(a1 + 24) )
      {
        v16 = *v8;
        if ( *v8 != 10 && v16 != 13 && v16 != 8232 && v16 != 8233 )
          goto LABEL_106;
      }
      goto LABEL_9;
    case 7:
      if ( v8 == *(unsigned __int16 **)(a1 + 24) )
        goto LABEL_9;
      v17 = (dword_100CED28[4
                          * (unsigned __int8)byte_100CCEA8[*v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v8 >> 6] << 6)]] & 0x1F) == 9;
      goto LABEL_105;
    case 8:
      if ( v8 != *(unsigned __int16 **)(a1 + 24)
        && (dword_100CED28[4
                         * (unsigned __int8)byte_100CCEA8[*v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v8 >> 6] << 6)]] & 0x1F) != 9 )
      {
        goto LABEL_106;
      }
      goto LABEL_9;
    case 9:
      if ( v8 == *(unsigned __int16 **)(a1 + 24) )
        goto LABEL_9;
      if ( (574 >> (dword_100CED28[4
                                 * (unsigned __int8)byte_100CCEA8[*v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v8 >> 6] << 6)]] & 0x1F)) & 1 )
        goto LABEL_106;
      v17 = *v8 == 95;
      goto LABEL_105;
    case 10:
      if ( v8 != *(unsigned __int16 **)(a1 + 24)
        && !((574 >> (dword_100CED28[4
                                   * (unsigned __int8)byte_100CCEA8[*v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v8 >> 6] << 6)]] & 0x1F)) & 1)
        && *v8 != 95 )
      {
        goto LABEL_106;
      }
      goto LABEL_9;
    case 11:
      if ( v8 == *(unsigned __int16 **)(a1 + 24) )
        goto LABEL_9;
      v17 = (*(_DWORD *)&dword_100CED28[4
                                      * (unsigned __int8)byte_100CCEA8[*v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v8 >> 6] << 6)]] & 0x70000) == 0x40000;
      goto LABEL_105;
    case 12:
      if ( v8 != *(unsigned __int16 **)(a1 + 24)
        && (*(_DWORD *)&dword_100CED28[4
                                     * (unsigned __int8)byte_100CCEA8[*v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*v8 >> 6] << 6)]] & 0x70000) != 0x40000 )
      {
        goto LABEL_106;
      }
      goto LABEL_9;
    case 13:
      v18 = v7[1];
      LOBYTE(v19) = 0;
      HIBYTE(v19) = *v7;
      v7 += 2;
      result = sub_10022FE0(v18 | v19, a1, a2);
      goto LABEL_108;
    case 14:
      v20 = v7[1];
      LOBYTE(v21) = 0;
      HIBYTE(v21) = *v7;
      v22 = v7 + 2;
      LOBYTE(v23) = 0;
      HIBYTE(v23) = *v22;
      v7 = v22 + 2;
      v24 = v20 | v21;
      v25 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 16);
      v26 = *(v7 - 1) | v23;
      v27 = *(_DWORD *)v25;
      if ( *(_DWORD *)v25 & 0x40000000 )
      {
        v28 = *(_DWORD *)(v25 + 4);
        if ( *(_DWORD *)v28 & 0x40000000 )
        {
          v29 = sub_1001A200(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 16));
        }
        else if ( (v27 & 0x80000000) == 0 )
        {
          v29 = *(_DWORD *)(v28 + 4) + 2 * ((v27 >> 15) & 0x7FFF);
        }
        else
        {
          v29 = *(_DWORD *)(v28 + 4);
        }
      }
      else
      {
        v29 = *(_DWORD *)(v25 + 4);
      }
      v30 = v29 + 2 * v24;
      v31 = *a2;
      v32 = &(*a2)[v26];
      if ( (unsigned int)v32 > *(_DWORD *)(v6 + 24) )
        goto LABEL_9;
      v33 = 0;
      if ( v26 <= 0 )
        goto LABEL_79;
      v34 = v30 - (_DWORD)v31;
      break;
    case 15:
      v35 = *v7++;
      if ( v8 == *(unsigned __int16 **)(a1 + 24) )
        goto LABEL_9;
      v17 = *v8 == v35;
      goto LABEL_105;
    case 16:
      v36 = v7[1];
      LOBYTE(v37) = 0;
      HIBYTE(v37) = *v7;
      v38 = v7 + 2;
      LOBYTE(v39) = 0;
      HIBYTE(v39) = *v38;
      v7 = v38 + 2;
      v40 = v36 | v37;
      v41 = v39;
      v42 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 16);
      v43 = *(_DWORD *)v42;
      v44 = *(v7 - 1) | v41;
      if ( *(_DWORD *)v42 & 0x40000000 )
      {
        v45 = *(_DWORD *)(v42 + 4);
        if ( *(_DWORD *)v45 & 0x40000000 )
        {
          v46 = sub_1001A200(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 16));
        }
        else if ( (v43 & 0x80000000) == 0 )
        {
          v46 = *(_DWORD *)(v45 + 4) + 2 * ((v43 >> 15) & 0x7FFF);
        }
        else
        {
          v46 = *(_DWORD *)(v45 + 4);
        }
      }
      else
      {
        v46 = *(_DWORD *)(v42 + 4);
      }
      result = sub_10022F50((unsigned __int16 *)(v46 + 2 * v40), v6, (unsigned int *)a2, v44);
      v5 = a2;
      goto LABEL_108;
    case 17:
      v47 = *v7++;
      if ( v8 == *(unsigned __int16 **)(a1 + 24) )
        goto LABEL_9;
      v48 = v47;
      v64 = sub_10022040(*v8);
      v17 = v64 == sub_10022040(v48);
      goto LABEL_105;
    case 18:
      HIBYTE(v49) = *v7;
      v7 += 2;
      if ( v8 == *(unsigned __int16 **)(a1 + 24) )
        goto LABEL_9;
      LOBYTE(v49) = *(v7 - 1);
      v17 = *v8 == v49;
      goto LABEL_105;
    case 19:
      HIBYTE(v50) = *v7;
      v7 += 2;
      if ( v8 == *(unsigned __int16 **)(v6 + 24) )
        goto LABEL_9;
      LOBYTE(v50) = *(v7 - 1);
      v51 = v50;
      v65 = sub_10022040(*v8);
      v17 = v65 == sub_10022040(v51);
      goto LABEL_105;
    case 22:
      v52 = v7[1];
      LOBYTE(v53) = 0;
      HIBYTE(v53) = *v7;
      v7 += 2;
      if ( v8 != *(unsigned __int16 **)(a1 + 24) )
      {
        v54 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16 * (v52 | v53);
        v55 = *v8;
        v56 = *(_WORD *)(v54 + 8);
        if ( v56 )
        {
          if ( v55 <= v56
            && (unsigned __int8)(1 << (v55 & 7)) & *(_BYTE *)(((unsigned int)v55 >> 3) + *(_DWORD *)(v54 + 12)) )
          {
            goto LABEL_106;
          }
        }
      }
      goto LABEL_9;
    case 23:
      v57 = v7[1];
      LOBYTE(v58) = 0;
      HIBYTE(v58) = *v7;
      v7 += 2;
      v59 = v57 | v58;
      if ( v8 == *(unsigned __int16 **)(v6 + 24) )
        goto LABEL_9;
      v60 = *v8;
      v61 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16 * v59;
      v62 = *(_WORD *)(v61 + 8);
      if ( v62 )
      {
        if ( v60 <= v62 )
        {
          v17 = ((unsigned __int8)(1 << (v60 & 7)) & *(_BYTE *)(((unsigned int)v60 >> 3) + *(_DWORD *)(v61 + 12))) == 0;
LABEL_105:
          if ( !v17 )
            goto LABEL_9;
        }
      }
LABEL_106:
      *a2 = v8 + 1;
LABEL_107:
      result = a2;
      goto LABEL_108;
  }
  do
  {
    if ( *(unsigned __int16 *)((char *)v31 + v34) != *v31 )
      return 0;
    ++v33;
    ++v31;
  }
  while ( v33 < v26 );
LABEL_79:
  result = a2;
  *a2 = v32;
  v5 = a2;
LABEL_108:
  if ( !result )
  {
LABEL_9:
    *a2 = v63;
    return 0;
  }
  if ( a5 )
    *a4 = v7;
  else
    *v5 = v63;
  return result;
}

//----- (10023ED0) --------------------------------------------------------
int __usercall sub_10023ED0@<eax>(int a1@<eax>, unsigned __int16 **a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // edi@1
  unsigned __int16 *v5; // edi@1
  unsigned __int16 **v6; // eax@3
  int result; // eax@5
  unsigned __int16 **v8; // eax@11
  __int16 v9; // ax@12
  int v10; // ebp@12
  __int16 v11; // ax@13
  int v12; // edi@13
  __int16 v13; // cx@13
  int v14; // eax@15
  bool v15; // zf@15
  unsigned __int16 v16; // dx@18
  unsigned __int16 v17; // cx@18
  int v18; // ecx@21
  _BYTE *v19; // edi@25
  __int16 v20; // ax@25
  __int16 v21; // dx@25
  __int16 v22; // cx@25
  __int16 v23; // ax@26
  int v24; // ecx@29
  __int16 v25; // ax@29
  _BYTE *v26; // edi@29
  unsigned __int16 *v27; // ebp@31
  int v28; // eax@34
  __int16 v29; // cx@38
  __int16 v30; // ax@40
  int v31; // eax@40
  int v32; // edx@43
  __int16 v33; // cx@43
  __int16 v34; // ax@44
  char *v35; // eax@44
  _BYTE *v36; // edi@44
  int v37; // ecx@48
  signed int v38; // eax@48
  __int16 v39; // cx@51
  char *v40; // eax@51
  _BYTE *v41; // edi@51
  int v42; // edx@55
  signed int v43; // ecx@55
  int v44; // edx@58
  int v45; // ebp@58
  int v46; // ebp@62
  size_t v47; // ST14_4@62
  void *v48; // ST0C_4@62
  int v49; // edx@62
  unsigned __int16 v50; // ax@62
  int v51; // edx@64
  int v52; // ecx@64
  int v53; // ebp@64
  int v54; // eax@64
  __int16 v55; // cx@70
  __int16 v56; // dx@70
  int v57; // edx@72
  __int16 v58; // ax@72
  int v59; // ecx@72
  int v60; // eax@72
  int v61; // eax@75
  __int16 v62; // cx@75
  int v63; // eax@77
  int v64; // ebp@83
  __int16 v65; // ax@85
  __int16 v66; // ax@89
  unsigned __int16 *v67; // edx@92
  int v68; // eax@92
  __int16 v69; // ax@104
  __int16 v70; // ax@108
  __int16 v71; // cx@108
  int v72; // eax@109
  __int16 v73; // ax@114
  int v74; // ecx@114
  int v75; // eax@114
  int v76; // ebp@115
  __int16 v77; // ax@116
  signed int v78; // ecx@118
  unsigned int v79; // ecx@118
  unsigned int v80; // ebp@118
  _DWORD *v81; // eax@119
  int v82; // ecx@119
  __int16 v83; // ax@124
  __int16 v84; // ax@129
  unsigned int v85; // edx@132
  unsigned int v86; // ecx@132
  _DWORD *v87; // eax@133
  int v88; // ecx@133
  int v89; // edx@138
  __int16 v90; // dx@141
  int v91; // eax@141
  int v92; // edx@141
  unsigned int v93; // ebp@142
  _DWORD *v94; // eax@143
  int v95; // ecx@143
  char v96; // [sp-18h] [bp-3Ch]@35
  int v97; // [sp-14h] [bp-38h]@35
  int v98; // [sp-10h] [bp-34h]@35
  unsigned __int16 *v99; // [sp-Ch] [bp-30h]@35
  int v100; // [sp+10h] [bp-14h]@1
  unsigned __int16 *v101; // [sp+14h] [bp-10h]@1
  unsigned __int16 **v102; // [sp+18h] [bp-Ch]@1
  unsigned __int16 *v103; // [sp+1Ch] [bp-8h]@3
  unsigned int v104; // [sp+20h] [bp-4h]@1

  v2 = (int)a2;
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 4);
  v100 = *(_BYTE *)(v4 + 20);
  v5 = (unsigned __int16 *)(v4 + 21);
  v102 = 0;
  v104 = 0;
  v101 = v5;
  if ( (unsigned int)(v100 - 2) < 0x17 )
  {
    if ( (unsigned int)*a2 > *(_DWORD *)(a1 + 24) )
      return 0;
    while ( 1 )
    {
      v103 = v5;
      v6 = (unsigned __int16 **)sub_100237B0(v3, a2, v100, (_BYTE **)&v103, 1);
      v102 = v6;
      if ( v6 )
        break;
      ++*(_DWORD *)(v3 + 16);
      ++*a2;
      if ( (unsigned int)*a2 > *(_DWORD *)(v3 + 24) )
        return 0;
    }
    v5 = v103;
    v2 = (int)v6;
    a2 = v6;
    goto LABEL_7;
  }
LABEL_10:
  while ( 2 )
  {
    if ( (unsigned int)(v100 - 2) < 0x17 )
    {
      v8 = (unsigned __int16 **)sub_100237B0(v3, (unsigned __int16 **)v2, v100, (_BYTE **)&v101, 1);
      v5 = v101;
      v102 = v8;
      goto LABEL_60;
    }
    v9 = *(_WORD *)(v3 + 32);
    v10 = *(_DWORD *)(v3 + 28) + 20 * *(_WORD *)(v3 + 32);
    switch ( v100 )
    {
      case 55:
        HIBYTE(v11) = *((_BYTE *)v5 + 2);
        v12 = (int)(v5 + 1);
        LOBYTE(v13) = 0;
        HIBYTE(v13) = *(_BYTE *)(v12 + 2);
        v5 = (unsigned __int16 *)(v12 + 4);
        if ( *(_DWORD *)v2 == *(_DWORD *)(v3 + 24) )
          goto LABEL_24;
        LOBYTE(v11) = *((_BYTE *)v5 - 3);
        if ( **(_WORD **)v2 == v11 )
          goto LABEL_29;
        v14 = *(_DWORD *)(*(_DWORD *)(v3 + 4) + 12) + 16 * (*((_BYTE *)v5 - 1) | v13);
        v15 = *(_DWORD *)v14 == 0;
        v103 = (unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)(v3 + 4) + 12) + 16 * (*((_BYTE *)v5 - 1) | v13));
        if ( !v15 )
          goto LABEL_18;
        if ( !sub_10023150(v3, v14) )
          return 0;
        v14 = (int)v103;
LABEL_18:
        v16 = *(_WORD *)(v14 + 8);
        v17 = **(_WORD **)v2;
        v18 = 1;
        if ( v16 )
        {
          if ( v17 <= v16 )
          {
            v15 = ((unsigned __int8)(1 << (v17 & 7)) & *(_BYTE *)(((unsigned int)v17 >> 3) + *(_DWORD *)(v14 + 12))) == 0;
            v14 = (int)v103;
            v2 = (int)a2;
            if ( !v15 )
              v18 = 0;
          }
        }
        if ( v18 == *(_DWORD *)(v14 + 4) )
          goto LABEL_24;
        goto LABEL_29;
      default:
        goto LABEL_24;
      case 54:
        v19 = v5 + 1;
        HIBYTE(v20) = *v19;
        v19 += 2;
        HIBYTE(v21) = *v19;
        v5 = (unsigned __int16 *)(v19 + 2);
        LOBYTE(v20) = *((_BYTE *)v5 - 3);
        v22 = v20;
        if ( *(_DWORD *)v2 != *(_DWORD *)(v3 + 24) )
        {
          v23 = **(_WORD **)v2;
          if ( v23 == v22 )
            goto LABEL_29;
          LOBYTE(v21) = *((_BYTE *)v5 - 1);
          if ( v23 == v21 )
            goto LABEL_29;
        }
        v102 = 0;
        goto LABEL_61;
      case 1:
LABEL_29:
        v24 = *((_BYTE *)v5 + 1);
        LOBYTE(v25) = 0;
        HIBYTE(v25) = *(_BYTE *)v5;
        *(_DWORD *)(v10 + 8) = v104;
        ++*(_WORD *)(v3 + 32);
        v103 = (unsigned __int16 *)((char *)v5 + (v24 | v25));
        v26 = v5 + 1;
        if ( *(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 34) && !sub_10023720(v3) )
          return 0;
        v27 = *(unsigned __int16 **)v2;
        v100 = *v26;
        v5 = (unsigned __int16 *)(v26 + 1);
        v101 = v5;
        if ( (unsigned int)(v100 - 2) >= 0x17 )
          goto LABEL_35;
        if ( !sub_100237B0(v3, (unsigned __int16 **)v2, v100, (_BYTE **)&v101, 1) )
        {
          v5 = v103;
          v100 = *(_BYTE *)v103;
          goto LABEL_8;
        }
        v28 = *(_BYTE *)v101;
        v5 = (unsigned __int16 *)((char *)v101 + 1);
        v102 = (unsigned __int16 **)v2;
        v100 = v28;
        v101 = (unsigned __int16 *)((char *)v101 + 1);
LABEL_35:
        v99 = v27;
        v98 = v2;
        v97 = (int)v103 + 1;
        v96 = *(_BYTE *)v103;
        goto LABEL_36;
      case 31:
        LOBYTE(v29) = 0;
        *(_WORD *)(v3 + 32) = v9 - 1;
        HIBYTE(v29) = *(_BYTE *)v5;
        v5 = (unsigned __int16 *)((char *)v5 + (*((_BYTE *)v5 + 1) | v29));
        goto LABEL_7;
      case 56:
        *(_WORD *)(v3 + 32) = v9 - 1;
        v100 = *(_BYTE *)v5;
        goto LABEL_8;
      case 29:
        LOBYTE(v30) = 0;
        HIBYTE(v30) = *(_BYTE *)v5;
        v31 = *((_BYTE *)v5 + 1) | v30;
        if ( v31 + 1 > v104 )
          v104 = v31 + 1;
        ++v5;
        *(_DWORD *)(v2 + 8 * v31 + 4) = (*(_DWORD *)v2 - *(_DWORD *)(v3 + 20)) >> 1;
        *(_WORD *)(v2 + 8 * v31 + 8) = 0;
        v100 = *(_BYTE *)v5;
        goto LABEL_8;
      case 30:
        v32 = *((_BYTE *)v5 + 1);
        LOBYTE(v33) = 0;
        HIBYTE(v33) = *(_BYTE *)v5;
        ++v5;
        *(_WORD *)(v2 + 8 * (v32 | v33) + 8) = (*(_DWORD *)v2
                                              + -2 * *(_DWORD *)(v2 + 8 * (v32 | v33) + 4)
                                              - *(_DWORD *)(v3 + 20)) >> 1;
        v100 = *(_BYTE *)v5;
        goto LABEL_8;
      case 43:
        LOBYTE(v34) = 0;
        HIBYTE(v34) = *(_BYTE *)v5;
        v35 = (char *)v5 + (*((_BYTE *)v5 + 1) | v34);
        v36 = v5 + 1;
        v103 = (unsigned __int16 *)v35;
        v100 = *v36;
        v5 = (unsigned __int16 *)(v36 + 1);
        v101 = v5;
        if ( (unsigned int)(v100 - 2) >= 0x17 )
          goto LABEL_48;
        if ( !sub_100237B0(v3, (unsigned __int16 **)v2, v100, (_BYTE **)&v101, 0) )
        {
          v102 = 0;
          goto LABEL_61;
        }
        v5 = v101;
LABEL_48:
        *(_DWORD *)(v10 + 12) = *(_DWORD *)(v3 + 40) - *(_DWORD *)(v3 + 36);
        v37 = v104;
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v3 + 48);
        v38 = *(_DWORD *)v2 - *(_DWORD *)(v3 + 20);
        *(_DWORD *)(v10 + 8) = v37;
        *(_WORD *)(v10 + 6) = v38 >> 1;
        if ( ++*(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 34) && !sub_10023720(v3) )
          return 0;
        v99 = *(unsigned __int16 **)v2;
        v98 = v2;
        v97 = (int)v103;
        v96 = 45;
        goto LABEL_36;
      case 44:
        LOBYTE(v39) = 0;
        HIBYTE(v39) = *(_BYTE *)v5;
        v40 = (char *)v5 + (*((_BYTE *)v5 + 1) | v39);
        v41 = v5 + 1;
        v103 = (unsigned __int16 *)v40;
        v100 = *v41;
        v5 = (unsigned __int16 *)(v41 + 1);
        v101 = v5;
        if ( (unsigned int)(v100 - 2) >= 0x17 )
          goto LABEL_55;
        if ( !sub_100237B0(v3, (unsigned __int16 **)v2, v100, (_BYTE **)&v101, 0) )
        {
          v5 = v101;
LABEL_55:
          *(_DWORD *)(v10 + 12) = *(_DWORD *)(v3 + 40) - *(_DWORD *)(v3 + 36);
          v42 = v104;
          *(_DWORD *)(v10 + 16) = *(_DWORD *)(v3 + 48);
          v43 = *(_DWORD *)v2 - *(_DWORD *)(v3 + 20);
          *(_DWORD *)(v10 + 8) = v42;
          *(_WORD *)(v10 + 6) = v43 >> 1;
          if ( ++*(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 34) && !sub_10023720(v3) )
            return 0;
          v99 = *(unsigned __int16 **)v2;
          v98 = v2;
          v97 = (int)v103;
          v96 = 46;
LABEL_36:
          result = sub_10022E00(v3, v96, v97, v98, (int)v99, 0, 0);
          if ( result )
            continue;
          return result;
        }
        v102 = 0;
        goto LABEL_61;
      case 45:
        *(_WORD *)(v3 + 32) = v9 - 1;
        v44 = *(_WORD *)(v10 - 14);
        v45 = v10 - 20;
        *(_DWORD *)v2 = *(_DWORD *)(v3 + 20) + 2 * v44;
        v15 = v102 == 0;
        *(_DWORD *)(v3 + 40) = *(_DWORD *)(v3 + 36) + *(_DWORD *)(v45 + 12);
        *(_DWORD *)(v3 + 48) = *(_DWORD *)(v45 + 16);
        if ( !v15 )
          goto LABEL_59;
        goto LABEL_61;
      case 0:
        goto LABEL_59;
      case 46:
        v51 = *(_DWORD *)(v3 + 20);
        *(_WORD *)(v3 + 32) = v9 - 1;
        v52 = *(_WORD *)(v10 - 14);
        v53 = v10 - 20;
        *(_DWORD *)v2 = v51 + 2 * v52;
        v54 = -(v102 == 0);
        *(_DWORD *)(v3 + 40) = *(_DWORD *)(v3 + 36) + *(_DWORD *)(v53 + 12);
        *(_DWORD *)(v3 + 48) = *(_DWORD *)(v53 + 16);
        v102 = (unsigned __int16 **)(v2 & v54);
        goto LABEL_60;
      case 58:
        if ( !v2 )
          goto LABEL_60;
        return v2;
      case 26:
        *(_WORD *)(v10 + 12) = 0;
        *(_WORD *)(v10 + 14) = -1;
        goto LABEL_71;
      case 27:
        *(_WORD *)(v10 + 12) = 1;
        *(_WORD *)(v10 + 14) = -1;
        goto LABEL_71;
      case 28:
        *(_WORD *)(v10 + 12) = 0;
        *(_WORD *)(v10 + 14) = 1;
        goto LABEL_71;
      case 25:
        HIBYTE(v55) = *(_BYTE *)v5;
        v5 += 2;
        LOBYTE(v55) = *((_BYTE *)v5 - 3);
        *(_WORD *)(v10 + 12) = v55;
        HIBYTE(v56) = *((_BYTE *)v5 - 2);
        LOBYTE(v56) = *((_BYTE *)v5 - 1);
        *(_WORD *)(v10 + 14) = v56;
LABEL_71:
        if ( !*(_WORD *)(v10 + 14) )
        {
          v57 = *((_BYTE *)v5 + 1);
          LOBYTE(v58) = 0;
          HIBYTE(v58) = *(_BYTE *)v5;
          v102 = (unsigned __int16 **)v2;
          v59 = v57 | v58;
          v60 = *((_BYTE *)v5 + v59);
          v5 = (unsigned __int16 *)((char *)v5 + v59);
          v100 = v60;
          goto LABEL_8;
        }
        v100 = *((_BYTE *)v5 + 2);
        v103 = (unsigned __int16 *)((char *)v5 + 3);
        v101 = *(unsigned __int16 **)v2;
        if ( (unsigned int)(v100 - 2) >= 0x17 )
          goto LABEL_77;
        if ( !sub_100237B0(v3, (unsigned __int16 **)v2, v100, (_BYTE **)&v103, 1) )
        {
          v61 = *((_BYTE *)v5 + 1);
          LOBYTE(v62) = 0;
          HIBYTE(v62) = *(_BYTE *)v5;
          v102 = (unsigned __int16 **)(*(_WORD *)(v10 + 12) == 0 ? v2 : 0);
          v5 = (unsigned __int16 *)((char *)v5 + (v61 | v62));
LABEL_60:
          if ( v102 )
          {
            v2 = (int)v102;
            a2 = v102;
            v100 = *(_BYTE *)v5;
            goto LABEL_8;
          }
LABEL_61:
          if ( !*(_DWORD *)(v3 + 48) )
            return 0;
          v46 = *(_DWORD *)(v3 + 40);
          *(_DWORD *)(v3 + 48) = *(_DWORD *)v46;
          *(_DWORD *)(v3 + 40) = v46 - *(_DWORD *)v46;
          *(_DWORD *)v2 = *(_DWORD *)(v46 + 12);
          v5 = *(unsigned __int16 **)(v46 + 4);
          v100 = *(_BYTE *)(v46 + 8);
          *(_WORD *)(v3 + 32) = *(_WORD *)(v46 + 20);
          v47 = 20 * *(_WORD *)(v46 + 20);
          v48 = *(void **)(v3 + 28);
          v101 = v5;
          memcpy(v48, (const void *)(v46 + 24), v47);
          v49 = *(_DWORD *)(v3 + 28) + 20 * *(_WORD *)(v3 + 32) - 20;
          v50 = *(_WORD *)(v46 + 18);
          if ( v50 )
          {
            memcpy(
              (void *)(v2 + 8 * *(_WORD *)(v46 + 16) + 4),
              (const void *)(v46 + 20 * *(_WORD *)(v46 + 20) + 24),
              8 * v50);
            v104 = *(_WORD *)(v46 + 16) + *(_WORD *)(v46 + 18);
          }
          else
          {
            v93 = *(_DWORD *)(v49 + 8);
            if ( v93 < v104 )
            {
              v94 = (_DWORD *)(v2 + 8 * v93 + 4);
              v95 = v104 - v93;
              do
              {
                *v94 = -1;
                v94 += 2;
                --v95;
              }
              while ( v95 );
            }
            v104 = *(_DWORD *)(v49 + 8);
          }
          continue;
        }
        v100 = *(_BYTE *)v103;
        v103 = (unsigned __int16 *)((char *)v103 + 1);
        v102 = (unsigned __int16 **)v2;
LABEL_77:
        v63 = v104;
        *(_WORD *)(v10 + 6) = ((signed int)v101 - *(_DWORD *)(v3 + 20)) >> 1;
        *(_BYTE *)(v10 + 4) = 52;
        *(_DWORD *)v10 = v5;
        *(_DWORD *)(v10 + 8) = v63;
        if ( (++*(_WORD *)(v3 + 32) != *(_WORD *)(v3 + 34) || sub_10023720(v3))
          && (*(_WORD *)(v10 + 12) || sub_10022E00(v3, 52, (int)v5, v2, (int)v101, 0, 0)) )
        {
          v5 = v103;
          goto LABEL_9;
        }
        return 0;
      case 51:
        v5 = *(unsigned __int16 **)(v10 - 20);
        v100 = *(_BYTE *)(v10 - 16);
        goto LABEL_9;
      case 52:
        v64 = v10 - 20;
        while ( 1 )
        {
          --*(_WORD *)(v3 + 32);
          if ( !v102 )
            break;
          v65 = *(_WORD *)(v64 + 12);
          if ( v65 )
          {
            *(_WORD *)(v64 + 12) = v65 - 1;
          }
          else if ( *(_DWORD *)v2 == *(_DWORD *)(v3 + 20) + 2 * *(_WORD *)(v64 + 6) )
          {
            goto LABEL_24;
          }
          v66 = *(_WORD *)(v64 + 14);
          if ( v66 != -1 )
            *(_WORD *)(v64 + 14) = v66 - 1;
          if ( !*(_WORD *)(v64 + 14) )
            goto LABEL_104;
          v67 = *(unsigned __int16 **)v2;
          v103 = v5 + 1;
          v68 = *((_BYTE *)v5 + 2);
          v101 = v67;
          if ( (unsigned int)(v68 - 2) < 0x17 )
          {
            v103 = (unsigned __int16 *)((char *)v103 + 1);
            if ( !sub_100237B0(v3, (unsigned __int16 **)v2, v68, (_BYTE **)&v103, 1) )
            {
              if ( *(_WORD *)(v64 + 12) )
              {
LABEL_24:
                v102 = 0;
                goto LABEL_61;
              }
LABEL_104:
              LOBYTE(v69) = 0;
              HIBYTE(v69) = *(_BYTE *)v5;
              v5 = (unsigned __int16 *)((char *)v5 + (*((_BYTE *)v5 + 1) | v69));
LABEL_59:
              v102 = (unsigned __int16 **)v2;
              goto LABEL_60;
            }
            v102 = (unsigned __int16 **)v2;
          }
          *(_WORD *)(v64 + 6) = ((signed int)v101 - *(_DWORD *)(v3 + 20)) >> 1;
          if ( ++*(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 34) && !sub_10023720(v3)
            || !*(_WORD *)(v64 + 12)
            && !sub_10022E00(v3, 52, (int)v5, v2, (int)v101, *(_DWORD *)(v64 + 8), v104 - *(_DWORD *)(v64 + 8)) )
          {
            return 0;
          }
          if ( *(_BYTE *)v103 != 51 )
          {
            v100 = *(_BYTE *)v103;
            v5 = (unsigned __int16 *)((char *)v103 + 1);
            v104 = *(_DWORD *)(v64 + 8);
LABEL_9:
            v101 = v5;
            goto LABEL_10;
          }
        }
        if ( *(_WORD *)(v64 + 12) )
          goto LABEL_61;
        goto LABEL_104;
      case 47:
        *(_WORD *)(v10 + 12) = 0;
        *(_WORD *)(v10 + 14) = -1;
        goto LABEL_109;
      case 48:
        *(_WORD *)(v10 + 12) = 1;
        *(_WORD *)(v10 + 14) = -1;
        goto LABEL_109;
      case 49:
        *(_WORD *)(v10 + 12) = 0;
        *(_WORD *)(v10 + 14) = 1;
        goto LABEL_109;
      case 50:
        HIBYTE(v70) = *(_BYTE *)v5;
        v5 += 2;
        LOBYTE(v70) = *((_BYTE *)v5 - 3);
        *(_WORD *)(v10 + 12) = v70;
        HIBYTE(v71) = *((_BYTE *)v5 - 2);
        LOBYTE(v71) = *((_BYTE *)v5 - 1);
        *(_WORD *)(v10 + 14) = v71;
LABEL_109:
        v72 = v104;
        *(_WORD *)(v10 + 6) = (*(_DWORD *)v2 - *(_DWORD *)(v3 + 20)) >> 1;
        *(_DWORD *)(v10 + 8) = v72;
        if ( ++*(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 34) && !sub_10023720(v3) )
          return 0;
        if ( *(_WORD *)(v10 + 12) )
        {
          *(_DWORD *)v10 = v5;
          *(_BYTE *)(v10 + 4) = 53;
          ++v5;
LABEL_7:
          v100 = *(_BYTE *)v5;
          goto LABEL_8;
        }
        if ( !sub_10022E00(v3, 53, (int)v5, v2, *(_DWORD *)v2, 0, 0) )
          return 0;
        --*(_WORD *)(v3 + 32);
        LOBYTE(v73) = 0;
        HIBYTE(v73) = *(_BYTE *)v5;
        v74 = *((_BYTE *)v5 + 1) | v73;
        v75 = *((_BYTE *)v5 + v74);
        v5 = (unsigned __int16 *)((char *)v5 + v74);
        v100 = v75;
        goto LABEL_8;
      case 53:
        v76 = v10 - 20;
        v15 = v102 == 0;
        *(_WORD *)(v3 + 32) = v9 - 1;
        if ( v15 )
        {
          v77 = *(_WORD *)(v76 + 14);
          if ( v77 != -1 && !v77 )
            goto LABEL_61;
          v78 = *(_DWORD *)v2 - *(_DWORD *)(v3 + 20);
          *(_DWORD *)v76 = v5;
          *(_WORD *)(v76 + 6) = v78 >> 1;
          v79 = v104;
          *(_BYTE *)(v76 + 4) = 53;
          v80 = *(_DWORD *)(v76 + 8);
          ++v5;
          if ( v80 < v79 )
          {
            v81 = (_DWORD *)(v2 + 8 * v80 + 4);
            v82 = v79 - v80;
            do
            {
              *v81 = -1;
              v81 += 2;
              --v82;
            }
            while ( v82 );
          }
          if ( ++*(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 34) && !sub_10023720(v3) )
            return 0;
          v100 = *(_BYTE *)v5;
        }
        else
        {
          v83 = *(_WORD *)(v76 + 12);
          if ( !v83 )
          {
            if ( *(_DWORD *)v2 != *(_DWORD *)(v3 + 20) + 2 * *(_WORD *)(v76 + 6) )
              goto LABEL_129;
            v102 = 0;
            goto LABEL_61;
          }
          *(_WORD *)(v76 + 12) = v83 - 1;
LABEL_129:
          v84 = *(_WORD *)(v76 + 14);
          if ( v84 != -1 )
            *(_WORD *)(v76 + 14) = v84 - 1;
          if ( *(_WORD *)(v76 + 12) )
          {
            v85 = *(_DWORD *)(v76 + 8);
            v86 = v104;
            *(_DWORD *)v76 = v5;
            ++v5;
            *(_BYTE *)(v76 + 4) = 53;
            if ( v85 < v86 )
            {
              v87 = (_DWORD *)(v2 + 8 * v85 + 4);
              v88 = v86 - v85;
              do
              {
                *v87 = -1;
                v87 += 2;
                --v88;
              }
              while ( v88 );
            }
            *(_WORD *)(v76 + 6) = (*(_DWORD *)v2 - *(_DWORD *)(v3 + 20)) >> 1;
            if ( ++*(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 34) && !sub_10023720(v3) )
              return 0;
            v100 = *(_BYTE *)v5;
          }
          else
          {
            v89 = v104;
            *(_WORD *)(v76 + 6) = (*(_DWORD *)v2 - *(_DWORD *)(v3 + 20)) >> 1;
            *(_DWORD *)(v76 + 8) = v89;
            if ( ++*(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 34) && !sub_10023720(v3)
              || !sub_10022E00(v3, 53, (int)v5, v2, *(_DWORD *)v2, *(_DWORD *)(v76 + 8), v104 - *(_DWORD *)(v76 + 8)) )
            {
              return 0;
            }
            --*(_WORD *)(v3 + 32);
            LOBYTE(v90) = 0;
            HIBYTE(v90) = *(_BYTE *)v5;
            v91 = *((_BYTE *)v5 + 1) | v90;
            v92 = *((_BYTE *)v5 + v91);
            v5 = (unsigned __int16 *)((char *)v5 + v91);
            v100 = v92;
          }
        }
LABEL_8:
        v5 = (unsigned __int16 *)((char *)v5 + 1);
        goto LABEL_9;
    }
  }
}

//----- (10024A70) --------------------------------------------------------
int __usercall sub_10024A70@<eax>(unsigned __int16 **a1@<ebx>, int a2@<esi>)
{
  unsigned __int16 *v2; // edi@1
  unsigned __int16 *v3; // eax@1
  unsigned int v4; // eax@2
  unsigned __int16 **v5; // ecx@3
  int result; // eax@5
  int v7; // eax@7
  int v8; // ecx@7

  v2 = *a1;
  v3 = *a1;
  if ( (unsigned int)*a1 > *(_DWORD *)(a2 + 24) )
  {
LABEL_8:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      *(_DWORD *)(a2 + 16) = v3 - v2;
      *a1 = v3;
      v4 = 0;
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) & 0xFFFFFF )
      {
        v5 = a1 + 1;
        do
        {
          *v5 = (unsigned __int16 *)-1;
          ++v4;
          v5 += 2;
        }
        while ( v4 < (*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) & 0xFFFFFFu) );
      }
      result = sub_10023ED0(a2, a1);
      if ( !*(_DWORD *)(a2 + 8) || result )
        break;
      v7 = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(a2 + 48) = 0;
      *(_WORD *)(a2 + 32) = 0;
      v8 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 40) = v7;
      v3 = &v2[v8 + 1];
      if ( (unsigned int)v3 > *(_DWORD *)(a2 + 24) )
        goto LABEL_8;
    }
  }
  return result;
}

//----- (10024AF0) --------------------------------------------------------
int __usercall sub_10024AF0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  int v3; // ecx@1
  int v4; // eax@1
  unsigned int v5; // ebp@4
  int v7; // ecx@6
  int v8; // eax@6
  int v9; // ecx@10
  int v10; // ebx@10
  unsigned int v11; // eax@10
  int v12; // ebx@15
  int v13; // ecx@16
  int v14; // [sp+0h] [bp-4h]@10

  v3 = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 44) = 8000;
  v4 = *(_DWORD *)(v3 + 12);
  if ( (unsigned int)(v4 + 8000) <= *(_DWORD *)(v3 + 8) )
    *(_DWORD *)(v3 + 12) = v4 + 8000;
  else
    v4 = sub_1003E2D0(a2 + 52, 0x1F40u);
  v5 = 0;
  *(_DWORD *)(a2 + 36) = v4;
  if ( !v4 )
    return 0;
  v7 = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 40) = v4;
  *(_DWORD *)(a2 + 48) = 0;
  *(_WORD *)(a2 + 34) = 100;
  v8 = *(_DWORD *)(v7 + 12);
  if ( (unsigned int)(v8 + 2000) <= *(_DWORD *)(v7 + 8) )
    *(_DWORD *)(v7 + 12) = v8 + 2000;
  else
    v8 = sub_1003E2D0(a2 + 52, 0x7D0u);
  *(_DWORD *)(a2 + 28) = v8;
  if ( !v8 )
    return 0;
  v9 = *(_DWORD *)(a2 + 68);
  *(_DWORD *)a2 = a3;
  *(_WORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 4) = a1;
  *(_DWORD *)(a2 + 8) = 1;
  v10 = *(_DWORD *)(v9 + 12);
  v11 = (8 * (*(_DWORD *)(a1 + 4) & 0xFFFFFF) + 7) & 0xFFFFFFFC;
  v14 = *(_DWORD *)(v9 + 12);
  if ( v10 + v11 <= *(_DWORD *)(v9 + 8) )
  {
    *(_DWORD *)(v9 + 12) = v10 + v11;
  }
  else
  {
    v14 = sub_1003E2D0(a2 + 52, v11);
    v10 = v14;
  }
  if ( v10 )
  {
    if ( *(_DWORD *)(a1 + 8) <= 0u )
      return v10;
    v12 = 0;
    while ( 1 )
    {
      v13 = *(_DWORD *)(a1 + 12);
      if ( !*(_DWORD *)(v12 + v13) && !sub_10023150(a2, v12 + v13) )
        break;
      ++v5;
      v12 += 16;
      if ( v5 >= *(_DWORD *)(a1 + 8) )
        return v14;
    }
  }
  return 0;
}

//----- (10024C00) --------------------------------------------------------
unsigned __int16 **__cdecl sub_10024C00(int a1, int a2, int a3, int *a4, int a5, int *a6)
{
  unsigned int v6; // edi@1
  unsigned int v7; // eax@1
  unsigned int v8; // esi@1
  int v9; // ecx@6
  unsigned int v10; // ebx@7
  unsigned __int16 **result; // eax@12
  int *v12; // ebx@13
  int v13; // ecx@16
  int v14; // esi@16
  int v15; // eax@16
  int v16; // edi@16
  int v17; // esi@18
  char *v18; // eax@20
  int v19; // ecx@25
  unsigned int v20; // ecx@27
  int v21; // edx@28
  signed int v22; // edi@28
  int v23; // esi@28
  void *v24; // eax@33
  unsigned int v25; // ecx@35
  int v26; // ecx@36
  int v27; // eax@40
  int v28; // eax@41
  char *v29; // eax@45
  bool v30; // cf@49
  unsigned int v31; // eax@59
  int v32; // ecx@61
  unsigned int v33; // edx@62
  int v34; // eax@62
  int v35; // edx@65
  int v36; // ecx@68
  unsigned int v37; // eax@69
  int v38; // ecx@75
  unsigned int v39; // [sp-1Ch] [bp-A4h]@44
  int v40; // [sp-18h] [bp-A0h]@44
  signed int v41; // [sp-14h] [bp-9Ch]@44
  signed int v42; // [sp+10h] [bp-78h]@13
  int v43; // [sp+14h] [bp-74h]@1
  unsigned int v44; // [sp+18h] [bp-70h]@17
  int v45; // [sp+1Ch] [bp-6Ch]@28
  int v46; // [sp+20h] [bp-68h]@27
  int v47; // [sp+24h] [bp-64h]@28
  int v48; // [sp+28h] [bp-60h]@1
  void *v49; // [sp+2Ch] [bp-5Ch]@16
  int v50; // [sp+30h] [bp-58h]@16
  int v51; // [sp+34h] [bp-54h]@16
  char v52; // [sp+38h] [bp-50h]@12
  int v53; // [sp+40h] [bp-48h]@13
  unsigned int v54; // [sp+44h] [bp-44h]@12
  int v55; // [sp+48h] [bp-40h]@12
  unsigned int v56; // [sp+4Ch] [bp-3Ch]@12
  int v57; // [sp+50h] [bp-38h]@12
  char v58; // [sp+6Ch] [bp-1Ch]@12

  v6 = *a4;
  v7 = *(_DWORD *)a3;
  v48 = 0;
  v43 = *a4;
  v8 = *(_DWORD *)a3;
  if ( *(_DWORD *)a3 & 0x40000000 )
    v8 = v7 & ((v7 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( v6 > v8 )
  {
    v43 = v8;
    v6 = v8;
  }
  if ( *(_DWORD *)a3 & 0x40000000 )
  {
    v9 = *(_DWORD *)(a3 + 4);
    if ( *(_DWORD *)v9 & 0x40000000 )
    {
      v10 = sub_1001A200(a3);
    }
    else if ( (v7 & 0x80000000) == 0 )
    {
      v10 = *(_DWORD *)(v9 + 4) + 2 * ((v7 >> 15) & 0x7FFF);
    }
    else
    {
      v10 = *(_DWORD *)(v9 + 4);
    }
  }
  else
  {
    v10 = *(_DWORD *)(a3 + 4);
  }
  v56 = v10;
  v57 = v10 + 2 * v8;
  v54 = v6;
  v55 = 0;
  sub_1003E280((int)&v58, (int)"RegExpPool", 8096, 4u);
  result = (unsigned __int16 **)sub_10024AF0(a2, (int)&v52, a1);
  if ( !result )
    return result;
  *result = (unsigned __int16 *)(v10 + 2 * v43);
  v12 = (int *)sub_10024A70(result, (int)&v52);
  v42 = v53;
  if ( !v53 )
    goto LABEL_76;
  if ( !v12 )
  {
    *a6 = 0;
    goto LABEL_76;
  }
  v14 = v43;
  v51 = *v12;
  v13 = *v12;
  v15 = (signed int)(*v12 - v56) >> 1;
  *a4 = v15;
  v16 = v15 - v55 - v43;
  v50 = v16;
  v49 = (void *)(v13 + -2 * v16);
  if ( a5 )
  {
    *a6 = 14;
    v44 = 0;
  }
  else
  {
    v17 = sub_1002EAB0(a1, 0, 0);
    v44 = v17;
    if ( !v17 )
    {
      v42 = 0;
      goto LABEL_76;
    }
    *a6 = v17;
    v18 = sub_1001AB60(a1, v49, v16, 0);
    if ( !v18 )
    {
      *(_DWORD *)(a1 + 92) = 0;
      v42 = 0;
      goto LABEL_76;
    }
    v42 = sub_10018AC0(a1, v17, 1, (unsigned int)v18 | 4, sub_100104C0, sub_100104C0, 1, 0);
    if ( !v42 )
    {
      *(_DWORD *)(a1 + 92) = 0;
      *(_DWORD *)(a1 + 96) = 0;
      goto LABEL_76;
    }
    v14 = v43;
  }
  *(_DWORD *)(a1 + 128) = a3;
  v19 = *(_DWORD *)(a2 + 4) & 0xFFFFFF;
  *(_DWORD *)(a1 + 136) = v19;
  if ( v19 )
  {
    v20 = 0;
    v46 = 0;
    if ( !(*(_DWORD *)(a2 + 4) & 0xFFFFFF) )
    {
LABEL_51:
      if ( *(_DWORD *)v48 == -1 )
      {
        *(_DWORD *)(a1 + 228) = dword_10161A98;
        *(_DWORD *)(a1 + 232) = off_10161A9C;
      }
      else
      {
        *(_DWORD *)(a1 + 232) = v56 + 2 * *(_DWORD *)v48;
        *(_DWORD *)(a1 + 228) = *(_WORD *)(v48 + 4);
      }
      goto LABEL_56;
    }
    v21 = a1 + 144;
    v22 = 2;
    v45 = a1 + 144;
    v23 = (int)(v12 + 1);
    v47 = -76 - (_DWORD)v12;
    while ( 1 )
    {
      v48 = v23;
      if ( v20 < 9 )
      {
        if ( *(_DWORD *)v23 == -1 )
        {
          *(_DWORD *)(v21 + 4) = 0;
          *(_DWORD *)v21 = 0;
        }
        else
        {
          *(_DWORD *)(v21 + 4) = v56 + 2 * *(_DWORD *)v23;
          *(_DWORD *)v21 = *(_WORD *)(v23 + 4);
        }
        goto LABEL_42;
      }
      v24 = *(void **)(a1 + 216);
      if ( !v24 )
        break;
      v25 = *(_DWORD *)(a1 + 140);
      if ( v46 - 9 >= v25 )
      {
        v26 = v25 + 10;
        *(_DWORD *)(a1 + 140) = v26;
        v24 = sub_10011870(a1, v24, 8 * v26);
        goto LABEL_37;
      }
LABEL_38:
      if ( !v24 )
        goto LABEL_53;
      *(_DWORD *)(a1 + 216) = v24;
      if ( *(_DWORD *)v23 == -1 )
      {
        v27 = (int)v24 + v23 + v47;
        *(_DWORD *)(v27 + 4) = 0;
        *(_DWORD *)v27 = 0;
      }
      else
      {
        v28 = (int)v24 + v23 + v47;
        *(_DWORD *)(v28 + 4) = v56 + 2 * *(_DWORD *)v23;
        *(_DWORD *)v28 = *(_WORD *)(v23 + 4);
      }
LABEL_42:
      if ( !a5 )
      {
        if ( *(_DWORD *)v23 == -1 )
        {
          v41 = -2147483647;
          v40 = v22 | 1;
          v39 = v44;
        }
        else
        {
          v29 = sub_1001AB60(a1, (void *)(v56 + 2 * *(_DWORD *)v23), *(_WORD *)(v23 + 4), 0);
          if ( !v29 )
          {
LABEL_53:
            *(_DWORD *)(a1 + 92) = 0;
            *(_DWORD *)(a1 + 96) = 0;
            v42 = 0;
            goto LABEL_76;
          }
          v41 = (unsigned int)v29 | 4;
          v40 = v22 | 1;
          v39 = v44;
        }
        v42 = sub_10018AC0(a1, v39, v40, v41, 0, 0, 1, 0);
        if ( !v42 )
          goto LABEL_54;
        v21 = v45;
      }
      v20 = v46 + 1;
      v21 += 8;
      v23 += 8;
      v22 += 2;
      v30 = v46++ + 1 < (*(_DWORD *)(a2 + 4) & 0xFFFFFFu);
      v45 = v21;
      if ( !v30 )
      {
        v16 = v50;
        v14 = v43;
        goto LABEL_51;
      }
    }
    *(_DWORD *)(a1 + 140) = 10;
    v24 = (void *)sub_10011830(a1, 0x50u);
LABEL_37:
    v21 = v45;
    goto LABEL_38;
  }
  *(_DWORD *)(a1 + 228) = dword_10161A98;
  *(_DWORD *)(a1 + 232) = off_10161A9C;
LABEL_56:
  if ( a5
    || (v42 = sub_10018AC0(
                a1,
                v44,
                *(_DWORD *)(*(_DWORD *)(a1 + 24) + 256),
                2 * (v14 + v55) | 1,
                sub_100104C0,
                sub_100104C0,
                1,
                0)) != 0
    && (v42 = sub_10018AC0(a1, v44, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 260), a3 | 4, sub_100104C0, sub_100104C0, 1, 0)) != 0 )
  {
    *(_DWORD *)(a1 + 224) = v49;
    *(_DWORD *)(a1 + 220) = v16;
    v31 = *(_DWORD *)a3;
    if ( *(_DWORD *)(a1 + 16) == 120 )
    {
      if ( v31 & 0x40000000 )
      {
        v32 = *(_DWORD *)(a3 + 4);
        if ( *(_DWORD *)v32 & 0x40000000 )
        {
          v33 = sub_1001A200(a3) + 2 * v14;
          v34 = v55;
          *(_DWORD *)(a1 + 240) = v33;
        }
        else if ( (v31 & 0x80000000) == 0 )
        {
          v35 = *(_DWORD *)(v32 + 4) + 2 * ((v31 >> 15) & 0x7FFF) + 2 * v14;
          v34 = v55;
          *(_DWORD *)(a1 + 240) = v35;
        }
        else
        {
          v34 = v55;
          *(_DWORD *)(a1 + 240) = *(_DWORD *)(v32 + 4) + 2 * v14;
        }
      }
      else
      {
        v34 = v55;
        *(_DWORD *)(a1 + 240) = *(_DWORD *)(a3 + 4) + 2 * v14;
      }
    }
    else
    {
      if ( v31 & 0x40000000 )
      {
        v36 = *(_DWORD *)(a3 + 4);
        if ( *(_DWORD *)v36 & 0x40000000 )
        {
          v37 = sub_1001A200(a3);
        }
        else if ( (v31 & 0x80000000) == 0 )
        {
          v37 = *(_DWORD *)(v36 + 4) + 2 * ((v31 >> 15) & 0x7FFF);
        }
        else
        {
          v37 = *(_DWORD *)(v36 + 4);
        }
      }
      else
      {
        v37 = *(_DWORD *)(a3 + 4);
      }
      *(_DWORD *)(a1 + 240) = v37;
      v34 = v14 + v55;
    }
    v38 = v57;
    *(_DWORD *)(a1 + 236) = v34;
    *(_DWORD *)(a1 + 248) = v51;
    *(_DWORD *)(a1 + 244) = (v38 - v51) >> 1;
  }
  else
  {
LABEL_54:
    *(_DWORD *)(a1 + 92) = 0;
    *(_DWORD *)(a1 + 96) = 0;
  }
LABEL_76:
  sub_1003E6D0((_DWORD **)&v58);
  return (unsigned __int16 **)v42;
}
// 10161A98: using guessed type int dword_10161A98;

//----- (100251E0) --------------------------------------------------------
signed int __cdecl sub_100251E0(int a1, int a2, signed int a3, int *a4)
{
  signed int result; // eax@4
  unsigned int v5; // eax@5

  if ( a3 & 1 && a3 != -2147483647 )
  {
    if ( a3 >> 1 == -4 )
    {
      result = sub_10011AD0(a1, a2, 0, a4);
    }
    else
    {
      v5 = sub_10012430(a1, a2, (int *)&off_10162008, 0);
      if ( v5 )
      {
        switch ( a3 >> 1 )
        {
          case -1:
            *a4 = *(_DWORD *)(v5 + 16) | 4;
            return 1;
          case -2:
            *a4 = 8 * ((*(_DWORD *)(v5 + 4) >> 25) & 1) | 6;
            return 1;
          case -3:
            *a4 = 8 * (*(_BYTE *)(v5 + 7) & 1) | 6;
            return 1;
          case -5:
            *a4 = 8 * ((*(_DWORD *)(v5 + 4) >> 26) & 1) | 6;
            break;
          default:
            break;
        }
      }
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10011AD0: using guessed type _DWORD __cdecl sub_10011AD0(_DWORD, _DWORD, _DWORD, _DWORD);
// 10162008: using guessed type char *off_10162008;

//----- (100252D0) --------------------------------------------------------
signed int __cdecl sub_100252D0(int a1, int a2, int a3, int *a4)
{
  signed int result; // eax@1
  double v5; // [sp+14h] [bp-8h]@4

  result = 1;
  if ( a3 & 1 && a3 != -2147483647 && (a3 & 0xFFFFFFFE) == -8 )
  {
    result = 0;
    if ( sub_10020030(a1, *a4, &v5) )
    {
      v5 = sub_1001F900(v5);
      if ( sub_1001F600(a1, v5, (int)a4) )
      {
        if ( sub_10011B50(a1, a2, 0, *a4) )
          result = 1;
      }
    }
  }
  return result;
}

//----- (10025370) --------------------------------------------------------
signed int __cdecl sub_10025370(int a1, int a2)
{
  sub_100111B0(a1);
  return sub_1003AB10(a1, a2, (unsigned int)"res->input");
}

//----- (10025390) --------------------------------------------------------
signed int __cdecl sub_10025390(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 88) )
  {
    sub_10010340(a1, *(_DWORD *)(a2 + 88));
    *(_DWORD *)(a2 + 88) = 0;
  }
  return sub_1003A860(*(_DWORD *)(a1 + 24), a2);
}

//----- (100253D0) --------------------------------------------------------
signed int __cdecl sub_100253D0(int a1, int a2, signed int a3, int *a4)
{
  unsigned int v4; // eax@3
  signed int result; // eax@4
  int *v6; // eax@7

  if ( !(a3 & 1) || a3 == -2147483647 )
    goto LABEL_18;
  v4 = a3 >> 1;
  switch ( a3 >> 1 )
  {
    case -1:
      result = *(_DWORD *)(a1 + 128);
      if ( result )
        goto LABEL_17;
      *a4 = sub_10010180(a1);
      return 1;
    case -2:
      *a4 = 8 * *(_DWORD *)(a1 + 132) | 6;
      return 1;
    case -3:
      v6 = (int *)(a1 + 220);
      break;
    case -4:
      v6 = (int *)(a1 + 228);
      break;
    case -5:
      v6 = (int *)(a1 + 236);
      break;
    case -6:
      v6 = (int *)(a1 + 244);
      break;
    default:
      if ( v4 >= *(_DWORD *)(a1 + 136) )
      {
        v6 = &dword_10161A98;
      }
      else if ( v4 >= 9 )
      {
        v6 = (int *)(*(_DWORD *)(a1 + 216) + 8 * v4 - 72);
      }
      else
      {
        v6 = (int *)(a1 + 8 * v4 + 144);
      }
      break;
  }
  result = (signed int)sub_1001AB60(a1, (void *)v6[1], *v6, 0);
  if ( result )
  {
LABEL_17:
    *a4 = result | 4;
LABEL_18:
    result = 1;
  }
  return result;
}
// 10161A98: using guessed type int dword_10161A98;

//----- (100254C0) --------------------------------------------------------
signed int __cdecl sub_100254C0(int a1, int a2, signed int a3, signed int *a4)
{
  signed int result; // eax@6

  if ( a3 & 1 && a3 != -2147483647 )
  {
    if ( a3 >> 1 == -1 )
    {
      if ( (*a4 & 7) == 4 || sub_10011380(a1, *a4, 3, a4) )
      {
        *(_DWORD *)(a1 + 128) = *a4 & 0xFFFFFFF8;
        return 1;
      }
      return 0;
    }
    if ( a3 >> 1 == -2 )
    {
      if ( (*(_BYTE *)a4 & 7) != 6 && !sub_10011380(a1, *a4, 5, a4) )
        return 0;
      *(_DWORD *)(a1 + 132) = *a4 >> 3;
    }
    result = 1;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10025560) --------------------------------------------------------
void __cdecl sub_10025560(int a1, int a2)
{
  unsigned int v2; // eax@1

  v2 = sub_10010550(a1, a2);
  if ( v2 )
    sub_100236A0(a1, v2);
}

//----- (10025590) --------------------------------------------------------
int __cdecl sub_10025590(int a1, int a2)
{
  unsigned int v2; // eax@1

  v2 = sub_10010550(a1, a2);
  if ( v2 )
    sub_100103D0(a1, *(_DWORD *)(v2 + 16));
  return 0;
}

//----- (100255D0) --------------------------------------------------------
signed int __cdecl sub_100255D0(int a1, int a2, int a3, int a4, int *a5)
{
  signed int result; // eax@1
  unsigned int v6; // eax@2
  unsigned int v7; // ebp@2
  int v8; // ecx@4
  unsigned int v9; // eax@4
  int v10; // edx@5
  unsigned int v11; // eax@6
  int *v12; // ecx@12
  int v13; // esi@12
  int v14; // eax@16
  unsigned int v15; // esi@16
  int v16; // ebx@16
  int v17; // edi@18
  int v18; // eax@26
  const wchar_t *v19; // [sp+8h] [bp-4h]@8

  result = sub_100123C0(a1, a2, (int *)&off_10162008, a4);
  if ( !result )
    return result;
  v6 = sub_10010550(a1, a2);
  v7 = v6;
  if ( !v6 )
  {
    *a5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480) | 4;
    return 1;
  }
  v8 = *(_DWORD *)(v6 + 16);
  v9 = *(_DWORD *)v8;
  if ( *(_DWORD *)v8 & 0x40000000 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( !(*(_DWORD *)v10 & 0x40000000) )
    {
      if ( (v9 & 0x80000000) == 0 )
        v19 = (const wchar_t *)(*(_DWORD *)(v10 + 4) + 2 * ((v9 >> 15) & 0x7FFF));
      else
        v19 = *(const wchar_t **)(v10 + 4);
      goto LABEL_12;
    }
    v11 = sub_1001A200(*(_DWORD *)(v7 + 16));
  }
  else
  {
    v11 = *(_DWORD *)(v8 + 4);
  }
  v19 = (const wchar_t *)v11;
LABEL_12:
  v12 = *(int **)(v7 + 16);
  v13 = *v12;
  if ( *v12 & 0x40000000 )
    v13 = *v12 & ((*v12 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( !v13 )
  {
    v19 = L"(?:)";
    v13 = 4;
  }
  v14 = *(_BYTE *)(v7 + 7);
  v15 = v13 + 2;
  v16 = 0;
  if ( *(_BYTE *)(v7 + 7) )
  {
    do
    {
      ++v16;
      v14 &= v14 - 1;
    }
    while ( v14 );
  }
  v17 = sub_10011830(a1, 2 * (v16 + v15) + 2);
  if ( !v17 )
    return 0;
  *(_WORD *)v17 = 47;
  memcpy((void *)(v17 + 2), v19, 2 * v15 - 4);
  *(_WORD *)(v17 + 2 * v15 - 2) = 47;
  if ( v16 )
  {
    if ( *(_BYTE *)(v7 + 7) & 2 )
      *(_WORD *)(v17 + 2 * v15++) = 103;
    if ( *(_BYTE *)(v7 + 7) & 1 )
      *(_WORD *)(v17 + 2 * v15++) = 105;
    if ( *(_BYTE *)(v7 + 7) & 4 )
      *(_WORD *)(v17 + 2 * v15++) = 109;
  }
  *(_WORD *)(v17 + 2 * v15) = 0;
  v18 = sub_1001AB10(a1, v17, v15, 0);
  if ( !v18 )
  {
    sub_10010340(a1, v17);
    return 0;
  }
  *a5 = v18 | 4;
  return 1;
}
// 100CF234: using guessed type wchar_t a_[5];
// 10162008: using guessed type char *off_10162008;

//----- (10025780) --------------------------------------------------------
BOOL __cdecl sub_10025780(int a1, int a2, double *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10011AD0(a1, a2, 0, &v5) && sub_10020030(a1, v5, a3);
}
// 10011AD0: using guessed type _DWORD __cdecl sub_10011AD0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100257D0) --------------------------------------------------------
BOOL __cdecl sub_100257D0(int a1, int a2, double a3)
{
  int v3; // ecx@0
  int v5; // [sp+10h] [bp-4h]@1

  v5 = v3;
  return sub_1001F600(a1, a3, (int)&v5) && sub_10011B50(a1, a2, 0, v5);
}

//----- (10025820) --------------------------------------------------------
int __usercall sub_10025820@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  _WORD *v2; // eax@1
  __int16 v3; // si@1
  int v4; // ecx@1
  unsigned __int16 *v5; // eax@1
  int result; // eax@2
  unsigned int v7; // edx@7
  unsigned __int16 v8; // si@9
  int v9; // ecx@9
  int v10; // eax@9
  signed __int16 v11; // si@14
  int v12; // ebp@15
  unsigned int v13; // eax@15
  __int16 v14; // bx@15
  int i; // edx@19
  __int16 *v16; // eax@20
  unsigned __int16 v17; // cx@20
  int v18; // eax@26
  unsigned __int16 v19; // cx@34
  int v20; // eax@34
  _BYTE *v21; // edx@35
  int v22; // ebx@42
  int v23; // ebp@42
  _WORD *v24; // ecx@43
  unsigned int v25; // eax@44
  int v26; // esi@44
  int v27; // ecx@47
  int v28; // eax@49
  int v29; // eax@57
  int v30; // eax@59
  char *v31; // ebp@60
  _WORD *v32; // ecx@61
  unsigned int v33; // edx@67
  int v34; // eax@67
  int v35; // esi@68
  unsigned __int16 v36; // cx@69
  int v37; // edx@70
  int v38; // ebx@70
  char *v39; // ecx@70
  _WORD *v40; // eax@77
  int v41; // ST10_4@77
  int v42; // eax@51
  int v43; // eax@85
  char v44; // [sp+0h] [bp-18h]@0
  unsigned int v45; // [sp+10h] [bp-8h]@40
  unsigned int v46; // [sp+10h] [bp-8h]@67
  int v47; // [sp+14h] [bp-4h]@44

  v1 = a1;
  v2 = *(_WORD **)(a1 + 16);
  v3 = *v2;
  v4 = *v2;
  v5 = v2 + 1;
  *(_DWORD *)(v1 + 16) = v5;
  switch ( v4 )
  {
    case 94:
      result = sub_100220E0((int *)v1, 2);
      goto LABEL_5;
    case 36:
      result = sub_100220E0((int *)v1, 3);
LABEL_5:
      *(_DWORD *)(v1 + 36) = result;
      if ( result )
      {
        result = 1;
        ++*(_DWORD *)(v1 + 28);
      }
      return result;
    case 92:
      v7 = *(_DWORD *)(v1 + 12);
      if ( (unsigned int)v5 >= v7 )
      {
        sub_10045A60(*(_DWORD *)v1, *(_DWORD *)(v1 + 4), 0, 0, 56, v44);
        return 0;
      }
      v8 = *v5;
      v9 = *v5;
      v10 = (int)(v5 + 1);
      *(_DWORD *)(v1 + 16) = v10;
      switch ( v9 )
      {
        case 98:
          result = sub_100220E0((int *)v1, 4);
          goto LABEL_5;
        case 66:
          result = sub_100220E0((int *)v1, 5);
          goto LABEL_5;
        case 48:
          if ( !(*(_BYTE *)(*(_DWORD *)v1 + 300) & 1) )
            goto LABEL_19;
          if ( !sub_10045A60(*(_DWORD *)v1, *(_DWORD *)(v1 + 4), 0, 5, 148, v44) )
            return 0;
          v11 = 0;
          goto LABEL_49;
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          v12 = v10 - 2;
          v13 = sub_10022390(v1, v8, *(_WORD *)(v1 + 24), (int (__cdecl *)(int))sub_10022310);
          v14 = v13;
          if ( *(_DWORD *)(v1 + 20) & 0x4000 )
            return 0;
          if ( v13 != -1 )
            goto LABEL_26;
          if ( !(*(_BYTE *)(*(_DWORD *)v1 + 300) & 1) )
          {
            *(_DWORD *)(v1 + 16) = v12;
LABEL_19:
            for ( i = 0; *(_DWORD *)(v1 + 16) < *(_DWORD *)(v1 + 12); i = v17 + 8 * i - 48 )
            {
              v16 = *(__int16 **)(v1 + 16);
              v17 = *v16;
              if ( (unsigned __int16)(*v16 - 48) > 7u )
                break;
              *(_DWORD *)(v1 + 16) = v16 + 1;
              if ( (unsigned int)v17 + 8 * i - 48 > 0xFF )
                break;
            }
            v11 = i;
            goto LABEL_49;
          }
          if ( sub_10045A60(*(_DWORD *)v1, *(_DWORD *)(v1 + 4), 0, 5, (v8 < 0x38u) + 148, v44) )
          {
            v14 = 0;
LABEL_26:
            v18 = sub_100220E0((int *)v1, 13);
            *(_DWORD *)(v1 + 36) = v18;
            if ( v18 )
            {
              *(_WORD *)(v18 + 12) = v14 - 1;
              *(_DWORD *)(v1 + 28) += 3;
              return sub_10022770(v1);
            }
          }
          return 0;
        case 102:
          v11 = 12;
          goto LABEL_49;
        case 110:
          v11 = 10;
          goto LABEL_49;
        case 114:
          v11 = 13;
          goto LABEL_49;
        case 116:
          v11 = 9;
          goto LABEL_49;
        case 118:
          v11 = 11;
          goto LABEL_49;
        case 99:
          if ( v10 + 2 >= v7
            || ((v19 = *(_WORD *)(v10 + 2), v20 = v10 + 2, v19 < 0x41u) || (v21 = *(_BYTE **)(v1 + 16), v19 > 0x5Au))
            && ((v21 = *(_BYTE **)(v1 + 16), v19 < 0x61u) || v19 > 0x7Au) )
          {
            *(_DWORD *)(v1 + 16) -= 2;
            v11 = 92;
          }
          else
          {
            v11 = *v21 & 0x1F;
            *(_DWORD *)(v1 + 16) = v20;
          }
          goto LABEL_49;
        case 120:
          v45 = 2;
          goto LABEL_42;
        case 117:
          v45 = 4;
LABEL_42:
          v22 = 0;
          v23 = 0;
          if ( !v45 )
            goto LABEL_48;
          break;
        case 100:
          v42 = sub_100220E0((int *)v1, 7);
          goto LABEL_82;
        case 68:
          v42 = sub_100220E0((int *)v1, 8);
          goto LABEL_82;
        case 115:
          v42 = sub_100220E0((int *)v1, 11);
          goto LABEL_82;
        case 83:
          v42 = sub_100220E0((int *)v1, 12);
          goto LABEL_82;
        case 119:
          v42 = sub_100220E0((int *)v1, 9);
          goto LABEL_82;
        case 87:
          v42 = sub_100220E0((int *)v1, 10);
          goto LABEL_82;
        default:
          v29 = sub_100220E0((int *)v1, 14);
          *(_DWORD *)(v1 + 36) = v29;
          if ( !v29 )
            return 0;
          *(_WORD *)(v29 + 12) = v8;
          *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) = 1;
          *(_DWORD *)(*(_DWORD *)(v1 + 36) + 8) = *(_DWORD *)(v1 + 16) - 2;
          *(_DWORD *)(v1 + 28) += 3;
          return sub_10022770(v1);
      }
      while ( 2 )
      {
        v24 = *(_WORD **)(v1 + 16);
        if ( (unsigned int)v24 < *(_DWORD *)(v1 + 12) )
        {
          v25 = *v24;
          v26 = (int)(v24 + 1);
          *(_DWORD *)(v1 + 16) = v24 + 1;
          if ( sub_10022130(v25, &v47) )
          {
            v23 = v47 | 16 * v23;
            if ( ++v22 >= v45 )
              break;
            continue;
          }
          v27 = 2 * v22 + 4;
          *(_DWORD *)(v1 + 16) = v26 - v27;
          LOWORD(v23) = *(_WORD *)(v26 - v27);
          *(_DWORD *)(v1 + 16) = v26 - v27 + 2;
        }
        break;
      }
LABEL_48:
      v11 = v23;
LABEL_49:
      v28 = sub_100220E0((int *)v1, 14);
      *(_DWORD *)(v1 + 36) = v28;
      if ( !v28 )
        return 0;
      *(_WORD *)(v28 + 12) = v11;
      *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) = 1;
      *(_DWORD *)(v1 + 28) += 3;
      return sub_10022770(v1);
    case 91:
      v30 = sub_100220E0((int *)v1, 22);
      *(_DWORD *)(v1 + 36) = v30;
      if ( !v30 )
        return 0;
      v31 = *(char **)(v1 + 16);
      *(_WORD *)(v30 + 12) = (*(_DWORD *)(v1 + 16) - *(_DWORD *)(v1 + 8)) >> 1;
      if ( *(_DWORD *)(v1 + 16) == *(_DWORD *)(v1 + 12) )
        goto LABEL_65;
      break;
    case 46:
      v42 = sub_100220E0((int *)v1, 6);
LABEL_82:
      *(_DWORD *)(v1 + 36) = v42;
      if ( !v42 )
        return 0;
      ++*(_DWORD *)(v1 + 28);
      return sub_10022770(v1);
    case 42:
    case 43:
    case 63:
      sub_10045A60(*(_DWORD *)v1, *(_DWORD *)(v1 + 4), 0, 0, 46, (_BYTE)v5 - 2);
      return 0;
    default:
      v43 = sub_100220E0((int *)v1, 14);
      *(_DWORD *)(v1 + 36) = v43;
      if ( !v43 )
        return 0;
      *(_WORD *)(v43 + 12) = v3;
      *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) = 1;
      *(_DWORD *)(*(_DWORD *)(v1 + 36) + 8) = *(_DWORD *)(v1 + 16) - 2;
      goto LABEL_87;
  }
  while ( 1 )
  {
    v32 = *(_WORD **)(v1 + 16);
    if ( *v32 != 92 )
      break;
    *(_DWORD *)(v1 + 16) = v32 + 1;
LABEL_64:
    *(_DWORD *)(v1 + 16) += 2;
    if ( *(_DWORD *)(v1 + 16) == *(_DWORD *)(v1 + 12) )
    {
LABEL_65:
      sub_10045A60(*(_DWORD *)v1, *(_DWORD *)(v1 + 4), 0, 0, 55, (char)v31);
      return 0;
    }
  }
  if ( *v32 != 93 )
    goto LABEL_64;
  *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) = (*(_DWORD *)(v1 + 16) - (signed int)v31) >> 1;
  v33 = 0;
  v34 = v1 + 40;
  v46 = 0;
  v47 = v1 + 40;
  while ( 1 )
  {
    v35 = *(_DWORD *)v34;
    if ( !*(_DWORD *)v34 )
    {
      *(_DWORD *)(v1 + 8 * v33 + 40) = v31;
      *(_WORD *)(v1 + 8 * v33 + 44) = *(_WORD *)(*(_DWORD *)(v1 + 36) + 14);
      *(_WORD *)(v1 + 8 * v33 + 46) = *(_WORD *)(v1 + 26);
LABEL_76:
      *(_WORD *)(*(_DWORD *)(v1 + 36) + 18) = (*(_WORD *)(v1 + 26))++;
      goto LABEL_77;
    }
    v36 = *(_WORD *)(v34 + 4);
    if ( v36 == *(_WORD *)(*(_DWORD *)(v1 + 36) + 14) )
      break;
LABEL_75:
    ++v33;
    v34 += 8;
    v46 = v33;
    v47 = v34;
    if ( v33 >= 4 )
      goto LABEL_76;
  }
  v37 = 0;
  v38 = v36;
  v39 = v31;
  v35 -= (signed int)v31;
  while ( v37 != v38 )
  {
    if ( *(_WORD *)&v39[v35] != *(_WORD *)v39 )
    {
      v34 = v47;
      v33 = v46;
      goto LABEL_75;
    }
    ++v37;
    v39 += 2;
  }
  *(_WORD *)(*(_DWORD *)(v1 + 36) + 18) = *(_WORD *)(v1 + 8 * v46 + 46);
LABEL_77:
  v40 = *(_WORD **)(v1 + 16);
  v41 = *(_DWORD *)(v1 + 36);
  *(_DWORD *)(v1 + 16) = v40 + 1;
  result = sub_10022430(v31, v35, v1, v41, v40);
  if ( result )
  {
LABEL_87:
    *(_DWORD *)(v1 + 28) += 3;
    result = sub_10022770(v1);
  }
  return result;
}

//----- (10025E30) --------------------------------------------------------
unsigned __int16 **__usercall sub_10025E30@<eax>(int a1@<ebx>, int a2@<edi>, int a3, signed int *a4, int a5, int *a6)
{
  unsigned __int16 **result; // eax@1
  unsigned __int16 **v7; // esi@1
  unsigned int v8; // eax@2
  unsigned int v9; // ebp@2
  BOOL v10; // eax@5
  double v11; // st7@5
  int v12; // ecx@9
  char v13; // al@10
  int v14; // eax@14
  int v15; // esi@19
  int v16; // esi@20
  int v17; // [sp+10h] [bp-14h]@17
  __int64 v18; // [sp+14h] [bp-10h]@16
  double v19; // [sp+1Ch] [bp-8h]@5

  result = (unsigned __int16 **)sub_100123C0(a2, a1, (int *)&off_10162008, (int)a4);
  v7 = result;
  if ( result )
  {
    v8 = sub_10010550(a2, a1);
    v9 = v8;
    if ( !v8 )
      return (unsigned __int16 **)1;
    ++*(_DWORD *)v8;
    if ( *(_BYTE *)(v8 + 7) & 2 )
    {
      v10 = sub_10025780(a2, a1, &v19);
      v11 = v19;
      v7 = (unsigned __int16 **)v10;
    }
    else
    {
      v11 = 0.0;
      v19 = 0.0;
    }
    if ( v7 )
    {
      if ( !a3 )
      {
        v12 = *(_DWORD *)(a2 + 128);
        if ( !v12 )
        {
          *(_BYTE *)(v9 + 7);
          v13 = (unsigned int)sub_10010FF0(*(_DWORD *)(v9 + 16));
          sub_100110F0(a2, (int)sub_1003ED50, 0, 59, v13);
          sub_100236A0(a2, v9);
          return 0;
        }
        goto LABEL_13;
      }
      v12 = sub_1001ACB0(a2, *a4);
      if ( v12 )
      {
        v11 = v19;
        *a4 = v12 | 4;
LABEL_13:
        if ( v11 < 0.0 )
          goto LABEL_24;
        v14 = *(_DWORD *)v12;
        if ( *(_DWORD *)v12 & 0x40000000 )
          v14 = *(_DWORD *)v12 & ((v14 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        LODWORD(v18) = v14;
        if ( (double)(unsigned int)v14 < v11 )
        {
LABEL_24:
          v16 = sub_100257D0(a2, a1, 0.0);
          *a6 = 0;
          sub_100236A0(a2, v9);
          return (unsigned __int16 **)v16;
        }
        v18 = (signed __int64)v11;
        v17 = (signed __int64)v11;
        v7 = sub_10024C00(a2, v9, v12, &v17, a5, a6);
        if ( v7 && *(_BYTE *)(v9 + 7) & 2 )
        {
          LODWORD(v18) = *a6 != 0 ? v17 : 0;
          v15 = sub_100257D0(a2, a1, (double)(unsigned int)v18);
          sub_100236A0(a2, v9);
          return (unsigned __int16 **)v15;
        }
        goto LABEL_21;
      }
    }
LABEL_21:
    sub_100236A0(a2, v9);
    result = v7;
  }
  return result;
}
// 10162008: using guessed type char *off_10162008;

//----- (10026070) --------------------------------------------------------
unsigned __int16 **__cdecl sub_10026070(int a1, int a2, int a3, signed int *a4, int *a5)
{
  return sub_10025E30(a2, a1, a3, a4, 0, a5);
}

//----- (100260A0) --------------------------------------------------------
unsigned __int16 **__cdecl sub_100260A0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  unsigned __int16 **result; // eax@1

  result = sub_10025E30(a2, a1, a3, a4, 1, a5);
  if ( result )
  {
    if ( *a5 != 14 )
      *a5 = 6;
    result = (unsigned __int16 **)1;
  }
  return result;
}

//----- (100260E0) --------------------------------------------------------
signed int __usercall sub_100260E0@<eax>(char a1@<bpl>, int a2)
{
  int v2; // esi@1
  int v3; // ebx@1
  int v4; // eax@2
  int v6; // edi@3
  __int16 v7; // bp@6
  _WORD *v8; // eax@6
  unsigned int v9; // ecx@6
  int v10; // edi@8
  _WORD *v11; // ebp@13
  int v12; // ecx@20
  int *v13; // edx@20
  int v14; // eax@22
  int v15; // ecx@27
  int *v16; // edx@27
  int v17; // eax@29
  int v18; // edi@34
  int v19; // eax@35
  int v20; // eax@38
  int v21; // edi@39
  _DWORD *v22; // ecx@39
  int v23; // edi@44
  signed int v24; // edi@48
  int v25; // eax@50
  int v26; // ecx@55
  _DWORD *v27; // eax@62
  int v28; // eax@65
  int v29; // edi@68
  char v30; // [sp-8h] [bp-28h]@5
  int v31; // [sp+8h] [bp-18h]@1
  void *v32; // [sp+Ch] [bp-14h]@5
  signed int v33; // [sp+10h] [bp-10h]@1
  signed int v34; // [sp+14h] [bp-Ch]@1
  signed int v35; // [sp+18h] [bp-8h]@1
  __int16 v36; // [sp+1Ch] [bp-4h]@6
  _DWORD *v37; // [sp+24h] [bp+4h]@3

  v2 = a2;
  v3 = 0;
  v35 = 128;
  v34 = 128;
  v33 = 0;
  v31 = 0;
  if ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a2 + 12) )
  {
    v4 = sub_100220E0((int *)a2, 0);
    *(_DWORD *)(a2 + 36) = v4;
    return v4 != 0;
  }
  v6 = sub_10011830(*(_DWORD *)a2, 0x600u);
  v37 = (_DWORD *)v6;
  if ( !v6 )
    return 0;
  v30 = a1;
  v32 = (void *)sub_10011830(*(_DWORD *)v2, 0x200u);
  if ( v32 )
  {
    while ( 1 )
    {
      v7 = *(_WORD *)(v2 + 24);
      v8 = *(_WORD **)(v2 + 16);
      v36 = *(_WORD *)(v2 + 24);
      v9 = *(_DWORD *)(v2 + 12);
      if ( v8 == (_WORD *)v9 )
        break;
      if ( *v8 != 40 )
      {
        if ( *v8 == 41 )
        {
          v12 = v3 - 1;
          v13 = (int *)(v6 + 12 * (v3 - 1));
          while ( v12 >= 0 )
          {
            v14 = *v13;
            if ( *v13 == 43 || v14 == 44 || v14 == 41 || v14 == 29 )
              goto LABEL_8;
            --v12;
            v13 -= 3;
          }
LABEL_66:
          sub_10045A60(*(_DWORD *)v2, *(_DWORD *)(v2 + 4), 0, 0, 62, v30);
          goto LABEL_76;
        }
        if ( *v8 != 124 )
        {
          if ( !sub_10025820(v2) )
            goto LABEL_76;
          v10 = *(_DWORD *)(v2 + 36);
          goto LABEL_9;
        }
LABEL_8:
        v10 = sub_100220E0((int *)v2, 0);
        if ( !v10 )
          goto LABEL_75;
LABEL_9:
        if ( v31 == v34 )
        {
          v34 *= 2;
          v32 = sub_10011870(*(_DWORD *)v2, v32, 4 * v34);
          if ( !v32 )
            goto LABEL_75;
        }
        *((_DWORD *)v32 + v31++) = v10;
        while ( 2 )
        {
          v6 = (int)v37;
LABEL_13:
          v11 = *(_WORD **)(v2 + 16);
          if ( v11 == *(_WORD **)(v2 + 12) )
          {
            if ( !v3 )
            {
LABEL_72:
              *(_DWORD *)(v2 + 36) = *(_DWORD *)v32;
              v33 = 1;
              goto LABEL_76;
            }
            v29 = v6 + 12 * v3;
            while ( 1 )
            {
              v29 -= 12;
              --v3;
              if ( !sub_10022170(v31, v29, v2, (int)v32) )
                goto LABEL_75;
              --v31;
              if ( !v3 )
              {
                v6 = (int)v37;
                goto LABEL_72;
              }
            }
          }
          switch ( *v11 )
          {
            case 0x29:
              v15 = v3 - 1;
              v16 = (int *)(v6 + 12 * (v3 - 1));
              while ( 2 )
              {
                if ( v15 < 0 )
                  goto LABEL_66;
                v17 = *v16;
                if ( *v16 != 43 && v17 != 44 && v17 != 41 && v17 != 29 )
                {
                  --v15;
                  v16 -= 3;
                  continue;
                }
                break;
              }
              *(_DWORD *)(v2 + 16) = v11 + 1;
              v18 = v6 + 12 * v3;
              while ( 2 )
              {
                v19 = *(_DWORD *)(v18 - 12);
                v18 -= 12;
                --v3;
                switch ( v19 )
                {
                  default:
                    if ( !sub_10022170(v31, v18, v2, (int)v32) )
                      goto LABEL_75;
                    --v31;
                    continue;
                  case 29:
                  case 43:
                  case 44:
                    v20 = sub_100220E0((int *)v2, v37[3 * v3]);
                    if ( !v20 )
                      goto LABEL_75;
                    v21 = v31;
                    *(_WORD *)(v20 + 12) = v37[3 * v3 + 2];
                    v22 = v32;
                    *(_DWORD *)(v20 + 8) = *((_DWORD *)v32 + v31 - 1);
                    *((_DWORD *)v32 + v31 - 1) = v20;
                    ++*(_DWORD *)(v2 + 32);
                    break;
                  case 41:
                    v21 = v31;
                    v22 = v32;
                    break;
                }
                break;
              }
              *(_DWORD *)(v2 + 36) = v22[v21 - 1];
              if ( !sub_10022770(v2) )
                goto LABEL_75;
              *((_DWORD *)v32 + v21 - 1) = *(_DWORD *)(v2 + 36);
              continue;
            case 0x7C:
              *(_DWORD *)(v2 + 16) += 2;
              if ( !v3 )
                goto LABEL_48;
              v23 = v6 + 12 * v3;
              break;
            default:
              v24 = 57;
              goto LABEL_61;
            case 0x2A:
            case 0x2B:
            case 0x3F:
            case 0x7B:
              sub_10045A60(*(_DWORD *)v2, *(_DWORD *)(v2 + 4), 0, 0, 46, *(_DWORD *)(v2 + 16));
              v33 = 0;
              goto LABEL_76;
          }
          break;
        }
        do
        {
          if ( *(_DWORD *)(v23 - 12) != 57 )
            break;
          v23 = (int)&v37[3 * --v3];
          if ( !sub_10022170(v31, (int)&v37[3 * v3], v2, (int)v32) )
            goto LABEL_75;
          --v31;
        }
        while ( v3 );
LABEL_48:
        v24 = 1;
        goto LABEL_61;
      }
      v25 = (int)(v8 + 1);
      *(_DWORD *)(v2 + 16) = v25;
      if ( v25 + 2 >= v9
        || *(_WORD *)v25 != 63
        || (LOWORD(v25) = *(_WORD *)(v25 + 2), (_WORD)v25 != 61) && (_WORD)v25 != 33 && (_WORD)v25 != 58 )
      {
        *(_DWORD *)(v2 + 28) += 6;
        v24 = 29;
        *(_WORD *)(v2 + 24) = v7 + 1;
        if ( v7 == -2 )
        {
          sub_10045A60(*(_DWORD *)v2, *(_DWORD *)(v2 + 4), 0, 0, 139, v30);
LABEL_75:
          v6 = (int)v37;
          goto LABEL_76;
        }
      }
      else
      {
        v26 = *(_DWORD *)(v2 + 16);
        v25 = (unsigned __int16)v25;
        if ( (unsigned __int16)v25 == 33 )
        {
          *(_DWORD *)(v2 + 28) += 4;
          v24 = 44;
          *(_DWORD *)(v2 + 16) = v26 + 4;
        }
        else if ( v25 == 61 )
        {
          *(_DWORD *)(v2 + 28) += 4;
          v24 = 43;
          *(_DWORD *)(v2 + 16) = v26 + 4;
        }
        else
        {
          v24 = 41;
          *(_DWORD *)(v2 + 16) = v26 + 4;
        }
      }
LABEL_61:
      if ( v3 == v35 )
      {
        v35 *= 2;
        v27 = sub_10011870(*(_DWORD *)v2, v37, 12 * v35);
        v37 = v27;
        if ( !v27 )
          goto LABEL_78;
      }
      else
      {
        v27 = v37;
      }
      v28 = (int)&v27[3 * v3];
      *(_DWORD *)v28 = v24;
      v6 = (int)v37;
      *(_DWORD *)(v28 + 4) = *(_DWORD *)(v2 + 16);
      *(_WORD *)(v28 + 8) = v36;
      ++v3;
    }
    if ( v3 >= v31 )
      goto LABEL_8;
    goto LABEL_13;
  }
LABEL_76:
  if ( v6 )
    sub_10010340(*(_DWORD *)v2, v6);
LABEL_78:
  if ( v32 )
    sub_10010340(*(_DWORD *)v2, (unsigned int)v32);
  return v33;
}
// 100260E0: could not find valid save-restore pair for ebp

//----- (100265F0) --------------------------------------------------------
int __cdecl sub_100265F0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  unsigned int v6; // eax@1
  int v7; // esi@1
  bool v8; // zf@1
  int v9; // ecx@2
  _WORD *v10; // eax@3
  int v11; // edx@8
  int v12; // edi@8
  int v13; // ecx@8
  int v14; // eax@10
  int v15; // eax@14
  int v16; // eax@14
  int v17; // eax@18
  int v18; // eax@20
  _BYTE *v19; // eax@23
  int v20; // ecx@25
  int v21; // eax@26
  int result; // eax@28
  int v23; // [sp+10h] [bp-48h]@1
  int v24; // [sp+14h] [bp-44h]@1
  _WORD *v25; // [sp+18h] [bp-40h]@8
  _WORD *v26; // [sp+1Ch] [bp-3Ch]@10
  _WORD *v27; // [sp+20h] [bp-38h]@8
  int v28; // [sp+24h] [bp-34h]@10
  unsigned __int16 v29; // [sp+28h] [bp-30h]@10
  unsigned __int16 v30; // [sp+2Ah] [bp-2Eh]@10
  int v31; // [sp+2Ch] [bp-2Ch]@10
  int v32; // [sp+30h] [bp-28h]@10
  int v33; // [sp+34h] [bp-24h]@14
  int v34; // [sp+38h] [bp-20h]@10
  int v35; // [sp+40h] [bp-18h]@10
  int v36; // [sp+48h] [bp-10h]@10
  int v37; // [sp+50h] [bp-8h]@10
  int v38; // [sp+5Ch] [bp+4h]@1

  v5 = a1;
  v6 = *(_DWORD *)a3;
  v7 = 0;
  v8 = (*(_DWORD *)a3 & 0x40000000) == 0;
  v38 = *(_DWORD *)(*(_DWORD *)(a1 + 76) + 12);
  v23 = v5;
  v24 = a2;
  if ( v8 )
  {
    v10 = *(_WORD **)(a3 + 4);
  }
  else
  {
    v9 = *(_DWORD *)(a3 + 4);
    if ( *(_DWORD *)v9 & 0x40000000 )
    {
      v10 = (_WORD *)sub_1001A200(a3);
    }
    else if ( (v6 & 0x80000000) == 0 )
    {
      v10 = (_WORD *)(*(_DWORD *)(v9 + 4) + 2 * ((v6 >> 15) & 0x7FFF));
    }
    else
    {
      v10 = *(_WORD **)(v9 + 4);
    }
  }
  v11 = *(_DWORD *)a3;
  v12 = *(_DWORD *)a3 & 0x40000000;
  v27 = v10;
  v25 = v10;
  v13 = v11;
  if ( v12 )
    v13 = v11 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  v28 = a4;
  v26 = &v10[v13];
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v14 = v11;
  if ( v12 )
    v14 = v11 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( v14 && a5 )
  {
    v15 = sub_100220E0(&v23, 14);
    v33 = v15;
    *(_WORD *)(v15 + 12) = *v25;
    v16 = *(_DWORD *)a3;
    if ( *(_DWORD *)a3 & 0x40000000 )
      v16 = *(_DWORD *)a3 & ((v16 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    *(_WORD *)(v33 + 14) = v16;
    *(_DWORD *)(v33 + 8) = v25;
    v31 += 5;
  }
  else if ( !sub_100260E0(a3, (int)&v23) )
  {
    goto LABEL_26;
  }
  v17 = sub_10011830(v5, 4 * ((unsigned int)(v31 + 28) >> 2));
  v7 = v17;
  if ( v17 )
  {
    *(_DWORD *)(v17 + 8) = v30;
    if ( v30 )
    {
      v18 = sub_10011830(v5, 16 * v30);
      *(_DWORD *)(v7 + 12) = v18;
      if ( !v18 )
        goto LABEL_26;
    }
    else
    {
      *(_DWORD *)(v17 + 12) = 0;
    }
    v19 = sub_10022A00(v32, (_BYTE *)(v7 + 20), v33, &v23, v7);
    if ( v19 )
    {
      *v19 = 58;
      *(_DWORD *)v7 = 1;
      v20 = *(_DWORD *)(v7 + 4) ^ v29;
      *(_DWORD *)(v7 + 16) = a3;
      *(_DWORD *)(v7 + 4) ^= v20 & 0xFFFFFF;
      *(_BYTE *)(v7 + 7) = a4;
    }
    else
    {
      v7 = 0;
    }
  }
LABEL_26:
  v21 = *(_DWORD *)(v5 + 76);
  if ( v21 == v5 + 60 || v38 - *(_DWORD *)(v21 + 4) > (unsigned int)(*(_DWORD *)(v21 + 12) - *(_DWORD *)(v21 + 4)) )
  {
    sub_1003E5E0(v5 + 60, v38);
    result = v7;
  }
  else
  {
    *(_DWORD *)(v21 + 12) = (v38 + 3) & 0xFFFFFFFC;
    result = v7;
  }
  return result;
}

//----- (10026830) --------------------------------------------------------
int __cdecl sub_10026830(int a1, int a2, int a3, int a4, int a5)
{
  unsigned int *v5; // esi@1
  int v6; // ebx@1
  unsigned int v7; // eax@2
  int v8; // ecx@3
  unsigned int v9; // eax@4
  int v10; // edi@9
  unsigned int v11; // ecx@9

  v5 = (unsigned int *)a4;
  v6 = 0;
  if ( !a4 )
    return sub_100265F0(a1, a2, a3, v6, a5);
  v7 = *(_DWORD *)a4;
  if ( *(_DWORD *)a4 & 0x40000000 )
  {
    v8 = *(_DWORD *)(a4 + 4);
    if ( *(_DWORD *)v8 & 0x40000000 )
      v9 = sub_1001A200(a4);
    else
      v9 = (v7 & 0x80000000) == 0 ? *(_DWORD *)(v8 + 4) + 2 * ((v7 >> 15) & 0x7FFF) : *(_DWORD *)(v8 + 4);
  }
  else
  {
    v9 = *(_DWORD *)(a4 + 4);
  }
  v10 = 0;
  v11 = *v5;
  if ( *v5 & 0x40000000 )
    v11 = *v5 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( !v11 )
    return sub_100265F0(a1, a2, a3, v6, a5);
  while ( 1 )
  {
    if ( *(_WORD *)(v9 + 2 * v10) == 103 )
    {
      v6 |= 2u;
      goto LABEL_18;
    }
    if ( *(_WORD *)(v9 + 2 * v10) == 105 )
    {
      v6 |= 1u;
      goto LABEL_18;
    }
    if ( *(_WORD *)(v9 + 2 * v10) != 109 )
      break;
    v6 |= 4u;
LABEL_18:
    if ( ++v10 >= v11 )
      return sub_100265F0(a1, a2, a3, v6, a5);
  }
  LOWORD(a4) = *(_BYTE *)(v9 + 2 * v10);
  sub_10045A60(a1, a2, 0, 0, 58, (unsigned int)&a4);
  return 0;
}

//----- (10026930) --------------------------------------------------------
unsigned __int16 **__cdecl sub_10026930(int a1, int a2, int a3, signed int *a4, int *a5)
{
  return sub_10026070(a1, *(a4 - 2) & 0xFFFFFFF8, a3, a4, a5);
}

//----- (10026950) --------------------------------------------------------
signed int __cdecl sub_10026950(unsigned int a1, int *a2)
{
  int *v2; // ebx@1
  unsigned int v3; // esi@1
  unsigned int v4; // eax@2
  int v6; // eax@8
  int v7; // eax@9
  unsigned int v8; // edi@9
  int v9; // [sp+14h] [bp-4h]@4

  v2 = a2;
  v3 = a1;
  if ( !*(_DWORD *)a1 )
  {
    v4 = sub_10010550(*(_DWORD *)(a1 + 8), *a2);
    if ( !v4 )
      return 0;
    v9 = *(_DWORD *)(v4 + 16);
    LOBYTE(a1) = *(_BYTE *)(v4 + 7);
  }
  if ( !sub_10052700(v3, &v9) || !sub_10052D00(v3, &a1) )
    return 0;
  if ( *(_DWORD *)v3 == 1 )
  {
    v6 = sub_10017C40(*(_DWORD *)(v3 + 8), (int)&off_10162008, 0, 0);
    *v2 = v6;
    if ( !v6 )
      return 0;
    v7 = sub_100265F0(*(_DWORD *)(v3 + 8), 0, v9, (unsigned __int8)a1, 0);
    v8 = v7;
    if ( !v7 )
      return 0;
    if ( !sub_10010570(*(_DWORD *)(v3 + 8), *v2, v7) || !sub_100257D0(*(_DWORD *)(v3 + 8), *v2, 0.0) )
    {
      sub_100236A0(*(_DWORD *)(v3 + 8), v8);
      return 0;
    }
  }
  return 1;
}
// 10162008: using guessed type char *off_10162008;

//----- (10026A40) --------------------------------------------------------
signed int __usercall sub_10026A40@<eax>(char a1@<dil>, __int64 a2, unsigned int a3, int a4, _DWORD *a5)
{
  signed int result; // eax@1
  int v6; // ebx@2
  int v7; // edi@3
  signed int v8; // ecx@4
  unsigned int v9; // eax@11
  int v10; // eax@12
  int v11; // eax@13
  int v12; // eax@17
  unsigned int v13; // edi@20
  unsigned int v14; // ebp@21

  result = sub_100123C0(a2, SHIDWORD(a2), (int *)&off_10162008, a4);
  if ( !result )
    return result;
  v6 = 0;
  if ( a3 )
  {
    v8 = *(_DWORD *)a4;
    if ( *(_DWORD *)a4 & 7
      || !(v8 & 0xFFFFFFF8)
      || (char **)(*(_DWORD *)(*(_DWORD *)((v8 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_10162008 )
    {
      v11 = sub_1001ACB0(a2, *(_DWORD *)a4);
      v7 = v11;
      if ( v11 )
      {
        *(_DWORD *)a4 = v11 | 4;
        if ( a3 <= 1 )
          goto LABEL_19;
        if ( *(_DWORD *)(a4 + 4) == -2147483647 )
        {
          v6 = 0;
          goto LABEL_19;
        }
        v12 = sub_1001ACB0(a2, *(_DWORD *)(a4 + 4));
        v6 = v12;
        if ( v12 )
        {
          *(_DWORD *)(a4 + 4) = v12 | 4;
          goto LABEL_19;
        }
      }
    }
    else if ( a3 < 2 || *(_DWORD *)(a4 + 4) == -2147483647 )
    {
      v9 = sub_10010550(a2, v8 & 0xFFFFFFF8);
      if ( v9 )
      {
        v10 = sub_100265F0(a2, 0, *(_DWORD *)(v9 + 16), *(_BYTE *)(v9 + 7), 0);
        goto LABEL_20;
      }
    }
    else
    {
      sub_100110F0(a2, (int)sub_1003ED50, 0, 165, a1);
    }
    return 0;
  }
  v7 = *(_DWORD *)(*(_DWORD *)(a2 + 24) + 480);
LABEL_19:
  v10 = sub_10026830(a2, 0, v7, v6, 0);
LABEL_20:
  v13 = v10;
  if ( !v10 )
    return 0;
  v14 = sub_10010550(a2, SHIDWORD(a2));
  if ( sub_10010570(a2, SHIDWORD(a2), v13) && sub_100257D0(a2, SHIDWORD(a2), 0.0) )
  {
    if ( v14 )
      sub_100236A0(a2, v14);
    *a5 = HIDWORD(a2);
    result = 1;
  }
  else
  {
    sub_100236A0(a2, v13);
    result = 0;
  }
  return result;
}
// 10026A40: could not find valid save-restore pair for edi
// 10162008: using guessed type char *off_10162008;

//----- (10026BC0) --------------------------------------------------------
int __cdecl sub_10026BC0(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v5; // eax@4
  int result; // eax@6

  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1 )
  {
    result = a2;
    return sub_10026A40(a4, __PAIR__(result, a1), a3, a4, a5);
  }
  if ( a3 < 2 || *(_DWORD *)(a4 + 4) == -2147483647 )
  {
    v5 = *(_DWORD *)a4;
    if ( !(*(_DWORD *)a4 & 7)
      && (char **)(*(_DWORD *)(*(_DWORD *)((v5 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) == &off_10162008 )
    {
      *a5 = v5;
      return 1;
    }
  }
  result = sub_10017C40(a1, (int)&off_10162008, 0, 0);
  if ( result )
    return sub_10026A40(a4, __PAIR__(result, a1), a3, a4, a5);
  return result;
}
// 10162008: using guessed type char *off_10162008;

//----- (10026C50) --------------------------------------------------------
char *__cdecl sub_10026C50(int a1, unsigned int a2)
{
  char *v2; // eax@1
  char *v3; // ebx@1
  int v4; // eax@2
  int v5; // edi@2
  char v7; // [sp+10h] [bp-4h]@9

  v2 = sub_10012240(
         a1,
         a2,
         0,
         (int *)&off_10162008,
         (int)sub_10026BC0,
         1,
         (int *)&off_10161EA8,
         (const char **)&off_10162050,
         (int *)&off_10161F08,
         0);
  v3 = v2;
  if ( v2 )
  {
    v4 = sub_100118F0(a1, (int)v2);
    v5 = v4;
    if ( v4 )
    {
      if ( sub_10011970(a1, v4, "input", "$_")
        && sub_10011970(a1, v5, "multiline", "$*")
        && sub_10011970(a1, v5, "lastMatch", "$&")
        && sub_10011970(a1, v5, "lastParen", "$+")
        && sub_10011970(a1, v5, "leftContext", "$`")
        && sub_10011970(a1, v5, "rightContext", "$'")
        && sub_10026A40(v5, __PAIR__((unsigned int)v3, a1), 0, 0, &v7) )
      {
        return v3;
      }
      sub_10011AB0(a1, a2, off_10162008);
    }
  }
  return 0;
}
// 10161EA8: using guessed type char *off_10161EA8;
// 10161F08: using guessed type char *off_10161F08;
// 10162008: using guessed type char *off_10162008;
// 10162050: using guessed type char *off_10162050;

//----- (10026D70) --------------------------------------------------------
char *__cdecl sub_10026D70(int a1, int a2, void *a3, int a4, int a5)
{
  char *result; // eax@1
  char *v6; // ebx@2
  int v7; // eax@3
  char *v8; // edi@3

  result = sub_1001AB60(a1, a3, a4, 0);
  if ( result )
  {
    result = (char *)sub_100265F0(a1, a2, (int)result, a5, 0);
    v6 = result;
    if ( result )
    {
      v7 = sub_10017C40(a1, (int)&off_10162008, 0, 0);
      v8 = (char *)v7;
      if ( v7 && sub_10010570(a1, v7, (int)v6) && sub_100257D0(a1, (int)v8, 0.0) )
      {
        result = v8;
      }
      else
      {
        sub_100236A0(a1, (unsigned int)v6);
        result = 0;
      }
    }
  }
  return result;
}
// 10162008: using guessed type char *off_10162008;

//----- (10026E10) --------------------------------------------------------
int *__usercall sub_10026E10@<eax>(int a1@<eax>, int a2@<ebx>, unsigned int a3)
{
  int v3; // esi@1
  int v4; // ebp@1
  int v5; // eax@1
  unsigned int v6; // eax@2
  unsigned int v7; // esi@2
  int *v8; // esi@7
  size_t v9; // edi@8
  int *result; // eax@8
  int v11; // [sp+Ch] [bp-8h]@7
  int v12; // [sp+10h] [bp-4h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 4);
  sub_10011AD0(a2, *(_DWORD *)(a1 + 4), 0, &v12);
  v5 = *(_DWORD *)(v3 + 16);
  if ( v5 )
  {
    v6 = *(_WORD *)(v5 + 16);
    v7 = *(_DWORD *)(v3 + 24);
    if ( v7 > v6 )
      v6 = v7;
  }
  else
  {
    v6 = *(_DWORD *)(v3 + 24);
  }
  if ( v12 == -2147483647 )
  {
    if ( v6 > 0x1F )
    {
      v9 = 4 * ((v6 + 31) >> 5);
      result = (int *)sub_10011830(a2, 4 * ((v6 + 31) >> 5));
      v8 = result;
      if ( !result )
        return result;
      memset(result, 0, v9);
      v12 = (unsigned int)v8 | 1;
      sub_10011B50(a2, v4, 0, (unsigned int)v8 | 1);
    }
    else
    {
      v11 = 0;
      v8 = &v11;
    }
  }
  else if ( v6 > 0x1F )
  {
    v8 = (int *)(v12 & 0xFFFFFFFE);
  }
  else
  {
    v11 = v12 >> 1;
    v8 = &v11;
  }
  v8[a3 >> 5] |= 1 << (a3 & 0x1F);
  if ( v8 == &v11 )
  {
    v12 = 2 * v11 | 1;
    sub_10011B50(a2, v4, 0, v12);
  }
  return (int *)1;
}
// 10011AD0: using guessed type _DWORD __cdecl sub_10011AD0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10026F00) --------------------------------------------------------
int __usercall sub_10026F00@<eax>(unsigned int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // edi@1
  int v4; // esi@1
  int result; // eax@2
  int v6; // eax@3
  unsigned int v7; // esi@3
  unsigned int v8; // eax@4
  int *v9; // edx@7
  int v10; // [sp+8h] [bp-8h]@1
  int v11; // [sp+Ch] [bp-4h]@7

  v3 = a1;
  v4 = a3;
  sub_10011AD0(a2, *(_DWORD *)(a3 + 4), 0, &v10);
  if ( v10 == -2147483647 )
  {
    result = 0;
  }
  else
  {
    v6 = *(_DWORD *)(v4 + 16);
    v7 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      v8 = *(_WORD *)(v6 + 16);
      if ( v7 <= v8 )
        v7 = v8;
    }
    if ( v7 > 0x1F )
    {
      v9 = (int *)(v10 & 0xFFFFFFFE);
    }
    else
    {
      v11 = v10 >> 1;
      v9 = &v11;
    }
    result = (v9[v3 >> 5] & (1 << (v3 & 0x1F))) != 0;
  }
  return result;
}
// 10011AD0: using guessed type _DWORD __cdecl sub_10011AD0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10026F80) --------------------------------------------------------
int __cdecl sub_10026F80(int a1, signed int a2, signed int a3, unsigned int *a4, int *a5)
{
  int v5; // esi@1
  _BYTE *v7; // eax@6
  int *v8; // edx@9
  signed int v9; // ebx@9
  bool v10; // zf@9
  int v11; // eax@11
  unsigned int v12; // edi@11
  unsigned int v13; // eax@12

  v5 = a2;
  if ( *(_DWORD *)(a2 + 76) & 0x1000000 )
  {
    if ( !(*(int (__cdecl **)(int, _DWORD, _DWORD, signed int *))(*(_DWORD *)(**(_DWORD **)a2 + 4) + 16))(
            a1,
            *(_DWORD *)a2,
            *(_DWORD *)(*(_DWORD *)(a1 + 24) + 216),
            &a2) )
      return 0;
    if ( a2 & 7 || !a2 )
    {
      v7 = sub_10017540(a1, a2);
      if ( !v7 )
        return 0;
    }
    else
    {
      v7 = (_BYTE *)(a2 & 0xFFFFFFF8);
    }
    *a4 = (unsigned int)v7;
    return (*(int (__cdecl **)(int, _BYTE *, signed int, int *))(*(_DWORD *)(*(_DWORD *)v7 + 4) + 16))(a1, v7, a3, a5);
  }
  v8 = a5;
  v9 = a3;
  v10 = (a3 & 1) == 0;
  *a4 = 0;
  *v8 = -2147483647;
  if ( v10 || v9 == -2147483647 )
  {
    if ( v9 == *(_DWORD *)(*(_DWORD *)(a1 + 24) + 264) )
    {
      if ( *(_DWORD *)(v5 + 4) && *(_DWORD *)(v5 + 76) & 0x4000000 )
        return (*(int (__cdecl **)(int, _DWORD, signed int, int *))(*(_DWORD *)(**(_DWORD **)(v5 + 4) + 4) + 16))(
                 a1,
                 *(_DWORD *)(v5 + 4),
                 v9,
                 v8);
      *v8 = 2 * *(_DWORD *)(v5 + 24) | 1;
    }
    return 1;
  }
  v11 = *(_DWORD *)(v5 + 16);
  v12 = v9 >> 1;
  if ( v11 )
  {
    v13 = *(_WORD *)(v11 + 16);
    if ( *(_DWORD *)(v5 + 24) > v13 )
      v13 = *(_DWORD *)(v5 + 24);
  }
  else
  {
    v13 = *(_DWORD *)(v5 + 24);
  }
  if ( v12 >= v13 )
    return 1;
  if ( *(_DWORD *)(v5 + 4) )
  {
    if ( sub_10026F00(v9 >> 1, a1, v5) )
      return (*(int (__cdecl **)(int, _DWORD, signed int, int *))(*(_DWORD *)(**(_DWORD **)(v5 + 4) + 4) + 16))(
               a1,
               *(_DWORD *)(v5 + 4),
               v9,
               a5);
    v8 = a5;
  }
  *v8 = *(_DWORD *)(*(_DWORD *)(v5 + 28) + 4 * v12);
  return 1;
}

//----- (100270E0) --------------------------------------------------------
int __cdecl sub_100270E0(int a1, int a2)
{
  int result; // eax@1
  int v3; // eax@2
  int v4; // esi@2

  result = *(_DWORD *)(a2 + 4);
  if ( !result )
  {
    v3 = sub_10017C40(a1, (int)&off_10162098, 0, 0);
    v4 = v3;
    if ( v3 && sub_10010570(a1, v3, a2) )
    {
      *(_DWORD *)(a2 + 4) = v4;
      result = v4;
    }
    else
    {
      *(_DWORD *)(a1 + 92) = 0;
      result = 0;
    }
  }
  return result;
}
// 10162098: using guessed type char *off_10162098;

//----- (10027130) --------------------------------------------------------
int *__cdecl sub_10027130(int a1, int a2, signed int a3)
{
  int v3; // eax@3
  signed int v4; // ebx@4
  int *result; // eax@7
  int v6; // ecx@8
  unsigned int v7; // ecx@9

  if ( a3 & 1 && a3 != -2147483647 )
  {
    v3 = sub_10012430(a1, a2, (int *)&off_10162098, 0);
    if ( !v3 )
      return (int *)1;
    v4 = a3 >> 1;
    if ( a3 >> 1 >= -4 && v4 <= -3 )
    {
      *(_DWORD *)(v3 + 76) |= 1 << (23 - v4);
      return (int *)1;
    }
    v6 = *(_DWORD *)(v3 + 16);
    if ( v6 )
    {
      v7 = *(_WORD *)(v6 + 16);
      if ( *(_DWORD *)(v3 + 24) > v7 )
        v7 = *(_DWORD *)(v3 + 24);
    }
    else
    {
      v7 = *(_DWORD *)(v3 + 24);
    }
    if ( v4 >= v7 )
      return (int *)1;
    result = sub_10026E10(v3, a1, v4);
    if ( result )
      return (int *)1;
  }
  else
  {
    result = (int *)1;
  }
  return result;
}
// 10162098: using guessed type char *off_10162098;

//----- (100271C0) --------------------------------------------------------
signed int __cdecl sub_100271C0(int a1, int a2, signed int a3, int *a4)
{
  unsigned int v4; // eax@3
  int v5; // esi@3
  unsigned int v6; // ebx@4
  int v7; // eax@6
  unsigned int v8; // eax@7
  signed int result; // eax@12
  int v10; // eax@16

  if ( a3 & 1 && a3 != -2147483647 )
  {
    v4 = sub_10012430(a1, a2, (int *)&off_10162098, 0);
    v5 = v4;
    if ( v4 )
    {
      v6 = a3 >> 1;
      if ( a3 >> 1 == -4 )
      {
        if ( !(*(_DWORD *)(v4 + 76) & 0x8000000) )
        {
          v10 = *(_DWORD *)(v4 + 28);
          if ( v10 )
          {
            *a4 = *(_DWORD *)(v10 - 8);
            return 1;
          }
          *a4 = *(_DWORD *)(*(_DWORD *)(v5 + 16) + 4);
        }
      }
      else if ( v6 == -3 )
      {
        if ( !(*(_DWORD *)(v4 + 76) & 0x4000000) )
        {
          *a4 = 2 * *(_DWORD *)(v4 + 24) | 1;
          return 1;
        }
      }
      else
      {
        v7 = *(_DWORD *)(v4 + 16);
        if ( v7 )
        {
          v8 = *(_WORD *)(v7 + 16);
          if ( *(_DWORD *)(v5 + 24) > v8 )
            v8 = *(_DWORD *)(v5 + 24);
        }
        else
        {
          v8 = *(_DWORD *)(v5 + 24);
        }
        if ( v6 < v8 && !sub_10026F00(v6, a1, v5) )
        {
          *a4 = *(_DWORD *)(*(_DWORD *)(v5 + 28) + 4 * v6);
          return 1;
        }
      }
    }
    result = 1;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10162098: using guessed type char *off_10162098;

//----- (100272B0) --------------------------------------------------------
signed int __cdecl sub_100272B0(int a1, int a2, signed int a3, _DWORD *a4)
{
  unsigned int v4; // eax@3
  int v5; // esi@3
  signed int result; // eax@4
  signed int v7; // ebx@5
  int v8; // eax@8
  unsigned int v9; // eax@9

  if ( a3 & 1 && a3 != -2147483647 )
  {
    v4 = sub_10012430(a1, a2, (int *)&off_10162098, 0);
    v5 = v4;
    if ( v4 )
    {
      v7 = a3 >> 1;
      if ( a3 >> 1 < -4 || v7 > -3 )
      {
        v8 = *(_DWORD *)(v4 + 16);
        if ( v8 )
        {
          v9 = *(_WORD *)(v8 + 16);
          if ( *(_DWORD *)(v5 + 24) > v9 )
            v9 = *(_DWORD *)(v5 + 24);
        }
        else
        {
          v9 = *(_DWORD *)(v5 + 24);
        }
        if ( v7 < v9 && !sub_10026F00(v7, a1, v5) )
          *(_DWORD *)(*(_DWORD *)(v5 + 28) + 4 * v7) = *a4;
        result = 1;
      }
      else
      {
        result = 1;
        *(_DWORD *)(v5 + 76) |= 1 << (23 - v7);
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10162098: using guessed type char *off_10162098;

//----- (10027370) --------------------------------------------------------
signed int __cdecl sub_10027370(int a1, unsigned int a2, int a3, int a4, unsigned int *a5)
{
  unsigned int v5; // eax@1
  int v6; // esi@1
  int v8; // eax@5
  unsigned int v9; // edi@5
  unsigned int v10; // eax@6
  signed int v11; // eax@11
  int v12; // eax@13
  int v13; // eax@17
  int v14; // edx@17
  int v15; // edi@18
  int v16; // eax@18
  int v17; // eax@20

  *a5 = 0;
  v5 = sub_10012430(a1, a2, (int *)&off_10162098, 0);
  v6 = v5;
  if ( !v5 )
    return 1;
  if ( a3 & 1 && a3 != -2147483647 )
  {
    v8 = *(_DWORD *)(v5 + 16);
    v9 = a3 >> 1;
    if ( v8 )
    {
      v10 = *(_WORD *)(v8 + 16);
      if ( *(_DWORD *)(v6 + 24) > v10 )
        v10 = *(_DWORD *)(v6 + 24);
    }
    else
    {
      v10 = *(_DWORD *)(v6 + 24);
    }
    if ( v9 < v10 && !sub_10026F00(a3 >> 1, a1, v6) )
    {
      v11 = *(_DWORD *)(a1 + 16);
      v12 = v11 && v11 < 130;
      if ( sub_10018AC0(
             a1,
             a2,
             a3,
             *(_DWORD *)(*(_DWORD *)(v6 + 28) + 4 * v9),
             (signed int (*)())sub_100271C0,
             (signed int (*)())sub_100272B0,
             v12,
             0) )
      {
        *a5 = a2;
        return 1;
      }
      return 0;
    }
  }
  else
  {
    v13 = *(_DWORD *)(a1 + 24);
    v14 = *(_DWORD *)(v13 + 264);
    if ( (a3 & 0xFFFFFFF8) == (*(_DWORD *)(v14 + 8) & 0xFFFFFFF8) )
    {
      v15 = -3;
      v16 = 2 * *(_DWORD *)(v6 + 24) | 1;
    }
    else
    {
      v14 = *(_DWORD *)(v13 + 224);
      if ( (a3 & 0xFFFFFFF8) != (*(_DWORD *)(v14 + 8) & 0xFFFFFFF8) )
        return 1;
      v17 = *(_DWORD *)(v6 + 28);
      v15 = -4;
      if ( v17 )
        v16 = *(_DWORD *)(v17 - 8);
      else
        v16 = *(_DWORD *)(*(_DWORD *)(v6 + 16) + 4);
    }
    if ( !((1 << (23 - v15)) & *(_DWORD *)(v6 + 76)) )
    {
      if ( !sub_10017EF0(a1, a2, v14, v16, (signed int (*)())sub_100271C0, (signed int (*)())sub_100272B0, 0, 8, v15, 0) )
        return 0;
      *a5 = a2;
    }
  }
  return 1;
}
// 10162098: using guessed type char *off_10162098;

//----- (100274F0) --------------------------------------------------------
signed int __cdecl sub_100274F0(int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  signed int result; // eax@2
  void (__cdecl *v4)(int, int, int); // eax@6
  void (__cdecl *v5)(int, int, int); // eax@10
  int v6; // eax@12
  unsigned int v7; // eax@13
  unsigned int v8; // ebx@14
  int v9; // esi@17
  void (__cdecl *v10)(int, int, int); // eax@20
  int v11; // [sp+Ch] [bp-8h]@3
  int v12; // [sp+10h] [bp-4h]@3

  v2 = sub_10012430(a1, a2, (int *)&off_10162098, 0);
  if ( v2 )
  {
    if ( !sub_10015D00(a1, a2, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 264), &v12, (unsigned int *)&v11) )
      goto LABEL_27;
    if ( v11 )
    {
      v4 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v12 + 4) + 52);
      if ( v4 )
        v4(a1, v12, v11);
    }
    if ( sub_10015D00(a1, a2, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 224), &v12, (unsigned int *)&v11) )
    {
      if ( v11 )
      {
        v5 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v12 + 4) + 52);
        if ( v5 )
          v5(a1, v12, v11);
      }
      v6 = *(_DWORD *)(v2 + 16);
      if ( v6 )
      {
        v7 = *(_WORD *)(v6 + 16);
        if ( *(_DWORD *)(v2 + 24) <= v7 )
          v8 = v7;
        else
          v8 = *(_DWORD *)(v2 + 24);
      }
      else
      {
        v8 = *(_DWORD *)(v2 + 24);
      }
      v9 = 0;
      if ( v8 )
      {
        while ( sub_10015D00(a1, a2, 2 * v9 | 1, &v12, (unsigned int *)&v11) )
        {
          if ( v11 )
          {
            v10 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v12 + 4) + 52);
            if ( v10 )
              v10(a1, v12, v11);
          }
          if ( ++v9 >= v8 )
            goto LABEL_23;
        }
        result = 0;
      }
      else
      {
LABEL_23:
        result = 1;
      }
    }
    else
    {
LABEL_27:
      result = 0;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10162098: using guessed type char *off_10162098;

//----- (10027630) --------------------------------------------------------
int __cdecl sub_10027630(int a1, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // ecx@2
  int v5; // eax@3
  unsigned int v6; // eax@4
  int v7; // eax@8
  int v8; // esi@8

  result = *(_DWORD *)a2;
  if ( !*(_DWORD *)a2 )
  {
    v4 = a3;
    if ( !a3 )
    {
      v5 = *(_DWORD *)(a2 + 28);
      v6 = v5 ? *(_DWORD *)(v5 - 8) & 0xFFFFFFF8 : *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4);
      if ( v6 )
        v4 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4) & 0xFFFFFFF8;
    }
    v7 = sub_10017C40(a1, (int)&off_10162110, 0, v4);
    v8 = v7;
    if ( v7 && sub_10010570(a1, v7, a2) )
    {
      *(_DWORD *)a2 = v8;
      *(_DWORD *)(a2 + 52) = v8;
      *(_DWORD *)(a2 + 8) = v8;
      result = v8;
    }
    else
    {
      *(_DWORD *)(a1 + 92) = 0;
      result = 0;
    }
  }
  return result;
}
// 10162110: using guessed type char *off_10162110;

//----- (100276B0) --------------------------------------------------------
int __cdecl sub_100276B0(int a1, int a2, signed int a3, int *a4)
{
  int v4; // eax@3
  unsigned int v5; // ebx@4
  unsigned int v6; // ecx@6
  int result; // eax@9
  int v8; // ecx@14

  if ( a3 & 1 && a3 != -2147483647 )
  {
    v4 = sub_10010550(a1, a2);
    if ( !v4 )
      return 1;
    v5 = a3 >> 1;
    if ( a3 >> 1 == -2 )
    {
      if ( !(*(_DWORD *)(v4 + 76) & 0x2000000) )
      {
        v8 = *(_DWORD *)(v4 + 28);
        if ( v8 )
        {
          *a4 = *(_DWORD *)(v8 - 8);
          return 1;
        }
        *a4 = *(_DWORD *)(*(_DWORD *)(v4 + 16) + 4);
      }
      return 1;
    }
    if ( v5 != -1 )
    {
      v6 = *(_WORD *)(*(_DWORD *)(v4 + 16) + 16);
      if ( *(_DWORD *)(v4 + 24) > v6 )
        v6 = *(_DWORD *)(v4 + 24);
      if ( v5 < v6 )
      {
        *a4 = *(_DWORD *)(*(_DWORD *)(v4 + 28) + 4 * v5);
        return 1;
      }
      return 1;
    }
    if ( *(_DWORD *)(v4 + 76) & 0x1000000 )
      return 1;
    result = sub_100270E0(a1, v4);
    if ( result )
    {
      *a4 = result;
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10027780) --------------------------------------------------------
signed int __cdecl sub_10027780(int a1, int a2, signed int a3, _DWORD *a4)
{
  unsigned int v4; // eax@3
  signed int v5; // ebx@4
  unsigned int v7; // ecx@7

  if ( a3 & 1 )
  {
    if ( a3 != -2147483647 )
    {
      v4 = sub_10010550(a1, a2);
      if ( v4 )
      {
        v5 = a3 >> 1;
        if ( a3 >> 1 >= -2 && v5 < 0 )
        {
          *(_DWORD *)(v4 + 76) |= 1 << (23 - v5);
          return 1;
        }
        v7 = *(_WORD *)(*(_DWORD *)(v4 + 16) + 16);
        if ( *(_DWORD *)(v4 + 24) > v7 )
          v7 = *(_DWORD *)(v4 + 24);
        if ( v5 < v7 )
          *(_DWORD *)(*(_DWORD *)(v4 + 28) + 4 * v5) = *a4;
      }
    }
  }
  return 1;
}

//----- (10027800) --------------------------------------------------------
signed int __cdecl sub_10027800(int a1, int a2, signed int a3, _DWORD *a4)
{
  unsigned int v4; // eax@1

  v4 = sub_10010550(a1, a2);
  if ( v4 && (unsigned int)(a3 >> 1) < *(_DWORD *)(v4 + 36) )
    *a4 = *(_DWORD *)(*(_DWORD *)(v4 + 40) + 4 * (a3 >> 1));
  return 1;
}

//----- (10027840) --------------------------------------------------------
signed int __cdecl sub_10027840(int a1, int a2, signed int a3, _DWORD *a4)
{
  unsigned int v4; // eax@1

  v4 = sub_10010550(a1, a2);
  if ( v4 && (unsigned int)(a3 >> 1) < *(_DWORD *)(v4 + 36) )
    *(_DWORD *)(*(_DWORD *)(v4 + 40) + 4 * (a3 >> 1)) = *a4;
  return 1;
}

//----- (10027880) --------------------------------------------------------
signed int __cdecl sub_10027880(int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ebx@1
  int v5; // eax@3
  int v6; // esi@4
  int v7; // ecx@5
  signed int (*v8)(); // eax@6
  int v9; // edi@7
  void (__cdecl *v10)(int, int, int); // eax@11
  int v11; // [sp+8h] [bp-4h]@10

  v2 = sub_10010550(a1, a2);
  v3 = v2;
  if ( !v2 )
    return 1;
  v5 = *(_DWORD *)(*(_DWORD *)(v2 + 16) + 4);
  if ( !v5 )
    return 1;
  v6 = *(_DWORD *)(*(_DWORD *)v5 + 36);
  if ( !v6 )
    return 1;
  v7 = a2;
  while ( 1 )
  {
    v8 = *(signed int (**)())(v6 + 4);
    if ( v8 == sub_1002FB00 )
    {
      v9 = *(_DWORD *)(v3 + 28);
      goto LABEL_10;
    }
    if ( v8 == sub_1002FB80 )
      break;
LABEL_13:
    v6 = *(_DWORD *)(v6 + 20);
    if ( !v6 )
      return 1;
  }
  v9 = *(_DWORD *)(v3 + 40);
LABEL_10:
  if ( sub_10015D00(a1, v7, *(_DWORD *)v6, &a2, (unsigned int *)&v11) )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * *(_DWORD *)(v11 + 12)) = *(_DWORD *)(v9 + 4 * *(_WORD *)(v6 + 18));
    v7 = a2;
    v10 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 52);
    if ( v10 )
    {
      v10(a1, a2, v11);
      v7 = a2;
    }
    goto LABEL_13;
  }
  return 0;
}

//----- (10027950) --------------------------------------------------------
signed int __cdecl sub_10027950(int a1, unsigned int a2, int a3, int a4, unsigned int *a5)
{
  unsigned int v5; // eax@1
  unsigned int v6; // esi@1
  signed int result; // eax@2
  int v8; // eax@4
  unsigned int v9; // edi@5
  int v10; // eax@9
  int v11; // ecx@13
  void (__cdecl *v12)(int, int, int); // ecx@16
  signed int (*v13)(); // ebx@16
  unsigned int v14; // ebp@16
  int v15; // edi@16
  int v16; // ecx@20
  unsigned int v17; // eax@20
  signed int (*v18)(); // ebx@20
  signed int (*v19)(); // esi@20
  int v20; // eax@22
  int v21; // ecx@22
  int v22; // edx@22
  unsigned int v23; // esi@23
  int v24; // [sp+8h] [bp-Ch]@10
  int v25; // [sp+Ch] [bp-8h]@10
  int v26; // [sp+10h] [bp-4h]@16

  v5 = sub_10010550(a1, a2);
  v6 = v5;
  if ( !v5 || (a3 & 7) != 4 )
    return 1;
  v8 = *(_DWORD *)(v5 + 28);
  if ( v8 )
    v9 = *(_DWORD *)(v8 - 8) & 0xFFFFFFF8;
  else
    v9 = *(_DWORD *)(*(_DWORD *)(v6 + 16) + 4);
  if ( !v9 )
    return 1;
  v10 = sub_10038890(a1, a3 & 0xFFFFFFF8, 0);
  if ( !v10 || !sub_10015D00(a1, v9, v10, &v25, (unsigned int *)&v24) )
    return 0;
  if ( !v24 )
    return 1;
  v11 = *(_DWORD *)(*(_DWORD *)v25 + 4);
  if ( (int (__cdecl **)(int, int, int, int, int))v11 != &off_101614B0
    && (!v11 || *(int (__cdecl **)(int, int, int, int, int))v11 != off_101614B0) )
  {
    return 1;
  }
  v12 = *(void (__cdecl **)(int, int, int))(v11 + 52);
  v13 = *(signed int (**)())(v24 + 4);
  v14 = *(_WORD *)(v24 + 18);
  v26 = *(_DWORD *)v24;
  v15 = *(_BYTE *)(v24 + 16) & 0xBF;
  if ( v12 )
    v12(a1, v25, v24);
  if ( v13 == sub_1002FB00 )
  {
    v17 = *(_WORD *)(*(_DWORD *)(v6 + 16) + 16);
    v16 = *(_DWORD *)(v6 + 28);
    v23 = *(_DWORD *)(v6 + 24);
    if ( v23 > v17 )
      v17 = v23;
    v19 = 0;
    v18 = 0;
  }
  else
  {
    if ( v13 != sub_1002FB80 )
      return 1;
    v16 = *(_DWORD *)(v6 + 40);
    v17 = *(_DWORD *)(v6 + 36);
    v18 = (signed int (*)())sub_10027800;
    v19 = (signed int (*)())sub_10027840;
  }
  if ( v14 >= v17 )
  {
    v21 = 0;
    v20 = -2147483647;
    v22 = 0;
  }
  else
  {
    v20 = *(_DWORD *)(v16 + 4 * v14);
    v21 = 8;
    v22 = v14;
  }
  result = sub_10017EF0(a1, a2, v26, v20, v18, v19, v15, v21, v22, 0);
  if ( result )
  {
    *a5 = a2;
    return 1;
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10027AD0) --------------------------------------------------------
signed int __cdecl sub_10027AD0(int a1, int a2, int a3, _DWORD *a4)
{
  unsigned int v4; // eax@2
  int v5; // ecx@3

  if ( a3 == 2 )
  {
    v4 = sub_10010550(a1, a2);
    if ( v4 )
    {
      v5 = *(_DWORD *)(v4 + 28);
      if ( v5 )
      {
        *a4 = *(_DWORD *)(v5 - 8);
        return 1;
      }
      *a4 = *(_DWORD *)(*(_DWORD *)(v4 + 16) + 4);
    }
  }
  return 1;
}

//----- (10027B20) --------------------------------------------------------
signed int __cdecl sub_10027B20(int a1, int a2, int a3, char a4, int *a5)
{
  int v5; // ebx@1
  int v7; // ebp@3
  unsigned int v8; // eax@3
  unsigned int v9; // edi@3
  int v10; // eax@4
  int v11; // ecx@6
  int v12; // ebx@7
  int v13; // eax@15

  v5 = a3;
  if ( (a3 & 7) != 4 )
    return 1;
  v7 = a2;
  v8 = sub_10012430(a1, a2, (int *)&off_101621B8, 0);
  v9 = v8;
  if ( !v8 )
    return 1;
  v10 = *(_DWORD *)(v8 + 4);
  if ( !v10 )
    return 1;
  if ( a4 & 2 )
    return 1;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 232);
  if ( (v5 ^ *(_DWORD *)(v11 + 8)) & 0xFFFFFFF8 )
    return 1;
  v12 = 0;
  if ( v10 != a2 )
  {
    if ( !(*(int (__cdecl **)(int, int, int, int *))(*(_DWORD *)(*(_DWORD *)v10 + 4) + 16))(a1, v10, v11, &a3) )
      return 0;
    if ( !(a3 & 7) )
    {
      v12 = a3 & 0xFFFFFFF8;
      if ( a3 & 0xFFFFFFF8 )
      {
        v7 = a2;
        goto LABEL_15;
      }
    }
    v7 = a2;
  }
  if ( *(_DWORD *)(v9 + 24) == *(_DWORD *)(*(_DWORD *)(a1 + 24) + 196) )
    return 1;
LABEL_15:
  v13 = sub_10017C40(a1, (int)&off_10161510, v12, *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4) & 0xFFFFFFF8);
  if ( !v13 )
    return 0;
  if ( !sub_100173E0(a1, v7, v13, 5) )
  {
    *(_DWORD *)(a1 + 92) = 0;
    return 0;
  }
  *a5 = v7;
  return 1;
}
// 10161510: using guessed type char *off_10161510;
// 101621B8: using guessed type char *off_101621B8;

//----- (10027C20) --------------------------------------------------------
signed int __cdecl sub_10027C20(int a1, int a2, int a3, int *a4)
{
  signed int result; // eax@2

  if ( a3 == 2 )
  {
    *a4 = a2;
    result = 1;
  }
  else
  {
    result = sub_10018370(a1, a2, a3, a4);
  }
  return result;
}

//----- (10027C50) --------------------------------------------------------
unsigned int __cdecl sub_10027C50(int a1, int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // esi@1
  bool v4; // zf@4

  result = sub_10010550(a1, a2);
  v3 = result;
  if ( result )
  {
    if ( *(_DWORD *)(result + 4) == a2 )
      *(_DWORD *)(result + 4) = 0;
    v4 = (*(_DWORD *)result)-- == 1;
    if ( v4 )
    {
      if ( *(_DWORD *)(result + 12) )
        sub_10021340(a1, *(_DWORD *)(result + 12));
      result = (unsigned int)sub_10010340(a1, v3);
    }
  }
  return result;
}

//----- (10027CA0) --------------------------------------------------------
signed int __cdecl sub_10027CA0(int a1, signed int a2, int a3, _DWORD *a4)
{
  signed int v4; // ebp@1
  int v5; // edi@1
  int v6; // ebx@4
  _DWORD *v7; // esi@4
  unsigned int v8; // ebx@9
  unsigned int v9; // esi@14
  unsigned int v10; // eax@14
  _BYTE *v12; // eax@21
  char v13; // al@22

  v4 = a2;
  v5 = a1;
  if ( !(*(int (__cdecl **)(int, signed int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(
          a1,
          a2,
          *(_DWORD *)(*(_DWORD *)(a1 + 24) + 232),
          &a1) )
    return 0;
  if ( a1 & 7 || !a1 )
  {
    v12 = sub_1004F8E0(v5, -1, v4, 0);
    if ( v12 )
    {
      v13 = (unsigned int)sub_10010FF0((unsigned int)v12);
      sub_100110F0(v5, (int)sub_1003ED50, 0, 135, v13);
    }
    return 0;
  }
  v6 = a3;
  v7 = a4;
  if ( !sub_10017300(v5, a1 & 0xFFFFFFF8, a3, a4) )
    return 0;
  if ( !*v7 && !(v6 & 7) && v6 && v6 != a1 )
  {
    v8 = v6 & 0xFFFFFFF8;
    while ( (*(int (__cdecl **)(int, unsigned int, _DWORD, signed int *))(*(_DWORD *)(*(_DWORD *)v8 + 4) + 16))(
              v5,
              v8,
              *(_DWORD *)(*(_DWORD *)(v5 + 24) + 236),
              &a2) )
    {
      if ( !(a2 & 7) )
      {
        if ( a2 & 0xFFFFFFF8 )
        {
          if ( (char **)(*(_DWORD *)(*(_DWORD *)((a2 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) == &off_101621B8 )
          {
            v9 = sub_10010550(v5, a2 & 0xFFFFFFF8);
            v10 = sub_10010550(v5, v4);
            if ( *(_DWORD *)(v9 + 8) == *(_DWORD *)(v10 + 8) && *(_DWORD *)(v9 + 12) == *(_DWORD *)(v10 + 12) )
            {
              *a4 = 1;
              return 1;
            }
          }
        }
      }
      v8 = **(_DWORD **)(v8 + 4) & 0xFFFFFFF8;
      if ( !v8 )
        return 1;
    }
    return 0;
  }
  return 1;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10027E00) --------------------------------------------------------
int __cdecl sub_10027E00(int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // esi@1
  int v4; // eax@2
  int v5; // esi@5
  int result; // eax@7

  v2 = sub_10010550(a1, a2);
  v3 = v2;
  if ( v2 )
  {
    v4 = *(_DWORD *)(v2 + 24);
    if ( v4 && !(*(_BYTE *)(v4 + 16) & 4) )
      sub_1003AB90(a1, v4);
    v5 = *(_DWORD *)(v3 + 12);
    if ( v5 )
      sub_100213B0(a1, v5);
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10027E60) --------------------------------------------------------
signed int __usercall sub_10027E60@<eax>(char a1@<bpl>, int a2, int a3, unsigned int a4, int a5, int a6, int *a7)
{
  _DWORD *v7; // ebx@1
  int v8; // eax@2
  int v9; // edx@2
  int v10; // ecx@4
  signed int v11; // eax@11
  int v13; // esi@14
  __int64 v14; // ST20_8@16
  int v15; // eax@17

  v7 = (_DWORD *)a6;
  if ( a6 )
  {
    v8 = *(_DWORD *)(a6 - 4);
    v9 = *(_DWORD *)(a6 - 4) & 7;
    a6 = *(_DWORD *)(a6 - 4);
    if ( a6 & 7
      || !(v8 & 0xFFFFFFF8)
      || (v10 = v8 & 0xFFFFFFF8,
          (char **)(*(_DWORD *)(*(_DWORD *)((v8 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8) )
    {
      if ( !v9 )
      {
        if ( !(*(int (__cdecl **)(int, unsigned int, signed int, int *))((*(_DWORD *)(*(_DWORD *)((v8 & 0xFFFFFFF8) + 4)
                                                                                    + 8) & 0xFFFFFFFE)
                                                                       + 32))(
                a2,
                v8 & 0xFFFFFFF8,
                2,
                &a6) )
          return 0;
        v8 = a6;
      }
      if ( v8 & 7
        || !(v8 & 0xFFFFFFF8)
        || (v10 = v8 & 0xFFFFFFF8,
            (char **)(*(_DWORD *)(*(_DWORD *)((v8 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8) )
      {
        v11 = sub_100101E0(a2, v8);
        sub_10010260(a2, v11);
        sub_100110F0(a2, (int)sub_1003ED50, 0, 8, (unsigned int)"Function");
        return 0;
      }
    }
  }
  else
  {
    v10 = a3;
  }
  v13 = sub_10010550(a2, v10);
  if ( v13 )
  {
    if ( a5 )
    {
      HIDWORD(v14) = *v7;
      LODWORD(v14) = a2;
      if ( !sub_100201D0(v14, &a4) )
        return 0;
    }
    v15 = sub_10011C70(a1, a2, v13, a4);
    if ( !v15 )
      return 0;
    *a7 = v15 | 4;
  }
  return 1;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10027F70) --------------------------------------------------------
signed int __usercall sub_10027F70@<eax>(char a1@<bpl>, int a2, int a3, int a4, int a5, int *a6)
{
  return sub_10027E60(a1, a2, a3, 0, a4, a5, a6);
}

//----- (10027FA0) --------------------------------------------------------
signed int __usercall sub_10027FA0@<eax>(char a1@<bpl>, int a2, int a3, int a4, int a5, int *a6)
{
  return sub_10027E60(a1, a2, a3, 0x8000u, a4, a5, a6);
}

//----- (10027FD0) --------------------------------------------------------
int __cdecl sub_10027FD0(int a1, unsigned int a2, unsigned int a3, int a4, _DWORD *a5)
{
  signed int *v5; // edi@1
  int *v6; // esi@1
  int result; // eax@1
  int v8; // ebx@2
  unsigned int v9; // esi@5
  _DWORD *v10; // eax@9
  unsigned int *v11; // eax@10
  _DWORD *v12; // eax@10
  unsigned int v13; // ecx@10
  int v14; // edi@12
  int v15; // ebx@12
  int v16; // esi@12
  unsigned int v17; // eax@13

  v5 = (signed int *)a4;
  v6 = (int *)(a4 - 4);
  result = (*(int (__cdecl **)(int, unsigned int, signed int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 36))(
             a1,
             a2,
             2,
             a4 - 4);
  if ( !result )
    return result;
  v8 = *v6;
  if ( *v6 & 7
    || !(v8 & 0xFFFFFFF8)
    || (char **)(*(_DWORD *)(*(_DWORD *)((v8 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8 )
  {
    v17 = sub_100101C0(a1, *v6);
    sub_10010FF0(v17);
    sub_100110F0(a1, (int)sub_1003ED50, 0, 8, (unsigned int)"Function");
    return 0;
  }
  v9 = a3;
  if ( a3 )
  {
    if ( !sub_10017450(a1, *v5, &a2) )
      return 0;
    --v9;
    ++v5;
  }
  else
  {
    a2 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) & 0xFFFFFFF8;
  }
  v10 = (_DWORD *)sub_1002F880(a1, v9 + 2, &a4);
  if ( !v10 )
    return 0;
  *v10 = v8;
  v11 = v10 + 1;
  *v11 = a2;
  v12 = v11 + 1;
  v13 = 0;
  if ( v9 )
  {
    do
    {
      *v12 = v5[v13++];
      ++v12;
    }
    while ( v13 < v9 );
  }
  v14 = *(_DWORD *)(a1 + 56);
  v15 = *(_DWORD *)(v14 + 60);
  *(_DWORD *)(v14 + 60) = v12;
  v16 = sub_1002FC40(a1, v9, 6);
  *a5 = *(_DWORD *)(*(_DWORD *)(v14 + 60) - 4);
  *(_DWORD *)(v14 + 60) = v15;
  sub_1002F930(a1, a4);
  return v16;
}
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);
// 101621B8: using guessed type char *off_101621B8;

//----- (10028110) --------------------------------------------------------
int __usercall sub_10028110@<eax>(char a1@<dil>, int a2, unsigned int a3, unsigned int a4, int a5, _DWORD *a6)
{
  unsigned int v6; // ebp@1
  int v8; // ebx@3
  int v9; // edi@3
  int *v10; // esi@3
  int v11; // eax@4
  int v12; // eax@8
  int v13; // eax@11
  char **v14; // ecx@11
  unsigned int v15; // ebp@15
  int v16; // eax@17
  int v17; // esi@18
  unsigned int v18; // edi@18
  int v19; // ebx@19
  int v20; // edi@21
  int v21; // ST3C_4@21
  unsigned int v22; // eax@24
  char v23; // [sp-Ch] [bp-1Ch]@3
  int v24; // [sp+4h] [bp-Ch]@7
  int v25; // [sp+8h] [bp-8h]@4
  int v26; // [sp+Ch] [bp-4h]@17

  v6 = a4;
  if ( !a4 )
    return sub_10027FD0(a2, a3, a4, a5, a6);
  v8 = a2;
  v23 = a1;
  v9 = a5;
  v10 = (int *)(a5 - 4);
  if ( !(*(int (__cdecl **)(int, unsigned int, signed int, int))(*(_DWORD *)(*(_DWORD *)a3 + 4) + 36))(
          a2,
          a3,
          2,
          a5 - 4) )
    return 0;
  v11 = *v10;
  v25 = *v10;
  if ( *v10 & 7
    || !(v11 & 0xFFFFFFF8)
    || (char **)(*(_DWORD *)(*(_DWORD *)((v11 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8 )
  {
    v22 = sub_100101C0(a2, v11);
    sub_10010FF0(v22);
    sub_100110F0(a2, (int)sub_1003ED50, 0, 8, (unsigned int)"Function");
    return 0;
  }
  v24 = 0;
  a4 = 0;
  if ( v6 >= 2 )
  {
    v12 = *(_DWORD *)(v9 + 4);
    if ( v12 )
    {
      if ( v12 != -2147483647 )
      {
        if ( v12 & 7
          || (v13 = v12 & 0xFFFFFFF8,
              v14 = (char **)(*(_DWORD *)(*(_DWORD *)(v13 + 4) + 8) & 0xFFFFFFFE),
              v24 = v13,
              v14 != &off_10162098)
          && v14 != &off_10162958 )
        {
          sub_100110F0(a2, (int)sub_1003ED50, 0, 154, v23);
          return 0;
        }
        if ( !sub_1002D770(a2, v13, (signed int *)&a4) )
          return 0;
      }
    }
  }
  if ( !sub_10017450(a2, *(_DWORD *)v9, &a3) )
    return 0;
  v15 = a4;
  if ( a4 >= 0xFFFF )
    v15 = 0xFFFF;
  v16 = sub_1002F880(a2, v15 + 2, &v26);
  if ( !v16 )
    return 0;
  *(_DWORD *)v16 = v25;
  *(_DWORD *)(v16 + 4) = a3;
  v17 = v16 + 8;
  v18 = 0;
  if ( v15 )
  {
    while ( 1 )
    {
      v19 = sub_10010A10(v8, v24, v18);
      if ( !v19 )
        break;
      v8 = a2;
      ++v18;
      v17 += 4;
      if ( v18 >= v15 )
        goto LABEL_21;
    }
  }
  else
  {
LABEL_21:
    v20 = *(_DWORD *)(v8 + 56);
    v21 = *(_DWORD *)(v20 + 60);
    *(_DWORD *)(v20 + 60) = v17;
    v19 = sub_1002FC40(v8, v15, 6);
    *a6 = *(_DWORD *)(*(_DWORD *)(v20 + 60) - 4);
    *(_DWORD *)(v20 + 60) = v21;
  }
  sub_1002F930(a2, v26);
  return v19;
}
// 10028110: could not find valid save-restore pair for edi
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);
// 10162098: using guessed type char *off_10162098;
// 101621B8: using guessed type char *off_101621B8;
// 10162958: using guessed type char *off_10162958;

//----- (10028320) --------------------------------------------------------
signed int __cdecl sub_10028320(int a1)
{
  unsigned int v1; // eax@1
  int v2; // edi@1
  int v4; // ecx@6
  unsigned int v5; // esi@7
  __int16 v6; // ax@12
  int v7; // edi@15
  unsigned __int16 v8; // dx@16

  v1 = *(_DWORD *)a1;
  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & 0x40000000 )
    v2 = v1 & ((v2 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
  if ( !v2 )
    return 0;
  if ( *(_DWORD *)a1 & 0x40000000 )
  {
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)v4 & 0x40000000 )
    {
      v5 = sub_1001A200(a1);
    }
    else if ( (v1 & 0x80000000) == 0 )
    {
      v5 = *(_DWORD *)(v4 + 4) + 2 * ((v1 >> 15) & 0x7FFF);
    }
    else
    {
      v5 = *(_DWORD *)(v4 + 4);
    }
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 4);
  }
  v6 = *(_WORD *)v5;
  if ( (1086 >> (dword_100CED28[4
                              * (unsigned __int8)byte_100CCEA8[*(_WORD *)v5 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)*(_WORD *)v5 >> 6] << 6)]] & 0x1F)) & 1
    || v6 == 95
    || v6 == 36 )
  {
    v7 = v2 - 1;
    if ( !v7 )
      return 1;
    while ( 1 )
    {
      v8 = *(_WORD *)(v5 + 2);
      v5 += 2;
      if ( !((8390526 >> (dword_100CED28[4
                                       * (unsigned __int8)byte_100CCEA8[v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)v8 >> 6] << 6)]] & 0x1F)) & 1)
        && v8 != 95
        && v8 != 36 )
      {
        break;
      }
      if ( !--v7 )
        return 1;
    }
  }
  return 0;
}

//----- (10028440) --------------------------------------------------------
char *__cdecl sub_10028440(int a1, unsigned int a2)
{
  return sub_10012240(a1, a2, 0, (int *)&off_10162110, 0, 0, (int *)&off_101620E0, 0, 0, 0);
}
// 101620E0: using guessed type char *off_101620E0;
// 10162110: using guessed type char *off_10162110;

//----- (10028470) --------------------------------------------------------
signed int __cdecl sub_10028470(int a1, int a2, int a3)
{
  signed int result; // eax@3

  if ( !*(_DWORD *)(a2 + 4) )
    *(_DWORD *)(a2 + 4) = a3;
  result = sub_10010570(a1, a3, a2);
  if ( result )
  {
    ++*(_DWORD *)a2;
    result = 1;
  }
  return result;
}

//----- (100284B0) --------------------------------------------------------
_BYTE *__cdecl sub_100284B0(int a1, int *a2, char a3)
{
  _BYTE *v3; // ecx@1
  signed int v4; // eax@2
  int v5; // edx@3
  _BYTE *result; // eax@6
  char v7; // al@7

  v3 = (_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 4 * sub_100101E0(a1, *a2) + 124) + 8) & 0xFFFFFFF8);
  if ( a3 & 2 )
  {
    v4 = 1;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 56);
    if ( v5 )
      v4 = ((signed int)a2 - *(_DWORD *)(v5 + 60)) >> 2;
    else
      v4 = 0;
  }
  result = sub_1004F8E0(a1, v4, *a2, v3);
  if ( result )
  {
    v7 = (unsigned int)sub_10010FF0((unsigned int)result);
    result = (_BYTE *)sub_100110F0(a1, (int)sub_1003ED50, 0, a3 & 1 | 0x16, v7);
  }
  return result;
}

//----- (10028530) --------------------------------------------------------
int __cdecl sub_10028530(int a1, _DWORD *a2, int *a3)
{
  int result; // eax@2

  if ( a2[19] & 0x1000000 )
  {
    result = (*(int (__cdecl **)(int, _DWORD, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)*a2 + 4) + 16))(
               a1,
               *a2,
               *(_DWORD *)(*(_DWORD *)(a1 + 24) + 216),
               a3);
  }
  else
  {
    result = sub_100270E0(a1, (int)a2);
    if ( result )
    {
      *a3 = result;
      result = 1;
    }
  }
  return result;
}

//----- (10028590) --------------------------------------------------------
int __cdecl sub_10028590(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // esi@1
  unsigned int v4; // edi@1
  signed int v5; // ebx@1
  int v6; // eax@2
  unsigned int v7; // ebp@2
  unsigned int v8; // eax@3
  int v9; // ebp@7
  int v10; // ebx@7
  int v11; // ebx@7
  int v12; // ebx@7
  int v13; // ebx@7
  int result; // eax@7
  int v15; // [sp+10h] [bp-4h]@1

  v2 = a2;
  v3 = a1;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = sub_100274F0(a1, *(_DWORD *)(a2 + 4));
  sub_10011AD0(v3, v4, 0, &v15);
  if ( v15 != -2147483647 )
  {
    sub_10011B50(v3, v4, 0, -2147483647);
    v6 = *(_DWORD *)(v2 + 16);
    v7 = *(_DWORD *)(v2 + 24);
    if ( v6 )
    {
      v8 = *(_WORD *)(v6 + 16);
      if ( v7 <= v8 )
        v7 = v8;
    }
    if ( v7 > 0x1F )
      sub_10010340(v3, v15 & 0xFFFFFFFE);
  }
  v9 = *(_DWORD *)(v3 + 24);
  v10 = sub_10016210(v3, v4, *(_DWORD *)(v9 + 224), &a1) & v5;
  v11 = sub_10016530(v3, v4, *(_DWORD *)(v9 + 224), &a1) & v10;
  v12 = sub_10016210(v3, v4, *(_DWORD *)(v9 + 264), &a1) & v11;
  v13 = sub_10016530(v3, v4, *(_DWORD *)(v9 + 264), &a1) & v12;
  result = sub_10010570(v3, v4, 0) & v13;
  *(_DWORD *)(a2 + 4) = 0;
  return result;
}
// 10011AD0: using guessed type _DWORD __cdecl sub_10011AD0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10028680) --------------------------------------------------------
int __cdecl sub_10028680(int a1, unsigned int *a2)
{
  unsigned int *v2; // ebp@1
  unsigned int v3; // ebx@1
  int result; // eax@2
  signed int v5; // esi@3
  int v6; // ST38_4@4
  int v7; // esi@4
  int v8; // esi@4

  v2 = a2;
  v3 = *a2;
  if ( *a2 )
  {
    v5 = sub_10027880(a1, v3);
    if ( v2[1] )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 216);
      v7 = sub_10016210(a1, v3, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 216), &a2) & v5;
      v8 = sub_10016530(a1, v3, v6, &a2) & v7;
      v5 = sub_10028590(a1, (int)v2) & v8;
    }
    result = sub_10010570(a1, v3, 0) & v5;
    *v2 = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10028710) --------------------------------------------------------
signed int __cdecl sub_10028710(int a1, int a2, signed int a3, int *a4)
{
  unsigned int v4; // ebx@3
  unsigned int v5; // eax@3
  signed int result; // eax@4
  int i; // esi@5
  int v8; // eax@12
  signed int v9; // ecx@16
  int v10; // eax@23
  int v11; // eax@28
  int *v12; // edx@30
  int v13; // ecx@33
  int v14; // esi@35
  int v15; // esi@37
  int v16; // eax@40

  if ( a3 & 1 && a3 != -2147483647 )
  {
    v4 = a3 >> 1;
    v5 = sub_10012430(a1, a2, (int *)&off_101621B8, 0);
    if ( v5 )
    {
      for ( i = *(_DWORD *)(a1 + 56); i; i = *(_DWORD *)(i + 44) )
      {
        if ( *(_DWORD *)(i + 16) == v5 && !(*(_BYTE *)(i + 76) & 0x30) )
          break;
      }
      switch ( v4 )
      {
        case 0xFFFFFFFF:
          if ( !sub_10011140(a1, 5, (int)sub_1003ED50, 0, 158, (unsigned int)"arguments") )
            goto LABEL_14;
          if ( i )
          {
            v8 = sub_10028530(a1, (_DWORD *)i, a4);
            goto LABEL_13;
          }
          *a4 = 0;
          result = 1;
          break;
        case 0xFFFFFFFD:
          v9 = *(_DWORD *)(a1 + 16);
          if ( !v9 || v9 >= 130 )
            goto LABEL_22;
          if ( i && *(_DWORD *)(i + 16) )
          {
            *a4 = 2 * *(_DWORD *)(i + 24) | 1;
            result = 1;
          }
          else
          {
            *a4 = 2 * *(_WORD *)(v5 + 16) | 1;
            result = 1;
          }
          break;
        case 0xFFFFFFFB:
LABEL_22:
          *a4 = 2 * *(_WORD *)(v5 + 16) | 1;
          result = 1;
          break;
        case 0xFFFFFFFA:
          v10 = *(_DWORD *)(v5 + 24);
          if ( v10 )
          {
            *a4 = *(_DWORD *)(v10 + 8);
            result = 1;
          }
          else
          {
            *a4 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 480) | 4;
            result = 1;
          }
          break;
        case 0xFFFFFFF9:
          if ( !i )
            goto LABEL_30;
          while ( *(_BYTE *)(i + 76) & 4 )
          {
            v11 = *(_DWORD *)(i + 44);
            if ( !v11 )
              break;
            i = *(_DWORD *)(i + 44);
            if ( !v11 )
              goto LABEL_30;
          }
          v14 = *(_DWORD *)(i + 44);
          if ( v14 && *(_DWORD *)(v14 + 16) && (v15 = *(_DWORD *)(v14 + 28)) != 0 )
          {
            v12 = a4;
            *a4 = *(_DWORD *)(v15 - 8);
          }
          else
          {
LABEL_30:
            v12 = a4;
            *a4 = 0;
          }
          if ( *v12 & 7 )
            goto LABEL_43;
          if ( !*v12 )
            goto LABEL_43;
          v13 = *(_DWORD *)(a1 + 24);
          if ( !*(_DWORD *)(v13 + 8792) )
            goto LABEL_43;
          v8 = (*(int (__cdecl **)(int, int, _DWORD, signed int, int *))(*(_DWORD *)(a1 + 24) + 8792))(
                 a1,
                 a2,
                 *(_DWORD *)(*(_DWORD *)(v13 + 228) + 8),
                 4,
                 v12);
LABEL_13:
          if ( v8 )
            goto LABEL_43;
LABEL_14:
          result = 0;
          break;
        default:
          if ( i )
          {
            v16 = *(_DWORD *)(i + 16);
            if ( v16 )
            {
              if ( v4 < *(_WORD *)(v16 + 16) )
                *a4 = *(_DWORD *)(*(_DWORD *)(i + 28) + 4 * v4);
            }
          }
LABEL_43:
          result = 1;
          break;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10028940) --------------------------------------------------------
int __cdecl sub_10028940(int a1, int a2, int a3, __int16 a4, char a5, unsigned int a6, int a7)
{
  int v7; // esi@1
  int v8; // eax@2

  v7 = sub_10011830(a1, 0x20u);
  if ( !v7 )
    return 0;
  v8 = a2;
  if ( a2 )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) = a6;
  }
  else
  {
    v8 = sub_10017C40(a1, (int)&off_101621B8, 0, a6);
    if ( !v8 )
    {
LABEL_7:
      sub_10010340(a1, v7);
      return 0;
    }
  }
  *(_DWORD *)(v7 + 8) = a3;
  *(_WORD *)(v7 + 16) = a4;
  *(_DWORD *)v7 = 0;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 12) = 0;
  *(_WORD *)(v7 + 18) = 0;
  *(_WORD *)(v7 + 20) = 0;
  *(_BYTE *)(v7 + 22) = a5 & 0xF8;
  *(_BYTE *)(v7 + 23) = 0;
  *(_DWORD *)(v7 + 24) = a7;
  *(_DWORD *)(v7 + 28) = 0;
  if ( !sub_10028470(a1, v7, v8) )
  {
    *(_DWORD *)(a1 + 92) = 0;
    goto LABEL_7;
  }
  return v7;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (100289F0) --------------------------------------------------------
int __cdecl sub_100289F0(int a1, int a2, unsigned int a3)
{
  int v3; // edi@1
  int v4; // eax@2

  v3 = sub_10017C40(a1, (int)&off_101621B8, a2, a3);
  if ( !v3 )
    return 0;
  v4 = sub_10010550(a1, a2);
  if ( !sub_10028470(a1, v4, v3) )
  {
    *(_DWORD *)(a1 + 92) = 0;
    return 0;
  }
  return v3;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10028A40) --------------------------------------------------------
int __cdecl sub_10028A40(int a1, unsigned int a2, int a3, int a4, __int16 a5, int a6)
{
  int result; // eax@1

  result = sub_10028940(a1, 0, a4, a5, a6, a2, a3);
  if ( result )
    result &= -((*(int (__cdecl **)(int, unsigned int, int, _DWORD, _DWORD, _DWORD, unsigned int, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 12))(
                  a1,
                  a2,
                  a3,
                  *(_DWORD *)(result + 4),
                  0,
                  0,
                  a6 & 0xFFFFFF07,
                  0) != 0);
  return result;
}

//----- (10028AB0) --------------------------------------------------------
unsigned int __cdecl sub_10028AB0(int a1, int *a2, char a3)
{
  int *v3; // edi@1
  int v4; // eax@1
  int v5; // eax@2

  v3 = a2;
  v4 = *a2;
  a2 = (int *)*a2;
  if ( (unsigned __int8)a2 & 7 )
    goto LABEL_14;
  v5 = v4 & 0xFFFFFFF8;
  if ( !v5 )
    goto LABEL_14;
  if ( (char **)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 8) & 0xFFFFFFFE) != &off_101621B8 )
  {
    if ( !(*(int (__cdecl **)(int, int, signed int, int **))(*(_DWORD *)(*(_DWORD *)v5 + 4) + 36))(a1, v5, 2, &a2) )
      return 0;
    if ( (unsigned __int8)a2 & 7 )
      goto LABEL_14;
    if ( !((unsigned int)a2 & 0xFFFFFFF8) )
      goto LABEL_14;
    v5 = (unsigned int)a2 & 0xFFFFFFF8;
    if ( (char **)(*(_DWORD *)(*(_DWORD *)(((unsigned int)a2 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8 )
      goto LABEL_14;
  }
  if ( !v5 )
  {
LABEL_14:
    sub_100284B0(a1, v3, a3);
    return 0;
  }
  return sub_10010550(a1, v5);
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10028B40) --------------------------------------------------------
signed int __cdecl sub_10028B40(unsigned int a1, int *a2)
{
  _DWORD *v2; // ebx@1
  int v3; // ebp@1
  unsigned int v4; // eax@2
  int v5; // edi@2
  int v6; // eax@3
  int v7; // eax@5
  unsigned int v8; // esi@14
  char *v9; // ebx@16
  int v10; // edx@17
  int v11; // eax@17
  unsigned int v12; // edi@17
  signed int result; // eax@22
  int i; // eax@24
  signed int (*v15)(); // ecx@25
  unsigned int v16; // edi@30
  int v17; // eax@31
  int v18; // eax@40
  int v19; // eax@44
  signed int v20; // edi@50
  signed int (*v21)(); // ebp@54
  signed int (*v22)(); // ebx@54
  char *v23; // esi@60
  unsigned int *v24; // eax@61
  int v25; // eax@67
  bool v26; // zf@67
  int v27; // eax@68
  int v28; // [sp+10h] [bp-3Ch]@2
  int v29; // [sp+14h] [bp-38h]@1
  int v30; // [sp+14h] [bp-38h]@16
  unsigned int v31; // [sp+18h] [bp-34h]@32
  const char *v32; // [sp+1Ch] [bp-30h]@34
  unsigned int v33; // [sp+20h] [bp-2Ch]@4
  int v34; // [sp+24h] [bp-28h]@34
  int v35; // [sp+28h] [bp-24h]@49
  char v36; // [sp+2Ch] [bp-20h]@16

  v2 = (_DWORD *)a1;
  v3 = *(_DWORD *)(a1 + 8);
  v29 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)a1 )
  {
    v7 = sub_10028940(v3, 0, 0, 0, 0, 0, 0);
    v28 = v7;
    if ( !v7 )
      return 0;
    v5 = v7;
LABEL_7:
    v33 = 0;
    goto LABEL_8;
  }
  v4 = sub_10010550(v3, *a2);
  v5 = v4;
  v28 = v4;
  if ( !v4 )
    return 1;
  v6 = *(_DWORD *)(v4 + 24);
  if ( !v6 )
    goto LABEL_7;
  v33 = *(_DWORD *)(v6 + 8) & 0xFFFFFFF8;
LABEL_8:
  if ( !sub_100528A0(a1, (int *)&v33)
    || !sub_10052D40(a1, (_WORD *)(v5 + 16))
    || !sub_10052D40(a1, (_WORD *)(v5 + 18))
    || !sub_10052D40(a1, (_WORD *)(v5 + 20))
    || !sub_10052D00(a1, (_BYTE *)(v5 + 22)) )
  {
    return 0;
  }
  if ( !*(_DWORD *)(v5 + 4) )
  {
LABEL_65:
    if ( !sub_10021730((int)v2, (_DWORD **)(v5 + 12), 0) )
      return 0;
    if ( *v2 == 1 )
    {
      v25 = v33;
      v26 = v33 == 0;
      *a2 = *(_DWORD *)(v5 + 4);
      if ( v26
        || (v27 = sub_10038890(v3, v25, 0), (*(_DWORD *)(v5 + 24) = v27) != 0)
        && (*(int (__cdecl **)(int, _DWORD, int, int, _DWORD, _DWORD, signed int, _DWORD))(*(_DWORD *)(**(_DWORD **)(v3 + 88) + 4)
                                                                                         + 12))(
             v3,
             *(_DWORD *)(v3 + 88),
             v27,
             *a2,
             0,
             0,
             1,
             0) )
      {
        sub_100212D0(v3, *(_DWORD *)(v5 + 12), v5);
        return 1;
      }
      return 0;
    }
    return 1;
  }
  v8 = *(_WORD *)(v5 + 16) + *(_WORD *)(v5 + 20);
  if ( *(_DWORD *)a1 )
  {
    v35 = *(_WORD *)(v5 + 16) + *(_WORD *)(v5 + 20);
    if ( v8 )
    {
      while ( 1 )
      {
        v20 = 5;
        if ( !sub_10052520(a1, (int *)&v31)
          || !sub_10052520(a1, &v34)
          || !sub_100525F0((char *)a1, (unsigned int *)&v32) )
        {
          return 0;
        }
        if ( v31 == 1 )
        {
          v21 = sub_1002FB00;
          v22 = (signed int (*)())sub_1002FB20;
        }
        else if ( v31 == 2 || v31 == 3 )
        {
          v21 = sub_1002FB80;
          v22 = (signed int (*)())sub_1002FB50;
          if ( v31 == 3 )
            v20 = 7;
        }
        else
        {
          v21 = 0;
          v22 = 0;
        }
        v23 = sub_10038950(v29, (int)v32, strlen(v32), 0);
        sub_10010340(v29, (unsigned int)v32);
        if ( !v23 )
          return 0;
        v24 = sub_10039580(**(_DWORD **)(v28 + 4), (signed int)v23, 0);
        if ( !sub_10015BB0(
                v29,
                *(_DWORD *)(v28 + 4),
                (int)v23,
                v21,
                v22,
                -1,
                v20 | 0x40,
                ((*v24 & 0xFFFFFFFE) != 0 ? 2 : 0) | 8,
                v34 >> 1) )
          return 0;
        if ( !--v35 )
        {
          v3 = v29;
          goto LABEL_64;
        }
      }
    }
    goto LABEL_65;
  }
  if ( v8 > 8 )
  {
    v10 = *(_DWORD *)(v3 + 76);
    v30 = *(_DWORD *)(v10 + 12);
    v11 = v30;
    v12 = v30 + ((4 * v8 + 3) & 0xFFFFFFFC);
    if ( v12 <= *(_DWORD *)(v10 + 8) )
      *(_DWORD *)(v10 + 12) = v12;
    else
      v11 = sub_1003E2D0(v3 + 60, (4 * v8 + 3) & 0xFFFFFFFC);
    v9 = (char *)v11;
    if ( !v11 )
    {
      sub_10011170(v3);
      return 0;
    }
    v5 = v28;
  }
  else
  {
    v9 = &v36;
    v30 = 0;
  }
  for ( i = *(_DWORD *)(**(_DWORD **)(v5 + 4) + 36); i; i = *(_DWORD *)(i + 20) )
  {
    v15 = *(signed int (**)())(i + 4);
    if ( v15 == sub_1002FB00 )
    {
      *(_DWORD *)&v9[4 * *(_WORD *)(i + 18)] = i;
    }
    else if ( v15 == sub_1002FB80 )
    {
      *(_DWORD *)&v9[4 * (*(_WORD *)(v5 + 16) + *(_WORD *)(i + 18))] = i;
    }
  }
  v16 = 0;
  if ( !v8 )
  {
LABEL_39:
    if ( v30 )
    {
      v18 = *(_DWORD *)(v3 + 76);
      if ( v18 == v3 + 60 || v30 - *(_DWORD *)(v18 + 4) > (unsigned int)(*(_DWORD *)(v18 + 12) - *(_DWORD *)(v18 + 4)) )
        sub_1003E5E0(v3 + 60, v30);
      else
        *(_DWORD *)(v18 + 12) = (v30 + 3) & 0xFFFFFFFC;
    }
LABEL_64:
    v2 = (_DWORD *)a1;
    v5 = v28;
    goto LABEL_65;
  }
  while ( 1 )
  {
    v17 = *(_DWORD *)&v9[4 * v16];
    v31 = v16 >= *(_WORD *)(v28 + 16) ? (*(_BYTE *)(v17 + 16) & 2 | 4u) >> 1 : 1;
    v34 = 2 * *(_WORD *)(v17 + 18) | 1;
    v32 = (const char *)sub_10010FF0(*(_DWORD *)(*(_DWORD *)v17 + 8) & 0xFFFFFFF8);
    if ( !v32
      || !sub_10052520(a1, (int *)&v31)
      || !sub_10052520(a1, &v34)
      || !sub_100525F0((char *)a1, (unsigned int *)&v32) )
    {
      break;
    }
    if ( ++v16 >= v8 )
      goto LABEL_39;
  }
  if ( !v30 )
    return 0;
  v19 = *(_DWORD *)(v3 + 76);
  if ( v19 == v3 + 60 || v30 - *(_DWORD *)(v19 + 4) > (unsigned int)(*(_DWORD *)(v19 + 12) - *(_DWORD *)(v19 + 4)) )
  {
    sub_1003E5E0(v3 + 60, v30);
    result = 0;
  }
  else
  {
    *(_DWORD *)(v19 + 12) = (v30 + 3) & 0xFFFFFFFC;
    result = 0;
  }
  return result;
}

//----- (10028FD0) --------------------------------------------------------
signed int __cdecl sub_10028FD0(int a1, unsigned int a2, int a3, int a4, int *a5)
{
  int v5; // edi@1
  int v6; // ebx@1
  unsigned int v7; // esi@3
  signed int result; // eax@7
  signed int v9; // ecx@8
  int v10; // ecx@10
  int v11; // eax@13
  int v12; // esi@13
  int v13; // eax@14
  int v14; // ST20_4@14
  int v15; // esi@18
  unsigned int v16; // ebx@18
  int v17; // eax@18
  int v18; // eax@19
  int v19; // ecx@20
  int v20; // eax@20
  int v21; // ecx@24
  void *v22; // edx@24
  int v23; // eax@24
  unsigned int v24; // eax@24
  void *v25; // ebx@24
  unsigned int v26; // edx@24
  bool v27; // cf@24
  bool v28; // zf@24
  unsigned int v29; // ebp@28
  unsigned int v30; // ecx@29
  unsigned int v31; // eax@29
  int v32; // esi@29
  int v33; // edx@32
  const void *v34; // eax@33
  char *v35; // ebx@38
  int v36; // eax@39
  int v37; // ebx@39
  int v38; // eax@40
  signed int v39; // eax@45
  int v40; // ebp@47
  signed int v41; // esi@48
  int v42; // eax@49
  int v43; // eax@50
  void (__cdecl *v44)(int, int, int); // ecx@54
  int v45; // esi@58
  signed int v46; // eax@59
  int v47; // eax@64
  int v48; // eax@68
  int v49; // eax@73
  int v50; // ebx@76
  unsigned int v51; // ecx@76
  int v52; // esi@76
  int v53; // edx@79
  int v54; // eax@80
  int v55; // eax@85
  int v56; // esi@85
  signed int v57; // esi@88
  int v58; // eax@90
  char v59; // [sp+0h] [bp-34h]@0
  signed int v60; // [sp+10h] [bp-24h]@49
  BOOL v61; // [sp+10h] [bp-24h]@68
  int v62; // [sp+14h] [bp-20h]@47
  int v63; // [sp+18h] [bp-1Ch]@14
  int v64; // [sp+1Ch] [bp-18h]@14
  int v65; // [sp+20h] [bp-14h]@14
  int v66; // [sp+24h] [bp-10h]@12
  int v67; // [sp+28h] [bp-Ch]@24
  int v68; // [sp+2Ch] [bp-8h]@47
  int v69; // [sp+30h] [bp-4h]@24
  int v70; // [sp+38h] [bp+4h]@24

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 56);
  if ( !v6 || *(_BYTE *)(v6 + 76) & 1 )
  {
    v7 = a2;
  }
  else
  {
    v7 = sub_10017C40(a1, (int)&off_101621B8, 0, 0);
    a2 = v7;
    if ( !v7 )
      return 0;
    *a5 = v7;
  }
  if ( sub_10010550(a1, v7) )
    return 1;
  v9 = *(_DWORD *)(a1 + 16);
  if ( v9 && v9 < 130 )
    v10 = 0;
  else
    v10 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 212);
  v66 = sub_10028940(
          a1,
          v7,
          0,
          0,
          8,
          *(_DWORD *)(*(_DWORD *)((*(_DWORD *)(a4 - 8) & 0xFFFFFFF8) + 4) + 4) & 0xFFFFFFF8,
          v10);
  if ( !v66 )
    return 0;
  v11 = sub_10051900(a1, v6);
  v12 = v11;
  if ( v11 )
  {
    v13 = *(_DWORD *)(v11 + 12);
    v14 = *(_DWORD *)(v12 + 56);
    v65 = *(_DWORD *)(v13 + 24);
    v64 = sub_10021490(a1, v13, v14);
    v63 = sub_10051980(a1, v6, v12);
  }
  else
  {
    v65 = 0;
    v64 = 0;
    v63 = 0;
  }
  if ( !a3 )
  {
    v49 = (int)sub_1001DF40(a1, &word_1068B4AC, 0);
LABEL_75:
    if ( v49 )
    {
      *(_DWORD *)(a4 + 4 * a3 - 4) = v49 | 4;
      v50 = *(_DWORD *)(*(_DWORD *)(v5 + 76) + 12);
      v51 = *(_DWORD *)v49;
      v52 = *(_DWORD *)v49;
      if ( *(_DWORD *)v49 & 0x40000000 )
        v52 = v51 & ((v52 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      if ( *(_DWORD *)v49 & 0x40000000 )
      {
        v53 = *(_DWORD *)(v49 + 4);
        if ( *(_DWORD *)v53 & 0x40000000 )
        {
          v54 = sub_1001A200(v49);
        }
        else if ( (v51 & 0x80000000) == 0 )
        {
          v54 = *(_DWORD *)(v53 + 4) + 2 * ((v51 >> 15) & 0x7FFF);
        }
        else
        {
          v54 = *(_DWORD *)(v53 + 4);
        }
      }
      else
      {
        v54 = *(_DWORD *)(v49 + 4);
      }
      v55 = sub_100475A0(v5, v54, v52, v65, v64, v63);
      v56 = v55;
      v57 = v55 && sub_1004B0E0(v5, v55, v66) && sub_100456B0(v5, v56);
      v58 = *(_DWORD *)(v5 + 76);
      if ( v58 == v5 + 60 || v50 - *(_DWORD *)(v58 + 4) > (unsigned int)(*(_DWORD *)(v58 + 12) - *(_DWORD *)(v58 + 4)) )
      {
        sub_1003E5E0(v5 + 60, v50);
        result = v57;
      }
      else
      {
        *(_DWORD *)(v58 + 12) = (v50 + 3) & 0xFFFFFFFC;
        result = v57;
      }
      return result;
    }
    return 0;
  }
  if ( (unsigned int)(a3 - 1) <= 0 )
  {
LABEL_73:
    v49 = sub_1001ACB0(v5, *(_DWORD *)(a4 + 4 * a3 - 4));
    goto LABEL_75;
  }
  v15 = 0;
  v16 = 0;
  v17 = a3 - 1;
  if ( a3 != 1 )
  {
    while ( 1 )
    {
      v18 = sub_1001ACB0(a1, *(_DWORD *)(a4 + 4 * v16));
      if ( !v18 )
        return 0;
      *(_DWORD *)(a4 + 4 * v16) = v18 | 4;
      v19 = *(_DWORD *)v18;
      v20 = *(_DWORD *)v18;
      if ( v20 & 0x40000000 )
        v20 = v19 & ((v20 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      ++v16;
      v15 += v20;
      if ( v16 >= a3 - 1 )
      {
        v17 = a3 - 1;
        break;
      }
    }
  }
  v21 = *(_DWORD *)(a1 + 76);
  v22 = *(void **)(v21 + 12);
  v23 = v15 + v17 - 1;
  v69 = v23;
  v24 = (2 * v23 + 5) & 0xFFFFFFFC;
  v25 = v22;
  v70 = (int)v22;
  v26 = (unsigned int)v22 + v24;
  v27 = v26 < *(_DWORD *)(v21 + 8);
  v28 = v26 == *(_DWORD *)(v21 + 8);
  v67 = (int)v25;
  if ( v27 || v28 )
  {
    *(_DWORD *)(v21 + 12) = v26;
  }
  else
  {
    v25 = (void *)sub_1003E2D0(v5 + 60, v24);
    v67 = (int)v25;
  }
  if ( !v25 )
    return 0;
  v29 = 0;
  if ( a3 != 1 )
  {
    do
    {
      v30 = *(_DWORD *)(a4 + 4 * v29) & 0xFFFFFFF8;
      v31 = *(_DWORD *)v30;
      v32 = *(_DWORD *)v30;
      if ( *(_DWORD *)v30 & 0x40000000 )
        v32 = v31 & ((v32 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      if ( *(_DWORD *)v30 & 0x40000000 )
      {
        v33 = *(_DWORD *)(v30 + 4);
        if ( *(_DWORD *)v33 & 0x40000000 )
        {
          v34 = (const void *)sub_1001A200(*(_DWORD *)(a4 + 4 * v29) & 0xFFFFFFF8);
        }
        else if ( (v31 & 0x80000000) == 0 )
        {
          v34 = (const void *)(*(_DWORD *)(v33 + 4) + 2 * ((v31 >> 15) & 0x7FFF));
        }
        else
        {
          v34 = *(const void **)(v33 + 4);
        }
      }
      else
      {
        v34 = *(const void **)(v30 + 4);
      }
      v15 = 2 * v32;
      memcpy(v25, v34, v15);
      v35 = (char *)v25 + v15;
      *(_WORD *)v35 = v29++ + 1 < a3 - 1 ? 0x2C : 0;
      v25 = v35 + 2;
    }
    while ( v29 < a3 - 1 );
  }
  v36 = sub_100475A0(v5, v67, v69, v65, v64, v63);
  v37 = v36;
  if ( !v36 )
  {
    v38 = *(_DWORD *)(v5 + 76);
    if ( v38 != v5 + 60 && v70 - *(_DWORD *)(v38 + 4) <= (unsigned int)(*(_DWORD *)(v38 + 12) - *(_DWORD *)(v38 + 4)) )
    {
      *(_DWORD *)(v38 + 12) = (v70 + 3) & 0xFFFFFFFC;
      return 0;
    }
    sub_1003E5E0(v5 + 60, v70);
    return 0;
  }
  v39 = sub_10045FA0(v15, v5, v36);
  if ( !v39 )
  {
LABEL_68:
    v61 = sub_100456B0(v5, v37);
    v48 = *(_DWORD *)(v5 + 76);
    if ( v48 == v5 + 60 || v70 - *(_DWORD *)(v48 + 4) > (unsigned int)(*(_DWORD *)(v48 + 12) - *(_DWORD *)(v48 + 4)) )
      sub_1003E5E0(v5 + 60, v70);
    else
      *(_DWORD *)(v48 + 12) = (v70 + 3) & 0xFFFFFFFC;
    if ( !v61 )
      return 0;
    goto LABEL_73;
  }
  if ( v39 == 29 )
  {
    do
    {
      v40 = *(_DWORD *)(v37 + 24 * *(_DWORD *)(v37 + 96) + 20);
      if ( !sub_10015D00(v5, a2, *(_DWORD *)(v37 + 24 * *(_DWORD *)(v37 + 96) + 20), &v68, (unsigned int *)&v62) )
        break;
      v41 = 0;
      if ( v62 )
      {
        v42 = v68;
        v60 = 1;
        if ( v68 == a2 )
        {
          v43 = sub_10038330(v5, v40);
          if ( !v43 || (v60 = 1, !sub_10045A60(v5, v37, 0, 5, 111, v43)) )
            v60 = 0;
          v42 = v68;
          v41 = 2;
        }
        v44 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v42 + 4) + 52);
        if ( v44 )
          v44(v5, v42, v62);
        if ( !v60 )
          break;
        v62 = 0;
      }
      v45 = v41 | 8;
      if ( !sub_10015BB0(
              v5,
              *(_DWORD *)(v66 + 4),
              v40,
              sub_1002FB00,
              (signed int (*)())sub_1002FB20,
              -1,
              69,
              v45,
              *(_WORD *)(v66 + 16)) )
        break;
      ++*(_WORD *)(v66 + 16);
      v46 = sub_10045FA0(v45, v5, v37);
      if ( !v46 )
        goto LABEL_68;
    }
    while ( v46 == 3 && sub_10045FA0(v45, v5, v37) == 29 );
  }
  if ( !(*(_BYTE *)(v37 + 124) & 1) )
    sub_100110F0(v5, (int)sub_1003ED50, 0, 20, v59);
  sub_100456B0(v5, v37);
  v47 = *(_DWORD *)(v5 + 76);
  if ( v47 == v5 + 60 || v70 - *(_DWORD *)(v47 + 4) > (unsigned int)(*(_DWORD *)(v47 + 12) - *(_DWORD *)(v47 + 4)) )
  {
    sub_1003E5E0(v5 + 60, v70);
    result = 0;
  }
  else
  {
    *(_DWORD *)(v47 + 12) = (v70 + 3) & 0xFFFFFFFC;
    result = 0;
  }
  return result;
}
// 101621B8: using guessed type char *off_101621B8;
// 1068B4AC: using guessed type __int16 word_1068B4AC;

//----- (100295A0) --------------------------------------------------------
char *__cdecl sub_100295A0(int a1, unsigned int a2)
{
  char *result; // eax@1
  int v3; // ebx@1
  int v4; // edi@3
  _DWORD *v5; // eax@4

  result = sub_10012240(
             a1,
             a2,
             0,
             (int *)&off_101621B8,
             (int)sub_10028FD0,
             1,
             (int *)&off_10162158,
             (const char **)&off_10162200,
             0,
             0);
  v3 = (int)result;
  if ( result )
  {
    if ( sub_10038950(a1, (int)off_101621B8, strlen(off_101621B8), 0)
      && (v4 = sub_10028940(a1, v3, 0, 0, 0, a2, 0)) != 0
      && (v5 = sub_10021260(a1, 0, 0, 0), (*(_DWORD *)(v4 + 12) = v5) != 0) )
    {
      result = (char *)v3;
    }
    else
    {
      *(_DWORD *)(a1 + 92) = 0;
      result = 0;
    }
  }
  return result;
}
// 10162158: using guessed type char *off_10162158;
// 101621B8: using guessed type char *off_101621B8;
// 10162200: using guessed type char *off_10162200;

//----- (10029650) --------------------------------------------------------
_WORD *__cdecl sub_10029650(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, fabs(v6), a5);
  return result;
}

//----- (100296A0) --------------------------------------------------------
_WORD *__cdecl sub_100296A0(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, acos(v6), a5);
  return result;
}

//----- (100296F0) --------------------------------------------------------
_WORD *__cdecl sub_100296F0(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, asin(v6), a5);
  return result;
}

//----- (10029740) --------------------------------------------------------
_WORD *__cdecl sub_10029740(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, atan(v6), a5);
  return result;
}

//----- (10029790) --------------------------------------------------------
int __cdecl sub_10029790(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@2
  double v6; // st7@4
  double v7; // [sp+18h] [bp-10h]@3
  double v8; // [sp+20h] [bp-8h]@1

  if ( sub_10020030(a1, *(_DWORD *)a4, &v8) && sub_10020030(a1, *(_DWORD *)(a4 + 4), &v7) )
  {
    v6 = v8;
    sub_10052DD0(v8, v7);
    result = sub_1001F600(a1, v6, a5);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10029810) --------------------------------------------------------
_WORD *__cdecl sub_10029810(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  double v6; // st7@2
  double v7; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v7);
  if ( result )
  {
    v6 = ceil(v7);
    result = (_WORD *)sub_1001F600(a1, v6, a5);
  }
  return result;
}

//----- (10029870) --------------------------------------------------------
_WORD *__cdecl sub_10029870(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, cos(v6), a5);
  return result;
}

//----- (100298C0) --------------------------------------------------------
_WORD *__cdecl sub_100298C0(int a1, int a2, int a3, signed int *a4, unsigned int *a5)
{
  _WORD *result; // eax@1
  int v6; // edx@5
  double *v7; // ecx@5
  long double v8; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v8);
  if ( result )
  {
    if ( (HIDWORD(v8) & 0x7FF00000) == 2146435072 && (LODWORD(v8) || HIDWORD(v8) & 0xFFFFF) )
      goto LABEL_12;
    v6 = *(_DWORD *)(a1 + 24);
    v7 = *(double **)(v6 + 476);
    if ( *v7 == v8 )
    {
      *a5 = (unsigned int)v7 | 2;
      return (_WORD *)1;
    }
    if ( *(double *)*(_DWORD *)(v6 + 472) != v8 )
    {
LABEL_12:
      result = (_WORD *)sub_1001F600(a1, exp(v8), (int)a5);
    }
    else
    {
      *a5 = 1;
      result = (_WORD *)1;
    }
  }
  return result;
}

//----- (10029980) --------------------------------------------------------
_WORD *__cdecl sub_10029980(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  double v6; // st7@2
  double v7; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v7);
  if ( result )
  {
    v6 = floor(v7);
    result = (_WORD *)sub_1001F600(a1, v6, a5);
  }
  return result;
}

//----- (100299E0) --------------------------------------------------------
_WORD *__cdecl sub_100299E0(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, log(v6), a5);
  return result;
}

//----- (10029A30) --------------------------------------------------------
int __cdecl sub_10029A30(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  double *v5; // eax@1
  double v6; // st7@1
  int v8; // esi@3
  double v9; // st6@8
  bool v10; // c3@10
  double v11; // [sp+40h] [bp-10h]@4
  double v12; // [sp+48h] [bp-8h]@1

  v5 = *(double **)(*(_DWORD *)(a1 + 24) + 472);
  v6 = *v5;
  v12 = v6;
  if ( !a3 )
  {
    *a5 = (unsigned int)v5 | 2;
    return 1;
  }
  v8 = 0;
  if ( !a3 )
    return sub_1001F600(a1, v6, (int)a5);
  while ( 1 )
  {
    if ( !sub_10020030(a1, *(_DWORD *)(a4 + 4 * v8), &v11) )
      return 0;
    if ( (HIDWORD(v11) & 0x7FF00000) == 2146435072 && (LODWORD(v11) || HIDWORD(v11) & 0xFFFFF) )
      break;
    v6 = v11;
    v9 = v12;
    if ( v11 != 0.0 || v12 != v11 )
      goto LABEL_13;
    v10 = sub_10052DF0(1.0, v12) == -1.0;
    v6 = v11;
    if ( !v10 )
    {
      v9 = v12;
LABEL_13:
      if ( v9 >= v6 )
        v6 = v9;
      else
        v12 = v6;
      goto LABEL_16;
    }
    v12 = v11;
LABEL_16:
    if ( ++v8 >= a3 )
      return sub_1001F600(a1, v6, (int)a5);
  }
  *a5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 468) | 2;
  return 1;
}

//----- (10029B70) --------------------------------------------------------
int __cdecl sub_10029B70(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  double *v5; // eax@1
  double v6; // st7@1
  int result; // eax@2
  int v8; // esi@3
  bool v9; // c3@10
  double v10; // [sp+40h] [bp-10h]@4
  double v11; // [sp+48h] [bp-8h]@1

  v5 = *(double **)(*(_DWORD *)(a1 + 24) + 476);
  v6 = *v5;
  v11 = v6;
  if ( a3 )
  {
    v8 = 0;
    if ( a3 )
    {
      while ( 1 )
      {
        if ( !sub_10020030(a1, *(_DWORD *)(a4 + 4 * v8), &v10) )
          return 0;
        if ( (HIDWORD(v10) & 0x7FF00000) == 2146435072 && (LODWORD(v10) || HIDWORD(v10) & 0xFFFFF) )
          break;
        v6 = v10;
        if ( v10 == 0.0 && v11 == v10 && (v9 = sub_10052DF0(1.0, v10) == -1.0, v6 = v10, v9) )
        {
          v11 = v10;
        }
        else if ( v11 <= v6 )
        {
          v6 = v11;
        }
        else
        {
          v11 = v6;
        }
        if ( ++v8 >= a3 )
          goto LABEL_16;
      }
      *a5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 468) | 2;
      result = 1;
    }
    else
    {
LABEL_16:
      result = sub_1001F600(a1, v6, (int)a5);
    }
  }
  else
  {
    *a5 = (unsigned int)v5 | 2;
    result = 1;
  }
  return result;
}

//----- (10029CB0) --------------------------------------------------------
int __cdecl sub_10029CB0(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@2
  double v6; // st7@4
  double v7; // [sp+18h] [bp-10h]@3
  double v8; // [sp+20h] [bp-8h]@1

  if ( sub_10020030(a1, *(_DWORD *)a4, &v8) && sub_10020030(a1, *(_DWORD *)(a4 + 4), &v7) )
  {
    v6 = v8;
    sub_10052E20(v8, v7);
    result = sub_1001F600(a1, v6, a5);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10029D30) --------------------------------------------------------
int __usercall sub_10029D30@<eax>(int a1@<esi>, signed __int64 a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = *(_DWORD *)(a1 + 444) & (*(_DWORD *)(a1 + 428) ^ (unsigned __int64)(a2 / 1000));
  v3 = *(_DWORD *)(a1 + 448) & (*(_DWORD *)(a1 + 432) ^ ((unsigned __int64)(a2 / 1000) >> 32));
  *(_DWORD *)(a1 + 452) = result;
  *(_DWORD *)(a1 + 456) = v3;
  return result;
}

//----- (10029D70) --------------------------------------------------------
int __usercall sub_10029D70@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int result; // eax@1
  __int64 v3; // rax@2

  v1 = a1;
  result = 0;
  if ( !*(_DWORD *)(v1 + 424) )
  {
    *(_DWORD *)(v1 + 424) = 1;
    *(_DWORD *)(v1 + 428) = -554899859;
    *(_DWORD *)(v1 + 432) = 5;
    *(double *)(v1 + 460) = (double)0x20000000000000i64;
    *(_DWORD *)(v1 + 436) = 11;
    *(_DWORD *)(v1 + 440) = 0;
    *(_DWORD *)(v1 + 444) = -1;
    *(_DWORD *)(v1 + 448) = 0xFFFF;
    v3 = sub_1002F6B0();
    result = sub_10029D30(v1, v3);
  }
  return result;
}

//----- (10029DF0) --------------------------------------------------------
unsigned __int64 __usercall sub_10029DF0@<edx:eax>(int a1@<esi>, char a2)
{
  __int64 v2; // rax@1
  __int64 v3; // ST08_8@1
  unsigned __int64 v4; // rax@1

  HIDWORD(v2) = *(_DWORD *)(a1 + 432);
  HIDWORD(v3) = *(_DWORD *)(a1 + 456);
  LODWORD(v2) = *(_DWORD *)(a1 + 428);
  LODWORD(v3) = *(_DWORD *)(a1 + 452);
  v4 = *(_QWORD *)(a1 + 444) & (*(_QWORD *)(a1 + 436) + v2 * v3);
  *(_QWORD *)(a1 + 452) = v4;
  return v4 >> (48 - a2);
}

//----- (10029E50) --------------------------------------------------------
double __usercall sub_10029E50@<st0>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // eax@1

  v1 = a1;
  v2 = sub_10029DF0(a1, 26);
  return (double)(signed __int64)(((unsigned __int64)v2 << 27) + (unsigned int)sub_10029DF0(v1, 27))
       / *(double *)(v1 + 460);
}

//----- (10029EA0) --------------------------------------------------------
int __cdecl sub_10029EA0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  double v6; // st7@1

  v5 = *(_DWORD *)(a1 + 24);
  sub_10029D70(*(_DWORD *)(a1 + 24));
  v6 = sub_10029E50(v5);
  return sub_1001F600(a1, v6, a5);
}

//----- (10029ED0) --------------------------------------------------------
_WORD *__cdecl sub_10029ED0(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  double v6; // ST08_8@2
  double v7; // st7@2
  double v8; // st7@2
  double v9; // [sp+14h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v9);
  if ( result )
  {
    v6 = v9;
    v7 = floor(v9 + 0.5);
    v8 = sub_10052DF0(v7, v6);
    result = (_WORD *)sub_1001F600(a1, v8, a5);
  }
  return result;
}

//----- (10029F40) --------------------------------------------------------
_WORD *__cdecl sub_10029F40(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, sin(v6), a5);
  return result;
}

//----- (10029F90) --------------------------------------------------------
_WORD *__cdecl sub_10029F90(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, sqrt(v6), a5);
  return result;
}

//----- (10029FE0) --------------------------------------------------------
_WORD *__cdecl sub_10029FE0(int a1, int a2, int a3, signed int *a4, int a5)
{
  _WORD *result; // eax@1
  long double v6; // [sp+10h] [bp-8h]@1

  result = sub_10020030(a1, *a4, &v6);
  if ( result )
    result = (_WORD *)sub_1001F600(a1, tan(v6), a5);
  return result;
}

//----- (1002A030) --------------------------------------------------------
signed int __cdecl sub_1002A030(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  *a5 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 188) + 8);
  return 1;
}

//----- (1002A050) --------------------------------------------------------
unsigned int __cdecl sub_1002A050(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int v3; // esi@1
  unsigned int result; // eax@2

  v2 = sub_10010720(a1, a2, (int)"Math", &off_101622D0, 0, 0);
  v3 = v2;
  if ( v2 && sub_10011BE0(a1, v2, (const char **)&off_10162318) )
    result = sub_10010780(a1, v3, (int)&unk_10162240) != 0 ? v3 : 0;
  else
    result = 0;
  return result;
}
// 101622D0: using guessed type char *off_101622D0;
// 10162318: using guessed type char *off_10162318;

//----- (1002A0B0) --------------------------------------------------------
double __cdecl sub_1002A0B0(double a1)
{
  double result; // st7@1

  result = fmod(a1, dbl_10162410);
  if ( result < 0.0 )
    result = result + dbl_10162410;
  return result;
}
// 10162410: using guessed type double dbl_10162410;

//----- (1002A0E0) --------------------------------------------------------
int __cdecl sub_1002A0E0(double a1)
{
  signed int v1; // eax@1
  signed int v2; // esi@1
  double v3; // ST40_8@1
  double v4; // ST40_8@1
  double v5; // st7@1
  int result; // eax@2
  signed int v7; // [sp+3Ch] [bp-Ch]@6

  v1 = (signed int)floor(a1 / (dbl_10162410 * 365.2425));
  v2 = v1 + 1970;
  v3 = floor((double)(v1 + 1) * 0.25) + (double)(365 * v1);
  v4 = v3 - floor((double)(v2 - 1901) / 100.0);
  v5 = (floor((double)(v2 - 1601) / 400.0) + v4) * dbl_10162410;
  if ( a1 >= v5 )
  {
    if ( v2 % 4 || !(v2 % 100) && v2 % 400 )
      v7 = 365;
    else
      v7 = 366;
    if ( a1 >= v5 + dbl_10162410 * (double)v7 )
      ++v2;
    result = v2;
  }
  else
  {
    result = v2 - 1;
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;

//----- (1002A230) --------------------------------------------------------
int __cdecl sub_1002A230(double a1)
{
  signed int v1; // esi@1
  double v2; // ST40_8@1
  double v3; // ST38_8@1
  double v4; // ST38_8@1
  int v5; // ecx@1
  int result; // eax@2
  signed int v7; // eax@6
  int v8; // eax@8
  int v9; // eax@10
  int v10; // eax@12
  int v11; // eax@14
  int v12; // eax@16
  int v13; // eax@18
  int v14; // eax@20
  int v15; // eax@22
  int v16; // eax@24

  v1 = sub_1002A0E0(a1);
  v2 = floor(a1 / dbl_10162410);
  v3 = floor((double)(v1 - 1969) * 0.25) + (double)(365 * (v1 - 1970));
  v4 = v3 - floor((double)(v1 - 1901) / 100.0);
  v5 = (signed int)(v2 - (floor((double)(v1 - 1601) / 400.0) + v4));
  if ( v5 >= 31 )
  {
    if ( v1 % 4 || !(v1 % 100) && v1 % 400 )
      v7 = 365;
    else
      v7 = 366;
    v8 = (v7 == 366) + 59;
    if ( v5 >= v8 )
    {
      v9 = v8 + 31;
      if ( v5 >= v9 )
      {
        v10 = v9 + 30;
        if ( v5 >= v10 )
        {
          v11 = v10 + 31;
          if ( v5 >= v11 )
          {
            v12 = v11 + 30;
            if ( v5 >= v12 )
            {
              v13 = v12 + 31;
              if ( v5 >= v13 )
              {
                v14 = v13 + 31;
                if ( v5 >= v14 )
                {
                  v15 = v14 + 30;
                  if ( v5 >= v15 )
                  {
                    v16 = v15 + 31;
                    if ( v5 >= v16 )
                      result = (v5 >= v16 + 30) + 10;
                    else
                      result = 9;
                  }
                  else
                  {
                    result = 8;
                  }
                }
                else
                {
                  result = 7;
                }
              }
              else
              {
                result = 6;
              }
            }
            else
            {
              result = 5;
            }
          }
          else
          {
            result = 4;
          }
        }
        else
        {
          result = 3;
        }
      }
      else
      {
        result = 2;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;

//----- (1002A400) --------------------------------------------------------
int __cdecl sub_1002A400(double a1)
{
  signed int v1; // edi@1
  double v2; // ST40_8@1
  double v3; // ST38_8@1
  double v4; // ST38_8@1
  double v5; // st7@1
  int v6; // esi@1
  signed int v8; // eax@6
  int v9; // edx@10
  signed int v10; // eax@11
  int v11; // ecx@14
  int v12; // ecx@15
  int v13; // ecx@16
  int v14; // ecx@17
  int v15; // ecx@18
  int v16; // ecx@19
  int v17; // ecx@20

  v1 = sub_1002A0E0(a1);
  v2 = floor(a1 / dbl_10162410);
  v3 = floor((double)(v1 - 1969) * 0.25) + (double)(365 * (v1 - 1970));
  v4 = v3 - floor((double)(v1 - 1901) / 100.0);
  v5 = v2 - (floor((double)(v1 - 1601) / 400.0) + v4);
  v6 = (signed int)v5;
  if ( (signed int)v5 <= 30 )
    return (signed int)v5 + 1;
  if ( v1 % 4 || !(v1 % 100) && v1 % 400 )
    v8 = 365;
  else
    v8 = 366;
  if ( v6 <= (v8 == 366) + 58 )
    return v6 - 30;
  v9 = (v8 == 366) + 58;
  if ( v6 <= (v8 == 366) + 89
    || (v9 = (v8 == 366) + 89, v6 <= (v8 == 366) + 119)
    || (v9 = (v8 == 366) + 119, v11 = (v8 == 366) + 150, v6 <= v11)
    || (v9 = (v8 == 366) + 150, v12 = (v8 == 366) + 180, v6 <= v12)
    || (v9 = (v8 == 366) + 180, v13 = (v8 == 366) + 211, v6 <= v13)
    || (v9 = (v8 == 366) + 211, v14 = (v8 == 366) + 242, v6 <= v14)
    || (v9 = (v8 == 366) + 242, v15 = (v8 == 366) + 272, v6 <= v15)
    || (v9 = (v8 == 366) + 272, v16 = (v8 == 366) + 303, v6 <= v16) )
  {
    v10 = (signed int)v5;
    return v10 - v9;
  }
  v9 = (v8 == 366) + 303;
  v17 = (v8 == 366) + 333;
  v10 = (signed int)v5;
  if ( v6 <= v17 )
    return v10 - v9;
  return v6 - v17;
}
// 10162410: using guessed type double dbl_10162410;

//----- (1002A580) --------------------------------------------------------
int __cdecl sub_1002A580(double a1)
{
  signed int v1; // eax@1
  signed int v2; // ecx@1

  v1 = (signed int)floor(a1 / dbl_10162410);
  v2 = 7
     * (((signed int)(((unsigned __int64)(1840700269i64 * (v1 + 4)) >> 32) - (v1 + 4)) >> 2)
      + ((unsigned int)(((unsigned __int64)(1840700269i64 * (v1 + 4)) >> 32) - (v1 + 4)) >> 31))
     + v1
     + 4;
  return v2 + (v2 < 0 ? 7 : 0);
}
// 10162410: using guessed type double dbl_10162410;

//----- (1002A5D0) --------------------------------------------------------
double __cdecl sub_1002A5D0(double a1)
{
  double result; // st7@4

  if ( (HIDWORD(a1) & 0x7FF00000) == 2146435072 && (LODWORD(a1) || HIDWORD(a1) & 0xFFFFF) )
    result = a1;
  else
    result = (double)(sub_1002F6D0() / 1000);
  return result;
}

//----- (1002A660) --------------------------------------------------------
long double __cdecl sub_1002A660(double a1)
{
  return a1 - fmod(sub_1002A5D0(a1 - dbl_10572688) + dbl_10572688, dbl_10162410);
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002A690) --------------------------------------------------------
int __cdecl sub_1002A690(double a1)
{
  signed int v1; // eax@1

  v1 = (signed int)fmod(floor(a1 / dbl_10162418), 24.0);
  return v1 + (v1 < 0 ? 0x18 : 0);
}
// 10162418: using guessed type double dbl_10162418;

//----- (1002A6C0) --------------------------------------------------------
int __cdecl sub_1002A6C0(double a1)
{
  signed int v1; // eax@1

  v1 = (signed int)fmod(floor(a1 / dbl_10162420), 60.0);
  return v1 + (v1 < 0 ? 0x3C : 0);
}
// 10162420: using guessed type double dbl_10162420;

//----- (1002A6F0) --------------------------------------------------------
int __cdecl sub_1002A6F0(double a1)
{
  signed int v1; // eax@1

  v1 = (signed int)fmod(floor(a1 / dbl_10162408), 60.0);
  return v1 + (v1 < 0 ? 0x3C : 0);
}
// 10162408: using guessed type double dbl_10162408;

//----- (1002A720) --------------------------------------------------------
int __cdecl sub_1002A720(double a1)
{
  long double v1; // st7@1
  int result; // eax@1

  v1 = fmod(a1, dbl_10162408);
  result = (signed int)v1;
  if ( (signed int)v1 < 0 )
    result = (signed int)dbl_10162408 + (signed int)v1;
  return result;
}
// 10162408: using guessed type double dbl_10162408;

//----- (1002A750) --------------------------------------------------------
double __cdecl sub_1002A750(double a1, double a2, double a3)
{
  long double v3; // st7@1
  signed int v4; // ecx@3
  bool v5; // zf@3
  signed int v6; // eax@3
  signed int v7; // esi@8
  double v8; // st7@10
  double v10; // [sp+50h] [bp+8h]@1
  double v11; // [sp+58h] [bp+10h]@1
  double v12; // [sp+7Ch] [bp+34h]@10
  double v13; // [sp+7Ch] [bp+34h]@10

  v10 = floor(a2 / 12.0) + a1;
  v3 = fmod(a2, 12.0);
  v11 = v3;
  if ( v3 < 0.0 )
    v11 = v3 + 12.0;
  v4 = (signed int)v10;
  v6 = (signed int)v10 & 0x80000003;
  v5 = v6 == 0;
  if ( v6 < 0 )
    v5 = (((_BYTE)v6 - 1) | 0xFFFFFFFC) == -1;
  if ( v5 && (v4 % 100 || !(v4 % 400)) )
    v7 = 366;
  else
    v7 = 365;
  v12 = floor((v10 - 1969.0) * 0.25) + (v10 - 1970.0) * 365.0;
  v13 = v12 - floor((v10 - 1901.0) / 100.0);
  v8 = floor((v10 - 1601.0) / 400.0);
  return floor((v8 + v13) * dbl_10162410 / dbl_10162410)
       + dbl_10162428[(signed int)v11 + 12 * (unsigned int)(v7 == 366)]
       + a3
       - 1.0;
}
// 1002A750: could not find valid save-restore pair for esi
// 10162410: using guessed type double dbl_10162410;
// 10162428: using guessed type double dbl_10162428[];

//----- (1002A890) --------------------------------------------------------
BOOL __usercall sub_1002A890@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5, int a6)
{
  int v6; // ebp@1
  bool v7; // zf@1
  _BYTE *v8; // esi@2
  __int16 *v9; // edi@2
  int v10; // edx@3
  __int16 v11; // bx@4
  bool v12; // zf@10

  v6 = a5;
  v7 = a5 == 0;
  if ( a5 > 0 )
  {
    v8 = (_BYTE *)(a3 + a1);
    v9 = (__int16 *)(a4 + 2 * a2);
    do
    {
      LOBYTE(v10) = *v8;
      if ( !*v8 )
        break;
      v11 = *v9;
      if ( !*v9 )
        break;
      if ( a6 )
      {
        if ( *(_DWORD *)&dword_100CED28[4
                                      * (unsigned __int8)byte_100CCEA8[v10 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int8)v10 >> 6] << 6)]] & 0x200000 )
          v10 = (unsigned __int8)v10
              + (*(_DWORD *)&dword_100CED28[4
                                          * (unsigned __int8)byte_100CCEA8[v10 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int8)v10 >> 6] << 6)]] >> 22);
        else
          LOWORD(v10) = (unsigned __int8)v10;
        v12 = *(_DWORD *)&dword_100CED28[4
                                       * (unsigned __int8)byte_100CCEA8[*v9 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)*v9 >> 6] << 6)]] & 0x200000 ? (_WORD)v10 == (unsigned __int16)(*(_DWORD *)&dword_100CED28[4 * (unsigned __int8)byte_100CCEA8[*v9 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)*v9 >> 6] << 6)]] >> 22) + *v9 : (_WORD)v10 == v11;
      }
      else
      {
        v12 = (unsigned __int8)v10 == v11;
      }
      if ( !v12 )
        break;
      --v6;
      ++v8;
      ++v9;
    }
    while ( v6 > 0 );
    v7 = v6 == 0;
  }
  return v7 != 0;
}

//----- (1002A9C0) --------------------------------------------------------
double __cdecl sub_1002A9C0(double a1, double a2, double a3, double a4, double a5, double a6, double a7)
{
  return sub_1002A750(a1, a2, a3) * dbl_10162410 + (60.0 * (a4 * 60.0 + a5) + a6) * dbl_10162408 + a7;
}
// 10162408: using guessed type double dbl_10162408;
// 10162410: using guessed type double dbl_10162410;

//----- (1002AA10) --------------------------------------------------------
int __cdecl sub_1002AA10(int a1, int a2, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // esi@1
  double v6; // st7@5
  double v7; // st7@8
  double v8; // st6@11
  double v10; // st7@16
  double v11; // st5@17
  double v12; // st7@20
  double v13; // [sp+78h] [bp-40h]@3
  double v14; // [sp+80h] [bp-38h]@7
  double v15; // [sp+88h] [bp-30h]@16
  double v16; // [sp+90h] [bp-28h]@11
  double v17; // [sp+98h] [bp-20h]@16
  double v18; // [sp+A0h] [bp-18h]@16
  double v19; // [sp+A8h] [bp-10h]@16
  double v20; // [sp+B0h] [bp-8h]@16

  v5 = 0;
  do
  {
    if ( v5 >= a3 )
    {
      v6 = 0.0;
    }
    else
    {
      if ( !sub_10020030(a1, *(_DWORD *)(a4 + 4 * v5), &v13) )
        return 0;
      if ( (HIDWORD(v13) & 0x7FF00000) == 2146435072 )
        return sub_1001F600(a1, v13, a5);
      v6 = floor(v13);
    }
    *(&v14 + v5++) = v6;
  }
  while ( v5 < 7 );
  v7 = v14;
  if ( v14 >= 0.0 && v14 <= 99.0 )
    v7 = v14 + 1900.0;
  v8 = 1.0;
  if ( v16 >= 1.0 )
    v8 = v16;
  v10 = sub_1002A9C0(v7, v15, v8, v17, v18, v19, v20);
  v13 = v10;
  if ( (HIDWORD(v13) & 0x7FF00000) == 2146435072 )
    goto LABEL_25;
  v11 = v10;
  if ( v10 < 0.0 )
    v11 = -v10;
  if ( v11 > 8.64e15 )
LABEL_25:
    v12 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
  else
    v12 = sub_1001F900(v10 + 0.0);
  v13 = v12;
  return sub_1001F600(a1, v12, a5);
}

//----- (1002AB80) --------------------------------------------------------
signed int __usercall sub_1002AB80@<eax>(unsigned int *a1@<eax>, long double *a2)
{
  unsigned int *v2; // esi@1
  unsigned int v3; // eax@1
  unsigned int v4; // ecx@2
  unsigned int v5; // ebx@3
  unsigned int v6; // edi@9
  signed int v7; // ebp@12
  double v8; // st6@12
  unsigned int v9; // esi@12
  double v10; // st5@12
  signed int v11; // eax@13
  signed int v12; // ecx@17
  int v13; // eax@19
  signed int v14; // ecx@24
  double v15; // st4@50
  double v16; // rt0@51
  double v17; // st5@51
  double v18; // rt1@51
  double v19; // rt2@52
  double v20; // st5@52
  double v21; // rtt@52
  int v22; // ecx@70
  bool v23; // c3@75
  long double v24; // st6@75
  double v25; // st5@76
  double v26; // rt0@76
  double v27; // st6@77
  double v28; // st5@77
  double v29; // rt1@77
  int i; // ebp@81
  signed int v31; // eax@82
  signed int v32; // ebx@87
  signed int result; // eax@91
  int v34; // eax@92
  double v35; // st6@104
  double v36; // st5@104
  double v37; // rt2@104
  unsigned __int16 v38; // cx@108
  double v39; // st7@122
  double v40; // [sp+0h] [bp-78h]@121
  double v41; // [sp+8h] [bp-70h]@121
  double v42; // [sp+10h] [bp-68h]@121
  double v43; // [sp+18h] [bp-60h]@121
  double v44; // [sp+20h] [bp-58h]@121
  double v45; // [sp+28h] [bp-50h]@121
  signed int v46; // [sp+48h] [bp-30h]@12
  signed int v47; // [sp+4Ch] [bp-2Ch]@12
  int v48; // [sp+50h] [bp-28h]@25
  int v49; // [sp+50h] [bp-28h]@70
  signed int v50; // [sp+54h] [bp-24h]@12
  int v51; // [sp+58h] [bp-20h]@12
  signed int v52; // [sp+5Ch] [bp-1Ch]@12
  signed int v53; // [sp+60h] [bp-18h]@12
  int v54; // [sp+64h] [bp-14h]@3
  signed int v55; // [sp+68h] [bp-10h]@12
  unsigned int v56; // [sp+6Ch] [bp-Ch]@10
  double v57; // [sp+70h] [bp-8h]@12

  v2 = a1;
  v3 = *a1;
  if ( v3 & 0x40000000 )
  {
    v4 = v2[1];
    if ( *(_DWORD *)v4 & 0x40000000 )
    {
      v5 = sub_1001A200((int)v2);
      v54 = v5;
      goto LABEL_9;
    }
    if ( (v3 & 0x80000000) == 0 )
      v5 = *(_DWORD *)(v4 + 4) + 2 * ((v3 >> 15) & 0x7FFF);
    else
      v5 = *(_DWORD *)(v4 + 4);
  }
  else
  {
    v5 = v2[1];
  }
  v54 = v5;
LABEL_9:
  v6 = *v2;
  if ( *v2 & 0x40000000 )
  {
    v6 = *v2 & ((v6 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v56 = v6;
  }
  else
  {
    v56 = *v2;
  }
  v7 = 0;
  v8 = -1.0;
  v9 = 0;
  v57 = -1.0;
  v10 = 0.0;
  v52 = -1;
  v51 = -1;
  v50 = -1;
  v46 = -1;
  v47 = -1;
  v53 = -1;
  v55 = 0;
  if ( !v6 )
    goto LABEL_90;
  while ( 1 )
  {
    v11 = *(_WORD *)(v5 + 2 * v9++);
    if ( v11 <= 32 || v11 == 44 )
    {
      if ( v11 != 45 )
        goto LABEL_111;
LABEL_108:
      v38 = *(_WORD *)(v5 + 2 * v9);
      if ( v38 < 0x30u || v38 > 0x39u )
        goto LABEL_111;
LABEL_110:
      v7 = v11;
      goto LABEL_111;
    }
    if ( v11 == 45 )
      goto LABEL_108;
    if ( v11 == 40 )
      break;
    v14 = v11 - 48;
    if ( (unsigned int)(v11 - 48) > 9 )
    {
      if ( v11 != 47 && v11 != 58 && v11 != 43 )
      {
        for ( i = v9 - 1; v9 < v6; ++v9 )
        {
          v31 = *(_WORD *)(v5 + 2 * v9);
          if ( (v31 < 65 || v31 > 90) && (unsigned int)(v31 - 97) > 0x19 )
            break;
        }
        if ( v9 <= i + 1 )
          goto LABEL_90;
        v32 = 31;
        while ( !sub_1002A890(0, i, (int)off_10162530[v32], v54, v9 - i, 1) )
        {
          if ( --v32 < 0 )
            goto LABEL_90;
        }
        v34 = dword_101625B0[v32];
        if ( v34 )
        {
          if ( v34 >= 0 )
          {
            if ( v34 > 13 )
            {
              v35 = v10;
              v36 = (double)(v34 - 10000);
              v57 = v36;
              v37 = v36;
              v10 = v35;
              v8 = v37;
            }
            else
            {
              if ( v51 >= 0 )
                goto LABEL_90;
              v51 = v34 - 2;
            }
          }
          else
          {
            if ( (unsigned int)v46 > 0xC )
              goto LABEL_90;
            if ( v34 == -1 )
            {
              if ( v46 == 12 )
                v46 = 0;
            }
            else if ( v34 == -2 && v46 != 12 )
            {
              v46 += 12;
            }
          }
        }
        if ( v32 < 0 )
          goto LABEL_90;
        v5 = v54;
        v6 = v56;
        v7 = 0;
        goto LABEL_111;
      }
      goto LABEL_110;
    }
    v48 = v11 - 48;
    if ( v9 < v6 )
    {
      do
      {
        v11 = *(_WORD *)(v5 + 2 * v9);
        if ( (unsigned int)(v11 - 48) > 9 )
          break;
        ++v9;
        v14 = v11 + 10 * v14 - 48;
      }
      while ( v9 < v6 );
      v48 = v14;
    }
    if ( v7 == 43 || v7 == 45 )
    {
      v55 = 1;
      if ( v14 >= 24 )
      {
        v22 = -40 * (v14 / 100) + v14;
        v49 = v22;
      }
      else
      {
        v22 = 60 * v14;
        v49 = v22;
      }
      if ( v7 == 43 )
        v49 = -v22;
      if ( v10 == v8 )
      {
        v27 = v10;
        v7 = 0;
        v28 = (double)v49;
        v57 = v28;
        v29 = v28;
        v10 = v27;
        v8 = v29;
      }
      else
      {
        v23 = -1.0 == v8;
        v24 = v10;
        if ( !v23 )
          goto LABEL_91;
        v25 = (double)v49;
        v7 = 0;
        v57 = v25;
        v26 = v25;
        v10 = v24;
        v8 = v26;
      }
      goto LABEL_111;
    }
    if ( v14 >= 70 )
    {
      if ( v52 >= 0 )
        goto LABEL_90;
LABEL_62:
      if ( v11 > 32 && v11 != 44 && v11 != 47 && v9 < v6 )
        goto LABEL_90;
      if ( v14 < 100 )
        v14 += 1900;
      v52 = v14;
      v7 = 0;
      goto LABEL_111;
    }
    if ( v7 == 47 && v51 >= 0 && v50 >= 0 && v52 < 0 )
      goto LABEL_62;
    if ( v11 == 58 )
    {
      if ( v46 >= 0 )
      {
        if ( v47 >= 0 )
          goto LABEL_90;
        v47 = v14;
        v7 = 0;
      }
      else
      {
        v46 = v14;
        v7 = 0;
      }
      goto LABEL_111;
    }
    if ( v11 == 47 )
    {
      if ( v51 >= 0 )
        goto LABEL_59;
      v51 = v14 - 1;
      v7 = 0;
    }
    else
    {
      if ( v9 < v6 && v11 != 44 && v11 > 32 && v11 != 45 )
        goto LABEL_90;
      if ( v55 && v14 < 60 )
      {
        v15 = (double)v48;
        if ( v10 <= v8 )
        {
          v7 = 0;
          v19 = v10;
          v20 = v8 + v15;
          v57 = v20;
          v21 = v20;
          v10 = v19;
          v8 = v21;
        }
        else
        {
          v7 = 0;
          v16 = v10;
          v17 = v8 - v15;
          v57 = v17;
          v18 = v17;
          v10 = v16;
          v8 = v18;
        }
        goto LABEL_111;
      }
      if ( v46 < 0 )
      {
        if ( v47 < 0 )
          goto LABEL_59;
      }
      else if ( v47 < 0 )
      {
        v47 = v14;
        v7 = 0;
        goto LABEL_111;
      }
      if ( v53 >= 0 )
      {
LABEL_59:
        if ( v50 >= 0 )
          goto LABEL_90;
        v50 = v14;
        v7 = 0;
        goto LABEL_111;
      }
      v53 = v14;
      v7 = 0;
    }
LABEL_111:
    if ( v9 >= v6 )
      goto LABEL_112;
  }
  v12 = 1;
  while ( v9 < v6 )
  {
    v13 = *(_WORD *)(v5 + 2 * v9++);
    if ( v13 == 40 )
    {
      ++v12;
    }
    else if ( v13 == 41 && --v12 <= 0 )
    {
      goto LABEL_111;
    }
  }
LABEL_112:
  if ( v52 >= 0 && v51 >= 0 && v50 >= 0 )
  {
    if ( v53 < 0 )
      v53 = 0;
    if ( v47 < 0 )
      v47 = 0;
    if ( v46 < 0 )
      v46 = 0;
    v45 = (double)v53;
    v44 = (double)v47;
    v43 = (double)v46;
    v42 = (double)v50;
    v41 = (double)v51;
    v40 = (double)v52;
    if ( v8 == -1.0 )
    {
      v39 = sub_1002A9C0(v40, v41, v42, v43, v44, v45, v10);
      *a2 = sub_1002A660(v39);
      result = 1;
    }
    else
    {
      *a2 = sub_1002A9C0(v40, v41, v42, v43, v44, v45, v10) + dbl_10162420 * v57;
      result = 1;
    }
    return result;
  }
LABEL_90:
  v24 = v10;
LABEL_91:
  *a2 = v24;
  return 0;
}
// 10162420: using guessed type double dbl_10162420;
// 10162530: using guessed type char *off_10162530[32];
// 101625B0: using guessed type int dword_101625B0[];

//----- (1002B0A0) --------------------------------------------------------
unsigned int *__cdecl sub_1002B0A0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  unsigned int *result; // eax@1
  double v6; // st5@5
  double v7; // st7@8
  double v8; // [sp+10h] [bp-8h]@2

  result = (unsigned int *)sub_1001ACB0(a1, *a4);
  if ( result )
  {
    if ( sub_1002AB80(result, &v8) )
    {
      if ( (HIDWORD(v8) & 0x7FF00000) == 2146435072 )
        goto LABEL_13;
      v6 = v8;
      if ( v8 < 0.0 )
        v6 = -v8;
      if ( v6 > 8.64e15 )
LABEL_13:
        v7 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
      else
        v7 = sub_1001F900(v8 + 0.0);
      result = (unsigned int *)sub_1001F600(a1, v7, (int)a5);
    }
    else
    {
      *a5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 468) | 2;
      result = (unsigned int *)1;
    }
  }
  return result;
}

//----- (1002B160) --------------------------------------------------------
int __cdecl sub_1002B160(int a1, int a2, int a3, int a4, int a5)
{
  __int64 v5; // ST10_8@1

  v5 = sub_1002F6B0() / 1000;
  return sub_1001F5D0(a1, (double)v5, a5);
}

//----- (1002B1A0) --------------------------------------------------------
unsigned int __usercall sub_1002B1A0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>)
{
  unsigned int result; // eax@1

  result = sub_100123C0(a2, a3, (int *)&off_101624E8, a1);
  if ( result )
    result = *(_DWORD *)(*(_DWORD *)(a3 + 4) + 12) & 0xFFFFFFF8;
  return result;
}
// 101624E8: using guessed type char *off_101624E8;

//----- (1002B1C0) --------------------------------------------------------
double *__cdecl sub_1002B1C0(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
    result = (double *)sub_1001F600(a1, *result, a5);
  return result;
}

//----- (1002B200) --------------------------------------------------------
double *__cdecl sub_1002B200(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  long double v7; // st7@4
  signed int v8; // ST18_4@4
  int v9; // eax@4
  double v10; // st7@4
  double v11; // [sp+14h] [bp-8h]@2

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v11 = v6;
    if ( (HIDWORD(v11) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v7 = fmod(sub_1002A5D0(v6) + dbl_10572688, dbl_10162410);
      v8 = sub_1002A0E0(v7 + v11);
      v9 = *(_DWORD *)(a1 + 16);
      v10 = (double)v8;
      if ( v9 == 100 || v9 == 110 || v9 == 120 )
      {
        if ( v10 >= 1900.0 && v10 < 2000.0 )
          v10 = v10 - 1900.0;
      }
      else
      {
        v10 = v10 - 1900.0;
      }
      result = (double *)sub_1001F600(a1, v10, a5);
    }
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002B2D0) --------------------------------------------------------
double *__cdecl sub_1002B2D0(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  long double v7; // st7@4
  signed int v8; // ST18_4@4
  double v9; // [sp+14h] [bp-8h]@2

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v9 = v6;
    if ( (HIDWORD(v9) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v7 = fmod(sub_1002A5D0(v6) + dbl_10572688, dbl_10162410);
      v8 = sub_1002A0E0(v7 + v9);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002B370) --------------------------------------------------------
double *__cdecl sub_1002B370(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  double v7; // ST18_8@2
  signed int v8; // ST18_4@4

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = v6;
    if ( (HIDWORD(v7) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v8 = sub_1002A0E0(v6);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}

//----- (1002B3E0) --------------------------------------------------------
double *__cdecl sub_1002B3E0(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  long double v7; // st7@4
  signed int v8; // ST18_4@4
  double v9; // [sp+14h] [bp-8h]@2

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v9 = v6;
    if ( (HIDWORD(v9) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v7 = fmod(sub_1002A5D0(v6) + dbl_10572688, dbl_10162410);
      v8 = sub_1002A230(v7 + v9);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002B480) --------------------------------------------------------
double *__cdecl sub_1002B480(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  double v7; // ST18_8@2
  signed int v8; // ST18_4@4

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = v6;
    if ( (HIDWORD(v7) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v8 = sub_1002A230(v6);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}

//----- (1002B4F0) --------------------------------------------------------
double *__cdecl sub_1002B4F0(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  long double v7; // st7@4
  signed int v8; // ST18_4@4
  double v9; // [sp+14h] [bp-8h]@2

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v9 = v6;
    if ( (HIDWORD(v9) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v7 = fmod(sub_1002A5D0(v6) + dbl_10572688, dbl_10162410);
      v8 = sub_1002A400(v7 + v9);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002B590) --------------------------------------------------------
double *__cdecl sub_1002B590(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  double v7; // ST18_8@2
  signed int v8; // ST18_4@4

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = v6;
    if ( (HIDWORD(v7) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v8 = sub_1002A400(v6);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}

//----- (1002B600) --------------------------------------------------------
double *__cdecl sub_1002B600(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  long double v7; // st7@4
  signed int v8; // ST18_4@4
  double v9; // [sp+14h] [bp-8h]@2

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v9 = v6;
    if ( (HIDWORD(v9) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v7 = fmod(sub_1002A5D0(v6) + dbl_10572688, dbl_10162410);
      v8 = sub_1002A580(v7 + v9);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002B6A0) --------------------------------------------------------
double *__cdecl sub_1002B6A0(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  double v7; // ST18_8@2
  signed int v8; // ST18_4@4

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = v6;
    if ( (HIDWORD(v7) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v8 = sub_1002A580(v6);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}

//----- (1002B710) --------------------------------------------------------
double *__cdecl sub_1002B710(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  long double v7; // st7@4
  signed int v8; // ST18_4@4
  double v9; // [sp+14h] [bp-8h]@2

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v9 = v6;
    if ( (HIDWORD(v9) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v7 = fmod(sub_1002A5D0(v6) + dbl_10572688, dbl_10162410);
      v8 = sub_1002A690(v7 + v9);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002B7B0) --------------------------------------------------------
double *__cdecl sub_1002B7B0(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  double v7; // ST18_8@2
  signed int v8; // ST18_4@4

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = v6;
    if ( (HIDWORD(v7) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v8 = sub_1002A690(v6);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}

//----- (1002B820) --------------------------------------------------------
double *__cdecl sub_1002B820(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  long double v7; // st7@4
  signed int v8; // ST18_4@4
  double v9; // [sp+14h] [bp-8h]@2

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v9 = v6;
    if ( (HIDWORD(v9) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v7 = fmod(sub_1002A5D0(v6) + dbl_10572688, dbl_10162410);
      v8 = sub_1002A6C0(v7 + v9);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002B8C0) --------------------------------------------------------
double *__cdecl sub_1002B8C0(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  double v7; // ST18_8@2
  signed int v8; // ST18_4@4

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = v6;
    if ( (HIDWORD(v7) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v8 = sub_1002A6C0(v6);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}

//----- (1002B930) --------------------------------------------------------
double *__cdecl sub_1002B930(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  double v7; // ST18_8@2
  signed int v8; // ST18_4@4

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = v6;
    if ( (HIDWORD(v7) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v8 = sub_1002A6F0(v6);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}

//----- (1002B9A0) --------------------------------------------------------
double *__cdecl sub_1002B9A0(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // st7@2
  double v7; // ST18_8@2
  signed int v8; // ST18_4@4

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = v6;
    if ( (HIDWORD(v7) & 0x7FF00000) == 2146435072 )
    {
      result = (double *)sub_1001F600(a1, v6, a5);
    }
    else
    {
      v8 = sub_1002A720(v6);
      result = (double *)sub_1001F600(a1, (double)v8, a5);
    }
  }
  return result;
}

//----- (1002BA10) --------------------------------------------------------
double *__cdecl sub_1002BA10(int a1, int a2, int a3, int a4, int a5)
{
  double *result; // eax@1
  double v6; // ST18_8@2
  long double v7; // st7@2

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
  {
    v6 = *result;
    v7 = fmod(sub_1002A5D0(v6) + dbl_10572688, dbl_10162410);
    result = (double *)sub_1001F600(a1, (v6 - (v7 + v6)) / dbl_10162420, a5);
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10162420: using guessed type double dbl_10162420;
// 10572688: using guessed type double dbl_10572688;

//----- (1002BA80) --------------------------------------------------------
int __cdecl sub_1002BA80(int a1, int a2, int a3, signed int *a4, int a5)
{
  double *v5; // esi@1
  int result; // eax@2
  double v7; // st5@5
  double v8; // st7@8
  double v9; // [sp+18h] [bp-8h]@3

  v5 = (double *)sub_1002B1A0((int)a4, a1, a2);
  if ( v5 && sub_10020030(a1, *a4, &v9) )
  {
    if ( (HIDWORD(v9) & 0x7FF00000) == 2146435072 )
      goto LABEL_13;
    v7 = v9;
    if ( v9 < 0.0 )
      v7 = -v9;
    if ( v7 > 8.64e15 )
LABEL_13:
      v8 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
    else
      v8 = sub_1001F900(v9 + 0.0);
    v9 = v8;
    *v5 = v8;
    result = sub_1001F600(a1, v9, a5);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002BB40) --------------------------------------------------------
int __usercall sub_1002BB40@<eax>(unsigned int a1@<eax>, int a2@<ecx>, int a3, int a4, unsigned int a5, int a6, int a7)
{
  unsigned int v7; // ebx@1
  double *v8; // eax@1
  int result; // eax@2
  long double v10; // st7@3
  unsigned int v11; // edi@9
  double *v12; // esi@10
  double *v13; // esi@17
  double *v14; // ebx@17
  double v15; // st7@20
  double v16; // st6@24
  double v17; // st6@28
  double v18; // st7@34
  double v19; // st5@37
  double v20; // st7@40
  double *v21; // [sp+40h] [bp-4Ch]@1
  double v22; // [sp+44h] [bp-48h]@3
  double v23; // [sp+44h] [bp-48h]@32
  double v24; // [sp+44h] [bp-48h]@34
  double v25; // [sp+54h] [bp-38h]@19
  double v26; // [sp+5Ch] [bp-30h]@24
  double v27; // [sp+64h] [bp-28h]@28
  double v28; // [sp+6Ch] [bp-20h]@10
  char v29; // [sp+74h] [bp-18h]@19

  v7 = a1;
  v8 = (double *)sub_1002B1A0(a4, a3, a2);
  v21 = v8;
  if ( !v8 )
    return 0;
  v10 = *v8;
  v22 = v10;
  if ( (HIDWORD(v22) & 0x7FF00000) == 2146435072 )
  {
    result = sub_1001F600(a3, v10, a7);
  }
  else
  {
    if ( v7 )
    {
      if ( v7 > a5 )
        v7 = a5;
    }
    else
    {
      v7 = 1;
    }
    v11 = 0;
    if ( v7 )
    {
      v12 = &v28;
      while ( sub_10020030(a3, *(_DWORD *)(a4 + 4 * v11), v12) )
      {
        if ( (*((_DWORD *)v12 + 1) & 0x7FF00000) == 2146435072 )
        {
          v15 = *(double *)*(_DWORD *)(*(_DWORD *)(a3 + 24) + 468);
          *v21 = v15;
          return sub_1001F600(a3, v15, a7);
        }
        *v12 = sub_1001F900(*v12);
        ++v11;
        ++v12;
        if ( v11 >= v7 )
        {
          v10 = v22;
          goto LABEL_15;
        }
      }
      return 0;
    }
LABEL_15:
    if ( a6 )
      v10 = fmod(sub_1002A5D0(v10) + dbl_10572688, dbl_10162410) + v22;
    v13 = &v28;
    v14 = &v28 + v7;
    if ( a5 < 4 || &v28 >= v14 )
    {
      v25 = (double)sub_1002A690(v10);
    }
    else
    {
      v13 = (double *)&v29;
      v25 = v28;
    }
    if ( a5 < 3 || v13 >= v14 )
    {
      v26 = (double)sub_1002A6C0(v10);
    }
    else
    {
      v16 = *v13;
      ++v13;
      v26 = v16;
    }
    if ( a5 < 2 || v13 >= v14 )
    {
      v27 = (double)sub_1002A6F0(v10);
    }
    else
    {
      v17 = *v13;
      ++v13;
      v27 = v17;
    }
    if ( a5 < 1 || v13 >= v14 )
      v23 = (double)sub_1002A720(v10);
    else
      v23 = *v13;
    v18 = floor(v10 / dbl_10162410) * dbl_10162410 + (60.0 * (v25 * 60.0 + v26) + v27) * dbl_10162408 + v23;
    v24 = v18;
    if ( a6 )
    {
      v18 = sub_1002A660(v18);
      v24 = v18;
    }
    if ( (HIDWORD(v24) & 0x7FF00000) == 2146435072 )
      goto LABEL_45;
    v19 = v18;
    if ( v18 < 0.0 )
      v19 = -v18;
    if ( v19 > 8.64e15 )
LABEL_45:
      v20 = *(double *)*(_DWORD *)(*(_DWORD *)(a3 + 24) + 468);
    else
      v20 = sub_1001F900(v18 + 0.0);
    *v21 = v20;
    result = sub_1001F600(a3, v20, a7);
  }
  return result;
}
// 10162408: using guessed type double dbl_10162408;
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002BE10) --------------------------------------------------------
int __cdecl sub_1002BE10(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BB40(a3, a2, a1, a4, 1u, 1, a5);
}

//----- (1002BE40) --------------------------------------------------------
int __cdecl sub_1002BE40(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BB40(a3, a2, a1, a4, 1u, 0, a5);
}

//----- (1002BE70) --------------------------------------------------------
int __cdecl sub_1002BE70(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BB40(a3, a2, a1, a4, 2u, 1, a5);
}

//----- (1002BEA0) --------------------------------------------------------
int __cdecl sub_1002BEA0(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BB40(a3, a2, a1, a4, 2u, 0, a5);
}

//----- (1002BED0) --------------------------------------------------------
int __cdecl sub_1002BED0(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BB40(a3, a2, a1, a4, 3u, 1, a5);
}

//----- (1002BF00) --------------------------------------------------------
int __cdecl sub_1002BF00(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BB40(a3, a2, a1, a4, 3u, 0, a5);
}

//----- (1002BF30) --------------------------------------------------------
int __cdecl sub_1002BF30(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BB40(a3, a2, a1, a4, 4u, 1, a5);
}

//----- (1002BF60) --------------------------------------------------------
int __cdecl sub_1002BF60(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BB40(a3, a2, a1, a4, 4u, 0, a5);
}

//----- (1002BF90) --------------------------------------------------------
int __usercall sub_1002BF90@<eax>(unsigned int a1@<eax>, int a2@<ecx>, int a3, int a4, unsigned int a5, int a6, int a7)
{
  unsigned int v7; // ebx@1
  double *v8; // eax@1
  long double v10; // st7@3
  unsigned int v11; // edi@7
  double *v12; // esi@8
  double v13; // st7@16
  double *v14; // esi@20
  double *v15; // ebx@20
  double v16; // st6@26
  double v17; // st7@30
  double v18; // ST78_8@32
  double v19; // st7@32
  double v20; // st5@35
  double v21; // st7@38
  double *v22; // [sp+5Ch] [bp-3Ch]@1
  double v23; // [sp+60h] [bp-38h]@3
  double v24; // [sp+60h] [bp-38h]@32
  double v25; // [sp+68h] [bp-30h]@20
  double v26; // [sp+70h] [bp-28h]@26
  double v27; // [sp+78h] [bp-20h]@22
  double v28; // [sp+80h] [bp-18h]@8
  char v29; // [sp+88h] [bp-10h]@22

  v7 = a1;
  v8 = (double *)sub_1002B1A0(a4, a3, a2);
  v22 = v8;
  if ( !v8 )
    return 0;
  v10 = *v8;
  v23 = v10;
  if ( v7 )
  {
    if ( v7 > a5 )
      v7 = a5;
  }
  else
  {
    v7 = 1;
  }
  v11 = 0;
  if ( v7 )
  {
    v12 = &v28;
    while ( sub_10020030(a3, *(_DWORD *)(a4 + 4 * v11), v12) )
    {
      if ( (*((_DWORD *)v12 + 1) & 0x7FF00000) == 2146435072 )
      {
        v13 = *(double *)*(_DWORD *)(*(_DWORD *)(a3 + 24) + 468);
        *v22 = v13;
        return sub_1001F600(a3, v13, a7);
      }
      *v12 = sub_1001F900(*v12);
      ++v11;
      ++v12;
      if ( v11 >= v7 )
      {
        v10 = v23;
        goto LABEL_13;
      }
    }
    return 0;
  }
LABEL_13:
  if ( (HIDWORD(v23) & 0x7FF00000) == 2146435072 )
  {
    if ( v7 < 3 )
      return sub_1001F600(a3, v10, a7);
    v10 = 0.0;
  }
  else if ( a6 )
  {
    v10 = fmod(sub_1002A5D0(v10) + dbl_10572688, dbl_10162410) + v23;
  }
  v25 = v10;
  v14 = &v28;
  v15 = &v28 + v7;
  if ( a5 < 3 || &v28 >= v15 )
  {
    v27 = (double)sub_1002A0E0(v10);
  }
  else
  {
    v14 = (double *)&v29;
    v27 = v28;
  }
  if ( a5 < 2 || v14 >= v15 )
  {
    v26 = (double)sub_1002A230(v10);
  }
  else
  {
    v16 = *v14;
    ++v14;
    v26 = v16;
  }
  if ( a5 < 1 || v14 >= v15 )
    v17 = (double)sub_1002A400(v10);
  else
    v17 = *v14;
  v18 = sub_1002A750(v27, v26, v17) * dbl_10162410;
  v19 = sub_1002A0B0(v25) + v18;
  v24 = v19;
  if ( a6 )
  {
    v19 = sub_1002A660(v19);
    v24 = v19;
  }
  if ( (HIDWORD(v24) & 0x7FF00000) == 2146435072 )
    goto LABEL_43;
  v20 = v19;
  if ( v19 < 0.0 )
    v20 = -v19;
  if ( v20 > 8.64e15 )
LABEL_43:
    v21 = *(double *)*(_DWORD *)(*(_DWORD *)(a3 + 24) + 468);
  else
    v21 = sub_1001F900(v19 + 0.0);
  *v22 = v21;
  return sub_1001F600(a3, v21, a7);
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002C230) --------------------------------------------------------
int __cdecl sub_1002C230(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BF90(a3, a2, a1, a4, 1u, 1, a5);
}

//----- (1002C260) --------------------------------------------------------
int __cdecl sub_1002C260(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BF90(a3, a2, a1, a4, 1u, 0, a5);
}

//----- (1002C290) --------------------------------------------------------
int __cdecl sub_1002C290(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BF90(a3, a2, a1, a4, 2u, 1, a5);
}

//----- (1002C2C0) --------------------------------------------------------
int __cdecl sub_1002C2C0(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BF90(a3, a2, a1, a4, 2u, 0, a5);
}

//----- (1002C2F0) --------------------------------------------------------
int __cdecl sub_1002C2F0(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BF90(a3, a2, a1, a4, 3u, 1, a5);
}

//----- (1002C320) --------------------------------------------------------
int __cdecl sub_1002C320(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1002BF90(a3, a2, a1, a4, 3u, 0, a5);
}

//----- (1002C350) --------------------------------------------------------
int __cdecl sub_1002C350(int a1, int a2, int a3, signed int *a4, int a5)
{
  double *v5; // eax@1
  double *v6; // esi@1
  int result; // eax@2
  double v8; // st7@5
  double v9; // st7@6
  long double v10; // st6@7
  long double v11; // st7@8
  long double v12; // rt1@11
  double v13; // st6@11
  double v14; // st7@11
  double v15; // ST10_8@13
  signed int v16; // eax@13
  double v17; // ST40_8@13
  double v18; // st7@13
  long double v19; // st7@13
  long double v20; // ST40_8@13
  long double v21; // st5@14
  int v22; // [sp+14h] [bp-44h]@5
  double v23; // [sp+40h] [bp-18h]@3
  double v24; // [sp+48h] [bp-10h]@3
  double v25; // [sp+50h] [bp-8h]@7

  v5 = (double *)sub_1002B1A0((int)a4, a1, a2);
  v6 = v5;
  if ( v5 && (v23 = *v5, sub_10020030(a1, *a4, &v24)) )
  {
    if ( (HIDWORD(v24) & 0x7FF00000) == 2146435072 )
    {
      v8 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
      v22 = a5;
    }
    else
    {
      v9 = sub_1001F900(v24);
      v24 = v9;
      if ( (HIDWORD(v23) & 0x7FF00000) == 2146435072 )
      {
        v10 = 0.0;
        v25 = 0.0;
      }
      else
      {
        v11 = fmod(sub_1002A5D0(v23) + dbl_10572688, dbl_10162410) + v23;
        v25 = v11;
        v10 = v11;
        v9 = v24;
      }
      if ( v9 < 0.0 || v9 > 99.0 )
      {
        v14 = v10;
      }
      else
      {
        v12 = v10;
        v13 = v9;
        v14 = v12;
        v24 = v13 + 1900.0;
      }
      v15 = (double)sub_1002A400(v14);
      v16 = sub_1002A230(v25);
      v17 = sub_1002A750(v24, (double)v16, v15) * dbl_10162410;
      v18 = sub_1002A0B0(v25);
      v19 = sub_1002A660(v18 + v17);
      v20 = v19;
      if ( (HIDWORD(v20) & 0x7FF00000) == 2146435072 )
        goto LABEL_23;
      v21 = v19;
      if ( v19 < 0.0 )
        v21 = -v19;
      if ( v21 > 8.64e15 )
LABEL_23:
        v8 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
      else
        v8 = sub_1001F900(v19 + 0.0);
      v22 = a5;
    }
    *v6 = v8;
    result = sub_1001F600(a1, v8, v22);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10572688: using guessed type double dbl_10572688;

//----- (1002C530) --------------------------------------------------------
signed int __cdecl sub_1002C530(int a1, int a2, int a3, int a4, int *a5)
{
  unsigned int v5; // eax@1
  signed int result; // eax@2
  double v7; // ST70_8@5
  char *v8; // ST14_4@5
  int v9; // eax@5
  int v10; // eax@6
  char v11; // [sp+20h] [bp-C0h]@0
  char v12; // [sp+70h] [bp-70h]@4

  v5 = sub_1002B1A0(a4, a1, a2);
  if ( v5
    && ((*(_DWORD *)(v5 + 4) & 0x7FF00000) != 2146435072 ? (v7 = *(double *)v5,
                                                            sub_1002A6F0(v7),
                                                            sub_1002A6C0(v7),
                                                            sub_1002A690(v7),
                                                            sub_1002A0E0(v7),
                                                            v8 = off_1016265C[sub_1002A230(v7)],
                                                            sub_1002A400(v7),
                                                            v9 = sub_1002A580(v7),
                                                            sub_10050B00(
                                                              (int)&v12,
                                                              100,
                                                              "%s, %.2d %s %.4d %.2d:%.2d:%.2d GMT",
                                                              (unsigned int)off_10162640[v9])) : sub_10050B00(
                                                                                                   (int)&v12,
                                                                                                   100,
                                                                                                   aInvalidDate,
                                                                                                   v11),
        (v10 = sub_10010F20(a1, &v12)) != 0) )
  {
    *a5 = v10 | 4;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10162640: using guessed type char *off_10162640[20];
// 1016265C: using guessed type char *off_1016265C[13];

//----- (1002C690) --------------------------------------------------------
int __usercall sub_1002C690@<eax>(int a1@<edi>, double a2, int a3)
{
  signed int v3; // esi@1
  __int16 v4; // bx@2
  double v5; // st7@8
  double v6; // ST40_8@8
  double v7; // ST38_8@8
  double v8; // ST38_8@8
  int result; // eax@9

  v3 = sub_1002A0E0(a2);
  if ( (unsigned int)(v3 + 0x8000) > 0xFFFF )
  {
    if ( a3 )
    {
      if ( v3 < 0 )
        v4 = v3 - 2800 * ((v3 + 1) / 2800 - 1);
      else
        v4 = v3 % 2800;
    }
    else
    {
      v4 = (v3 <= 0) - 1 + -32768;
    }
  }
  else
  {
    v4 = v3;
  }
  *(_DWORD *)a1 = 1000 * sub_1002A720(a2);
  *(_BYTE *)(a1 + 4) = sub_1002A6F0(a2);
  *(_BYTE *)(a1 + 5) = sub_1002A6C0(a2);
  *(_BYTE *)(a1 + 6) = sub_1002A690(a2);
  *(_BYTE *)(a1 + 7) = sub_1002A400(a2);
  *(_BYTE *)(a1 + 8) = sub_1002A230(a2);
  *(_BYTE *)(a1 + 9) = sub_1002A580(a2);
  v5 = a2 / dbl_10162410;
  *(_WORD *)(a1 + 10) = v4;
  v6 = floor(v5);
  v7 = floor((double)(v3 - 1969) * 0.25) + (double)(365 * (v3 - 1970));
  v8 = v7 - floor((double)(v3 - 1901) / 100.0);
  *(_WORD *)(a1 + 12) = (signed int)(v6 - (floor((double)(v3 - 1601) / 400.0) + v8));
  if ( sub_1002A5D0(a2) == 0.0 )
  {
    result = 0;
    *(_BYTE *)(a1 + 14) = 0;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a1 + 14) = 1;
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;

//----- (1002C860) --------------------------------------------------------
int __usercall sub_1002C860@<eax>(int a1@<ebx>, double a2, int a3, int *a4)
{
  long double v4; // st7@3
  signed int v5; // eax@3
  char v6; // al@6
  char *v7; // ST28_4@7
  int v8; // eax@7
  char *v9; // ST10_4@8
  int v10; // eax@8
  int result; // eax@9
  char v12; // [sp+2Ch] [bp-C0h]@0
  double v13; // [sp+5Ch] [bp-90h]@3
  char v14; // [sp+6Ch] [bp-80h]@3
  char v15; // [sp+7Ch] [bp-70h]@2

  if ( (HIDWORD(a2) & 0x7FF00000) == 2146435072 )
  {
    sub_10050B00((int)&v15, 100, aInvalidDate, v12);
  }
  else
  {
    v13 = fmod(sub_1002A5D0(a2) + dbl_10572688, dbl_10162410) + a2;
    v4 = fmod(sub_1002A5D0(a2) + dbl_10572688, dbl_10162410);
    v5 = (signed int)floor(v4 / dbl_10162420);
    sub_1002C690((int)&v14, a2, 1);
    if ( a3 )
    {
      if ( a3 == 1 )
      {
        sub_1002A0E0(v13);
        sub_1002A400(v13);
        v7 = off_1016265C[sub_1002A230(v13)];
        v8 = sub_1002A580(v13);
        sub_10050B00((int)&v15, 100, "%s %s %.2d %.4d", (unsigned int)off_10162640[v8]);
      }
      else if ( a3 == 2 )
      {
        sub_1002A6F0(v13);
        sub_1002A6C0(v13);
        v6 = sub_1002A690(v13);
        sub_10050B00((int)&v15, 100, "%.2d:%.2d:%.2d GMT%+.4d%s%s", v6);
      }
    }
    else
    {
      sub_1002A6F0(v13);
      sub_1002A6C0(v13);
      sub_1002A690(v13);
      sub_1002A0E0(v13);
      sub_1002A400(v13);
      v9 = off_1016265C[sub_1002A230(v13)];
      v10 = sub_1002A580(v13);
      sub_10050B00((int)&v15, 100, "%s %s %.2d %.4d %.2d:%.2d:%.2d GMT%+.4d%s%s", (unsigned int)off_10162640[v10]);
    }
  }
  result = sub_10010F20(a1, &v15);
  if ( result )
  {
    *a4 = result | 4;
    result = 1;
  }
  return result;
}
// 10162410: using guessed type double dbl_10162410;
// 10162420: using guessed type double dbl_10162420;
// 10162640: using guessed type char *off_10162640[20];
// 1016265C: using guessed type char *off_1016265C[13];
// 10572688: using guessed type double dbl_10572688;

//----- (1002CB30) --------------------------------------------------------
double *__cdecl sub_1002CB30(int a1, int a2, int a3, int a4, int *a5)
{
  double *result; // eax@1

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
    result = (double *)sub_1002C860(a1, *result, 2, a5);
  return result;
}

//----- (1002CB70) --------------------------------------------------------
double *__cdecl sub_1002CB70(int a1, int a2, int a3, int a4, int *a5)
{
  double *result; // eax@1

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
    result = (double *)sub_1002C860(a1, *result, 1, a5);
  return result;
}

//----- (1002CBB0) --------------------------------------------------------
signed int __cdecl sub_1002CBB0(int a1, int a2, int a3, int a4, int *a5)
{
  double *v5; // eax@1
  signed int result; // eax@4
  const char *v7; // eax@5
  unsigned int v8; // esi@5
  int v9; // eax@6
  int v10; // [sp+14h] [bp-20h]@2

  v5 = (double *)sub_1002B1A0(a4, a1, a2);
  if ( !v5 )
    return 0;
  if ( !sub_1003DB50((int)&v10, 26, 0, 0, *v5)
    || (v7 = (const char *)sub_10050AE0("(new %s(%s))", (char)off_101624E8), (v8 = (unsigned int)v7) == 0) )
  {
    sub_10011170(a1);
    return 0;
  }
  v9 = sub_10010EB0(a1, (unsigned int)v7, strlen(v7));
  if ( v9 )
  {
    *a5 = v9 | 4;
    result = 1;
  }
  else
  {
    sub_10053E10(v8, dword_10658DEC);
    result = 0;
  }
  return result;
}
// 101624E8: using guessed type char *off_101624E8;
// 10658DE8: using guessed type int dword_10658DE8;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1002CC90) --------------------------------------------------------
double *__cdecl sub_1002CC90(int a1, int a2, int a3, int a4, int *a5)
{
  double *result; // eax@1

  result = (double *)sub_1002B1A0(a4, a1, a2);
  if ( result )
    result = (double *)sub_1002C860(a1, *result, 0, a5);
  return result;
}

//----- (1002CCD0) --------------------------------------------------------
double *__cdecl sub_1002CCD0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  double *result; // eax@2

  if ( !a3 )
    return sub_1002B1C0(a1, a2, 0, (int)a4, (int)a5);
  if ( a3 != 1 )
    goto LABEL_10;
  result = (double *)sub_1001ACB0(a1, *a4);
  if ( !result )
    return result;
  if ( sub_1001AEA0((int)result, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 140) + 8) & 0xFFFFFFF8) )
LABEL_10:
    result = sub_1002CC90(a1, a2, a3, (int)a4, a5);
  else
    result = sub_1002B1C0(a1, a2, 1, (int)a4, (int)a5);
  return result;
}

//----- (1002CD60) --------------------------------------------------------
double *__usercall sub_1002CD60@<eax>(int a1@<eax>, int a2)
{
  double *result; // eax@1

  result = sub_1001F5B0(a1, 0.0);
  if ( result )
    *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) = (unsigned int)result | 2;
  return result;
}

//----- (1002CD90) --------------------------------------------------------
int __cdecl sub_1002CD90(int a1, int a2, unsigned int a3, signed int *a4, int *a5)
{
  int result; // eax@2
  unsigned int v6; // eax@3
  double *v7; // esi@4
  __int64 v8; // rax@6
  double v9; // st7@6
  double *v10; // esi@10
  long double v11; // st7@12
  double v12; // st6@12
  double v13; // st5@12
  double *v14; // esi@16
  unsigned int *v15; // eax@17
  double v16; // st6@21
  unsigned int v17; // esi@26
  double v18; // st7@30
  double v19; // st7@37
  double v20; // st7@40
  long double v21; // st5@41
  double *v22; // eax@45
  __int64 v23; // [sp+48h] [bp-50h]@2
  double v24; // [sp+50h] [bp-48h]@9
  long double v25; // [sp+58h] [bp-40h]@40
  double v26; // [sp+60h] [bp-38h]@34
  double v27; // [sp+68h] [bp-30h]@40
  double v28; // [sp+70h] [bp-28h]@32
  double v29; // [sp+78h] [bp-20h]@40
  double v30; // [sp+80h] [bp-18h]@40
  double v31; // [sp+88h] [bp-10h]@40
  double v32; // [sp+90h] [bp-8h]@40

  if ( !(*(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1) )
  {
    v23 = sub_1002F6B0() / 1000;
    return sub_1002C860(a1, (double)v23, 0, a5);
  }
  v6 = a3;
  if ( !a3 )
  {
    v7 = sub_1002CD60(a1, a2);
    if ( v7 )
    {
      v8 = sub_1002F6B0() / 1000;
      v23 = v8;
      v9 = (double)v8;
      result = 1;
      *v7 = v9;
      return result;
    }
    return 0;
  }
  if ( a3 == 1 )
  {
    if ( (*a4 & 7) == 4 )
    {
      v14 = sub_1002CD60(a1, a2);
      if ( v14 )
      {
        v15 = (unsigned int *)sub_1001ACB0(a1, *a4);
        if ( v15 )
        {
          if ( !sub_1002AB80(v15, v14) )
            *v14 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
          if ( (*((_DWORD *)v14 + 1) & 0x7FF00000) == 2146435072 )
            goto LABEL_50;
          v16 = *v14;
          if ( v16 < 0.0 )
            v16 = -v16;
          if ( v16 > 8.64e15 )
          {
LABEL_50:
            result = 1;
            *v14 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
          }
          else
          {
            *v14 = sub_1001F900(*v14 + 0.0);
            result = 1;
          }
          return result;
        }
      }
    }
    else if ( sub_10020030(a1, *a4, &v24) )
    {
      v10 = sub_1002CD60(a1, a2);
      if ( v10 )
      {
        if ( (HIDWORD(v24) & 0x7FF00000) != 2146435072 )
        {
          v11 = 0.0;
          v12 = v24;
          v13 = v24;
          if ( v24 < 0.0 )
            v13 = -v24;
          if ( v13 <= 8.64e15 )
            goto LABEL_44;
        }
LABEL_47:
        *v10 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
        return 1;
      }
    }
    return 0;
  }
  v17 = 0;
  do
  {
    if ( v17 >= v6 )
    {
      if ( v17 == 2 )
      {
        v28 = 1.0;
        goto LABEL_35;
      }
      v18 = 0.0;
    }
    else
    {
      if ( !sub_10020030(a1, a4[v17], (double *)&v23) )
        return 0;
      if ( (HIDWORD(v23) & 0x7FF00000) == 2146435072 )
      {
        v22 = sub_1002CD60(a1, a2);
        if ( !v22 )
          return 0;
        *v22 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
        return 1;
      }
      v18 = sub_1001F900(*(double *)&v23);
      v6 = a3;
    }
    *(&v26 + v17) = v18;
LABEL_35:
    ++v17;
  }
  while ( v17 < 7 );
  v10 = sub_1002CD60(a1, a2);
  if ( !v10 )
    return 0;
  v19 = v26;
  if ( v26 >= 0.0 && v26 <= 99.0 )
    v19 = v26 + 1900.0;
  v20 = sub_1002A750(v19, v27, v28);
  v11 = sub_1002A660(v20 * dbl_10162410 + (60.0 * (v29 * 60.0 + v30) + v31) * dbl_10162408 + v32);
  v25 = v11;
  if ( (HIDWORD(v25) & 0x7FF00000) == 2146435072 )
    goto LABEL_47;
  v12 = 0.0;
  v21 = v11;
  if ( v11 < 0.0 )
    v21 = -v11;
  if ( v21 > 8.64e15 )
    goto LABEL_47;
LABEL_44:
  *v10 = sub_1001F900(v11 + v12);
  return 1;
}
// 10162408: using guessed type double dbl_10162408;
// 10162410: using guessed type double dbl_10162410;

//----- (1002D100) --------------------------------------------------------
int __cdecl sub_1002D100(int a1, unsigned int a2)
{
  char *v2; // eax@1
  int v3; // esi@1
  int result; // eax@2
  double *v5; // eax@4

  dbl_10572688 = -((double)sub_1002F6A0() * dbl_10162408);
  v2 = sub_10012240(
         a1,
         a2,
         0,
         (int *)&off_101624E8,
         (int)sub_1002CD90,
         7,
         0,
         (const char **)&off_101626C0,
         0,
         (const char **)&off_1016268C);
  v3 = (int)v2;
  if ( v2 && sub_10011970(a1, (int)v2, "toUTCString", "toGMTString") && (v5 = sub_1002CD60(a1, v3)) != 0 )
  {
    *v5 = *(double *)*(_DWORD *)(*(_DWORD *)(a1 + 24) + 468);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10162408: using guessed type double dbl_10162408;
// 101624E8: using guessed type char *off_101624E8;
// 1016268C: using guessed type char *off_1016268C;
// 101626C0: using guessed type char *off_101626C0;
// 10572688: using guessed type double dbl_10572688;

//----- (1002D1A0) --------------------------------------------------------
int __cdecl sub_1002D1A0(int a1, int a2, int a3, int *a4, int *a5)
{
  int result; // eax@2
  char *v6; // ST18_4@5
  int v7; // eax@5
  char v8; // [sp+10h] [bp-24h]@5

  if ( !sub_100123C0(a1, a2, (int *)&off_101628E0, (int)a4) )
    return 0;
  if ( (*(_BYTE *)(*(_DWORD *)(a2 + 4) + 12) & 7) == 6 )
  {
    v6 = off_10162AF8[(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) & 0xFFFFFFF8) != 0];
    sub_10050B00((int)&v8, 32, "(new %s(%s))", (char)off_101628E0);
    v7 = sub_10010F20(a1, &v8);
    if ( !v7 )
      return 0;
    *a5 = v7 | 4;
    result = 1;
  }
  else
  {
    result = sub_10014780(a1, a2, a3, a4, a5);
  }
  return result;
}
// 101628E0: using guessed type char *off_101628E0;
// 10162AF8: using guessed type char *off_10162AF8[2];

//----- (1002D280) --------------------------------------------------------
int __cdecl sub_1002D280(int a1, int a2, int a3, int *a4, int *a5)
{
  int result; // eax@2
  int v6; // edx@5

  if ( !sub_100123C0(a1, a2, (int *)&off_101628E0, (int)a4) )
    return 0;
  if ( (*(_BYTE *)(*(_DWORD *)(a2 + 4) + 12) & 7) == 6 )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4 * ((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) & 0xFFFFFFF8) != 0) + 148);
    if ( !(*(_DWORD *)(v6 + 8) & 0xFFFFFFF8) )
      return 0;
    *a5 = *(_DWORD *)(v6 + 8) & 0xFFFFFFF8 | 4;
    result = 1;
  }
  else
  {
    result = sub_10014F50(a1, a2, a3, a4, a5);
  }
  return result;
}
// 101628E0: using guessed type char *off_101628E0;

//----- (1002D300) --------------------------------------------------------
signed int __cdecl sub_1002D300(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  signed int result; // eax@1

  result = sub_100123C0(a1, a2, (int *)&off_101628E0, a4);
  if ( result )
  {
    *a5 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
    result = 1;
  }
  return result;
}
// 101628E0: using guessed type char *off_101628E0;

//----- (1002D340) --------------------------------------------------------
int __cdecl sub_1002D340(int a1, int a2)
{
  int result; // eax@1

  result = sub_10017C40(a1, (int)&off_101628E0, 0, 0);
  if ( result )
    *(_DWORD *)(*(_DWORD *)(result + 4) + 12) = 8 * a2 | 6;
  return result;
}
// 101628E0: using guessed type char *off_101628E0;

//----- (1002D370) --------------------------------------------------------
unsigned int __cdecl sub_1002D370(int a1, int a2)
{
  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 4 * (a2 != 0) + 148) + 8) & 0xFFFFFFF8;
}

//----- (1002D390) --------------------------------------------------------
int __cdecl sub_1002D390(int a1, signed int a2, signed int *a3)
{
  signed int v3; // eax@1
  int v4; // ecx@3
  signed int v5; // ecx@4
  int result; // eax@6
  int v7; // eax@11
  int v8; // ecx@11
  double v9; // st7@17
  double v10; // [sp+0h] [bp-8h]@17

  v3 = a2;
  if ( a2 && a2 != -2147483647 )
  {
    v4 = a2 & 7;
    if ( !(a2 & 7) )
    {
      v5 = *(_DWORD *)(a1 + 16);
      if ( v5 && v5 < 130 )
      {
        result = (*(int (__cdecl **)(int, unsigned int, signed int, signed int *))(*(_DWORD *)(*(_DWORD *)(a2 & 0xFFFFFFF8)
                                                                                             + 4)
                                                                                 + 36))(
                   a1,
                   a2 & 0xFFFFFFF8,
                   5,
                   &a2);
        if ( !result )
          return result;
        v3 = a2;
        if ( (a2 & 7) != 6 )
          v3 = 14;
        goto LABEL_9;
      }
LABEL_21:
      result = 1;
      *a3 = 1;
      return result;
    }
    if ( v4 == 4 )
    {
      v7 = *(_DWORD *)(a2 & 0xFFFFFFF8);
      v8 = *(_DWORD *)(a2 & 0xFFFFFFF8);
      if ( v7 & 0x40000000 )
        v8 = v7 & ((v7 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
      *a3 = v8 != 0;
      result = 1;
    }
    else
    {
      if ( a2 & 1 )
      {
        *a3 = (a2 & 0xFFFFFFFE) != 0;
        return 1;
      }
      if ( v4 != 2 )
      {
LABEL_9:
        *a3 = v3 >> 3;
        return 1;
      }
      v9 = *(double *)(a2 & 0xFFFFFFF8);
      v10 = v9;
      if ( ((HIDWORD(v10) & 0x7FF00000) != 2146435072 || !LODWORD(v10) && !(HIDWORD(v10) & 0xFFFFF)) && 0.0 != v9 )
        goto LABEL_21;
      *a3 = 0;
      result = 1;
    }
  }
  else
  {
    *a3 = 0;
    result = 1;
  }
  return result;
}

//----- (1002D4E0) --------------------------------------------------------
int __cdecl sub_1002D4E0(int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@2
  int v6; // eax@3

  if ( a3 )
  {
    result = sub_1002D390(a1, *a4, &a3);
    if ( !result )
      return result;
    v6 = 8 * a3 | 6;
  }
  else
  {
    v6 = 6;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1 )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) = v6;
    result = 1;
  }
  else
  {
    *a5 = v6;
    result = 1;
  }
  return result;
}

//----- (1002D550) --------------------------------------------------------
char *__cdecl sub_1002D550(int a1, unsigned int a2)
{
  char *result; // eax@1

  result = sub_10012240(a1, a2, 0, (int *)&off_101628E0, (int)sub_1002D4E0, 1, 0, (const char **)&off_10162928, 0, 0);
  if ( result )
    *(_DWORD *)(*((_DWORD *)result + 1) + 12) = 6;
  return result;
}
// 101628E0: using guessed type char *off_101628E0;
// 10162928: using guessed type char *off_10162928;

//----- (1002D590) --------------------------------------------------------
signed int __usercall sub_1002D590@<eax>(signed int a1@<eax>, int *a2)
{
  int v2; // eax@3
  signed int result; // eax@4
  int v4; // esi@6
  unsigned int v5; // eax@6
  int v6; // ecx@7
  _WORD *v7; // edi@8
  unsigned int v8; // esi@15
  unsigned int v9; // eax@15
  int v10; // esi@18
  int v11; // edi@18
  unsigned int v12; // ebp@18
  unsigned int v13; // ebx@18
  unsigned __int16 i; // ax@19
  int v15; // ebx@21

  if ( a1 & 1 && a1 != -2147483647 )
  {
    v2 = a1 >> 1;
    if ( v2 >= 0 )
    {
      *a2 = v2;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v4 = a1 & 0xFFFFFFF8;
    v5 = *(_DWORD *)(a1 & 0xFFFFFFF8);
    if ( v5 & 0x40000000 )
    {
      v6 = *(_DWORD *)(v4 + 4);
      if ( *(_DWORD *)v6 & 0x40000000 )
      {
        v7 = (_WORD *)sub_1001A200(v4);
      }
      else if ( (v5 & 0x80000000) == 0 )
      {
        v7 = (_WORD *)(*(_DWORD *)(v6 + 4) + 2 * ((v5 >> 15) & 0x7FFF));
      }
      else
      {
        v7 = *(_WORD **)(v6 + 4);
      }
    }
    else
    {
      v7 = *(_WORD **)(v4 + 4);
    }
    if ( *v7 >= 0x80u || !isdigit(*v7) )
      goto LABEL_30;
    v8 = *(_DWORD *)v4;
    v9 = v8;
    if ( v8 & 0x40000000 )
      v9 = v8 & ((v8 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    if ( v9 >= 0xB )
      goto LABEL_30;
    v10 = *v7 - 48;
    v11 = (int)(v7 + 1);
    v12 = 0;
    v13 = 0;
    if ( v10 )
    {
      for ( i = *(_WORD *)v11; i < 0x80u; v10 = v13 + 10 * v10 )
      {
        if ( !isdigit(i) )
          break;
        v15 = *(_WORD *)v11;
        i = *(_WORD *)(v11 + 2);
        v11 += 2;
        v13 = v15 - 48;
        v12 = v10;
      }
    }
    if ( *(_WORD *)v11 || v12 >= 0x19999999 && (v12 != 429496729 || v13 >= 5) )
    {
LABEL_30:
      result = 0;
    }
    else
    {
      *a2 = v10;
      result = 1;
    }
  }
  return result;
}

//----- (1002D6C0) --------------------------------------------------------
signed int __usercall sub_1002D6C0@<eax>(signed int a1@<eax>, unsigned int *a2@<edi>, int a3@<esi>)
{
  signed int v3; // eax@3
  signed int result; // eax@4
  char v5; // [sp+Ch] [bp-Ch]@0
  double v6; // [sp+10h] [bp-8h]@6

  if ( a1 & 1 && a1 != -2147483647 )
  {
    v3 = a1 >> 1;
    if ( v3 < 0 )
    {
LABEL_4:
      sub_100110F0(a3, (int)sub_1003ED50, 0, 152, v5);
      return 0;
    }
    *a2 = v3;
    result = 1;
  }
  else
  {
    if ( !sub_10020030(a3, a1, &v6)
      || !sub_1001F840(a3, v6, a2)
      || (HIDWORD(v6) & 0x7FF00000) == 2146435072 && (LODWORD(v6) || HIDWORD(v6) & 0xFFFFF)
      || (double)*a2 != v6 )
    {
      goto LABEL_4;
    }
    result = 1;
  }
  return result;
}

//----- (1002D770) --------------------------------------------------------
_WORD *__cdecl sub_1002D770(signed int a1, int a2, signed int *a3)
{
  signed int v3; // esi@1
  _WORD *result; // eax@1

  v3 = a1;
  result = (_WORD *)(*(int (__cdecl **)(signed int, int, _DWORD, signed int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(
                      a1,
                      a2,
                      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 264),
                      &a1);
  if ( result )
  {
    if ( a1 & 1 && a1 != -2147483647 )
    {
      *a3 = a1 >> 1;
      result = (_WORD *)1;
    }
    else
    {
      result = sub_100201D0(__PAIR__(a1, v3), a3);
    }
  }
  return result;
}

//----- (1002D7D0) --------------------------------------------------------
int __usercall sub_1002D7D0@<eax>(int a1@<ecx>, unsigned int a2@<eax>, int a3)
{
  int result; // eax@2

  if ( a2 > 0x3FFFFFFF )
  {
    result = sub_1001F5D0(a3, (double)a2, a1);
  }
  else
  {
    *(_DWORD *)a1 = 2 * a2 | 1;
    result = 1;
  }
  return result;
}

//----- (1002D810) --------------------------------------------------------
signed int __usercall sub_1002D810@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edi>, int a3@<esi>)
{
  signed int result; // eax@2
  int v4; // eax@3
  int v5; // eax@5

  if ( a1 > 0x3FFFFFFF )
  {
    v4 = sub_1001F6E0(a3, (double)a1);
    if ( v4 && (v5 = sub_10038890(a3, v4, 0)) != 0 )
    {
      *a2 = v5;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    *a2 = 2 * a1 | 1;
    result = 1;
  }
  return result;
}

//----- (1002D870) --------------------------------------------------------
int __cdecl sub_1002D870(int a1, int a2, unsigned int a3)
{
  int result; // eax@1
  int v4; // [sp+4h] [bp-4h]@1

  result = sub_1002D7D0((int)&v4, a3, a1);
  if ( result )
    result = (*(int (__cdecl **)(int, int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(
               a1,
               a2,
               *(_DWORD *)(*(_DWORD *)(a1 + 24) + 264),
               &v4);
  return result;
}

//----- (1002D8C0) --------------------------------------------------------
int __cdecl sub_1002D8C0(int a1, int a2)
{
  return (*(int (**)(void))((*(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE) + 16))();
}

//----- (1002D8E0) --------------------------------------------------------
_WORD *__cdecl sub_1002D8E0(int a1, int a2, int a3, signed int *a4)
{
  _WORD *result; // eax@1
  unsigned int v5; // eax@3
  unsigned int v6; // ebx@3
  unsigned int v7; // [sp+8h] [bp-10h]@1
  unsigned int v8; // [sp+Ch] [bp-Ch]@2
  int v9; // [sp+10h] [bp-8h]@4
  char v10; // [sp+14h] [bp-4h]@5

  result = (_WORD *)sub_1002D6C0(*a4, &v7, a1);
  if ( result )
  {
    result = sub_1002D770(a1, a2, (signed int *)&v8);
    if ( result )
    {
      v5 = v7;
      v6 = v8;
      if ( v8 <= v7 )
      {
LABEL_7:
        result = (_WORD *)sub_1002D7D0((int)a4, v5, a1);
      }
      else
      {
        while ( sub_1002D810(--v6, &v9, a1)
             && (*(int (__cdecl **)(int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 32))(a1, a2, v9, &v10) )
        {
          v5 = v7;
          if ( v6 <= v7 )
            goto LABEL_7;
        }
        result = 0;
      }
    }
  }
  return result;
}

//----- (1002D990) --------------------------------------------------------
_WORD *__cdecl sub_1002D990(signed int a1, int a2, signed int a3)
{
  _WORD *result; // eax@2
  unsigned int v4; // [sp+0h] [bp-8h]@3
  unsigned int v5; // [sp+4h] [bp-4h]@1

  if ( sub_1002D590(a3, (int *)&v5) )
  {
    result = sub_1002D770(a1, a2, (signed int *)&v4);
    if ( result )
    {
      if ( v5 < v4 )
      {
        result = (_WORD *)1;
      }
      else
      {
        v4 = v5 + 1;
        result = (_WORD *)sub_1002D870(a1, a2, v5 + 1);
      }
    }
  }
  else
  {
    result = (_WORD *)1;
  }
  return result;
}

//----- (1002DA10) --------------------------------------------------------
_WORD *__cdecl sub_1002DA10(unsigned int a1, int a2, int a3, int *a4)
{
  int v4; // esi@1
  _WORD *result; // eax@2

  v4 = a1;
  if ( *(_DWORD *)(a1 + 16) == 120 )
  {
    result = sub_1002D770(a1, a2, (signed int *)&a1);
    if ( result )
    {
      if ( a3 == 4 )
      {
        result = (_WORD *)sub_1002D7D0((int)a4, a1, v4);
      }
      else
      {
        if ( a3 == 5 )
          *a4 = 8 * (a1 > 0) | 6;
        result = (_WORD *)1;
      }
    }
  }
  else
  {
    result = (_WORD *)sub_10018370(a1, a2, a3, a4);
  }
  return result;
}

//----- (1002DA90) --------------------------------------------------------
_WORD *__cdecl sub_1002DA90(signed int a1, int a2, int a3, int a4, int *a5, int a6)
{
  int v6; // edi@1
  int v7; // ebx@1
  int v9; // eax@3
  int v10; // ebp@3
  int v11; // eax@5
  _WORD *v12; // eax@10
  int v13; // eax@12
  _WORD *v14; // esi@12
  int v15; // eax@16
  int v16; // eax@19
  const void *v17; // esi@19
  bool v18; // zf@19
  int v19; // ebp@19
  int v20; // edi@26
  char *v21; // eax@30
  char *(__cdecl *v22)(int, signed int); // eax@31
  int v23; // eax@35
  int v24; // edx@37
  _WORD *v25; // esi@40
  unsigned int v26; // ecx@44
  int v27; // edx@44
  unsigned int v28; // ecx@51
  int v29; // esi@51
  int v30; // edx@54
  const void *v31; // ecx@55
  int v32; // ebx@71
  int v33; // eax@77
  _WORD *v34; // [sp+Ch] [bp-20h]@3
  unsigned int v35; // [sp+10h] [bp-1Ch]@19
  int v36; // [sp+14h] [bp-18h]@3
  int v37; // [sp+18h] [bp-14h]@21
  _WORD *v38; // [sp+1Ch] [bp-10h]@1
  int v39; // [sp+20h] [bp-Ch]@21
  unsigned int v40; // [sp+24h] [bp-8h]@1
  int v41; // [sp+28h] [bp-4h]@28

  v6 = a1;
  v7 = 0;
  v38 = sub_1002D770(a1, a2, (signed int *)&v40);
  if ( !v38 )
    return 0;
  v9 = sub_100144E0(a1, a2, 0, (unsigned int *)&v34);
  v10 = v9;
  v36 = v9;
  if ( !v9 )
    return 0;
  if ( !a4 )
  {
    if ( v34 )
      sub_10010340(a1, (unsigned int)v34);
    v34 = 0;
    v15 = *(_DWORD *)(v10 + 12);
    if ( v15 & 2 || !v40 )
    {
      sub_10014720(a1, 0);
      *a5 = sub_10010180(a1);
      return v38;
    }
    *(_DWORD *)(v10 + 12) = v15 | 2;
    goto LABEL_19;
  }
  v11 = *(_DWORD *)(v9 + 12);
  if ( !(v11 & 1) )
  {
    if ( v34 )
    {
      *(_DWORD *)(v10 + 12) = v11 | 1;
      v13 = sub_1001AFC0(v34);
      v7 = v13;
      v14 = v34;
      v12 = sub_10010140(v34, 2 * v13 + 10);
      v34 = v12;
      if ( !v12 )
      {
        sub_10053E10((unsigned int)v14, dword_10658DEC);
        v12 = v34;
        goto LABEL_68;
      }
    }
    else
    {
      v12 = malloc(0xAu);
      v34 = v12;
      if ( !v12 )
        goto LABEL_68;
    }
    v12[v7++] = 91;
LABEL_19:
    v16 = *(_DWORD *)a3;
    v17 = 0;
    v18 = (*(_DWORD *)a3 & 0x40000000) == 0;
    v35 = 0;
    v19 = v16;
    if ( !v18 )
      v19 = v16 & ((v16 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v37 = 0;
    v39 = 0;
    if ( v40 )
    {
      while ( 1 )
      {
        v38 = (_WORD *)sub_10010A10(v6, a2, v39);
        if ( !v38 )
          break;
        if ( a4 || v37 != -2147483647 && v37 )
        {
          if ( a6 )
          {
            if ( !sub_10017450(v6, v37, (unsigned int *)&v41)
              || !sub_100175A0(v6, v41, *(_DWORD *)(*(_DWORD *)(v6 + 24) + 292), 0, 0, &v37) )
            {
              goto LABEL_63;
            }
            v21 = (char *)sub_1001ACB0(v6, v37);
          }
          else
          {
            v22 = sub_1001AD70;
            if ( !a4 )
              v22 = (char *(__cdecl *)(int, signed int))sub_1001ACB0;
            v21 = v22(v6, v37);
          }
          v20 = (int)v21;
          if ( !v21 )
          {
            v6 = a1;
LABEL_63:
            v38 = 0;
            break;
          }
        }
        else
        {
          v20 = *(_DWORD *)(*(_DWORD *)(v6 + 24) + 480);
        }
        v23 = *(_DWORD *)v20;
        if ( *(_DWORD *)v20 & 0x40000000 )
          v23 = *(_DWORD *)v20 & ((v23 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        v24 = v7 + v23 + (v17 != 0 ? v19 : 0);
        if ( v34 )
        {
          v25 = v34;
          v12 = sub_10053FC0(v34, 2 * v24 + 8, dword_10658DEC);
          v34 = v12;
          if ( !v12 )
          {
            sub_10053E10((unsigned int)v25, dword_10658DEC);
            v12 = v34;
LABEL_66:
            v6 = a1;
            goto LABEL_67;
          }
          v17 = (const void *)v35;
        }
        else
        {
          v12 = (_WORD *)sub_10053CF0(2 * v24 + 8, dword_10658DEC);
          v34 = v12;
          if ( !v12 )
            goto LABEL_66;
        }
        if ( v17 )
        {
          memcpy(&v12[v7], v17, 2 * v19);
          v12 = v34;
          v7 += v19;
        }
        v26 = *(_DWORD *)a3;
        v27 = *(_DWORD *)(a3 + 4);
        if ( *(_DWORD *)a3 & 0x40000000 )
        {
          if ( *(_DWORD *)v27 & 0x40000000 )
          {
            v35 = sub_1001A200(a3);
            v12 = v34;
          }
          else if ( (v26 & 0x80000000) == 0 )
          {
            v35 = *(_DWORD *)(v27 + 4) + 2 * ((v26 >> 15) & 0x7FFF);
          }
          else
          {
            v35 = *(_DWORD *)(v27 + 4);
          }
        }
        else
        {
          v35 = *(_DWORD *)(a3 + 4);
        }
        v28 = *(_DWORD *)v20;
        v29 = *(_DWORD *)v20;
        if ( *(_DWORD *)v20 & 0x40000000 )
          v29 = v28 & ((v29 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        if ( *(_DWORD *)v20 & 0x40000000 )
        {
          v30 = *(_DWORD *)(v20 + 4);
          if ( *(_DWORD *)v30 & 0x40000000 )
          {
            v31 = (const void *)sub_1001A200(v20);
            v12 = v34;
          }
          else if ( (v28 & 0x80000000) == 0 )
          {
            v31 = (const void *)(*(_DWORD *)(v30 + 4) + 2 * ((v28 >> 15) & 0x7FFF));
          }
          else
          {
            v31 = *(const void **)(v30 + 4);
          }
        }
        else
        {
          v31 = *(const void **)(v20 + 4);
        }
        memcpy(&v12[v7], v31, 2 * v29);
        v6 = a1;
        v7 += v29;
        if ( ++v39 >= v40 )
          break;
        v17 = (const void *)v35;
      }
    }
    v12 = v34;
LABEL_67:
    v10 = v36;
LABEL_68:
    if ( a4 )
    {
      if ( v12 )
      {
        if ( v37 == -2147483647 )
        {
          v12[v7] = 44;
          v32 = v7 + 1;
          v34[v32] = 32;
          v12 = v34;
          v7 = v32 + 1;
        }
        v12[v7++] = 93;
      }
    }
    else
    {
      *(_DWORD *)(v10 + 12) &= 0xFFFFFFFD;
    }
    sub_10014720(v6, 0);
    if ( !v38 )
    {
      if ( v34 )
      {
        sub_10053E10((unsigned int)v34, dword_10658DEC);
        return 0;
      }
      return 0;
    }
    goto LABEL_7;
  }
  v7 = sub_1001AFC0(v34);
LABEL_7:
  if ( !v34 )
  {
    sub_10011170(v6);
    return 0;
  }
  v34[v7] = 0;
  v33 = sub_1001AB10(v6, (int)v34, v7, 0);
  if ( !v33 )
  {
    sub_10053E10((unsigned int)v34, dword_10658DEC);
    return 0;
  }
  *a5 = v33 | 4;
  return (_WORD *)1;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1002DF60) --------------------------------------------------------
_WORD *__cdecl sub_1002DF60(signed int a1, int a2, int a3, int a4, int *a5)
{
  return sub_1002DA90(a1, a2, (int)&unk_101629AC, 1, a5, 0);
}

//----- (1002DF90) --------------------------------------------------------
_WORD *__cdecl sub_1002DF90(signed int a1, int a2, int a3, int a4, int *a5)
{
  void *v5; // ecx@1

  v5 = &unk_101629AC;
  if ( *(_DWORD *)(a1 + 16) != 120 )
    v5 = &unk_101629B4;
  return sub_1002DA90(a1, a2, (int)v5, *(_DWORD *)(a1 + 16) == 120, a5, 0);
}

//----- (1002DFD0) --------------------------------------------------------
_WORD *__cdecl sub_1002DFD0(signed int a1, int a2, int a3, int a4, int *a5)
{
  return sub_1002DA90(a1, a2, (int)&unk_101629B4, 0, a5, 1);
}

//----- (1002E000) --------------------------------------------------------
signed int __usercall sub_1002E000@<eax>(int a1@<eax>, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // ebx@1
  int v5; // esi@1
  int v6; // ebp@2
  signed int result; // eax@6
  int v8; // [sp+10h] [bp-4h]@3

  v4 = 0;
  v5 = a1;
  if ( a3 )
  {
    v6 = a4;
    while ( sub_1002D810(v4, &v8, v5)
         && (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(v5, a2, v8, v6) )
    {
      ++v4;
      v6 += 4;
      if ( v4 >= a3 )
        goto LABEL_6;
    }
    result = 0;
  }
  else
  {
LABEL_6:
    result = 1;
  }
  return result;
}

//----- (1002E060) --------------------------------------------------------
signed int __usercall sub_1002E060@<eax>(unsigned int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  signed int result; // eax@2
  int v5; // [sp+0h] [bp-Ch]@0
  int v6; // [sp+8h] [bp-4h]@1

  if ( sub_1002D7D0((int)&v6, a1, v5)
    && (*(int (__cdecl **)(int, int, _DWORD, int, int (__cdecl *)(int, int), _WORD *(__cdecl *)(int, int, int, signed int *), signed int, _DWORD))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 12))(
         a3,
         a2,
         *(_DWORD *)(*(_DWORD *)(a3 + 24) + 264),
         v6,
         sub_1002D8C0,
         sub_1002D8E0,
         4,
         0) )
  {
    if ( a4 )
      result = sub_1002E000(a3, a2, a1, a4);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002E0D0) --------------------------------------------------------
int __cdecl sub_1002E0D0(signed int a1, int a2, int a3, signed int *a4, int *a5)
{
  int result; // eax@2

  if ( *a4 == -2147483647 )
  {
    result = (int)sub_1002DA90(a1, a2, (int)&unk_101629B4, 0, a5, 0);
  }
  else
  {
    result = sub_1001ACB0(a1, *a4);
    if ( result )
    {
      *a4 = result | 4;
      result = (int)sub_1002DA90(a1, a2, result, 0, a5, 0);
    }
  }
  return result;
}

//----- (1002E140) --------------------------------------------------------
_WORD *__cdecl sub_1002E140(signed int a1, int a2, int a3, int a4, int *a5)
{
  _WORD *result; // eax@1
  unsigned int v6; // ebp@2
  int v7; // edi@6
  unsigned int v8; // [sp+8h] [bp-18h]@1
  int v9; // [sp+Ch] [bp-14h]@3
  int v10; // [sp+10h] [bp-10h]@4
  char v11; // [sp+14h] [bp-Ch]@6
  char v12; // [sp+18h] [bp-8h]@5
  unsigned int v13; // [sp+1Ch] [bp-4h]@2

  result = sub_1002D770(a1, a2, (signed int *)&v8);
  if ( result )
  {
    v13 = v8 >> 1;
    v6 = 0;
    if ( v8 >> 1 )
    {
      while ( sub_1002D810(v6, &v9, a1) )
      {
        if ( !sub_1002D810(v8 - v6 - 1, &v10, a1) )
          break;
        if ( !(*(int (__cdecl **)(signed int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(a1, a2, v9, &v12) )
          break;
        v7 = v10;
        if ( !(*(int (__cdecl **)(signed int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(
                a1,
                a2,
                v10,
                &v11)
          || !(*(int (__cdecl **)(signed int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(a1, a2, v9, &v11)
          || !(*(int (__cdecl **)(signed int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(a1, a2, v7, &v12) )
        {
          break;
        }
        if ( ++v6 >= v13 )
          goto LABEL_10;
      }
      result = 0;
    }
    else
    {
LABEL_10:
      *a5 = a2;
      result = (_WORD *)1;
    }
  }
  return result;
}

//----- (1002E250) --------------------------------------------------------
_DWORD *__usercall sub_1002E250@<eax>(int a1@<eax>, int a2, signed int a3, unsigned int a4)
{
  const void *v4; // ecx@1
  int v5; // ebp@1
  size_t v6; // esi@1
  int v7; // ebx@1
  unsigned int v8; // edi@1
  const void *v9; // edi@5
  const void *v10; // ebp@5
  _DWORD *result; // eax@7
  unsigned int v12; // ebp@18
  void *v13; // [sp+10h] [bp-18h]@1
  int v14; // [sp+14h] [bp-14h]@1
  int v15; // [sp+18h] [bp-10h]@1
  int (__cdecl *v16)(size_t, size_t, int); // [sp+1Ch] [bp-Ch]@1
  int v17; // [sp+20h] [bp-8h]@1

  v4 = *(const void **)(a1 + 8);
  v5 = *(_DWORD *)a1;
  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_DWORD *)a1 - 2 * v6;
  v14 = *(_DWORD *)(a1 + 16);
  v8 = a3;
  v13 = *(void **)(a1 + 8);
  v17 = *(_DWORD *)a1;
  v16 = *(int (__cdecl **)(size_t, size_t, int))(a1 + 12);
  v15 = *(_DWORD *)(a1 + 20);
  if ( a3 != 1 )
  {
    if ( v15 )
    {
      *(_DWORD *)v4 = *(_DWORD *)(v7 + a3 * v6);
LABEL_15:
      if ( v8 <= a4 >> 1 )
      {
        while ( 1 )
        {
          v12 = 2 * v8;
          if ( 2 * v8 < a4 && v16(v7 + v6 * v12, v17 + v6 * (v12 - 1), v14) < 0 )
            ++v12;
          if ( v16(v13, v7 + v6 * v12, v14) >= 0 )
            break;
          if ( v15 )
            *(_DWORD *)(v7 + a3 * v6) = *(_DWORD *)(v7 + v6 * v12);
          else
            memcpy((void *)(v7 + a3 * v6), (const void *)(v7 + v6 * v12), v6);
          a3 = v12;
          if ( v12 > a4 >> 1 )
            break;
          v8 = v12;
        }
        v8 = a3;
        v4 = v13;
      }
      result = (_DWORD *)(v7 + v8 * v6);
      if ( v15 )
        *result = *(_DWORD *)v4;
      else
        result = memcpy((void *)(v7 + v8 * v6), v4, v6);
      return result;
    }
    memcpy((void *)v4, (const void *)(v7 + a3 * v6), v6);
LABEL_14:
    v4 = v13;
    goto LABEL_15;
  }
  a3 = 2;
  if ( a4 > 2 && (*(int (__cdecl **)(int, size_t, int))(a1 + 12))(v5, v6 + v5, v14) < 0 )
    a3 = 3;
  v9 = (const void *)(v5 + v6 * (a4 - 1));
  v10 = (const void *)(v7 + v6 * a3);
  if ( !a2 && a4 != 2 || (result = (_DWORD *)v16(v9, v7 + v6 * a3, v14), (signed int)result < 0) )
  {
    if ( v15 )
    {
      *(_DWORD *)v13 = *(_DWORD *)v9;
      *(_DWORD *)v9 = *(_DWORD *)v10;
      v8 = a3;
    }
    else
    {
      memcpy(v13, v9, v6);
      memcpy((void *)v9, v10, v6);
      v8 = a3;
    }
    goto LABEL_14;
  }
  return result;
}

//----- (1002E420) --------------------------------------------------------
signed int __cdecl sub_1002E420(signed int *a1, signed int *a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebp@1
  int v5; // eax@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // ebx@5
  int v9; // eax@6
  signed int result; // eax@7
  double v11; // st7@8
  double v12; // [sp+0h] [bp-10h]@1
  int v13; // [sp+8h] [bp-8h]@10
  int v14; // [sp+Ch] [bp-4h]@10

  v3 = *a1;
  v12 = -1.0;
  v4 = a3;
  v5 = *(_DWORD *)(a3 + 4);
  v6 = *(_DWORD *)a3;
  v7 = *a2;
  if ( v5 )
  {
    v13 = v3;
    v14 = v7;
    if ( !sub_100302A0(v6, *(_DWORD *)(*(_DWORD *)((v5 & 0xFFFFFFF8) + 4) + 4) & 0xFFFFFFF8, v5, 0, 2, (int)&v13, &a1) )
    {
LABEL_8:
      v11 = v12;
      *(_DWORD *)(v4 + 8) = 0;
      return (signed int)v11;
    }
    sub_10020030(v6, (signed int)a1, &v12);
    if ( (HIDWORD(v12) & 0x7FF00000) != 2146435072 || !LODWORD(v12) && !(HIDWORD(v12) & 0xFFFFF) )
    {
      if ( v12 == 0.0 )
      {
        result = (signed int)v12;
      }
      else
      {
        a1 = (signed int *)1;
        if ( v12 <= 0.0 )
          a1 = (signed int *)-1;
        result = (signed int)(double)(signed int)a1;
      }
      return result;
    }
    return (signed int)0.0;
  }
  if ( v3 == v7 )
    return (signed int)0.0;
  if ( v3 != -2147483647 && v7 != -2147483647 )
  {
    v8 = sub_1001ACB0(v6, v3);
    if ( v8 )
    {
      v9 = sub_1001ACB0(v6, v7);
      if ( v9 )
        return (signed int)(double)sub_1001AEA0(v8, v9);
    }
    goto LABEL_8;
  }
  return (signed int)(double)(2 * (v3 == -2147483647) - 1);
}

//----- (1002E5A0) --------------------------------------------------------
int __cdecl sub_1002E5A0(_DWORD *a1, _DWORD *a2)
{
  return sub_1001AEA0(*a1 & 0xFFFFFFF8, *a2 & 0xFFFFFFF8);
}

//----- (1002E5C0) --------------------------------------------------------
_WORD *__cdecl sub_1002E5C0(int a1, int a2, unsigned int a3, int a4, signed int *a5)
{
  _WORD *result; // eax@1
  unsigned int v6; // eax@2
  unsigned int v7; // ebx@2
  int v8; // ebp@3
  signed int v9; // eax@10
  unsigned int v10; // [sp+4h] [bp-8h]@1
  int v11; // [sp+8h] [bp-4h]@4

  result = sub_1002D770(a1, a2, (signed int *)&v10);
  if ( result )
  {
    v6 = a3;
    v7 = 0;
    if ( a3 )
    {
      v8 = a4;
      while ( sub_1002D810(v7 + v10, &v11, a1)
           && (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(a1, a2, v11, v8) )
      {
        ++v7;
        v8 += 4;
        if ( v7 >= a3 )
        {
          v6 = a3;
          goto LABEL_8;
        }
      }
      return 0;
    }
LABEL_8:
    v10 += v6;
    if ( *(_DWORD *)(a1 + 16) == 120 )
    {
      if ( v6 )
        v9 = *(_DWORD *)(a4 + 4 * v6 - 4);
      else
        v9 = -2147483647;
      *a5 = v9;
    }
    else if ( !sub_1002D7D0((int)a5, v10, a1) )
    {
      return 0;
    }
    result = (_WORD *)sub_1002D870(a1, a2, v10);
  }
  return result;
}

//----- (1002E6A0) --------------------------------------------------------
_WORD *__cdecl sub_1002E6A0(signed int a1, int a2, int a3, int a4, int a5)
{
  _WORD *result; // eax@1
  unsigned int v6; // eax@2
  int v7; // edi@4
  unsigned int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@3
  char v10; // [sp+10h] [bp-4h]@5

  result = sub_1002D770(a1, a2, (signed int *)&v8);
  if ( result )
  {
    v6 = v8;
    if ( v8 )
    {
      if ( !sub_1002D810(--v8, &v9, a1) )
        return 0;
      v7 = v9;
      if ( !(*(int (__cdecl **)(signed int, int, int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(a1, a2, v9, a5)
        || !(*(int (__cdecl **)(signed int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 32))(a1, a2, v7, &v10) )
      {
        return 0;
      }
      v6 = v8;
    }
    result = (_WORD *)sub_1002D870(a1, a2, v6);
  }
  return result;
}

//----- (1002E740) --------------------------------------------------------
_WORD *__cdecl sub_1002E740(signed int a1, int a2, int a3, int a4, int a5)
{
  _WORD *result; // eax@1
  int v6; // ecx@3
  signed int v7; // edi@3
  int (__cdecl *v8)(signed int, int, signed int, int); // ecx@3
  unsigned int v9; // ebp@5
  unsigned int v10; // [sp+8h] [bp-14h]@1
  int v11; // [sp+Ch] [bp-10h]@3
  char v12; // [sp+10h] [bp-Ch]@8
  int v13; // [sp+14h] [bp-8h]@7
  char v14; // [sp+18h] [bp-4h]@11

  result = sub_1002D770(a1, a2, (signed int *)&v10);
  if ( result )
  {
    if ( v10 )
    {
      v6 = *(_DWORD *)a2;
      v7 = 1;
      --v10;
      v8 = *(int (__cdecl **)(signed int, int, signed int, int))(*(_DWORD *)(v6 + 4) + 16);
      v11 = 1;
      if ( !v8(a1, a2, 1, a5) )
        return 0;
      if ( v10 )
      {
        v9 = 1;
        if ( v10 >= 1 )
        {
          while ( sub_1002D810(v9, &v11, a1) )
          {
            if ( !sub_1002D810(v9 - 1, &v13, a1) )
              break;
            v7 = v11;
            if ( !(*(int (__cdecl **)(signed int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(
                    a1,
                    a2,
                    v11,
                    &v12)
              || !(*(int (__cdecl **)(signed int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(
                    a1,
                    a2,
                    v13,
                    &v12) )
            {
              break;
            }
            if ( ++v9 > v10 )
              goto LABEL_11;
          }
          return 0;
        }
      }
LABEL_11:
      if ( !(*(int (__cdecl **)(signed int, int, signed int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 32))(
              a1,
              a2,
              v7,
              &v14) )
        return 0;
    }
    result = (_WORD *)sub_1002D870(a1, a2, v10);
  }
  return result;
}

//----- (1002E850) --------------------------------------------------------
_WORD *__cdecl sub_1002E850(int a1, int a2, int a3, int a4, int a5)
{
  _WORD *result; // eax@1
  unsigned int v6; // ebx@3
  unsigned int v7; // ebx@9
  int v8; // ebp@10
  unsigned int v9; // [sp+4h] [bp-10h]@1
  int v10; // [sp+8h] [bp-Ch]@4
  char v11; // [sp+Ch] [bp-8h]@6
  int v12; // [sp+10h] [bp-4h]@5

  result = sub_1002D770(a1, a2, (signed int *)&v9);
  if ( result )
  {
    if ( a3 )
    {
      v6 = v9;
      if ( v9 )
      {
        while ( sub_1002D810(--v6, &v10, a1)
             && sub_1002D810(v6 + a3, &v12, a1)
             && (*(int (__cdecl **)(int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(a1, a2, v10, &v11)
             && (*(int (__cdecl **)(int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(a1, a2, v12, &v11) )
        {
          if ( !v6 )
            goto LABEL_9;
        }
        return 0;
      }
LABEL_9:
      v7 = 0;
      if ( a3 )
      {
        v8 = a4;
        while ( sub_1002D810(v7, &v10, a1)
             && (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 20))(a1, a2, v10, v8) )
        {
          ++v7;
          v8 += 4;
          if ( v7 >= a3 )
            goto LABEL_14;
        }
        return 0;
      }
LABEL_14:
      v9 += a3;
      if ( !sub_1002D870(a1, a2, v9) )
        return 0;
    }
    result = (_WORD *)sub_1002D7D0(a5, v9, a1);
  }
  return result;
}

//----- (1002E990) --------------------------------------------------------
int __cdecl sub_1002E990(signed int a1, int a2, unsigned int a3, signed int *a4, int *a5)
{
  int v5; // esi@1
  int result; // eax@2
  int v7; // ebp@2
  signed int v8; // eax@11

  v5 = a1;
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) & 1 )
  {
    v7 = a2;
  }
  else
  {
    result = sub_10017C40(a1, (int)&off_10162958, 0, 0);
    v7 = result;
    if ( !result )
      return result;
    *a5 = result;
  }
  if ( !a3 )
  {
    a1 = 0;
    return sub_1002E060(a1, v7, v5, 0);
  }
  if ( *(_DWORD *)(v5 + 16) != 120 && a3 <= 1 )
  {
    v8 = *a4;
    if ( *a4 & 1 && v8 != -2147483647 || (v8 & 7) == 2 )
    {
      result = sub_1002D6C0(v8, (unsigned int *)&a1, v5);
      if ( result )
        return sub_1002E060(a1, v7, v5, 0);
    }
    else
    {
      a1 = 1;
      result = sub_1002E060(1u, v7, v5, (int)a4);
    }
  }
  else
  {
    a1 = a3;
    result = sub_1002E060(a3, v7, v5, (int)a4);
  }
  return result;
}
// 10162958: using guessed type char *off_10162958;

//----- (1002EA60) --------------------------------------------------------
char *__cdecl sub_1002EA60(int a1, unsigned int a2)
{
  char *v2; // edi@1
  char *result; // eax@3

  v2 = sub_10012240(a1, a2, 0, (int *)&off_10162958, (int)sub_1002E990, 1, 0, (const char **)&off_101629C0, 0, 0);
  if ( v2 && sub_1002E060(0, (int)v2, a1, 0) )
    result = v2;
  else
    result = 0;
  return result;
}
// 10162958: using guessed type char *off_10162958;
// 101629C0: using guessed type char *off_101629C0;

//----- (1002EAB0) --------------------------------------------------------
int __cdecl sub_1002EAB0(int a1, unsigned int a2, int a3)
{
  int v3; // edi@1

  v3 = sub_10017C40(a1, (int)&off_10162958, 0, 0);
  if ( !v3 )
    return 0;
  if ( !sub_1002E060(a2, v3, a1, a3) )
  {
    *(_DWORD *)(a1 + 92) = 0;
    return 0;
  }
  return v3;
}
// 10162958: using guessed type char *off_10162958;

//----- (1002EB00) --------------------------------------------------------
int __cdecl sub_1002EB00(int a1, unsigned int a2, unsigned int a3, signed int (__cdecl *a4)(signed int *a1, signed int *a2, int a3), int a5)
{
  int result; // eax@1
  unsigned int v6; // ebx@1
  unsigned int v7; // esi@5
  signed int v8; // edi@5
  int v9; // [sp+8h] [bp-18h]@2
  unsigned int v10; // [sp+Ch] [bp-14h]@2
  int v11; // [sp+10h] [bp-10h]@2
  signed int (__cdecl *v12)(signed int *, signed int *, int); // [sp+14h] [bp-Ch]@2
  int v13; // [sp+18h] [bp-8h]@2
  int v14; // [sp+1Ch] [bp-4h]@3

  result = sub_10053CF0(a3, dword_10658DEC);
  v6 = result;
  if ( result )
  {
    v9 = a1;
    v10 = a3;
    v11 = result;
    v12 = a4;
    v13 = a5;
    if ( a4 == sub_1002E420 || (v14 = 0, (char *)a4 == (char *)sub_1002E5A0) )
      v14 = 1;
    v7 = a2;
    v8 = a2 >> 1;
    if ( a2 >> 1 )
    {
      do
        sub_1002E250((int)&v9, 1, v8--, a2);
      while ( v8 );
    }
    if ( a2 > 2 )
    {
      do
        sub_1002E250((int)&v9, 0, 1, --v7);
      while ( v7 > 2 );
    }
    sub_10053E10(v6, dword_10658DEC);
    result = 1;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1002EBD0) --------------------------------------------------------
signed int __cdecl sub_1002EBD0(int a1, int a2, int a3, int *a4, int *a5)
{
  unsigned int v5; // ebp@1
  signed int result; // eax@5
  int v7; // edi@7
  _DWORD *v8; // ebx@13
  unsigned int v9; // eax@15
  int v10; // ecx@18
  signed int (__cdecl *v11)(signed int *, signed int *, int); // ecx@20
  char v12; // [sp+0h] [bp-24h]@0
  unsigned int v13; // [sp+4h] [bp-20h]@7
  int v14; // [sp+8h] [bp-1Ch]@4
  _DWORD *v15; // [sp+Ch] [bp-18h]@13
  int v16; // [sp+10h] [bp-14h]@16
  unsigned int v17; // [sp+14h] [bp-10h]@10
  int v18; // [sp+18h] [bp-Ch]@20
  int v19; // [sp+1Ch] [bp-8h]@20
  int v20; // [sp+20h] [bp-4h]@16
  signed int v21; // [sp+30h] [bp+Ch]@4

  v5 = 0;
  if ( a3 )
  {
    if ( *a4 & 7 || !*a4 )
    {
      sub_100110F0(a1, (int)sub_1003ED50, 0, 12, v12);
      return 0;
    }
    v14 = *a4;
    v21 = 0;
  }
  else
  {
    v14 = 0;
    v21 = 1;
  }
  v7 = a2;
  if ( !sub_1002D770(a1, a2, (signed int *)&v13) )
    return 0;
  if ( !v13 )
  {
    *a5 = a2;
    return 1;
  }
  v17 = v13;
  if ( (double)v13 * 4.0 != (double)(4 * v13) )
  {
    sub_10011170(a1);
    return 0;
  }
  v8 = (_DWORD *)sub_10011830(a1, 4 * v13);
  v15 = v8;
  if ( v8 )
  {
    v9 = v13;
    v17 = v13;
    if ( v13 <= 0 )
    {
LABEL_20:
      v18 = a1;
      v19 = v14;
      v20 = 1;
      v11 = (signed int (__cdecl *)(signed int *, signed int *, int))sub_1002E5A0;
      if ( !v21 )
        v11 = sub_1002E420;
      if ( sub_1002EB00((int)v8, v9, 4u, v11, (int)&v18) )
      {
        if ( v20 )
        {
          v20 = sub_1002E000(a1, v7, v17, (int)v8);
          if ( v20 )
            *a5 = v7;
        }
      }
      else
      {
        sub_10011170(a1);
        v20 = 0;
      }
    }
    else
    {
      while ( 1 )
      {
        v20 = sub_1002D810(v5, &v16, a1);
        if ( !v20 )
          break;
        v20 = (*(int (__cdecl **)(int, int, int, _DWORD *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(a1, a2, v16, v8);
        if ( !v20 )
          break;
        v9 = v13;
        v10 = (*v8 & 7) == 4;
        ++v5;
        ++v8;
        v21 &= v10;
        if ( v5 >= v13 )
        {
          v7 = a2;
          v8 = v15;
          goto LABEL_20;
        }
      }
      v8 = v15;
    }
    sub_10010340(a1, (unsigned int)v8);
    result = v20;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002EDC0) --------------------------------------------------------
_WORD *__cdecl sub_1002EDC0(__int64 a1, int a2, signed int *a3, int *a4)
{
  int v4; // edi@1
  _WORD *result; // eax@2
  double v6; // st7@5
  unsigned int v7; // ecx@5
  double v8; // st6@6
  double v9; // st6@8
  unsigned int v10; // edi@11
  signed int *v11; // ebp@11
  unsigned int v12; // ebx@11
  unsigned int v13; // ebp@12
  double v14; // st7@14
  double v15; // st6@16
  int v16; // eax@26
  int v17; // eax@38
  unsigned int v18; // ebx@38
  int v19; // eax@47
  unsigned int v20; // ebx@47
  unsigned int v21; // ebp@48
  unsigned int v22; // ebx@57
  signed int *v23; // ebp@58
  signed int v24; // [sp+4h] [bp-40h]@0
  unsigned int v25; // [sp+18h] [bp-2Ch]@3
  int v26; // [sp+1Ch] [bp-28h]@21
  char v27; // [sp+20h] [bp-24h]@32
  int v28; // [sp+24h] [bp-20h]@31
  unsigned int v29; // [sp+28h] [bp-1Ch]@28
  unsigned int v30; // [sp+2Ch] [bp-18h]@11
  int v31; // [sp+30h] [bp-14h]@11
  __int64 v32; // [sp+34h] [bp-10h]@11
  double v33; // [sp+3Ch] [bp-8h]@4
  unsigned int v34; // [sp+50h] [bp+Ch]@6
  unsigned int v35; // [sp+50h] [bp+Ch]@11
  signed int *v36; // [sp+54h] [bp+10h]@11

  v4 = a2;
  if ( !a2 )
    return (_WORD *)(a2 + 1);
  result = sub_1002D770(v24, SHIDWORD(a1), (signed int *)&v25);
  if ( !result )
    return result;
  result = sub_10020030(a1, *a3, &v33);
  if ( !result )
    return result;
  v6 = sub_1001F900(v33);
  v7 = v25;
  v33 = v6;
  if ( v6 >= 0.0 )
  {
    v34 = v25;
    v9 = (double)v25;
    if ( v9 < v6 )
    {
      v6 = v9;
      v33 = v9;
    }
  }
  else
  {
    v34 = v25;
    v8 = v6 + (double)v25;
    v6 = 0.0;
    v33 = v8;
    if ( v8 >= 0.0 )
      v6 = v8;
    else
      v33 = 0.0;
  }
  v31 = (unsigned __int16)v34 | 0xC00;
  v10 = v4 - 1;
  v11 = a3 + 1;
  v36 = a3 + 1;
  v32 = (signed __int64)v6;
  v12 = v25 - (unsigned __int64)(signed __int64)v6;
  v30 = (signed __int64)v6;
  v35 = v10;
  if ( v10 )
  {
    if ( !sub_10020030(a1, *v11, &v33) )
      return 0;
    v14 = sub_1001F900(v33);
    v33 = v14;
    if ( v14 >= 0.0 )
    {
      v35 = v12;
      v15 = (double)v12;
      if ( v15 < v14 )
      {
        v14 = v15;
        v33 = v15;
      }
    }
    else
    {
      v14 = 0.0;
      v33 = 0.0;
    }
    v7 = v25;
    v31 = (unsigned __int16)v35 | 0xC00;
    --v10;
    v36 = v11 + 1;
    v32 = (signed __int64)v14;
    v12 = (signed __int64)v14;
    v13 = v12 + v30;
    v35 = v10;
  }
  else
  {
    v13 = v25;
  }
  if ( v12 == 1 )
  {
    if ( *(_DWORD *)(a1 + 16) == 120 )
    {
      if ( !sub_1002D810(v30, &v26, a1)
        || !(*(int (__cdecl **)(_DWORD, _DWORD, int, int *))(*(_DWORD *)(*(_DWORD *)HIDWORD(a1) + 4) + 16))(
              a1,
              HIDWORD(a1),
              v26,
              a4) )
      {
        return 0;
      }
LABEL_35:
      v10 = v35;
      goto LABEL_36;
    }
    goto LABEL_26;
  }
  if ( *(_DWORD *)(a1 + 16) != 120 || v12 )
  {
LABEL_26:
    v16 = sub_1002EAB0(a1, 0, 0);
    LODWORD(v32) = v16;
    if ( v16 )
    {
      *a4 = v16;
      if ( v12 )
      {
        v29 = v30;
        if ( v30 < v13 )
        {
          v31 = 0;
          while ( sub_1002D810(v29, &v26, a1)
               && sub_1002D810(v31, &v28, a1)
               && (*(int (__cdecl **)(_DWORD, _DWORD, int, char *))(*(_DWORD *)(*(_DWORD *)HIDWORD(a1) + 4) + 16))(
                    a1,
                    HIDWORD(a1),
                    v26,
                    &v27)
               && (*(int (__cdecl **)(_DWORD, _DWORD, int, char *))(*(_DWORD *)(*(_DWORD *)v32 + 4) + 20))(
                    a1,
                    v32,
                    v28,
                    &v27) )
          {
            ++v31;
            if ( ++v29 >= v13 )
              goto LABEL_35;
          }
          return 0;
        }
      }
LABEL_36:
      v7 = v25;
      goto LABEL_37;
    }
    return 0;
  }
LABEL_37:
  if ( v10 > v12 )
  {
    v17 = v10 - v12;
    v29 = v10 - v12;
    v18 = v7;
    if ( v7 > v13 )
    {
      while ( sub_1002D810(--v18, &v26, a1)
           && sub_1002D810(v18 + v29, &v28, a1)
           && (*(int (__cdecl **)(_DWORD, _DWORD, int, char *))(*(_DWORD *)(*(_DWORD *)HIDWORD(a1) + 4) + 16))(
                a1,
                HIDWORD(a1),
                v26,
                &v27)
           && (*(int (__cdecl **)(_DWORD, _DWORD, int, char *))(*(_DWORD *)(*(_DWORD *)HIDWORD(a1) + 4) + 20))(
                a1,
                HIDWORD(a1),
                v28,
                &v27) )
      {
        if ( v18 <= v13 )
        {
          v7 = v25;
          v10 = v35;
          v17 = v29;
          goto LABEL_45;
        }
      }
      return 0;
    }
LABEL_45:
    v7 += v17;
    goto LABEL_56;
  }
  if ( v10 < v12 )
  {
    v19 = v12 - v10;
    v29 = v12 - v10;
    v20 = v13;
    if ( v13 < v7 )
    {
      v21 = v13 - v19;
      while ( sub_1002D810(v20, &v26, a1)
           && sub_1002D810(v21, &v28, a1)
           && (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)HIDWORD(a1) + 4) + 16))(
                a1,
                HIDWORD(a1),
                v26,
                &v27)
           && (*(int (__cdecl **)(_DWORD, _DWORD, int, char *))(*(_DWORD *)(*(_DWORD *)HIDWORD(a1) + 4) + 20))(
                a1,
                HIDWORD(a1),
                v28,
                &v27) )
      {
        v7 = v25;
        ++v20;
        ++v21;
        if ( v20 >= v25 )
        {
          v10 = v35;
          v19 = v29;
          goto LABEL_55;
        }
      }
      return 0;
    }
LABEL_55:
    v7 -= v19;
LABEL_56:
    v25 = v7;
  }
  v22 = 0;
  if ( v10 )
  {
    v23 = v36;
    while ( sub_1002D810(v22 + v30, &v26, a1)
         && (*(int (__cdecl **)(_DWORD, _DWORD, int, signed int *))(*(_DWORD *)(*(_DWORD *)HIDWORD(a1) + 4) + 20))(
              a1,
              HIDWORD(a1),
              v26,
              v23) )
    {
      ++v22;
      ++v23;
      if ( v22 >= v35 )
      {
        v7 = v25;
        return (_WORD *)sub_1002D870(a1, SHIDWORD(a1), v7);
      }
    }
    return 0;
  }
  return (_WORD *)sub_1002D870(a1, SHIDWORD(a1), v7);
}

//----- (1002F270) --------------------------------------------------------
signed int __cdecl sub_1002F270(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  unsigned int v5; // ebx@1
  int v6; // eax@1
  unsigned int v8; // eax@5
  unsigned int v9; // ebp@5
  unsigned int v10; // eax@9
  unsigned int v11; // ebx@9
  unsigned int v12; // [sp+8h] [bp-1Ch]@3
  int v13; // [sp+Ch] [bp-18h]@4
  int v14; // [sp+10h] [bp-14h]@10
  unsigned int v15; // [sp+14h] [bp-10h]@8
  int v16; // [sp+18h] [bp-Ch]@1
  unsigned int v17; // [sp+1Ch] [bp-8h]@3
  int v18; // [sp+20h] [bp-4h]@11
  int v19; // [sp+34h] [bp+10h]@1

  v19 = a4 - 4;
  v5 = 0;
  v6 = sub_1002EAB0(a1, 0, 0);
  v16 = v6;
  if ( !v6 )
    return 0;
  *a5 = v6;
  v12 = 0;
  v17 = 0;
  while ( 1 )
  {
    v13 = *(_DWORD *)(v19 + 4 * v5);
    if ( !(v13 & 7) )
    {
      v8 = v13 & 0xFFFFFFF8;
      v9 = v13 & 0xFFFFFFF8;
      if ( v13 & 0xFFFFFFF8 )
      {
        if ( (char **)(*(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) & 0xFFFFFFFE) == &off_10162958 )
          break;
      }
    }
    if ( !sub_1002D810(v12, &v14, a1)
      || !(*(int (__cdecl **)(int, int, int, int *))(*(_DWORD *)(*(_DWORD *)v16 + 4) + 20))(a1, v16, v14, &v13) )
    {
      return 0;
    }
    ++v12;
LABEL_19:
    v17 = ++v5;
    if ( v5 > a3 )
      return 1;
  }
  if ( !(*(int (__cdecl **)(int, unsigned int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)v8 + 4) + 16))(
          a1,
          v8,
          *(_DWORD *)(*(_DWORD *)(a1 + 24) + 264),
          &v13)
    || !sub_1002D6C0(v13, &v15, a1) )
  {
    return 0;
  }
  v10 = v15;
  v11 = 0;
  if ( !v15 )
  {
LABEL_15:
    v12 += v10;
    v5 = v17;
    goto LABEL_19;
  }
  while ( sub_1002D810(v11, &v14, a1)
       && sub_1002D810(v11 + v12, &v18, a1)
       && (*(int (__cdecl **)(int, unsigned int, int, int *))(*(_DWORD *)(*(_DWORD *)v9 + 4) + 16))(a1, v9, v14, &v13)
       && (*(int (__cdecl **)(int, int, int, int *))(*(_DWORD *)(*(_DWORD *)v16 + 4) + 20))(a1, v16, v18, &v13) )
  {
    v10 = v15;
    if ( ++v11 >= v15 )
      goto LABEL_15;
  }
  return 0;
}
// 10162958: using guessed type char *off_10162958;

//----- (1002F420) --------------------------------------------------------
signed int __cdecl sub_1002F420(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  unsigned int v6; // ebx@4
  double v7; // st7@6
  double v8; // st6@7
  double v9; // st6@9
  double v10; // st7@14
  double v11; // st6@15
  double v12; // st6@17
  unsigned __int16 v13; // [sp+20h] [bp-28h]@0
  unsigned int v14; // [sp+20h] [bp-28h]@22
  unsigned int v15; // [sp+24h] [bp-24h]@3
  unsigned int v16; // [sp+28h] [bp-20h]@4
  int v17; // [sp+2Ch] [bp-1Ch]@1
  int v18; // [sp+30h] [bp-18h]@12
  char v19; // [sp+34h] [bp-14h]@25
  __int64 v20; // [sp+38h] [bp-10h]@12
  double v21; // [sp+40h] [bp-8h]@5

  v17 = sub_1002EAB0(a1, 0, 0);
  if ( !v17 || !sub_1002D770(a1, a2, (signed int *)&v15) )
    return 0;
  v6 = 0;
  v16 = v15;
  if ( !a3 )
    goto LABEL_21;
  if ( !sub_10020030(a1, *(_DWORD *)a4, &v21) )
    return 0;
  v7 = sub_1001F900(v21);
  v21 = v7;
  if ( v7 >= 0.0 )
  {
    v9 = (double)v15;
    if ( v9 < v7 )
    {
      v7 = v9;
      v21 = v9;
    }
  }
  else
  {
    v8 = v7 + (double)v15;
    v7 = 0.0;
    v21 = v8;
    if ( v8 >= 0.0 )
      v7 = v8;
    else
      v21 = 0.0;
  }
  v18 = v13 | 0xC00;
  v20 = (signed __int64)v7;
  v6 = (signed __int64)v7;
  if ( a3 > 1 )
  {
    if ( sub_10020030(a1, *(_DWORD *)(a4 + 4), &v21) )
    {
      v10 = sub_1001F900(v21);
      v21 = v10;
      if ( v10 >= 0.0 )
      {
        v12 = (double)v15;
        if ( v12 < v10 )
        {
          v10 = v12;
          v21 = v12;
        }
      }
      else
      {
        v11 = v10 + (double)v15;
        v10 = 0.0;
        v21 = v11;
        if ( v11 >= 0.0 )
          v10 = v11;
        else
          v21 = 0.0;
      }
      v18 = v13 | 0xC00;
      v20 = (signed __int64)v10;
      v16 = (signed __int64)v10;
      goto LABEL_21;
    }
    return 0;
  }
LABEL_21:
  if ( v6 < v16 )
  {
    v14 = 0;
    while ( sub_1002D810(v6, &v18, a1)
         && sub_1002D810(v14, &v20, a1)
         && (*(int (__cdecl **)(int, int, int, char *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 16))(a1, a2, v18, &v19)
         && (*(int (__cdecl **)(int, int, _DWORD, char *))(*(_DWORD *)(*(_DWORD *)v17 + 4) + 20))(a1, v17, v20, &v19) )
    {
      ++v14;
      if ( ++v6 >= v16 )
        goto LABEL_28;
    }
    return 0;
  }
LABEL_28:
  *a5 = v17;
  return 1;
}

//----- (1002F6A0) --------------------------------------------------------
int sub_1002F6A0()
{
  return -unknown_libname_3();
}
// 1000A800: using guessed type int unknown_libname_3(void);

//----- (1002F6B0) --------------------------------------------------------
__int64 sub_1002F6B0()
{
  __int64 v1; // [sp+0h] [bp-8h]@1

  sub_1000A7A0(&v1);
  return v1;
}

//----- (1002F6D0) --------------------------------------------------------
__int64 sub_1002F6D0()
{
  return 0i64;
}

//----- (1002F6E0) --------------------------------------------------------
void *__cdecl sub_1002F6E0(int a1)
{
  void *result; // eax@1
  int v2; // esi@1

  result = (void *)a1;
  v2 = *(_DWORD *)(a1 + 24) + 588;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 24) + 8780) )
  {
    result = memset((void *)v2, 0, 0x2000u);
    *(_DWORD *)(v2 + 0x2000) = 1;
  }
  return result;
}

//----- (1002F720) --------------------------------------------------------
int __cdecl sub_1002F720(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8784) = 1;
  return result;
}

//----- (1002F740) --------------------------------------------------------
int __cdecl sub_1002F740(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8784) = 0;
  return result;
}

//----- (1002F760) --------------------------------------------------------
int __cdecl sub_1002F760(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int result; // eax@5

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 4);
  a2 = *(_DWORD *)(v3 + 12);
  v4 = *(_DWORD *)(v3 + 4);
  if ( a2 && !(v4 & 7) && v4 )
    (*(void (__cdecl **)(int, unsigned int, signed int, int *, _DWORD))(*(_DWORD *)(*(_DWORD *)(v4 & 0xFFFFFFF8) + 4)
                                                                      + 40))(
      a1,
      v4 & 0xFFFFFFF8,
      2,
      &a2,
      0);
  sub_1003A860(*(_DWORD *)(a1 + 24), *(_DWORD *)(v2 + 4) + 4);
  result = *(_DWORD *)(a1 + 24);
  ++*(_DWORD *)(result + 88);
  return result;
}

//----- (1002F7C0) --------------------------------------------------------
int __cdecl sub_1002F7C0(int a1, int a2, _DWORD *a3)
{
  int v3; // ecx@3
  int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@7
  int v7; // eax@8
  const char *v8; // eax@9

  if ( a3 )
    *a3 = *(_DWORD *)(*(_DWORD *)(a1 + 44) + 12);
  v3 = *(_DWORD *)(a1 + 44);
  v4 = *(_DWORD *)(v3 + 12);
  v5 = (4 * a2 + 3) & 0xFFFFFFFC;
  if ( v4 + v5 <= *(_DWORD *)(v3 + 8) )
    *(_DWORD *)(v3 + 12) = v4 + v5;
  else
    v4 = sub_1003E2D0(a1 + 28, v5);
  if ( !v4 )
  {
    v6 = *(_DWORD *)(a1 + 56);
    if ( v6 && (v7 = *(_DWORD *)(v6 + 16)) != 0 )
      LOBYTE(v8) = (unsigned int)sub_10011BC0(v7);
    else
      v8 = "script";
    sub_100110F0(a1, (int)sub_1003ED50, 0, 24, (char)v8);
  }
  return v4;
}

//----- (1002F840) --------------------------------------------------------
_DWORD *__cdecl sub_1002F840(int a1, int a2)
{
  _DWORD *result; // eax@1

  result = *(_DWORD **)(a1 + 44);
  if ( result == (_DWORD *)(a1 + 28) || a2 - result[1] > (unsigned int)(result[3] - result[1]) )
    result = sub_1003E5E0(a1 + 28, a2);
  else
    result[3] = (a2 + 3) & 0xFFFFFFFC;
  return result;
}

//----- (1002F880) --------------------------------------------------------
int __cdecl sub_1002F880(int a1, int a2, _DWORD *a3)
{
  int result; // eax@2
  int v4; // edx@3
  _DWORD *v5; // eax@4
  int v6; // ecx@4
  int v7; // eax@7
  int v8; // edi@8
  int v9; // ecx@9
  unsigned int v10; // ecx@10
  void *v11; // edi@10

  if ( a2 )
  {
    result = sub_1002F7C0(a1, a2 + 2, a3);
    v4 = result;
    if ( result )
    {
      v5 = *(_DWORD **)(a1 + 312);
      v6 = *(_DWORD *)(a1 + 44);
      if ( v5 && &v5[*v5 + 2] == (_DWORD *)v4 )
      {
        *v5 += a2;
        *(_DWORD *)(v6 + 12) -= 8;
        result = v4;
      }
      else
      {
        v7 = *(_DWORD *)(a1 + 56);
        if ( v7 )
        {
          v8 = *(_DWORD *)(v7 + 12);
          if ( v8 )
          {
            v9 = *(_DWORD *)(v7 + 64);
            if ( v9 )
            {
              v10 = v9 + 4 * *(_DWORD *)(v8 + 32);
              v11 = *(void **)(v7 + 60);
              if ( (unsigned int)v11 < v10 )
                memset32(v11, -2147483647, ((v10 - (unsigned int)v11 - 1) >> 2) + 1);
            }
          }
        }
        *(_DWORD *)v4 = a2;
        *(_DWORD *)(v4 + 4) = *(_DWORD *)(a1 + 312);
        *(_DWORD *)(a1 + 312) = v4;
        result = v4 + 8;
      }
    }
  }
  else
  {
    *a3 = 0;
    result = *(_DWORD *)(*(_DWORD *)(a1 + 44) + 12);
  }
  return result;
}

//----- (1002F930) --------------------------------------------------------
void __cdecl sub_1002F930(int a1, int a2)
{
  int v2; // ecx@2
  unsigned int v3; // eax@2
  int v4; // eax@5

  if ( a2 )
  {
    v2 = *(_DWORD *)(a1 + 312);
    v3 = (unsigned int)(a2 - v2 - 8) >> 2;
    if ( v3 >= *(_DWORD *)v2 )
      *(_DWORD *)(a1 + 312) = *(_DWORD *)(v2 + 4);
    else
      *(_DWORD *)v2 = v3;
    v4 = *(_DWORD *)(a1 + 44);
    if ( v4 == a1 + 28 || a2 - *(_DWORD *)(v4 + 4) > (unsigned int)(*(_DWORD *)(v4 + 12) - *(_DWORD *)(v4 + 4)) )
      sub_1003E5E0(a1 + 28, a2);
    else
      *(_DWORD *)(v4 + 12) = (a2 + 3) & 0xFFFFFFFC;
  }
}

//----- (1002F9A0) --------------------------------------------------------
int __usercall sub_1002F9A0@<eax>(signed int a1@<eax>, unsigned int a2@<edx>, signed int (*a3)()@<ecx>, int a4, int a5)
{
  unsigned int v5; // esi@1
  signed int v6; // edx@1
  int v7; // eax@1
  signed int (*v8)(); // ebx@1
  unsigned int v9; // edi@2
  unsigned int v10; // ecx@3
  int v11; // eax@5
  int result; // eax@9
  int v13; // ecx@10
  unsigned int v14; // eax@10
  int v15; // esi@10
  int v16; // edx@13
  _WORD *v17; // eax@14
  int v18; // eax@20
  unsigned int *v19; // eax@26

  v5 = a2;
  v6 = a1 >> 1;
  v7 = *(_DWORD *)(v5 + 4);
  v8 = a3;
  if ( (char **)(*(_DWORD *)(v7 + 8) & 0xFFFFFFFE) == &off_101621B8 )
  {
    v18 = *(_DWORD *)(*(_DWORD *)v5 + 36);
    if ( v18 )
    {
      while ( *(signed int (**)())(v18 + 8) != a3 || *(_WORD *)(v18 + 18) != v6 )
      {
        v18 = *(_DWORD *)(v18 + 20);
        if ( !v18 )
          return 1;
      }
      if ( *(_BYTE *)(v18 + 16) & 0x40 )
      {
        v19 = sub_1003A470(a4, *(_DWORD *)v5, v18, 0, -65, *(signed int (**)())(v18 + 4), a3);
        if ( !v19 )
          return 0;
        *(_BYTE *)(*(_DWORD *)(a4 + 24) + 96) = 1;
        *(_DWORD *)(*(_DWORD *)(v5 + 4) + 4 * v19[3]) = a5;
      }
    }
    result = 1;
  }
  else
  {
    v9 = v5;
    do
    {
      v10 = *(_DWORD *)v7 & 0xFFFFFFF8;
      if ( !v10 )
        return 1;
      v7 = *(_DWORD *)(v10 + 4);
    }
    while ( (char **)(*(_DWORD *)(v7 + 8) & 0xFFFFFFFE) != &off_101621B8 );
    v11 = *(_DWORD *)(*(_DWORD *)v10 + 36);
    if ( !v11 )
      return 1;
    while ( *(signed int (**)())(v11 + 8) != v8 || *(_WORD *)(v11 + 18) != v6 )
    {
      v11 = *(_DWORD *)(v11 + 20);
      if ( !v11 )
        return 1;
    }
    v13 = *(_DWORD *)(*(_DWORD *)v11 + 8) & 0xFFFFFFF8;
    v14 = *(_DWORD *)v13;
    v15 = *(_DWORD *)v13;
    if ( *(_DWORD *)v13 & 0x40000000 )
      v15 = v14 & ((v15 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    if ( *(_DWORD *)v13 & 0x40000000 )
    {
      v16 = *(_DWORD *)(v13 + 4);
      if ( *(_DWORD *)v16 & 0x40000000 )
      {
        v17 = (_WORD *)sub_1001A200(v13);
      }
      else if ( (v14 & 0x80000000) == 0 )
      {
        v17 = (_WORD *)(*(_DWORD *)(v16 + 4) + 2 * ((v14 >> 15) & 0x7FFF));
      }
      else
      {
        v17 = *(_WORD **)(v16 + 4);
      }
    }
    else
    {
      v17 = *(_WORD **)(v13 + 4);
    }
    result = sub_100109C0(a4, v9, v17, v15, a5, 0, 0, 1);
  }
  return result;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (1002FB00) --------------------------------------------------------
signed int sub_1002FB00()
{
  return 1;
}

//----- (1002FB20) --------------------------------------------------------
int __cdecl sub_1002FB20(int a1, unsigned int a2, signed int a3, int *a4)
{
  return sub_1002F9A0(a3, a2, (signed int (*)())sub_1002FB20, a1, *a4);
}

//----- (1002FB50) --------------------------------------------------------
int __cdecl sub_1002FB50(int a1, unsigned int a2, signed int a3, int *a4)
{
  return sub_1002F9A0(a3, a2, (signed int (*)())sub_1002FB50, a1, *a4);
}

//----- (1002FB80) --------------------------------------------------------
signed int sub_1002FB80()
{
  return 1;
}

//----- (1002FBA0) --------------------------------------------------------
unsigned int __usercall sub_1002FBA0@<eax>(unsigned int result@<eax>, int a2@<edx>, int a3@<esi>)
{
  int (__cdecl *v3)(int, unsigned int); // ecx@3
  int v4; // edx@7
  int v5; // eax@8
  unsigned int v6; // ecx@11
  unsigned int v7; // eax@12
  int v8; // edx@13
  int v9; // edx@15

  if ( !result || (char **)(*(_DWORD *)(*(_DWORD *)(result + 4) + 8) & 0xFFFFFFFE) == &off_10162110 )
  {
    v5 = *(_DWORD *)(*(_DWORD *)(a3 + 28) - 8);
    if ( !(v5 & 7) && v5 && (result = *(_DWORD *)(*(_DWORD *)((v5 & 0xFFFFFFF8) + 4) + 4) & 0xFFFFFFF8) != 0 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(result + 4) + 4) & 0xFFFFFFF8;
      if ( v6 )
      {
        do
        {
          v7 = v6;
          v6 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4) & 0xFFFFFFF8;
        }
        while ( v6 );
        v8 = *(_DWORD *)(a3 + 28);
        *(_DWORD *)(a3 + 20) = v7;
        *(_DWORD *)(v8 - 4) = v7;
        return 1;
      }
    }
    else
    {
      result = *(_DWORD *)(a2 + 88);
    }
LABEL_15:
    v9 = *(_DWORD *)(a3 + 28);
    *(_DWORD *)(a3 + 20) = result;
    *(_DWORD *)(v9 - 4) = result;
    return 1;
  }
  v3 = *(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(*(_DWORD *)result + 4) + 48);
  if ( v3 )
    result = v3(a2, result);
  if ( result )
  {
    if ( *(_BYTE *)(a3 + 76) & 1 )
    {
      v4 = *(_DWORD *)(a3 + 28);
      *(_DWORD *)(a3 + 32) = result;
      *(_DWORD *)(a3 + 20) = result;
      *(_DWORD *)(v4 - 4) = result;
      return 1;
    }
    goto LABEL_15;
  }
  return result;
}
// 10162110: using guessed type char *off_10162110;

//----- (1002FC40) --------------------------------------------------------
int __cdecl sub_1002FC40(int a1, unsigned int a2, int a3)
{
  int v3; // esi@1
  char *v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // eax@1
  unsigned int v7; // ecx@1
  int (__cdecl *v8)(int, unsigned int, int, int *); // edx@6
  int v9; // ST10_4@6
  int v10; // esi@9
  int v11; // eax@9
  unsigned __int16 v12; // cx@11
  int v13; // esi@11
  int v14; // eax@14
  int v15; // eax@15
  int v16; // eax@20
  int v17; // edx@20
  int v18; // eax@21
  int v19; // ecx@21
  unsigned int v20; // esi@21
  unsigned int v21; // ecx@21
  int v22; // esi@22
  int v23; // edx@24
  unsigned int v24; // eax@32
  int v25; // edi@32
  int v26; // edx@32
  unsigned int v27; // edi@32
  int v28; // ecx@32
  bool v29; // zf@32
  int v30; // eax@35
  unsigned int v31; // edi@36
  int v32; // eax@38
  int v33; // eax@47
  _DWORD *v34; // esi@47
  _DWORD *v35; // eax@50
  _DWORD *v36; // esi@50
  void *v37; // esi@50
  int v38; // edi@53
  int v39; // esi@55
  int v40; // eax@57
  int v41; // esi@61
  int (__cdecl *v42)(int, unsigned int, unsigned int, void *, int *); // esi@63
  int v43; // eax@68
  void (__cdecl *v44)(int, int *, _DWORD, int *, unsigned int); // eax@76
  int v45; // eax@79
  int v46; // eax@81
  int v47; // eax@84
  int v48; // eax@88
  int v49; // ecx@88
  int v51; // [sp+10h] [bp-84h]@5
  int v52; // [sp+14h] [bp-80h]@1
  unsigned int v53; // [sp+18h] [bp-7Ch]@1
  int v54; // [sp+1Ch] [bp-78h]@1
  int *v55; // [sp+20h] [bp-74h]@11
  int (__cdecl *v56)(int, unsigned int, unsigned int, void *, int *); // [sp+24h] [bp-70h]@32
  int v57; // [sp+28h] [bp-6Ch]@32
  _DWORD *v58; // [sp+2Ch] [bp-68h]@1
  int v59; // [sp+30h] [bp-64h]@1
  int v60; // [sp+34h] [bp-60h]@21
  int v61; // [sp+38h] [bp-5Ch]@5
  int v62; // [sp+3Ch] [bp-58h]@34
  int v63; // [sp+40h] [bp-54h]@34
  int v64; // [sp+44h] [bp-50h]@34
  int *v65; // [sp+48h] [bp-4Ch]@34
  unsigned int v66; // [sp+4Ch] [bp-48h]@6
  unsigned int v67; // [sp+50h] [bp-44h]@34
  void *v68; // [sp+54h] [bp-40h]@5
  int v69; // [sp+58h] [bp-3Ch]@1
  int v70; // [sp+5Ch] [bp-38h]@34
  unsigned int v71; // [sp+60h] [bp-34h]@34
  int v72; // [sp+64h] [bp-30h]@34
  int v73; // [sp+68h] [bp-2Ch]@34
  int v74; // [sp+6Ch] [bp-28h]@34
  int v75; // [sp+70h] [bp-24h]@34
  char *v76; // [sp+74h] [bp-20h]@63
  int v77; // [sp+78h] [bp-1Ch]@34
  int v78; // [sp+7Ch] [bp-18h]@34
  int v79; // [sp+80h] [bp-14h]@34
  int v80; // [sp+84h] [bp-10h]@1
  int v81; // [sp+88h] [bp-Ch]@34
  int v82; // [sp+8Ch] [bp-8h]@34
  int (__cdecl *v83)(int, int *, signed int, _DWORD, _DWORD); // [sp+90h] [bp-4h]@35

  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(char **)(v3 + 60);
  v5 = *(_DWORD *)(v3 + 60) - (4 * a2 + 8);
  v6 = *(_DWORD *)v5;
  v59 = *(_DWORD *)(*(_DWORD *)(a1 + 44) + 12);
  v52 = v6;
  v69 = -2147483647;
  v80 = a3;
  v7 = *(_DWORD *)(v5 + 4) & 0xFFFFFFF8;
  v54 = v3;
  v58 = (_DWORD *)v5;
  v53 = v7;
  if ( !(v6 & 7) && v6 )
    goto LABEL_21;
  if ( !*(_DWORD *)(v3 + 12) || a3 & 2 )
    goto LABEL_44;
  v68 = (void *)(v5 + 8);
  v51 = sub_1002FBA0(v7, a1, (int)&v61);
  if ( v51 )
  {
    v8 = *(int (__cdecl **)(int, unsigned int, int, int *))(*(_DWORD *)(*(_DWORD *)v66 + 4) + 16);
    v9 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 272);
    v53 = v66;
    v51 = v8(a1, v66, v9, &v52);
    if ( v51 )
    {
      if ( v52 & 7 )
        goto LABEL_44;
      if ( !v52 )
        goto LABEL_44;
      v10 = *(_DWORD *)(v54 + 12);
      v11 = *(_DWORD *)(v5 - 4 * *(_DWORD *)(v10 + 32));
      if ( *(_BYTE *)v11 != 53 && *(_BYTE *)v11 != 59 )
        goto LABEL_44;
      HIBYTE(v12) = *(_BYTE *)(v11 + 1);
      LOBYTE(v12) = *(_BYTE *)(v11 + 2);
      v55 = sub_10038D40(a1, v10 + 16, v12);
      v13 = sub_1002EAB0(a1, a2, v5 + 8);
      if ( !v13 )
      {
        v51 = 0;
        goto LABEL_84;
      }
      v4 = (char *)(v5 + 16);
      if ( a2 < 2 )
      {
        v14 = *(_DWORD *)(a1 + 44);
        if ( (unsigned int)v4 <= *(_DWORD *)(v14 + 8) )
        {
          if ( (unsigned int)v4 > *(_DWORD *)(v14 + 12) )
            *(_DWORD *)(v14 + 12) = v4;
        }
        else
        {
          v15 = sub_1002F7C0(a1, 4, 0);
          if ( !v15 )
          {
            v51 = 0;
            goto LABEL_84;
          }
          *(_DWORD *)(v15 + 4) = v53;
          v4 = (char *)(v15 + 16);
        }
      }
      v16 = (int)v55;
      *((_DWORD *)v4 - 4) = v52;
      v17 = v54;
      *((_DWORD *)v4 - 2) = *(_DWORD *)(v16 + 8);
      *((_DWORD *)v4 - 1) = v13;
      *(_DWORD *)(v17 + 60) = v4;
      v6 = v52;
      a2 = 2;
LABEL_21:
      v18 = v6 & 0xFFFFFFF8;
      v19 = *(_DWORD *)(v18 + 4);
      v20 = *(_DWORD *)(v19 + 4) & 0xFFFFFFF8;
      v21 = *(_DWORD *)(v19 + 8) & 0xFFFFFFFE;
      v60 = v20;
      if ( (char **)v21 == &off_101621B8 )
        goto LABEL_32;
      v22 = *(_DWORD *)(*(_DWORD *)v18 + 4);
      if ( *(_DWORD *)(a1 + 16) == 120
        || ((int (__cdecl **)(int, int, int, int, int))v22 != &off_101614B0 ? (v23 = *(_DWORD *)(v22 + 56)) : (v23 = *(_DWORD *)(v21 + 48)),
            v23) )
      {
        v51 = (*(int (__cdecl **)(int, int, signed int, int *))(v21 + 32))(a1, v18, 2, &v52);
        if ( !v51 )
          goto LABEL_84;
        if ( !(v52 & 7)
          && v52 & 0xFFFFFFF8
          && (char **)(*(_DWORD *)(*(_DWORD *)((v52 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) == &off_101621B8 )
        {
          *(_DWORD *)v5 = v52;
          v18 = v52 & 0xFFFFFFF8;
          v60 = *(_DWORD *)(*(_DWORD *)((v52 & 0xFFFFFFF8) + 4) + 4) & 0xFFFFFFF8;
          v20 = v60;
LABEL_32:
          v24 = sub_10010550(a1, v18);
          v25 = *(_WORD *)(v24 + 18);
          v26 = *(_DWORD *)(v24 + 12);
          v56 = *(int (__cdecl **)(int, unsigned int, unsigned int, void *, int *))(v24 + 8);
          v27 = *(_WORD *)(v24 + 16) + v25;
          v28 = *(_WORD *)(v24 + 20);
          v29 = (*(_BYTE *)(v24 + 22) & 0x40) == 0;
          v55 = (int *)v24;
          v57 = v26;
          if ( !v29 )
            v53 = v20;
LABEL_34:
          v64 = v57;
          v65 = v55;
          v67 = a2;
          v70 = v28;
          v63 = 0;
          v62 = 0;
          v61 = 0;
          v68 = &v4[-4 * a2];
          v73 = 0;
          v74 = 0;
          v75 = 0;
          v77 = 0;
          v78 = 0;
          v79 = 0;
          v81 = 0;
          v82 = 0;
          v71 = (unsigned int)v4;
          v72 = v54;
          v51 = sub_1002FBA0(v53, a1, (int)&v61);
          if ( !v51 )
          {
LABEL_83:
            v5 = (unsigned int)v58;
            goto LABEL_84;
          }
          v30 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 56) = &v61;
          v83 = *(int (__cdecl **)(int, int *, signed int, _DWORD, _DWORD))(v30 + 540);
          v53 = 0;
          if ( a2 < v27 )
          {
            v31 = v27 - a2;
            if ( v31 )
            {
              if ( (unsigned int)&v4[4 * v31] <= *(_DWORD *)(*(_DWORD *)(a1 + 44) + 8) )
                v32 = v31 - ((v59 - (signed int)v4) >> 2);
              else
                v32 = v31 + a2 + 2;
              if ( v32 > 0 )
              {
                v33 = sub_1002F7C0(a1, v32, 0);
                v34 = (_DWORD *)v33;
                if ( !v33 )
                {
                  v51 = 0;
LABEL_78:
                  if ( v61 )
                  {
                    v45 = sub_10028680(a1, (unsigned int *)&v61);
                    v51 &= v45;
                  }
                  if ( v62 )
                  {
                    v46 = sub_10028590(a1, (int)&v61);
                    v51 &= v46;
                  }
                  *(_DWORD *)(a1 + 56) = v54;
                  goto LABEL_83;
                }
                if ( v33 != v59 )
                {
                  v35 = v58;
                  *v34 = *v58;
                  v36 = v34 + 1;
                  *v36 = v35[1];
                  v37 = v36 + 1;
                  if ( a2 )
                    memcpy(v37, v68, 4 * a2);
                  v68 = v37;
                  v71 = (unsigned int)v37 + 4 * a2;
                  v4 = (char *)v37 + 4 * a2;
                }
              }
              v71 += 4 * v31;
              v38 = v31 - 1;
              if ( v38 >= 0 )
              {
                memset32(v4, -2147483647, v38 + 1);
                v4 += 4 * (v38 + 1);
              }
            }
          }
          v39 = v70;
          if ( v70 )
          {
            if ( (signed int)(*(_DWORD *)(*(_DWORD *)(a1 + 44) + 12) - v71) >> 2 < v70 )
            {
              v40 = sub_1002F7C0(a1, v70, 0);
              if ( !v40 )
              {
                v51 = 0;
                goto LABEL_78;
              }
              if ( (char *)v40 != v4 )
              {
                v71 = v40;
                v4 = (char *)v40;
              }
            }
            v41 = v39 - 1;
            if ( v41 >= 0 )
            {
              memset32(v4, -2147483647, v41 + 1);
              v4 += 4 * (v41 + 1);
            }
          }
          v42 = v56;
          v76 = v4;
          if ( v83 )
          {
            if ( !v56 && !v57 )
              goto LABEL_74;
            v53 = v83(a1, &v61, 1, 0, *(_DWORD *)(*(_DWORD *)(a1 + 24) + 544));
          }
          if ( v42 )
          {
            v43 = v54;
            *(_BYTE *)(a1 + 292) = 0;
            v63 = *(_DWORD *)(v43 + 8);
            v74 = *(_DWORD *)(v43 + 52);
            v51 = v42(a1, v66, a2, v68, &v69);
            goto LABEL_75;
          }
          if ( v57 )
          {
            v74 = v60;
            if ( !(*((_BYTE *)v55 + 22) & 0x80) || sub_10027630(a1, (int)&v61, v60) )
              v51 = sub_100305F0(a1, &v52);
            else
              v51 = 0;
LABEL_75:
            if ( v53 )
            {
              v44 = *(void (__cdecl **)(int, int *, _DWORD, int *, unsigned int))(*(_DWORD *)(a1 + 24) + 540);
              if ( v44 )
                v44(a1, &v61, 0, &v51, v53);
            }
            goto LABEL_78;
          }
LABEL_74:
          v74 = 0;
          v51 = 1;
          goto LABEL_75;
        }
      }
      v28 = 0;
      v27 = 0;
      v55 = 0;
      v57 = 0;
      if ( a3 & 1 )
        v56 = *(int (__cdecl **)(int, unsigned int, unsigned int, void *, int *))(v22 + 60);
      else
        v56 = *(int (__cdecl **)(int, unsigned int, unsigned int, void *, int *))(v22 + 56);
      if ( v56 )
        goto LABEL_34;
      v5 = (unsigned int)v58;
LABEL_44:
      sub_100284B0(a1, (int *)v5, a3 & 1);
      v51 = 0;
      goto LABEL_84;
    }
  }
LABEL_84:
  v47 = *(_DWORD *)(a1 + 44);
  if ( v47 == a1 + 28 || v59 - *(_DWORD *)(v47 + 4) > (unsigned int)(*(_DWORD *)(v47 + 12) - *(_DWORD *)(v47 + 4)) )
    sub_1003E5E0(a1 + 28, v59);
  else
    *(_DWORD *)(v47 + 12) = (v59 + 3) & 0xFFFFFFFC;
  v48 = v54;
  *(_DWORD *)v5 = v69;
  *(_DWORD *)(v48 + 60) = v5 + 4;
  v49 = *(_DWORD *)(v48 + 12);
  if ( v49 && !(a3 & 2) )
    *(_DWORD *)(v5 - 4 * *(_DWORD *)(v49 + 32)) = *(_DWORD *)(v48 + 56);
  return v51;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);
// 101621B8: using guessed type char *off_101621B8;

//----- (100302A0) --------------------------------------------------------
int __cdecl sub_100302A0(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  int v7; // ebx@1
  char *v8; // ebp@1
  char *v9; // edi@1
  unsigned int v10; // esi@3
  int *v11; // eax@3
  int v12; // esi@4
  int *v13; // eax@5
  _DWORD *v14; // eax@5
  unsigned int v15; // ecx@5
  int v16; // edx@6
  int result; // eax@12
  int v18; // [sp+10h] [bp-5Ch]@3
  char v19; // [sp+14h] [bp-58h]@2
  char *v20; // [sp+70h] [bp+4h]@1

  v7 = a1;
  v20 = *(char **)(a1 + 56);
  v8 = v20;
  v9 = v20;
  if ( !v20 )
  {
    memset(&v19, 0, 0x58u);
    v9 = &v19;
    *(_DWORD *)(v7 + 56) = &v19;
  }
  v10 = a5;
  v18 = *((_DWORD *)v9 + 15);
  v11 = (int *)sub_1002F880(v7, a5 + 2, &a5);
  if ( v11 )
  {
    *v11 = a3;
    v13 = v11 + 1;
    *v13 = a2;
    v14 = v13 + 1;
    v15 = 0;
    if ( v10 )
    {
      v16 = a6;
      do
      {
        *v14 = *(_DWORD *)(v16 + 4 * v15++);
        ++v14;
      }
      while ( v15 < v10 );
      v8 = v20;
    }
    *((_DWORD *)v9 + 15) = v14;
    v12 = sub_1002FC40(v7, v10, a4 | 2);
    if ( v12 )
      *a7 = *(_DWORD *)(*((_DWORD *)v9 + 15) - 4);
    sub_1002F930(v7, a5);
  }
  else
  {
    v12 = 0;
  }
  *((_DWORD *)v9 + 15) = v18;
  result = v12;
  if ( v8 != v9 )
    *(_DWORD *)(v7 + 56) = v8;
  return result;
}

//----- (10030390) --------------------------------------------------------
int __cdecl sub_10030390(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // ecx@2
  int v9; // eax@6
  int result; // eax@8

  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 24) + 8792) )
    goto LABEL_13;
  v8 = a4;
  if ( a4 & 7
    || !(a4 & 0xFFFFFFF8)
    || (char **)(*(_DWORD *)(*(_DWORD *)((a4 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8 )
  {
    goto LABEL_10;
  }
  if ( !*(_DWORD *)(sub_10010550(a1, a4 & 0xFFFFFFF8) + 12) )
    goto LABEL_13;
  v9 = a3;
  if ( !(a3 & 1) )
    v9 = *(_DWORD *)(a3 + 8);
  result = (*(int (__cdecl **)(int, int, int, int, int *))(*(_DWORD *)(a1 + 24) + 8792))(a1, a2, v9, a5, &a4);
  if ( result )
  {
LABEL_13:
    v8 = a4;
LABEL_10:
    result = sub_100302A0(a1, a2, v8, 0, a6, a7, (_DWORD *)a8);
  }
  return result;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (10030430) --------------------------------------------------------
int __cdecl sub_10030430(int a1, int a2, int a3, unsigned __int8 a4, _DWORD *a5)
{
  int v5; // ebp@1
  int v6; // esi@1
  int result; // eax@1
  int v8; // ecx@2
  bool v9; // zf@2
  int v10; // esi@4
  void (__cdecl *v11)(int, int, int); // eax@4
  unsigned __int8 v12; // al@7
  unsigned __int8 v13; // bl@7
  int v14; // ecx@7
  int v15; // esi@13
  const char *v16; // esi@22
  int v17; // [sp+Ch] [bp-10h]@1
  int v18; // [sp+10h] [bp-Ch]@1
  int v19; // [sp+14h] [bp-8h]@7
  int v20; // [sp+18h] [bp-4h]@14

  v5 = a2;
  v6 = a3;
  result = (*(int (__cdecl **)(int, int, int, int *, int *))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 8))(
             a1,
             a2,
             a3,
             &v17,
             &v18);
  if ( result )
  {
    v8 = v18;
    v9 = v18 == 0;
    *a5 = v18 != 0;
    if ( v9 )
      return v8 + 1;
    v10 = (*(int (__cdecl **)(int, int, int, int, int *))(*(_DWORD *)(*(_DWORD *)v17 + 4) + 24))(a1, v17, v6, v8, &a2);
    v11 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v17 + 4) + 52);
    if ( v11 )
      v11(a1, v17, v18);
    if ( !v10 )
      return 0;
    v12 = a2;
    v13 = a4;
    v14 = ((a4 | (unsigned __int8)a2) & 2) != 0 ? 0xFFFFFFFB : 0;
    v19 = v14 + 5;
    if ( v14 != -5 )
    {
      if ( !(a4 & 0x30) || !(~(a4 ^ (unsigned __int8)a2) & 0x30) || !(a2 & 4) )
        return 1;
      v19 = 0;
    }
    v15 = (a2 & 0x30) != 0;
    if ( !(a2 & 0x30) )
    {
      if ( !(*(int (__cdecl **)(int, int, int, int *))(*(_DWORD *)(*(_DWORD *)v5 + 4) + 16))(a1, v5, a3, &v20) )
        return 0;
      v15 = !(v20 & 7)
         && v20 & 0xFFFFFFF8
         && (char **)(*(_DWORD *)(*(_DWORD *)((v20 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) == &off_101621B8;
      v12 = a2;
    }
    if ( v13 & v12 & 0x10 )
    {
      v16 = "getter";
    }
    else if ( v13 & v12 & 0x20 )
    {
      v16 = "setter";
    }
    else if ( v12 & 2 )
    {
      v16 = "const";
    }
    else
    {
      v9 = v15 == 0;
      v16 = "function";
      if ( v9 )
        v16 = "var";
    }
    if ( !sub_10038330(a1, a3) )
      return 0;
    result = sub_10011140(a1, v19, (int)sub_1003ED50, 0, 155, (char)v16);
  }
  return result;
}
// 101621B8: using guessed type char *off_101621B8;

//----- (100305F0) --------------------------------------------------------
int __cdecl sub_100305F0(int a1, _DWORD *a2)
{
  unsigned int v2; // ebx@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // eax@1
  int (__cdecl *v6)(int, int); // ecx@3
  int v7; // eax@3
  unsigned int v8; // ecx@3
  int v9; // edi@3
  int v10; // eax@3
  int v11; // eax@5
  int *v12; // edi@6
  int v13; // ebx@10
  int v14; // esi@10
  int v15; // edx@12
  int (__cdecl *v16)(int, int, unsigned int, int *, _DWORD); // eax@12
  int v17; // eax@13
  int v18; // eax@14
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // edx@19
  int v22; // eax@22
  int v23; // edx@24
  int v24; // edi@26
  void (__cdecl *v25)(int, int, _DWORD, int *, _DWORD); // ecx@27
  int v26; // eax@30
  int v27; // eax@31
  int v28; // ecx@34
  _DWORD *v29; // esi@34
  int v30; // ebx@34
  int v31; // eax@34
  int v32; // edx@34
  char **v33; // ecx@34
  int v34; // eax@43
  int v35; // ecx@43
  _BYTE *v36; // ebx@43
  int v37; // eax@43
  int v38; // ecx@43
  _BYTE *v39; // eax@45
  int v40; // esi@46
  unsigned int v41; // ebx@46
  int v42; // edx@46
  int (__cdecl *v43)(_DWORD, int, unsigned int, int *, _DWORD); // ecx@46
  void **v44; // eax@47
  int v45; // eax@47
  int v46; // eax@48
  int v47; // eax@49
  int v48; // esi@53
  unsigned __int16 v49; // cx@55
  unsigned int v50; // esi@55
  int v51; // ebx@58
  unsigned int v52; // eax@58
  int v53; // ecx@62
  int v54; // eax@62
  int v55; // eax@62
  int v56; // esi@63
  char *v57; // ebx@63
  int v58; // ecx@63
  int v59; // edx@63
  int v60; // eax@63
  int v61; // edx@63
  int v62; // ecx@63
  int v63; // ecx@63
  int v64; // edx@63
  int v65; // edx@64
  int v66; // edx@66
  int v67; // eax@66
  int (__cdecl *v68)(int, int, signed int, _DWORD, _DWORD); // ecx@66
  int v69; // eax@67
  int v70; // eax@68
  int v71; // eax@71
  unsigned int v72; // ecx@71
  int v73; // eax@71
  int v74; // edx@76
  int v75; // esi@79
  void **v76; // eax@79
  int v77; // edx@80
  int v78; // eax@81
  int v79; // eax@84
  int v80; // edx@85
  __int16 v81; // dx@87
  int v82; // ecx@89
  int v83; // ST28_4@89
  int v84; // eax@89
  __int16 v85; // dx@98
  int (__cdecl *v86)(int, int); // eax@99
  int v87; // ecx@100
  __int16 v88; // ax@108
  int (__cdecl *v89)(int, int); // eax@109
  int v90; // ecx@110
  bool v91; // zf@117
  unsigned int v92; // eax@119
  int v93; // edx@119
  int v94; // ecx@119
  unsigned int v95; // eax@128
  unsigned __int16 v96; // cx@129
  int v97; // eax@131
  int v98; // ST28_4@131
  unsigned __int16 v99; // cx@138
  int (__cdecl *v100)(int, int); // eax@139
  int v101; // edx@140
  unsigned __int16 v102; // cx@147
  int (__cdecl *v103)(int, int); // eax@148
  int v104; // edx@149
  unsigned __int16 v105; // cx@156
  unsigned __int16 v106; // cx@163
  unsigned int v107; // eax@168
  int *v108; // ecx@168
  int v109; // esi@170
  int v110; // ST24_4@170
  int *v111; // eax@170
  void (__cdecl *v112)(int, unsigned int, int); // eax@175
  int v113; // esi@177
  unsigned __int16 v114; // dx@177
  signed int v115; // eax@177
  unsigned __int16 v116; // cx@178
  int *v117; // eax@178
  void (__cdecl *v118)(int, unsigned int, int); // eax@180
  int v119; // ecx@185
  char **v120; // eax@185
  int v121; // ecx@185
  int v122; // eax@187
  int v123; // eax@188
  int v124; // ebx@189
  unsigned int v125; // eax@191
  unsigned int v126; // eax@192
  unsigned int v127; // eax@194
  int v128; // ecx@199
  void (__cdecl *v129)(int, unsigned int, int); // eax@199
  int v130; // eax@202
  int v131; // eax@205
  int v132; // ebx@214
  int v133; // edx@219
  int v134; // ecx@219
  unsigned int v135; // ecx@226
  int v136; // eax@226
  int *v137; // edi@226
  unsigned int v138; // esi@227
  unsigned __int16 v139; // ax@227
  int *v140; // eax@227
  unsigned int v141; // esi@229
  int v142; // ebx@229
  unsigned __int16 v143; // ax@229
  int *v144; // eax@229
  int v145; // eax@229
  int v146; // esi@232
  unsigned __int16 v147; // cx@232
  int *v148; // eax@232
  int v149; // ecx@232
  int v150; // ecx@232
  int v151; // edx@232
  int v152; // ebx@232
  int v153; // eax@235
  int v154; // esi@236
  char v155; // al@241
  unsigned int v156; // esi@244
  int v157; // edx@245
  int (__cdecl *v158)(_DWORD, void **); // ebx@253
  int v159; // eax@254
  signed int v160; // eax@263
  int v161; // eax@265
  __int64 v162; // ST20_8@266
  signed int v163; // ecx@268
  double v164; // st7@271
  signed int v165; // ecx@274
  __int64 v166; // ST20_8@277
  signed int v167; // eax@281
  int v168; // eax@283
  __int64 v169; // ST20_8@284
  signed int v170; // ecx@286
  double v171; // st7@289
  signed int v172; // ecx@292
  __int64 v173; // ST20_8@295
  signed int v174; // eax@299
  int v175; // eax@301
  __int64 v176; // ST20_8@302
  signed int v177; // ecx@304
  double v178; // st7@307
  signed int v179; // ecx@310
  __int64 v180; // ST20_8@313
  signed int v181; // ecx@317
  signed int v182; // eax@317
  int v183; // esi@317
  int v184; // edx@317
  long double v185; // st7@321
  long double v186; // st6@321
  int v187; // eax@370
  signed int v188; // ecx@374
  signed int v189; // eax@374
  int v190; // esi@374
  int v191; // edx@374
  long double v192; // st7@378
  long double v193; // st6@378
  bool v194; // c3@385
  int v195; // eax@427
  int v196; // eax@431
  signed int v197; // ecx@431
  int v198; // edx@431
  int v199; // esi@431
  long double v200; // st7@435
  long double v201; // st6@435
  int v202; // eax@438
  bool v203; // zf@438
  int v204; // eax@459
  signed int v205; // ecx@459
  int v206; // edx@459
  int v207; // esi@459
  long double v208; // st7@463
  long double v209; // st6@463
  int v210; // eax@482
  int v211; // ebx@482
  signed int v212; // ecx@482
  int v213; // edx@482
  int v214; // esi@482
  long double v215; // st7@486
  long double v216; // st6@486
  unsigned int v217; // eax@505
  __int16 v218; // cx@506
  int v219; // edx@508
  int v220; // ST28_4@508
  int v221; // eax@510
  int v222; // ebx@510
  signed int v223; // ecx@510
  int v224; // edx@510
  int v225; // esi@510
  long double v226; // st7@514
  long double v227; // st6@514
  signed int v228; // ecx@535
  signed int v229; // eax@535
  int v230; // edx@535
  unsigned int v231; // esi@536
  long double v232; // st7@539
  long double v233; // st6@540
  int v234; // esi@552
  int v235; // ebx@552
  int v236; // edx@560
  signed int v237; // ecx@586
  signed int v238; // eax@586
  int v239; // edx@586
  unsigned int v240; // esi@587
  long double v241; // st7@590
  long double v242; // st6@591
  int v243; // esi@602
  int v244; // ebx@602
  int v245; // edx@610
  signed int v246; // ecx@635
  signed int v247; // eax@635
  int v248; // edx@635
  unsigned int v249; // esi@636
  long double v250; // st7@639
  long double v251; // st6@640
  int v252; // esi@651
  int v253; // ebx@651
  int v254; // edx@659
  signed int v255; // ecx@684
  signed int v256; // eax@684
  int v257; // edx@684
  unsigned int v258; // esi@685
  long double v259; // st7@688
  long double v260; // st6@689
  int v261; // esi@700
  int v262; // ebx@700
  int v263; // edx@708
  signed int v264; // eax@733
  signed int v265; // eax@737
  int v266; // eax@739
  char v267; // cl@740
  double v268; // st7@740
  signed int v269; // ecx@743
  int v270; // eax@745
  __int64 v271; // ST20_8@746
  signed int v272; // eax@751
  signed int v273; // eax@755
  signed int v274; // eax@757
  char v275; // cl@758
  double v276; // st7@758
  signed int v277; // ecx@761
  __int64 v278; // ST20_8@764
  signed int v279; // eax@768
  int v280; // esi@770
  __int64 v281; // ST20_8@771
  signed int v282; // ecx@772
  unsigned int v283; // eax@774
  char **v284; // eax@778
  double v285; // st7@778
  signed int v286; // ecx@781
  int v287; // ecx@786
  signed int v288; // eax@786
  int v289; // ebx@789
  int v290; // esi@794
  double v291; // st7@810
  signed int v292; // ecx@813
  int v293; // ecx@818
  int v294; // ebx@818
  void *v295; // esi@818
  int v296; // edx@819
  void *v297; // eax@821
  signed int v298; // eax@823
  int v299; // ST20_4@828
  signed int v300; // eax@829
  long double v301; // st7@831
  long double v302; // st7@836
  signed int v303; // ecx@839
  signed int v304; // eax@844
  int v305; // ST20_4@849
  signed int v306; // eax@850
  long double v307; // st7@852
  long double v308; // st7@857
  signed int v309; // ecx@860
  signed int v310; // eax@865
  int v311; // ST20_4@870
  signed int v312; // eax@871
  double v313; // st7@873
  long double v314; // st7@890
  signed int v315; // ecx@893
  signed int v316; // eax@898
  signed int v317; // eax@904
  double v318; // st7@906
  int v319; // ecx@912
  int v320; // eax@913
  signed int v321; // ecx@920
  int *v322; // edi@930
  signed int v323; // eax@931
  int v324; // eax@933
  __int64 v325; // ST20_8@934
  double v326; // st7@936
  signed int v327; // ecx@939
  signed int v328; // eax@944
  long double v329; // st7@946
  int v330; // ST20_4@949
  long double v331; // st7@951
  signed int v332; // ecx@954
  signed int v333; // eax@959
  double v334; // st7@961
  int v335; // ST20_4@964
  signed int v336; // ecx@969
  unsigned __int16 v337; // dx@974
  unsigned int v338; // ebx@975
  int v339; // esi@975
  unsigned __int16 v340; // ax@975
  int *v341; // eax@975
  void (__cdecl *v342)(int, unsigned int, int); // eax@977
  int v343; // esi@981
  unsigned __int16 v344; // cx@981
  int *v345; // ebx@981
  int v346; // eax@981
  int *v347; // ecx@987
  int v348; // ebx@989
  int v349; // esi@989
  int v350; // ST24_4@989
  int *v351; // eax@989
  int v352; // eax@999
  unsigned int *v353; // edi@999
  signed int v354; // eax@999
  unsigned int v355; // eax@999
  int v356; // ebx@1002
  unsigned __int16 v357; // cx@1002
  int *v358; // esi@1002
  void (__cdecl *v359)(int, unsigned int, int); // eax@1004
  int v360; // eax@1006
  unsigned __int16 v361; // cx@1007
  int *v362; // eax@1008
  int v363; // ST24_4@1010
  int *v364; // eax@1010
  unsigned int v365; // eax@1019
  int v366; // ecx@1019
  int v367; // ecx@1019
  int v368; // esi@1022
  signed int v369; // ecx@1026
  int (__cdecl *v370)(int, void **); // ecx@1039
  void *v371; // edx@1051
  int v372; // ecx@1053
  int v373; // ebx@1060
  double v374; // st7@1060
  int v375; // esi@1065
  void *v376; // eax@1065
  double v377; // st7@1072
  int v378; // eax@1074
  double v379; // st7@1076
  int v380; // ebx@1081
  int v381; // esi@1084
  int v382; // edx@1086
  char v383; // bl@1089
  unsigned int v384; // esi@1092
  int v385; // ebx@1097
  int (__cdecl *v386)(_DWORD, unsigned int); // ecx@1100
  unsigned int v387; // ebx@1109
  int v388; // edx@1109
  unsigned __int16 v389; // cx@1109
  int *v390; // esi@1109
  signed int v391; // eax@1109
  int v392; // ecx@1109
  int v393; // ecx@1112
  int v394; // ecx@1113
  unsigned __int16 v395; // ax@1114
  int v396; // eax@1117
  int v397; // edx@1118
  int v398; // ecx@1119
  unsigned __int16 v399; // ax@1120
  int v400; // eax@1123
  int v401; // ecx@1126
  unsigned __int16 v402; // ax@1127
  unsigned __int16 v403; // ax@1131
  double v404; // st7@1140
  void *v405; // ecx@1145
  double v406; // st7@1152
  double v407; // st7@1156
  int v408; // esi@1161
  unsigned __int16 v409; // cx@1161
  int *v410; // ebx@1161
  int v411; // eax@1161
  int v412; // eax@1165
  int v413; // edx@1165
  int v414; // eax@1168
  int v415; // esi@1169
  int v416; // ebx@1172
  int v417; // ebx@1182
  int (__cdecl *v418)(_DWORD, void **); // ecx@1185
  int v419; // esi@1194
  unsigned __int16 v420; // dx@1194
  int *v421; // ebx@1194
  int v422; // eax@1194
  int v423; // eax@1198
  int v424; // edx@1198
  int v425; // eax@1201
  int v426; // esi@1202
  int v427; // ecx@1204
  char v428; // dl@1207
  unsigned int v429; // esi@1210
  int v430; // ecx@1211
  int v431; // ebx@1215
  int (__cdecl *v432)(_DWORD, void **); // ecx@1218
  int *v433; // ebx@1228
  int v434; // esi@1230
  int v435; // ST24_4@1230
  int *v436; // eax@1230
  int v437; // eax@1236
  int v438; // eax@1237
  int v439; // edx@1237
  int v440; // esi@1241
  int v441; // ebx@1244
  int v442; // ebx@1254
  int (__cdecl *v443)(_DWORD, void **); // ecx@1257
  int *v444; // ebx@1262
  int v445; // esi@1264
  int v446; // ST24_4@1264
  int *v447; // eax@1264
  int v448; // ecx@1270
  int v449; // eax@1271
  int v450; // edx@1271
  int v451; // esi@1274
  int v452; // ecx@1276
  char v453; // dl@1279
  unsigned int v454; // esi@1282
  int v455; // ecx@1283
  int v456; // ebx@1287
  int (__cdecl *v457)(_DWORD, void **); // ecx@1290
  int *v458; // ecx@1299
  int v459; // ebx@1301
  int v460; // esi@1301
  int v461; // ST24_4@1301
  int *v462; // eax@1301
  int v463; // eax@1315
  int (__cdecl *v464)(int, int); // ecx@1315
  int *v465; // eax@1317
  int v466; // esi@1319
  unsigned int v467; // ebx@1330
  int v468; // esi@1330
  unsigned __int16 v469; // ax@1330
  int v470; // eax@1330
  int (__cdecl *v471)(int, int); // ecx@1330
  unsigned __int16 v472; // cx@1333
  int v473; // eax@1334
  _BYTE *i; // ecx@1335
  int v475; // eax@1337
  int (__cdecl **v476)(int, int, int, int, int); // edx@1340
  int v477; // ecx@1340
  int (__cdecl **v478)(int, int, int, int, int); // edx@1344
  void (__cdecl *v479)(int, int, int); // edx@1348
  int v480; // edx@1353
  void (__cdecl *v481)(int, int, int); // edx@1361
  int v482; // esi@1365
  int (__cdecl *v483)(int, int); // eax@1368
  int v484; // eax@1369
  unsigned __int16 v485; // ax@1374
  unsigned int v486; // esi@1375
  unsigned __int16 v487; // dx@1375
  int *v488; // eax@1375
  unsigned int v489; // esi@1376
  unsigned __int16 v490; // cx@1376
  int v491; // ecx@1380
  unsigned int v492; // esi@1383
  __int16 v493; // dx@1383
  unsigned int v494; // ecx@1383
  signed int v495; // eax@1383
  signed int v496; // eax@1385
  int v497; // edx@1387
  int v498; // edx@1390
  __int16 v499; // ax@1393
  int v500; // ebx@1393
  int v501; // ecx@1393
  unsigned int v502; // edx@1393
  __int16 v503; // cx@1394
  int v504; // edx@1394
  int v505; // eax@1396
  unsigned int v506; // ecx@1396
  __int16 v507; // dx@1396
  int v508; // edx@1398
  int v509; // esi@1402
  int v510; // ecx@1402
  int v511; // ebx@1402
  unsigned __int16 v512; // cx@1405
  int v513; // eax@1405
  int v514; // eax@1406
  __int16 v515; // ax@1410
  unsigned __int16 v516; // ax@1414
  int v517; // eax@1414
  __int16 v518; // dx@1418
  unsigned __int16 v519; // ax@1421
  unsigned int v520; // esi@1424
  unsigned __int16 v521; // dx@1424
  unsigned int v522; // edx@1424
  signed int v523; // eax@1424
  signed int v524; // ecx@1426
  int v525; // ecx@1428
  int v526; // ecx@1431
  int v527; // ebx@1434
  __int16 v528; // dx@1434
  int v529; // edx@1434
  __int16 v530; // ax@1434
  unsigned int v531; // ecx@1434
  unsigned __int16 v532; // ax@1435
  int v533; // eax@1435
  int v534; // eax@1437
  unsigned __int16 v535; // dx@1437
  int v536; // ecx@1439
  int v537; // esi@1442
  int v538; // ecx@1442
  int v539; // ebx@1442
  unsigned __int16 v540; // ax@1445
  int v541; // eax@1445
  int v542; // eax@1446
  unsigned __int16 v543; // ax@1450
  unsigned __int16 v544; // cx@1454
  int v545; // eax@1454
  unsigned __int16 v546; // dx@1458
  unsigned __int16 v547; // ax@1461
  _DWORD *v548; // ST24_4@1465
  int v549; // eax@1465
  unsigned int v550; // esi@1468
  signed int v551; // ecx@1468
  unsigned __int16 v552; // ax@1468
  int *v553; // eax@1472
  unsigned __int64 v554; // ST18_8@1472
  unsigned __int16 v555; // ax@1473
  unsigned int *v556; // esi@1473
  int v557; // ecx@1474
  int v558; // eax@1474
  unsigned __int16 v559; // ax@1476
  unsigned int *v560; // esi@1476
  int v561; // ebx@1478
  unsigned __int16 v562; // dx@1478
  int *v563; // eax@1478
  int v564; // ecx@1478
  int v565; // esi@1478
  signed int v566; // eax@1478
  int v567; // esi@1485
  unsigned __int16 v568; // cx@1485
  unsigned int v569; // eax@1485
  unsigned int v570; // ebx@1485
  unsigned int v571; // eax@1485
  signed int v572; // eax@1487
  int v573; // ecx@1489
  int v574; // ebx@1491
  int v575; // esi@1495
  unsigned __int16 v576; // cx@1495
  int v577; // ebx@1495
  int v578; // eax@1495
  int v579; // ebx@1498
  unsigned __int16 v580; // ax@1498
  int v581; // eax@1498
  int v582; // ebx@1500
  unsigned __int16 v583; // cx@1500
  unsigned int v584; // ST14_4@1500
  unsigned int v585; // eax@1500
  unsigned int v586; // esi@1500
  int v587; // eax@1501
  unsigned int v588; // eax@1502
  int v589; // ecx@1502
  int v590; // esi@1508
  unsigned __int16 v591; // dx@1508
  int *v592; // eax@1508
  int v593; // ebx@1508
  int v594; // eax@1508
  unsigned int v595; // eax@1510
  int v596; // ecx@1510
  int v597; // ecx@1516
  int v598; // eax@1516
  void **v599; // edx@1516
  int v600; // edx@1516
  int v601; // esi@1517
  unsigned __int16 v602; // dx@1517
  int *v603; // eax@1517
  int v604; // ecx@1517
  int *v605; // eax@1518
  int v606; // ST24_4@1520
  int *v607; // eax@1520
  unsigned __int16 v608; // cx@1528
  int *v609; // eax@1529
  int v610; // ST24_4@1531
  int *v611; // eax@1531
  unsigned int v612; // ebx@1539
  signed int v613; // eax@1539
  int v614; // edx@1546
  int v615; // eax@1546
  unsigned int v616; // eax@1547
  int v617; // ST20_4@1550
  unsigned int v618; // ebx@1554
  int v619; // eax@1559
  char **v620; // eax@1560
  int v621; // eax@1562
  int v622; // ebx@1563
  unsigned int v623; // ST24_4@1563
  int v624; // eax@1563
  int (__cdecl *v625)(int, int); // ecx@1563
  signed int v626; // eax@1564
  signed int v627; // ecx@1568
  int v628; // eax@1571
  unsigned __int16 v629; // cx@1574
  signed int v630; // eax@1574
  int *v631; // eax@1575
  int v632; // ST24_4@1577
  int *v633; // eax@1577
  int v634; // ebx@1582
  int v635; // esi@1582
  int v636; // eax@1583
  unsigned __int16 v637; // dx@1585
  int v638; // ecx@1585
  unsigned int v639; // esi@1588
  unsigned __int16 v640; // dx@1588
  int v641; // eax@1588
  unsigned __int16 v642; // cx@1594
  __int16 v643; // dx@1595
  unsigned __int16 v644; // dx@1596
  int v645; // eax@1597
  int v646; // ecx@1599
  int v647; // esi@1599
  unsigned __int16 v648; // dx@1599
  int *v649; // eax@1599
  int v650; // edx@1599
  int v651; // edx@1605
  int (__cdecl *v652)(int, int, unsigned int, int *, _DWORD); // eax@1605
  int v653; // ebx@1606
  int v654; // esi@1606
  int v655; // eax@1606
  int v656; // eax@1607
  int (__cdecl *v657)(int, int); // eax@1610
  int v658; // edx@1611
  int v659; // edx@1612
  void (__cdecl *v660)(int, unsigned int, int); // eax@1619
  int v661; // eax@1621
  int v662; // edx@1621
  int v663; // esi@1623
  _BYTE *v664; // eax@1623
  char v665; // ST24_1@1624
  int v666; // edx@1627
  int v667; // edx@1628
  int v668; // eax@1630
  int v669; // edx@1632
  const char *v670; // eax@1633
  int v671; // eax@1637
  char v672; // ST24_1@1638
  int v673; // eax@1642
  int v674; // esi@1643
  _BYTE *v675; // eax@1643
  char v676; // ST24_1@1644
  int v677; // ecx@1645
  int v678; // ST28_4@1648
  int v680; // [sp+4h] [bp-188h]@5
  char v681; // [sp+Ch] [bp-180h]@0
  int v682; // [sp+50h] [bp-13Ch]@13
  int v683; // [sp+54h] [bp-138h]@3
  unsigned __int64 v684; // [sp+58h] [bp-134h]@1
  int v685; // [sp+60h] [bp-12Ch]@93
  void **v686; // [sp+64h] [bp-128h]@58
  unsigned int v687; // [sp+68h] [bp-124h]@3
  char **v688; // [sp+6Ch] [bp-120h]@19
  int v689; // [sp+70h] [bp-11Ch]@3
  long double v690; // [sp+74h] [bp-118h]@271
  void **v691; // [sp+7Ch] [bp-110h]@55
  int *v692; // [sp+80h] [bp-10Ch]@168
  long double v693; // [sp+84h] [bp-108h]@321
  int v694; // [sp+90h] [bp-FCh]@1
  int v695; // [sp+94h] [bp-F8h]@58
  int v696; // [sp+98h] [bp-F4h]@185
  int v697; // [sp+9Ch] [bp-F0h]@18
  int v698; // [sp+A0h] [bp-ECh]@1
  int v699; // [sp+A4h] [bp-E8h]@317
  int v700; // [sp+A8h] [bp-E4h]@40
  void **v701; // [sp+ACh] [bp-E0h]@47
  int v702; // [sp+B4h] [bp-D8h]@47
  unsigned int v703; // [sp+B8h] [bp-D4h]@173
  int v704; // [sp+BCh] [bp-D0h]@265
  int v705; // [sp+C0h] [bp-CCh]@75
  int v706; // [sp+C4h] [bp-C8h]@173
  int (__cdecl *v707)(int, int); // [sp+C8h] [bp-C4h]@3
  int v708; // [sp+CCh] [bp-C0h]@1478
  int (__cdecl *v709)(_DWORD, int, unsigned int, int *, _DWORD); // [sp+D0h] [bp-BCh]@3
  int v710; // [sp+D4h] [bp-B8h]@1
  int v711; // [sp+D8h] [bp-B4h]@190
  int v712; // [sp+DCh] [bp-B0h]@1
  unsigned int v713; // [sp+E0h] [bp-ACh]@3
  int *v714; // [sp+E4h] [bp-A8h]@8
  int v715; // [sp+E8h] [bp-A4h]@276
  int v716; // [sp+ECh] [bp-A0h]@941
  int v717; // [sp+F0h] [bp-9Ch]@763
  int v718; // [sp+F4h] [bp-98h]@956
  int v719; // [sp+F8h] [bp-94h]@815
  int v720; // [sp+FCh] [bp-90h]@971
  int v721; // [sp+100h] [bp-8Ch]@862
  int v722; // [sp+104h] [bp-88h]@294
  int v723; // [sp+108h] [bp-84h]@922
  int v724; // [sp+10Ch] [bp-80h]@312
  int v725; // [sp+110h] [bp-7Ch]@841
  int v726; // [sp+114h] [bp-78h]@775
  int v727; // [sp+118h] [bp-74h]@783
  int v728; // [sp+11Ch] [bp-70h]@4
  int v729; // [sp+120h] [bp-6Ch]@895
  int v730; // [sp+124h] [bp-68h]@745
  int v731; // [sp+128h] [bp-64h]@1482
  _DWORD *v732; // [sp+12Ch] [bp-60h]@1
  int v733; // [sp+130h] [bp-5Ch]@1
  void **v734; // [sp+134h] [bp-58h]@1202
  void **v735; // [sp+13Ch] [bp-50h]@1241
  void **v736; // [sp+144h] [bp-48h]@1274
  void **v737; // [sp+14Ch] [bp-40h]@1169
  int v738; // [sp+154h] [bp-38h]@1084
  void **v739; // [sp+15Ch] [bp-30h]@236
  char v740; // [sp+164h] [bp-28h]@1639
  char v741; // [sp+170h] [bp-1Ch]@1641
  char v742; // [sp+17Ch] [bp-10h]@1647

  *a2 = -2147483647;
  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_DWORD *)(a1 + 16);
  v732 = a2;
  v4 = *(_DWORD *)(v2 + 12);
  v698 = *(_DWORD *)(a1 + 24);
  v5 = *(_DWORD *)(v4 + 12);
  v684 = __PAIR__(v2, a1);
  v694 = v4;
  v710 = 0;
  v712 = v5;
  v733 = v3;
  if ( v5 != v3 )
    sub_10010310(a1, v5);
  v6 = *(int (__cdecl **)(_DWORD, int))(a1 + 272);
  v683 = 1;
  v707 = v6;
  v7 = *(_DWORD *)(v4 + 4);
  v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
  v8 = *(_DWORD *)v4;
  v9 = *(_DWORD *)(v4 + 32);
  ++*(_DWORD *)(a1 + 8);
  v713 = v8 + v7;
  v10 = *(_DWORD *)(a1 + 8);
  v687 = v8;
  v689 = v9;
  if ( v10 == 1000 || (unsigned int)&v728 <= *(_DWORD *)(a1 + 12) )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 26, v681);
    goto LABEL_8;
  }
  v11 = sub_1002F7C0(a1, 2 * v9, &v728);
  if ( !v11 )
  {
LABEL_8:
    v12 = v714;
    goto LABEL_9;
  }
  v12 = (int *)(v11 + 4 * v9);
  *(_DWORD *)(v2 + 64) = v12;
  *(_DWORD *)(v2 + 60) = v12;
LABEL_45:
  v39 = (_BYTE *)v687;
  if ( v687 >= v713 )
    goto LABEL_10;
  v40 = v698;
  v41 = v687;
  *(_DWORD *)(HIDWORD(v684) + 56) = v687;
  v42 = *v39;
  v43 = v709;
  while ( 2 )
  {
    v44 = &off_100D1E40 + 4 * v42;
    v701 = v44;
    v45 = *((_BYTE *)v44 + 8);
    v702 = v42;
    v700 = v45;
    if ( v43 )
    {
      *(_DWORD *)(HIDWORD(v684) + 60) = v12;
      v46 = v43(v684, v694, v41, &v682, *(_DWORD *)(v40 + 496));
      if ( !v46 )
        goto LABEL_9;
      v47 = v46 - 2;
      if ( !v47 )
      {
LABEL_1622:
        *(_DWORD *)(HIDWORD(v684) + 32) = v682;
        goto LABEL_10;
      }
      if ( v47 == 1 )
      {
        v661 = v684;
        v662 = v682;
        *(_BYTE *)(v684 + 294) = 1;
        *(_DWORD *)(v661 + 296) = v662;
        goto LABEL_9;
      }
      v42 = v702;
      v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v40 + 492);
    }
    switch ( v42 )
    {
      case 0:
      case 118:
      case 133:
      case 134:
        goto LABEL_44;
      case 83:
        v41 = v687;
        v48 = v684;
        switch ( sub_100517E0(v684, v694, v687, &v682) )
        {
          case 0:
            goto LABEL_9;
          case 1:
            v40 = v698;
            v43 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
            v42 = v682 >> 1;
            v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
            continue;
          case 2:
            goto LABEL_1622;
          case 3:
            v669 = v682;
            *(_BYTE *)(v48 + 294) = 1;
            *(_DWORD *)(v48 + 296) = v669;
            goto LABEL_9;
          default:
            v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
            break;
        }
        goto LABEL_44;
      case 58:
      case 121:
        HIBYTE(v49) = *(_BYTE *)(v687 + 1);
        LOBYTE(v49) = *(_BYTE *)(v687 + 2);
        v50 = v49;
        v702 = (int)&v12[-v49 - 2];
        v691 = *(void ***)v702;
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v701 = (void **)v49;
        if ( (unsigned __int8)v691 & 7
          || !((unsigned int)v691 & 0xFFFFFFF8)
          || (char **)(*(_DWORD *)(*(_DWORD *)(((unsigned int)v691 & 0xFFFFFFF8) + 4) + 8) & 0xFFFFFFFE) != &off_101621B8 )
        {
          v51 = v684;
        }
        else
        {
          v51 = v684;
          v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
          v52 = sub_10010550(v684, (unsigned int)v691 & 0xFFFFFFF8);
          v91 = *(_DWORD *)(v52 + 8) == 0;
          v695 = v52;
          if ( v91 && !(*(_BYTE *)(v52 + 22) & 0xC0) && v50 >= *(_WORD *)(v52 + 16) + (unsigned int)*(_WORD *)(v52 + 18) )
          {
            if ( v710 == 1000 )
            {
              sub_100110F0(v51, (int)sub_1003ED50, 0, 26, v681);
              goto LABEL_9;
            }
            v53 = *(_WORD *)(v52 + 20);
            v54 = *(_DWORD *)(v52 + 12);
            v694 = v54;
            v689 = *(_DWORD *)(v54 + 32);
            v697 = v53;
            v55 = sub_1002F7C0(v51, v53 + 2 * v689 + 25, &v714);
            if ( !v55 )
            {
              v683 = 0;
              v666 = *(_DWORD *)(*(_DWORD *)(HIDWORD(v684) + 12) + 32);
              v694 = *(_DWORD *)(HIDWORD(v684) + 12);
              v689 = v666;
              goto LABEL_10;
            }
            v56 = v55;
            v57 = (char *)(v55 + 100);
            memset((void *)v55, 0, 0x64u);
            v58 = v694;
            v59 = v695;
            *(_DWORD *)(v56 + 24) = v701;
            v60 = v702;
            *(_DWORD *)(v56 + 12) = v58;
            *(_DWORD *)(v56 + 16) = v59;
            v61 = v697;
            *(_DWORD *)(v56 + 28) = v60 + 8;
            v62 = HIDWORD(v684);
            *(_DWORD *)(v56 + 36) = v61;
            *(_DWORD *)(v56 + 44) = v62;
            *(_DWORD *)(v56 + 32) = -2147483647;
            *(_DWORD *)(v56 + 40) = v57;
            v63 = (int)v714;
            *(_DWORD *)(v56 + 52) = *((_DWORD *)v686[1] + 1) & 0xFFFFFFF8;
            v64 = v684;
            *(_DWORD *)(v56 + 88) = v63;
            v683 = sub_1002FBA0(*(_DWORD *)(v60 + 4) & 0xFFFFFFF8, v64, v56);
            if ( !v683 )
            {
              sub_1002F840(v684, (int)v714);
              v667 = *(_DWORD *)(*(_DWORD *)(HIDWORD(v684) + 12) + 32);
              v694 = *(_DWORD *)(HIDWORD(v684) + 12);
              v689 = v667;
              goto LABEL_10;
            }
            v65 = v697;
            if ( v697 )
            {
              memset32(v57, -2147483647, v697);
              v57 += 4 * v65;
            }
            v12 = (int *)&v57[4 * v689];
            v66 = v684;
            *(_DWORD *)(v56 + 64) = v12;
            *(_DWORD *)(v56 + 60) = v12;
            v67 = *(_DWORD *)(v66 + 24);
            v68 = *(int (__cdecl **)(int, int, signed int, _DWORD, _DWORD))(v67 + 540);
            if ( v68 )
            {
              v69 = v68(v66, v56, 1, 0, *(_DWORD *)(v67 + 544));
              v66 = v684;
              *(_DWORD *)(v56 + 92) = v69;
              v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
            }
            *(_DWORD *)(v56 + 96) = *(_DWORD *)(v66 + 16);
            v70 = *(_DWORD *)(v66 + 16);
            if ( v70 == v712 )
            {
              v712 = *(_DWORD *)(v694 + 12);
              if ( v712 != v70 )
              {
                sub_10010310(v684, v712);
                v66 = v684;
              }
            }
            v71 = v694;
            *(_DWORD *)(v66 + 56) = v56;
            v72 = *(_DWORD *)v71;
            v73 = *(_DWORD *)v71 + *(_DWORD *)(v71 + 4);
            ++v710;
            HIDWORD(v684) = v56;
            v687 = v72;
            v713 = v73;
            goto LABEL_45;
          }
        }
        v463 = sub_1002FC40(v51, v50, 0);
        v464 = *(int (__cdecl **)(_DWORD, int))(v51 + 272);
        v683 = v463;
        v12 = *(int **)(HIDWORD(v684) + 60);
        v707 = v464;
        v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
        if ( !v463 )
          goto LABEL_10;
        if ( *(_BYTE *)(v51 + 292) )
        {
          v688 = (char **)(4 * v689);
          v12[-v689] = v687;
          *v12 = *(_DWORD *)(v51 + 288);
          ++v12;
          *(_BYTE *)(v51 + 292) = 0;
          v692 = (int *)*(v12 - 1);
          v465 = v692;
          if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
          {
            v466 = HIDWORD(v684);
          }
          else
          {
            v466 = HIDWORD(v684);
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v465 = (int *)sub_10038B20(v51, (signed int)v465);
            if ( !v465 )
              goto LABEL_9;
            v692 = v465;
          }
          v691 = (void **)*(v12 - 2);
          if ( (unsigned __int8)v691 & 7 || !v691 )
          {
            *(_DWORD *)(v466 + 60) = v12;
            v686 = (void **)sub_10017540(v51, (signed int)v691);
            if ( !v686 )
              goto LABEL_9;
            v465 = v692;
          }
          else
          {
            v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
          }
          *(_DWORD *)(v466 + 60) = v12;
          v683 = (*(int (__cdecl **)(int, void **, int *, int *))(*((_DWORD *)*v686 + 1) + 16))(v51, v686, v465, &v682);
          if ( !v683 )
            goto LABEL_10;
          --v12;
          *(_DWORD *)((char *)v12 - (char *)v688 - 4) = v687;
          *(v12 - 1) = v682;
        }
LABEL_1329:
        v686 = 0;
        goto LABEL_44;
      case 1:
        v12[-v689] = v687;
        *v12 = -2147483647;
        ++v12;
        goto LABEL_44;
      case 81:
        --v12;
        goto LABEL_44;
      case 107:
        v12 -= 2;
        goto LABEL_44;
      case 135:
        v705 = *(v12 - 1);
        *(v12 - 1) = *(v12 - 2);
        *(v12 - 2) = v705;
        goto LABEL_44;
      case 2:
        v74 = *(v12 - 1);
        --v12;
        *v732 = v74;
        goto LABEL_44;
      case 3:
        v682 = *(v12 - 1);
        if ( v682 & 7 || !v682 )
        {
          v75 = HIDWORD(v684);
          v77 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v76 = (void **)sub_10017540(v77, v682);
          v686 = v76;
          if ( !v76 )
            goto LABEL_9;
        }
        else
        {
          v75 = HIDWORD(v684);
          v76 = (void **)(v682 & 0xFFFFFFF8);
          v686 = (void **)(v682 & 0xFFFFFFF8);
        }
        v78 = sub_10017C40(v684, (int)&off_101616B0, (int)v76, *(_DWORD *)(v75 + 52));
        if ( !v78 )
          goto LABEL_10;
        *(_DWORD *)(v75 + 52) = v78;
LABEL_83:
        v12[-v689 - 1] = v687;
        *(v12 - 1) = v78;
        goto LABEL_44;
      case 4:
        v79 = *(v12 - 1);
        --v12;
        v682 = v79;
        v682 = *(_DWORD *)(*(_DWORD *)((v79 & 0xFFFFFFF8) + 4) + 4);
        *(_DWORD *)(HIDWORD(v684) + 52) = v682 & 0xFFFFFFF8;
        goto LABEL_44;
      case 152:
        v80 = *(v12 - 1);
        --v12;
        *(_DWORD *)(HIDWORD(v684) + 32) = v80;
        goto LABEL_44;
      case 120:
        --v12;
        goto LABEL_87;
      case 6:
LABEL_87:
        LOBYTE(v81) = 0;
        HIBYTE(v81) = *(_BYTE *)(v687 + 1);
        v700 = *(_BYTE *)(v687 + 2) | v81;
        if ( v700 > 0 || !v707 )
          goto LABEL_44;
        v82 = v684;
        v83 = v694;
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v84 = v707(v82, v83);
        goto LABEL_90;
      case 7:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            v685 = v682 >> 3;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
          }
        }
        else
        {
          v685 = 0;
        }
        --v12;
        if ( !v685 )
        {
          LOBYTE(v85) = 0;
          HIBYTE(v85) = *(_BYTE *)(v687 + 1);
          v700 = *(_BYTE *)(v687 + 2) | v85;
          if ( v700 <= 0 )
          {
            v86 = v707;
            if ( v707 )
            {
              v87 = v694;
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v683 = v86(v684, v87);
              if ( !v683 )
                goto LABEL_10;
            }
          }
        }
        goto LABEL_44;
      case 8:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            v685 = v682 >> 3;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
          }
        }
        else
        {
          v685 = 0;
        }
        --v12;
        if ( v685 )
        {
          LOBYTE(v88) = 0;
          HIBYTE(v88) = *(_BYTE *)(v687 + 1);
          v700 = *(_BYTE *)(v687 + 2) | v88;
          if ( v700 <= 0 )
          {
            v89 = v707;
            if ( v707 )
            {
              v90 = v694;
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v683 = v89(v684, v90);
              if ( !v683 )
                goto LABEL_10;
            }
          }
        }
        goto LABEL_44;
      case 68:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            v685 = v682 >> 3;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
          }
        }
        else
        {
          v685 = 0;
        }
        --v12;
        v91 = v685 == 1;
LABEL_118:
        if ( v91 )
        {
          v92 = v687;
          v93 = *(_BYTE *)(v687 + 2);
          LOBYTE(v94) = 0;
          BYTE1(v94) = *(_BYTE *)(v687 + 1);
          v94 = (signed __int16)v94;
LABEL_120:
          v700 = v93 | v94;
          v12[-v689] = v92;
          *v12 = v682;
          ++v12;
        }
        goto LABEL_44;
      case 69:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            --v12;
            v685 = v682 >> 3;
            v91 = v682 >> 3 == 0;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
            --v12;
            v91 = v685 == 0;
          }
        }
        else
        {
          --v12;
          v685 = 0;
          v91 = 1;
        }
        goto LABEL_118;
      case 146:
        --v12;
        goto LABEL_128;
      case 139:
LABEL_128:
        v95 = v687;
        goto LABEL_129;
      case 140:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            v685 = v682 >> 3;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
          }
        }
        else
        {
          v685 = 0;
        }
        --v12;
        if ( v685 )
          goto LABEL_44;
        HIBYTE(v99) = *(_BYTE *)(v687 + 1);
        LOBYTE(v99) = *(_BYTE *)(v687 + 2);
        v700 = *(_BYTE *)(v687 + 4) | ((*(_BYTE *)(v687 + 3) | (v99 << 8)) << 8);
        if ( v700 > 0 )
          goto LABEL_44;
        v100 = v707;
        if ( !v707 )
          goto LABEL_44;
        v101 = v694;
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v84 = v100(v684, v101);
        goto LABEL_90;
      case 141:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            v685 = v682 >> 3;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
          }
        }
        else
        {
          v685 = 0;
        }
        --v12;
        if ( !v685 )
          goto LABEL_44;
        HIBYTE(v102) = *(_BYTE *)(v687 + 1);
        LOBYTE(v102) = *(_BYTE *)(v687 + 2);
        v700 = *(_BYTE *)(v687 + 4) | ((*(_BYTE *)(v687 + 3) | (v102 << 8)) << 8);
        if ( v700 > 0 )
          goto LABEL_44;
        v103 = v707;
        if ( !v707 )
          goto LABEL_44;
        v104 = v694;
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v84 = v103(v684, v104);
        goto LABEL_90;
      case 142:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            v685 = v682 >> 3;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
          }
        }
        else
        {
          v685 = 0;
        }
        --v12;
        if ( v685 != 1 )
          goto LABEL_44;
        v92 = v687;
        HIBYTE(v105) = *(_BYTE *)(v687 + 1);
        LOBYTE(v105) = *(_BYTE *)(v687 + 2);
        v93 = *(_BYTE *)(v687 + 4);
        v94 = (*(_BYTE *)(v687 + 3) | (v105 << 8)) << 8;
        goto LABEL_120;
      case 143:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            v685 = v682 >> 3;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
          }
        }
        else
        {
          v685 = 0;
        }
        --v12;
        if ( v685 )
          goto LABEL_44;
        v92 = v687;
        HIBYTE(v106) = *(_BYTE *)(v687 + 1);
        LOBYTE(v106) = *(_BYTE *)(v687 + 2);
        v93 = *(_BYTE *)(v687 + 4);
        v94 = (*(_BYTE *)(v687 + 3) | (v106 << 8)) << 8;
        goto LABEL_120;
      case 103:
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v683 = sub_10017450(v684, *(v12 - 1), (unsigned int *)&v686);
        if ( !v683 )
          goto LABEL_10;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = (int)v686;
        goto LABEL_44;
      case 111:
        v682 = *(v12 - 1);
        if ( v682 & 7 || !v682 )
        {
          v663 = v684;
          v664 = sub_1004F8E0(v684, -1, v682, 0);
          if ( v664 )
          {
            v665 = (unsigned int)sub_10010FF0((unsigned int)v664);
            sub_100110F0(v663, (int)sub_1003ED50, 0, 27, v665);
          }
          goto LABEL_9;
        }
        v107 = v682 & 0xFFFFFFF8;
        --v12;
        v686 = (void **)(v682 & 0xFFFFFFF8);
        v692 = (int *)*(v12 - 1);
        v108 = v692;
        if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
        {
          v109 = v684;
        }
        else
        {
          v109 = v684;
          v110 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v111 = (int *)sub_10038B20(v110, (signed int)v108);
          if ( !v111 )
            goto LABEL_9;
          v692 = v111;
          v107 = (unsigned int)v686;
          v108 = v692;
        }
        v683 = (*(int (__cdecl **)(int, unsigned int, int *, unsigned int *, int *))(*(_DWORD *)(*(_DWORD *)v107 + 4) + 8))(
                 v109,
                 v107,
                 v108,
                 &v703,
                 &v706);
        if ( !v683 )
          goto LABEL_10;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = 8 * (v706 != 0) | 6;
        if ( v706 )
        {
          v112 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)v703 + 4) + 52);
          if ( v112 )
            v112(v109, v703, v706);
        }
        goto LABEL_44;
      case 105:
        v113 = v684;
        v691 = (void **)*(v12 - 1);
        HIBYTE(v114) = *(_BYTE *)(v687 + 1);
        LOBYTE(v114) = *(_BYTE *)(v687 + 2);
        v692 = sub_10038D40(v684, v694 + 16, v114);
        v115 = -2;
        goto LABEL_185;
      case 104:
        v113 = v684;
        HIBYTE(v116) = *(_BYTE *)(v687 + 1);
        LOBYTE(v116) = *(_BYTE *)(v687 + 2);
        v117 = sub_10038D40(v684, v694 + 16, v116);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v692 = v117;
        v683 = sub_10016010(v113, (int)v117, (unsigned int *)&v686, &v703, &v706);
        if ( !v683 )
          goto LABEL_10;
        if ( v706 )
        {
          v118 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)v703 + 4) + 52);
          if ( v118 )
            v118(v113, v703, v706);
        }
        v691 = v686;
        goto LABEL_184;
      case 10:
      case 11:
      case 106:
        v113 = v684;
LABEL_184:
        v115 = -1;
LABEL_185:
        v696 = v115;
        v119 = v12[v115];
        v120 = (char **)&v12[v115];
        v121 = v119 & 0xFFFFFFF8;
        v688 = v120;
        v686 = (void **)v121;
        if ( !v121 )
          goto LABEL_186;
        v122 = (int)*(v120 - 1);
        v701 = (void **)v121;
        v682 = v122;
        if ( v122 != -2147483647 )
        {
          v126 = v122 & 0xFFFFFFF8;
          v124 = v126 + 4;
          v125 = *(_DWORD *)(*(_DWORD *)(v126 + 4) + 4) & 0xFFFFFFF8;
          v686 = (void **)v125;
          v711 = *(_DWORD *)(*(_DWORD *)v124 + 12);
          do
          {
LABEL_193:
            while ( 1 )
            {
              (*(void (__cdecl **)(int, unsigned int, signed int, int *, int *))(*(_DWORD *)(*(_DWORD *)v125 + 4) + 40))(
                v113,
                v125,
                1,
                &v711,
                &v682);
              *(_DWORD *)(*(_DWORD *)v124 + 12) = v711;
              if ( v711 )
                break;
              v127 = *(_DWORD *)v686[1] & 0xFFFFFFF8;
              v686 = (void **)(*(_DWORD *)v686[1] & 0xFFFFFFF8);
              if ( !v686 )
              {
LABEL_186:
                v682 = 6;
                goto LABEL_223;
              }
              v683 = (*(int (__cdecl **)(int, unsigned int, _DWORD, int *, _DWORD))(*(_DWORD *)(*(_DWORD *)v127 + 4) + 40))(
                       v113,
                       v127,
                       0,
                       &v711,
                       0);
              *(_DWORD *)(*(_DWORD *)v124 + 12) = v711;
              if ( !v683 )
                goto LABEL_10;
              *(_DWORD *)(*(_DWORD *)v124 + 4) = v686;
              v125 = (unsigned int)v686;
            }
            v683 = (*(int (__cdecl **)(int, void **, int, unsigned int *, int *))(*((_DWORD *)*v701 + 1) + 8))(
                     v113,
                     v701,
                     v682,
                     &v703,
                     &v706);
            if ( !v683 )
              goto LABEL_10;
            if ( !v706 )
              break;
            v128 = v703;
            v129 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)v703 + 4) + 52);
            if ( v129 )
            {
              v129(v113, v703, v706);
              v128 = v703;
            }
            v125 = (unsigned int)v686;
          }
          while ( (void **)v128 != v686 );
          v130 = v682;
          if ( v682 & 1 && v682 != -2147483647 )
          {
            if ( *(_DWORD *)(v113 + 16) != 120 )
            {
              v688 = (char **)(v682 >> 1);
              v131 = sub_1001F6E0(v113, (double)(v682 >> 1));
              if ( v131 )
              {
                v130 = v131 | 4;
                goto LABEL_208;
              }
LABEL_9:
              v683 = 0;
              goto LABEL_10;
            }
          }
          else
          {
            v130 = *(_DWORD *)(v682 + 8);
LABEL_208:
            v682 = v130;
          }
          if ( v702 == 10 )
          {
            HIWORD(v133) = 0;
            BYTE1(v133) = *(_BYTE *)(v687 + 1);
            LOBYTE(v133) = *(_BYTE *)(v687 + 2);
            v134 = *(_DWORD *)(HIDWORD(v684) + 28);
          }
          else
          {
            if ( v702 != 11 )
            {
              if ( v702 == 106 )
              {
                v12[-v689] = v687;
                *v12 = v682;
                ++v12;
              }
              else
              {
                if ( (unsigned __int8)v691 & 7 || !v691 )
                {
                  v132 = HIDWORD(v684);
                  *(_DWORD *)(HIDWORD(v684) + 60) = v12;
                  v686 = (void **)sub_10017540(v113, (signed int)v691);
                  if ( !v686 )
                    goto LABEL_9;
                }
                else
                {
                  v132 = HIDWORD(v684);
                  v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
                }
                *(_DWORD *)(v132 + 76) |= 8u;
                v683 = (*(int (__cdecl **)(int, void **, int *, int *))(*((_DWORD *)*v686 + 1) + 20))(
                         v113,
                         v686,
                         v692,
                         &v682);
                *(_DWORD *)(v132 + 76) &= 0xFFFFFFF7;
                if ( !v683 )
                  goto LABEL_10;
              }
              goto LABEL_222;
            }
            HIWORD(v133) = 0;
            BYTE1(v133) = *(_BYTE *)(v687 + 1);
            LOBYTE(v133) = *(_BYTE *)(v687 + 2);
            v134 = *(_DWORD *)(HIDWORD(v684) + 40);
          }
          *(_DWORD *)(v134 + 4 * v133) = v130;
LABEL_222:
          v682 = 14;
LABEL_223:
          v12 += v696 + 1;
LABEL_224:
          v12[-v689] = v687;
          *v12 = v682;
          ++v12;
LABEL_44:
          v687 += v700;
          goto LABEL_45;
        }
        v123 = sub_10017C40(v113, (int)&off_10162A98, 0, v121);
        v697 = v123;
        if ( !v123 )
          goto LABEL_9;
        v124 = v123 + 4;
        *(_DWORD *)(*(_DWORD *)(v123 + 4) + 12) = 0;
        v683 = sub_1003AB10(v113, *(_DWORD *)(v123 + 4) + 4, (unsigned int)"propobj->parent");
        if ( v683 )
        {
          *(v688 - 1) = (char *)v697;
          v683 = (*(int (__cdecl **)(int, void **, _DWORD, int *, _DWORD))(*((_DWORD *)*v686 + 1) + 40))(
                   v113,
                   v686,
                   0,
                   &v711,
                   0);
          *(_DWORD *)(*(_DWORD *)v124 + 12) = v711;
          if ( v683 )
          {
            v125 = (unsigned int)v686;
            goto LABEL_193;
          }
        }
LABEL_10:
        while ( 2 )
        {
          v13 = HIDWORD(v684);
          v14 = v684;
          if ( !v683 && *(_BYTE *)(v684 + 294) )
          {
            v15 = v698;
            v16 = *(int (__cdecl **)(int, int, unsigned int, int *, _DWORD))(v698 + 556);
            if ( v16 )
            {
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v17 = v16(v14, v694, v687, &v682, *(_DWORD *)(v15 + 560));
              if ( v17 )
              {
                v18 = v17 - 2;
                if ( v18 )
                {
                  if ( v18 == 1 )
                    *(_DWORD *)(v14 + 296) = v682;
                  v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
                  goto LABEL_18;
                }
                v23 = v682;
                v683 = 1;
                *(_BYTE *)(v14 + 294) = 0;
                *(_DWORD *)(v13 + 32) = v23;
              }
              else
              {
                *(_BYTE *)(v14 + 294) = 0;
              }
            }
            else
            {
LABEL_18:
              v19 = *(_DWORD *)(v694 + 36);
              v20 = 0;
              v697 = 0;
              if ( v19 )
              {
                v21 = v687 - *(_DWORD *)(v694 + 8);
                v688 = *(char ***)(v694 + 8);
                if ( v21 < 0 )
                  goto LABEL_1654;
                for ( ; (unsigned int)(v21 - *(_DWORD *)v19) >= *(_DWORD *)(v19 + 4); v19 += 12 )
                  ;
                v22 = *(_DWORD *)(v19 + 8);
                if ( v22 )
                  v20 = (int)v688 + v22;
                else
LABEL_1654:
                  v20 = v697;
              }
              v687 = v20;
              if ( v20 )
              {
                v700 = 0;
                *(_BYTE *)(v14 + 294) = 0;
                v683 = 1;
                goto LABEL_44;
              }
            }
          }
          if ( v710 )
          {
LABEL_26:
            v24 = v13;
            if ( *(_DWORD *)(v13 + 92) )
            {
              v25 = *(void (__cdecl **)(int, int, _DWORD, int *, _DWORD))(*(_DWORD *)(v14 + 24) + 540);
              if ( v25 )
              {
                v25(v14, v13, 0, &v683, *(_DWORD *)(v13 + 92));
                v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
              }
            }
            if ( *(_DWORD *)(v13 + 4) )
            {
              v26 = sub_10028590(v14, v13);
              v683 &= v26;
            }
            v27 = *(_DWORD *)(v14 + 16);
            if ( v27 == v712 )
            {
              v712 = *(_DWORD *)(v13 + 96);
              if ( v712 != v27 )
                sub_10010310(v14, v712);
            }
            v28 = v684;
            v29 = (_DWORD *)(*(_DWORD *)(v13 + 28) - 8);
            *v29 = *(_DWORD *)(v13 + 32);
            v30 = *(_DWORD *)(v13 + 44);
            v31 = *(_DWORD *)(v28 + 44);
            *(_DWORD *)(v28 + 56) = v30;
            v32 = *(_DWORD *)(v24 + 88);
            v33 = (char **)(v28 + 28);
            HIDWORD(v684) = v30;
            v697 = v32;
            v688 = v33;
            if ( (char **)v31 != v33 )
            {
              if ( v32 - *(_DWORD *)(v31 + 4) <= (unsigned int)(*(_DWORD *)(v31 + 12) - *(_DWORD *)(v31 + 4)) )
              {
                *(_DWORD *)(v31 + 12) = (v697 + 3) & 0xFFFFFFFC;
                goto LABEL_43;
              }
              v33 = v688;
              v32 = v697;
            }
            sub_1003E5E0((int)v33, v32);
LABEL_43:
            v34 = *(_DWORD *)(v30 + 12);
            --v710;
            v12 = v29 + 1;
            *(_DWORD *)(v30 + 60) = v29 + 1;
            v35 = *(_DWORD *)v34 + *(_DWORD *)(v34 + 4);
            v36 = *(_BYTE **)(v30 + 56);
            v689 = *(_DWORD *)(v34 + 32);
            v29[-v689] = v36;
            v694 = v34;
            v37 = 16 * *v36;
            v713 = v35;
            v38 = byte_100D1E48[v37];
            v687 = (unsigned int)v36;
            v700 = v38;
            if ( v683 )
              goto LABEL_44;
            continue;
          }
          break;
        }
        v678 = v728;
        *(_DWORD *)(v13 + 60) = *(_DWORD *)(v13 + 64);
        *(_DWORD *)(v13 + 64) = 0;
        sub_1002F840(v14, v678);
        if ( *(_DWORD *)(v14 + 16) == v712 && v712 != v733 )
          sub_10010310(v14, v733);
        --*(_DWORD *)(v14 + 8);
        return v683;
      case 12:
        v682 = *(v12 - 1);
        goto LABEL_224;
      case 13:
        v135 = v687;
        v691 = (void **)*(v12 - 2);
        v682 = *(v12 - 1);
        v136 = 4 * v689;
        v12[-v689] = v687;
        *v12 = (int)v691;
        v137 = v12 + 1;
        v137[-v136 / 4u] = v135;
        *v137 = v682;
        v12 = v137 + 1;
        goto LABEL_44;
      case 14:
        v138 = v687;
        v686 = *(void ***)(HIDWORD(v684) + 8);
        HIBYTE(v139) = *(_BYTE *)(v687 + 1);
        LOBYTE(v139) = *(_BYTE *)(v687 + 2);
        v140 = sub_10038D40(v684, v694 + 16, v139);
        v682 = *(v12 - 1);
        v683 = (*(int (__cdecl **)(_DWORD, void **, int *, int, _DWORD, _DWORD, signed int, _DWORD))(*((_DWORD *)*v686 + 1) + 12))(
                 v684,
                 v686,
                 v140,
                 v682,
                 0,
                 0,
                 7,
                 0);
        if ( !v683 )
          goto LABEL_10;
        v12[-v689 - 1] = v138;
        *(v12 - 1) = v682;
        goto LABEL_44;
      case 108:
        v141 = v687;
        v142 = v684;
        HIBYTE(v143) = *(_BYTE *)(v687 + 1);
        LOBYTE(v143) = *(_BYTE *)(v687 + 2);
        v144 = sub_10038D40(v684, v694 + 16, v143);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v145 = sub_10016170(v142, (int)v144);
        goto LABEL_230;
      case 109:
        v146 = v684;
        HIBYTE(v147) = *(_BYTE *)(v687 + 1);
        LOBYTE(v147) = *(_BYTE *)(v687 + 2);
        v148 = sub_10038D40(v684, v694 + 16, v147);
        v682 = *(v12 - 1);
        v149 = *(v12 - 2);
        v691 = (void **)v149;
        v686 = (void **)(v149 & 0xFFFFFFF8);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v150 = (int)v686;
        v151 = (int)*v686;
        v152 = *((_DWORD *)*v686 + 1);
        v692 = v148;
        v695 = v151;
        if ( (int (__cdecl **)(int, int, int, int, int))v152 == &off_101614B0
          || v152 && *(int (__cdecl **)(int, int, int, int, int))v152 == off_101614B0 )
        {
          v739 = *(void ***)(v698
                           + 8 * (((unsigned __int16)v148 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                           + 588);
          v154 = *(_DWORD *)(v698
                           + 8 * (((unsigned __int16)v148 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                           + 592);
          if ( v154 )
          {
            if ( v739 == v686 )
            {
              v697 = *(_DWORD *)v154;
              if ( (int *)v697 == v148 && !(*(_BYTE *)(v154 + 16) & 2) && !(*(_BYTE *)(v695 + 20) & 2) )
              {
                v155 = *(_BYTE *)(v154 + 16);
                if ( v155 & 0x20 )
                {
                  v683 = sub_10030390(v684, (int)v686, v697, *(_DWORD *)(v154 + 8), 8, 1, (int)&v682, (int)&v682);
                  if ( !v683 )
                    goto LABEL_10;
                  v150 = (int)v686;
                }
                else
                {
                  if ( v155 & 0x10 )
                    goto LABEL_1615;
                  if ( *(_DWORD *)(v154 + 8) )
                  {
                    if ( *(_BYTE *)(v154 + 17) & 8 )
                    {
                      v701 = (void **)(2 * *(_WORD *)(v154 + 18) | 1);
                    }
                    else if ( v697 & 1 )
                    {
                      v701 = (void **)v697;
                    }
                    else
                    {
                      v701 = *(void ***)(v697 + 8);
                    }
                    v158 = *(int (__cdecl **)(_DWORD, void **))(v152 + 48);
                    if ( v158 )
                      v159 = v158(v684, v686);
                    else
                      v159 = (int)v686;
                    if ( !(*(int (__cdecl **)(_DWORD, int, void **, int *))(v154 + 8))(v684, v159, v701, &v682) )
                      goto LABEL_9;
                    v150 = (int)v686;
                  }
                  v683 = 1;
                }
                v156 = *(_DWORD *)(v154 + 12);
                if ( v156 < *(_DWORD *)(v695 + 12) )
                {
                  v157 = v684;
                  *(_DWORD *)(*(_DWORD *)(v150 + 4) + 4 * v156) = v682;
                  *(_BYTE *)(*(_DWORD *)(v157 + 24) + 96) = 1;
                }
LABEL_261:
                if ( !v683 )
                  goto LABEL_10;
                --v12;
                v12[-v689 - 1] = v687;
                *(v12 - 1) = v682;
                goto LABEL_44;
              }
            }
          }
          v153 = (*(int (__cdecl **)(_DWORD, void **, int *, int *))(v152 + 20))(v684, v686, v148, &v682);
        }
        else
        {
          v153 = (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD))(v152 + 20))(v146, v686, v148, &v682);
        }
        v683 = v153;
        goto LABEL_261;
      case 15:
        v160 = *(v12 - 1);
        if ( v160 & 1 && v160 != -2147483647 )
        {
          v161 = v160 >> 1;
          v704 = v161;
        }
        else
        {
          v162 = __PAIR__(v160, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v162, &v704);
          if ( !v683 )
            goto LABEL_10;
          v161 = v704;
        }
        v163 = *(v12 - 2);
        if ( v163 & 1 && v163 != -2147483647 )
        {
          v696 = v163 >> 1;
          if ( !v683 )
            goto LABEL_10;
        }
        else
        {
          v166 = __PAIR__(v163, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v166, &v696);
          if ( !v683 )
            goto LABEL_10;
          v161 = v704;
        }
        --v12;
        v688 = (char **)(v696 | v161);
        v164 = (double)(v696 | v161);
        v690 = v164;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v165 = (signed int)v164, v688 = (char **)(signed int)v164, (double)(signed int)v164 == v164)
          && (unsigned int)(v165 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v78 = 2 * v165 | 1;
          v715 = 2 * v165 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v164, (int)&v715);
          if ( !v683 )
            goto LABEL_10;
          v78 = v715;
        }
        goto LABEL_83;
      case 16:
        v167 = *(v12 - 1);
        if ( v167 & 1 && v167 != -2147483647 )
        {
          v168 = v167 >> 1;
          v704 = v168;
        }
        else
        {
          v169 = __PAIR__(v167, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v169, &v704);
          if ( !v683 )
            goto LABEL_10;
          v168 = v704;
        }
        v170 = *(v12 - 2);
        if ( v170 & 1 && v170 != -2147483647 )
        {
          v696 = v170 >> 1;
          if ( !v683 )
            goto LABEL_10;
        }
        else
        {
          v173 = __PAIR__(v170, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v173, &v696);
          if ( !v683 )
            goto LABEL_10;
          v168 = v704;
        }
        --v12;
        v688 = (char **)(v696 ^ v168);
        v171 = (double)(v696 ^ v168);
        v690 = v171;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v172 = (signed int)v171, v688 = (char **)(signed int)v171, (double)(signed int)v171 == v171)
          && (unsigned int)(v172 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v78 = 2 * v172 | 1;
          v722 = 2 * v172 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v171, (int)&v722);
          if ( !v683 )
            goto LABEL_10;
          v78 = v722;
        }
        goto LABEL_83;
      case 17:
        v174 = *(v12 - 1);
        if ( v174 & 1 && v174 != -2147483647 )
        {
          v175 = v174 >> 1;
          v704 = v175;
        }
        else
        {
          v176 = __PAIR__(v174, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v176, &v704);
          if ( !v683 )
            goto LABEL_10;
          v175 = v704;
        }
        v177 = *(v12 - 2);
        if ( v177 & 1 && v177 != -2147483647 )
        {
          v696 = v177 >> 1;
          if ( !v683 )
            goto LABEL_10;
        }
        else
        {
          v180 = __PAIR__(v177, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v180, &v696);
          if ( !v683 )
            goto LABEL_10;
          v175 = v704;
        }
        --v12;
        v688 = (char **)(v696 & v175);
        v178 = (double)(v696 & v175);
        v690 = v178;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v179 = (signed int)v178, v688 = (char **)(signed int)v178, (double)(signed int)v178 == v178)
          && (unsigned int)(v179 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v78 = 2 * v179 | 1;
          v724 = 2 * v179 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v178, (int)&v724);
          if ( !v683 )
            goto LABEL_10;
          v78 = v724;
        }
        goto LABEL_83;
      case 18:
        v181 = *(v12 - 1);
        v682 = v181;
        v182 = *(v12 - 2);
        v183 = v181 & 7;
        v184 = *(v12 - 2) & 7;
        v691 = (void **)*(v12 - 2);
        v705 = v184;
        v701 = (void **)(v181 & 7);
        v699 = v181 & 7;
        if ( v184 == v183 )
        {
          if ( v184 == 4 )
          {
            v685 = sub_1001AEA0(v182 & 0xFFFFFFF8, v181 & 0xFFFFFFF8) == 0;
          }
          else if ( v184 == 2 )
          {
            v185 = *(double *)(v182 & 0xFFFFFFF8);
            v690 = v185;
            v186 = *(double *)(v181 & 0xFFFFFFF8);
            v693 = v186;
            v685 = ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
                && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
                && v186 == v185;
          }
          else
          {
            v685 = v182 == v181;
          }
        }
        else if ( v182 && v182 != -2147483647 )
        {
          if ( !v181 || v181 == -2147483647 )
            goto LABEL_1655;
          if ( v184 )
          {
            if ( !(v181 & 7) )
            {
              if ( !v701 )
              {
                *(_DWORD *)(HIDWORD(v684) + 60) = v12;
                v683 = (*(int (__cdecl **)(_DWORD, unsigned int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)(v682 & 0xFFFFFFF8)
                                                                                           + 4)
                                                                               + 36))(
                         v684,
                         v682 & 0xFFFFFFF8,
                         0,
                         &v682);
                if ( !v683 )
                  goto LABEL_10;
                v181 = v682;
                v184 = v705;
                v182 = (signed int)v691;
              }
              v183 = v181 & 7;
              v699 = v181 & 7;
            }
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (*(int (__cdecl **)(_DWORD, unsigned int, _DWORD, void ***))(*(_DWORD *)(*(_DWORD *)((unsigned int)v691 & 0xFFFFFFF8)
                                                                                          + 4)
                                                                              + 36))(
                     v684,
                     (unsigned int)v691 & 0xFFFFFFF8,
                     0,
                     &v691);
            if ( !v683 )
              goto LABEL_10;
            v182 = (signed int)v691;
            v181 = v682;
            v183 = v699;
            v184 = (unsigned __int8)v691 & 7;
            v705 = (unsigned __int8)v691 & 7;
          }
          if ( v184 == 4 && v183 == 4 )
          {
            v685 = sub_1001AEA0(v182 & 0xFFFFFFF8, v181 & 0xFFFFFFF8) == 0;
            goto LABEL_373;
          }
          if ( v182 & 1 && v182 != -2147483647 )
          {
            v688 = (char **)(v182 >> 1);
            v690 = (double)(v182 >> 1);
          }
          else if ( (v182 & 7) == 2 )
          {
            v690 = *(double *)(v182 & 0xFFFFFFF8);
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (int)sub_10020030(v684, (signed int)v691, &v690);
            if ( !v683 )
              goto LABEL_10;
            v181 = v682;
          }
          if ( v181 & 1 && v181 != -2147483647 )
          {
            v688 = (char **)(v181 >> 1);
            v693 = (double)(v181 >> 1);
          }
          else if ( (v181 & 7) == 2 )
          {
            v693 = *(double *)(v181 & 0xFFFFFFF8);
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (int)sub_10020030(v684, v682, &v693);
            if ( !v683 )
              goto LABEL_10;
          }
          if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF)
            || (HIDWORD(v693) & 0x7FF00000) == 2146435072 && (LODWORD(v693) || HIDWORD(v693) & 0xFFFFF)
            || v693 != v690 )
          {
LABEL_1655:
            v685 = 0;
          }
          else
          {
            v685 = 1;
          }
        }
        else
        {
          v187 = !v181 || v181 == -2147483647;
          v685 = v187 == 1;
        }
LABEL_373:
        --v12;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = 8 * v685 | 6;
        goto LABEL_44;
      case 19:
        v188 = *(v12 - 1);
        v682 = v188;
        v189 = *(v12 - 2);
        v190 = v188 & 7;
        v191 = *(v12 - 2) & 7;
        v691 = (void **)*(v12 - 2);
        v705 = v191;
        v701 = (void **)(v188 & 7);
        v699 = v188 & 7;
        if ( v191 == v190 )
        {
          if ( v191 == 4 )
          {
            v685 = sub_1001AEA0(v189 & 0xFFFFFFF8, v188 & 0xFFFFFFF8) != 0;
            goto LABEL_430;
          }
          if ( v191 != 2 )
          {
            v685 = v189 != v188;
            goto LABEL_430;
          }
          v192 = *(double *)(v189 & 0xFFFFFFF8);
          v690 = v192;
          v193 = *(double *)(v188 & 0xFFFFFFF8);
          v693 = v193;
          if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF)
            || (HIDWORD(v693) & 0x7FF00000) == 2146435072 && (LODWORD(v693) || HIDWORD(v693) & 0xFFFFF) )
          {
            v685 = 1;
            goto LABEL_430;
          }
          v194 = v193 == v192;
        }
        else
        {
          if ( !v189 || v189 == -2147483647 )
          {
            v195 = !v188 || v188 == -2147483647;
            v685 = v195 != 1;
            goto LABEL_430;
          }
          if ( !v188 || v188 == -2147483647 )
            goto LABEL_387;
          if ( v191 )
          {
            if ( !(v188 & 7) )
            {
              if ( !v701 )
              {
                *(_DWORD *)(HIDWORD(v684) + 60) = v12;
                v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)(v682 & 0xFFFFFFF8)
                                                                                      + 4)
                                                                          + 36))(
                         v684,
                         v682 & 0xFFFFFFF8,
                         0,
                         &v682);
                if ( !v683 )
                  goto LABEL_10;
                v188 = v682;
                v191 = v705;
                v189 = (signed int)v691;
              }
              v190 = v188 & 7;
              v699 = v188 & 7;
            }
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)((unsigned int)v691 & 0xFFFFFFF8)
                                                                                  + 4)
                                                                      + 36))(
                     v684,
                     (unsigned int)v691 & 0xFFFFFFF8,
                     0,
                     &v691);
            if ( !v683 )
              goto LABEL_10;
            v189 = (signed int)v691;
            v188 = v682;
            v190 = v699;
            v191 = (unsigned __int8)v691 & 7;
            v705 = (unsigned __int8)v691 & 7;
          }
          if ( v191 == 4 && v190 == 4 )
          {
            v685 = sub_1001AEA0(v189 & 0xFFFFFFF8, v188 & 0xFFFFFFF8) != 0;
            goto LABEL_430;
          }
          if ( v189 & 1 && v189 != -2147483647 )
          {
            v688 = (char **)(v189 >> 1);
            v690 = (double)(v189 >> 1);
          }
          else if ( (v189 & 7) == 2 )
          {
            v690 = *(double *)(v189 & 0xFFFFFFF8);
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (int)sub_10020030(v684, (signed int)v691, &v690);
            if ( !v683 )
              goto LABEL_10;
            v188 = v682;
          }
          if ( v188 & 1 && v188 != -2147483647 )
          {
            v688 = (char **)(v188 >> 1);
            v693 = (double)(v188 >> 1);
          }
          else if ( (v188 & 7) == 2 )
          {
            v693 = *(double *)(v188 & 0xFFFFFFF8);
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (int)sub_10020030(v684, v682, &v693);
            if ( !v683 )
              goto LABEL_10;
          }
          if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF)
            || (HIDWORD(v693) & 0x7FF00000) == 2146435072 && (LODWORD(v693) || HIDWORD(v693) & 0xFFFFF) )
          {
LABEL_387:
            v685 = 1;
            goto LABEL_430;
          }
          v194 = v693 == v690;
        }
        if ( !v194 )
          goto LABEL_387;
        v685 = 0;
LABEL_430:
        --v12;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = 8 * v685 | 6;
        goto LABEL_44;
      case 72:
        v196 = *(v12 - 1);
        v682 = v196;
        v197 = *(v12 - 2);
        v198 = *(v12 - 2) & 7;
        v199 = v196 & 7;
        v691 = (void **)*(v12 - 2);
        v705 = v198;
        v699 = v196 & 7;
        if ( v198 == v199 )
        {
          if ( v198 == 4 )
          {
            v685 = sub_1001AEA0(v197 & 0xFFFFFFF8, v196 & 0xFFFFFFF8) == 0;
            goto LABEL_458;
          }
          if ( v198 != 2 )
          {
LABEL_457:
            v685 = v197 == v196;
            goto LABEL_458;
          }
          v200 = *(double *)(v197 & 0xFFFFFFF8);
          v690 = v200;
          v201 = *(double *)(v196 & 0xFFFFFFF8);
          v693 = v201;
          if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF) )
            goto LABEL_450;
          v202 = HIDWORD(v693);
          v203 = (HIDWORD(v693) & 0x7FF00000) == 2146435072;
        }
        else
        {
          if ( v198 == 2 && v196 & 1 && v196 != -2147483647 )
          {
            v200 = *(double *)(v197 & 0xFFFFFFF8);
            v688 = (char **)(v196 >> 1);
            v690 = v200;
            v201 = (double)(v196 >> 1);
          }
          else
          {
            if ( !(v197 & 1) || v197 == -2147483647 || v199 != 2 )
              goto LABEL_457;
            v688 = (char **)(v197 >> 1);
            v200 = (double)(v197 >> 1);
            v690 = v200;
            v201 = *(double *)(v196 & 0xFFFFFFF8);
          }
          v693 = v201;
          if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF) )
            goto LABEL_450;
          v202 = HIDWORD(v693);
          v203 = (HIDWORD(v693) & 0x7FF00000) == 2146435072;
        }
        if ( v203 && (LODWORD(v693) || v202 & 0xFFFFF) || v201 != v200 )
        {
LABEL_450:
          v685 = 0;
          goto LABEL_458;
        }
        v685 = 1;
LABEL_458:
        --v12;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = 8 * v685 | 6;
        goto LABEL_44;
      case 73:
        v204 = *(v12 - 1);
        v682 = v204;
        v205 = *(v12 - 2);
        v206 = *(v12 - 2) & 7;
        v207 = v204 & 7;
        v691 = (void **)*(v12 - 2);
        v705 = v206;
        v699 = v204 & 7;
        if ( v206 == v207 )
        {
          if ( v206 == 4 )
          {
            v685 = sub_1001AEA0(v205 & 0xFFFFFFF8, v204 & 0xFFFFFFF8) != 0;
            goto LABEL_481;
          }
          if ( v206 != 2 )
          {
LABEL_480:
            v685 = v205 != v204;
            goto LABEL_481;
          }
          v208 = *(double *)(v205 & 0xFFFFFFF8);
          v690 = v208;
          v209 = *(double *)(v204 & 0xFFFFFFF8);
        }
        else if ( v206 == 2 && v204 & 1 && v204 != -2147483647 )
        {
          v208 = *(double *)(v205 & 0xFFFFFFF8);
          v688 = (char **)(v204 >> 1);
          v690 = v208;
          v209 = (double)(v204 >> 1);
        }
        else
        {
          if ( !(v205 & 1) || v205 == -2147483647 || v207 != 2 )
            goto LABEL_480;
          v688 = (char **)(v205 >> 1);
          v208 = (double)(v205 >> 1);
          v690 = v208;
          v209 = *(double *)(v204 & 0xFFFFFFF8);
        }
        v693 = v209;
        if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF)
          || (HIDWORD(v693) & 0x7FF00000) == 2146435072 && (LODWORD(v693) || HIDWORD(v693) & 0xFFFFF) )
        {
          v685 = 1;
        }
        else
        {
          v685 = v209 != v208;
        }
LABEL_481:
        --v12;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = 8 * v685 | 6;
        goto LABEL_44;
      case 119:
        v210 = *(v12 - 1);
        v211 = (int)(v12 - 1);
        v682 = v210;
        v212 = *(v12 - 2);
        v213 = *(v12 - 2) & 7;
        v214 = v210 & 7;
        v691 = (void **)*(v12 - 2);
        v705 = v213;
        v699 = v210 & 7;
        if ( v213 == v214 )
        {
          if ( v213 == 4 )
          {
            v685 = sub_1001AEA0(v212 & 0xFFFFFFF8, v210 & 0xFFFFFFF8) == 0;
            goto LABEL_505;
          }
          if ( v213 != 2 )
          {
LABEL_504:
            v685 = v212 == v210;
            goto LABEL_505;
          }
          v215 = *(double *)(v212 & 0xFFFFFFF8);
          v690 = v215;
          v216 = *(double *)(v210 & 0xFFFFFFF8);
        }
        else if ( v213 == 2 && v210 & 1 && v210 != -2147483647 )
        {
          v215 = *(double *)(v212 & 0xFFFFFFF8);
          v688 = (char **)(v210 >> 1);
          v690 = v215;
          v216 = (double)(v210 >> 1);
        }
        else
        {
          if ( !(v212 & 1) || v212 == -2147483647 || v214 != 2 )
            goto LABEL_504;
          v688 = (char **)(v212 >> 1);
          v215 = (double)(v212 >> 1);
          v690 = v215;
          v216 = *(double *)(v210 & 0xFFFFFFF8);
        }
        v693 = v216;
        v685 = ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
            && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
            && v216 == v215;
LABEL_505:
        v217 = v687;
        *(_DWORD *)(v211 - (4 * v689 + 4)) = v687;
        v12 -= 2;
        *(_DWORD *)(v211 - 4) = 8 * v685 | 6;
        if ( v685 )
        {
          LOBYTE(v218) = 0;
          HIBYTE(v218) = *(_BYTE *)(v217 + 1);
          v700 = *(_BYTE *)(v217 + 2) | v218;
          if ( v700 <= 0 && v707 )
          {
            v219 = v684;
            v220 = v694;
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v84 = v707(v219, v220);
            goto LABEL_90;
          }
        }
        else
        {
          *v12 = (int)v691;
          v12 = (int *)v211;
        }
        goto LABEL_44;
      case 145:
        v221 = *(v12 - 1);
        v222 = (int)(v12 - 1);
        v682 = v221;
        v223 = *(v12 - 2);
        v224 = *(v12 - 2) & 7;
        v225 = v221 & 7;
        v691 = (void **)*(v12 - 2);
        v705 = v224;
        v699 = v221 & 7;
        if ( v224 == v225 )
        {
          if ( v224 == 4 )
          {
            v685 = sub_1001AEA0(v223 & 0xFFFFFFF8, v221 & 0xFFFFFFF8) == 0;
            goto LABEL_533;
          }
          if ( v224 != 2 )
          {
LABEL_532:
            v685 = v223 == v221;
            goto LABEL_533;
          }
          v226 = *(double *)(v223 & 0xFFFFFFF8);
          v690 = v226;
          v227 = *(double *)(v221 & 0xFFFFFFF8);
        }
        else if ( v224 == 2 && v221 & 1 && v221 != -2147483647 )
        {
          v226 = *(double *)(v223 & 0xFFFFFFF8);
          v688 = (char **)(v221 >> 1);
          v690 = v226;
          v227 = (double)(v221 >> 1);
        }
        else
        {
          if ( !(v223 & 1) || v223 == -2147483647 || v225 != 2 )
            goto LABEL_532;
          v688 = (char **)(v223 >> 1);
          v226 = (double)(v223 >> 1);
          v690 = v226;
          v227 = *(double *)(v221 & 0xFFFFFFF8);
        }
        v693 = v227;
        v685 = ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
            && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
            && v227 == v226;
LABEL_533:
        v95 = v687;
        *(_DWORD *)(v222 - (4 * v689 + 4)) = v687;
        v12 -= 2;
        *(_DWORD *)(v222 - 4) = 8 * v685 | 6;
        if ( v685 )
        {
LABEL_129:
          HIBYTE(v96) = *(_BYTE *)(v95 + 1);
          LOBYTE(v96) = *(_BYTE *)(v95 + 2);
          v700 = *(_BYTE *)(v95 + 4) | ((*(_BYTE *)(v95 + 3) | (v96 << 8)) << 8);
          if ( v700 <= 0 && v707 )
          {
            v97 = v684;
            v98 = v694;
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v84 = v707(v97, v98);
LABEL_90:
            v683 = v84;
            if ( !v84 )
              goto LABEL_10;
          }
        }
        else
        {
          *v12 = (int)v691;
          v12 = (int *)v222;
        }
        goto LABEL_44;
      case 20:
        v228 = *(v12 - 1);
        v682 = v228;
        v229 = *(v12 - 2);
        v230 = v228 & *(v12 - 2);
        v691 = (void **)*(v12 - 2);
        if ( v230 & 1 )
        {
          v231 = v228 ^ 0x80000001;
          v705 = v229 ^ 0x80000001;
          v699 = v228 ^ 0x80000001;
          if ( v229 == -2147483647 )
          {
            v232 = *(double *)*(_DWORD *)(v698 + 468);
            v690 = v232;
            if ( v231 )
            {
              v688 = (char **)(v228 >> 1);
              v233 = (double)(v228 >> 1);
LABEL_541:
              v693 = v233;
              if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF)
                || (HIDWORD(v693) & 0x7FF00000) == 2146435072 && (LODWORD(v693) || HIDWORD(v693) & 0xFFFFF)
                || v233 <= v232 )
              {
LABEL_547:
                v685 = 0;
              }
              else
              {
                v685 = 1;
              }
              goto LABEL_585;
            }
          }
          else
          {
            if ( v231 )
            {
              v685 = (signed int)(v229 & 0xFFFFFFFE) < (signed int)(v228 & 0xFFFFFFFE);
              goto LABEL_585;
            }
            v688 = (char **)(v229 >> 1);
            v232 = (double)(v229 >> 1);
            v690 = v232;
          }
          v233 = *(double *)*(_DWORD *)(v698 + 468);
          goto LABEL_541;
        }
        v234 = HIDWORD(v684);
        v235 = v684;
        if ( !(v229 & 7) && v229 )
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (*(int (__cdecl **)(int, _DWORD, signed int, _DWORD))(*(_DWORD *)(*(_DWORD *)((unsigned int)v691 & 0xFFFFFFF8)
                                                                                 + 4)
                                                                     + 36))(
                   v235,
                   (unsigned int)v691 & 0xFFFFFFF8,
                   4,
                   &v691);
          if ( !v683 )
            goto LABEL_10;
          v228 = v682;
          v229 = (signed int)v691;
        }
        if ( !(v228 & 7) && v228 )
        {
          *(_DWORD *)(v234 + 60) = v12;
          v683 = (*(int (__cdecl **)(int, _DWORD, signed int, _DWORD))(*(_DWORD *)(*(_DWORD *)(v682 & 0xFFFFFFF8) + 4)
                                                                     + 36))(
                   v235,
                   v682 & 0xFFFFFFF8,
                   4,
                   &v682);
          if ( !v683 )
            goto LABEL_10;
          v228 = v682;
          v229 = (signed int)v691;
        }
        v236 = v229 & 7;
        v695 = v229 & 7;
        if ( v236 == 4 )
        {
          if ( (v228 & 7) == 4 )
          {
            v685 = sub_1001AEA0(v229 & 0xFFFFFFF8, v228 & 0xFFFFFFF8) < 0;
            goto LABEL_585;
          }
          v236 = v695;
        }
        if ( v229 & 1 && v229 != -2147483647 )
        {
          v688 = (char **)(v229 >> 1);
          v690 = (double)(v229 >> 1);
        }
        else if ( v236 == 2 )
        {
          v690 = *(double *)(v229 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(v234 + 60) = v12;
          v683 = (int)sub_10020030(v235, (signed int)v691, &v690);
          if ( !v683 )
            goto LABEL_10;
          v228 = v682;
        }
        if ( v228 & 1 && v228 != -2147483647 )
        {
          v688 = (char **)(v228 >> 1);
          v693 = (double)(v228 >> 1);
        }
        else if ( (v228 & 7) == 2 )
        {
          v693 = *(double *)(v228 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(v234 + 60) = v12;
          v683 = (int)sub_10020030(v235, v682, &v693);
          if ( !v683 )
            goto LABEL_10;
        }
        if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF) )
          goto LABEL_584;
        if ( (HIDWORD(v693) & 0x7FF00000) == 2146435072 && (LODWORD(v693) || HIDWORD(v693) & 0xFFFFF) )
          goto LABEL_584;
        v685 = 1;
        if ( v693 <= v690 )
          goto LABEL_584;
        goto LABEL_585;
      case 21:
        v237 = *(v12 - 1);
        v682 = v237;
        v238 = *(v12 - 2);
        v239 = v237 & *(v12 - 2);
        v691 = (void **)*(v12 - 2);
        if ( v239 & 1 )
        {
          v240 = v237 ^ 0x80000001;
          v705 = v238 ^ 0x80000001;
          v699 = v237 ^ 0x80000001;
          if ( v238 == -2147483647 )
          {
            v241 = *(double *)*(_DWORD *)(v698 + 468);
            v690 = v241;
            if ( v240 )
            {
              v688 = (char **)(v237 >> 1);
              v242 = (double)(v237 >> 1);
LABEL_592:
              v693 = v242;
              if ( ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
                && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
                && v242 >= v241 )
              {
                v685 = 1;
                goto LABEL_585;
              }
              goto LABEL_547;
            }
          }
          else
          {
            if ( v240 )
            {
              v685 = (signed int)(v238 & 0xFFFFFFFE) <= (signed int)(v237 & 0xFFFFFFFE);
              goto LABEL_585;
            }
            v688 = (char **)(v238 >> 1);
            v241 = (double)(v238 >> 1);
            v690 = v241;
          }
          v242 = *(double *)*(_DWORD *)(v698 + 468);
          goto LABEL_592;
        }
        v243 = HIDWORD(v684);
        v244 = v684;
        if ( !(v238 & 7) && v238 )
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)((unsigned int)v691 & 0xFFFFFFF8)
                                                                                + 4)
                                                                    + 36))(
                   v244,
                   (unsigned int)v691 & 0xFFFFFFF8,
                   4,
                   &v691);
          if ( !v683 )
            goto LABEL_10;
          v237 = v682;
          v238 = (signed int)v691;
        }
        if ( !(v237 & 7) && v237 )
        {
          *(_DWORD *)(v243 + 60) = v12;
          v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)(v682 & 0xFFFFFFF8) + 4)
                                                                    + 36))(
                   v244,
                   v682 & 0xFFFFFFF8,
                   4,
                   &v682);
          if ( !v683 )
            goto LABEL_10;
          v237 = v682;
          v238 = (signed int)v691;
        }
        v245 = v238 & 7;
        v695 = v238 & 7;
        if ( v245 == 4 )
        {
          if ( (v237 & 7) == 4 )
          {
            v685 = sub_1001AEA0(v238 & 0xFFFFFFF8, v237 & 0xFFFFFFF8) <= 0;
            goto LABEL_585;
          }
          v245 = v695;
        }
        if ( v238 & 1 && v238 != -2147483647 )
        {
          v688 = (char **)(v238 >> 1);
          v690 = (double)(v238 >> 1);
        }
        else if ( v245 == 2 )
        {
          v690 = *(double *)(v238 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(v243 + 60) = v12;
          v683 = (int)sub_10020030(v244, (signed int)v691, &v690);
          if ( !v683 )
            goto LABEL_10;
          v237 = v682;
        }
        if ( v237 & 1 && v237 != -2147483647 )
        {
          v688 = (char **)(v237 >> 1);
          v693 = (double)(v237 >> 1);
        }
        else if ( (v237 & 7) == 2 )
        {
          v693 = *(double *)(v237 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(v243 + 60) = v12;
          v683 = (int)sub_10020030(v244, v682, &v693);
          if ( !v683 )
            goto LABEL_10;
        }
        if ( ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
          && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
          && v693 >= v690 )
        {
          v685 = 1;
          goto LABEL_585;
        }
        goto LABEL_584;
      case 22:
        v246 = *(v12 - 1);
        v682 = v246;
        v247 = *(v12 - 2);
        v248 = v246 & *(v12 - 2);
        v691 = (void **)*(v12 - 2);
        if ( v248 & 1 )
        {
          v249 = v246 ^ 0x80000001;
          v705 = v247 ^ 0x80000001;
          v699 = v246 ^ 0x80000001;
          if ( v247 == -2147483647 )
          {
            v250 = *(double *)*(_DWORD *)(v698 + 468);
            v690 = v250;
            if ( v249 )
            {
              v688 = (char **)(v246 >> 1);
              v251 = (double)(v246 >> 1);
LABEL_641:
              v693 = v251;
              if ( ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
                && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
                && v251 < v250 )
              {
                v685 = 1;
                goto LABEL_585;
              }
              goto LABEL_547;
            }
          }
          else
          {
            if ( v249 )
            {
              v685 = (signed int)(v247 & 0xFFFFFFFE) > (signed int)(v246 & 0xFFFFFFFE);
              goto LABEL_585;
            }
            v688 = (char **)(v247 >> 1);
            v250 = (double)(v247 >> 1);
            v690 = v250;
          }
          v251 = *(double *)*(_DWORD *)(v698 + 468);
          goto LABEL_641;
        }
        v252 = HIDWORD(v684);
        v253 = v684;
        if ( !(v247 & 7) && v247 )
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)((unsigned int)v691 & 0xFFFFFFF8)
                                                                                + 4)
                                                                    + 36))(
                   v253,
                   (unsigned int)v691 & 0xFFFFFFF8,
                   4,
                   &v691);
          if ( !v683 )
            goto LABEL_10;
          v246 = v682;
          v247 = (signed int)v691;
        }
        if ( !(v246 & 7) && v246 )
        {
          *(_DWORD *)(v252 + 60) = v12;
          v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)(v682 & 0xFFFFFFF8) + 4)
                                                                    + 36))(
                   v253,
                   v682 & 0xFFFFFFF8,
                   4,
                   &v682);
          if ( !v683 )
            goto LABEL_10;
          v246 = v682;
          v247 = (signed int)v691;
        }
        v254 = v247 & 7;
        v695 = v247 & 7;
        if ( v254 == 4 )
        {
          if ( (v246 & 7) == 4 )
          {
            v685 = sub_1001AEA0(v247 & 0xFFFFFFF8, v246 & 0xFFFFFFF8) > 0;
            goto LABEL_585;
          }
          v254 = v695;
        }
        if ( v247 & 1 && v247 != -2147483647 )
        {
          v688 = (char **)(v247 >> 1);
          v690 = (double)(v247 >> 1);
        }
        else if ( v254 == 2 )
        {
          v690 = *(double *)(v247 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(v252 + 60) = v12;
          v683 = (int)sub_10020030(v253, (signed int)v691, &v690);
          if ( !v683 )
            goto LABEL_10;
          v246 = v682;
        }
        if ( v246 & 1 && v246 != -2147483647 )
        {
          v688 = (char **)(v246 >> 1);
          v693 = (double)(v246 >> 1);
        }
        else if ( (v246 & 7) == 2 )
        {
          v693 = *(double *)(v246 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(v252 + 60) = v12;
          v683 = (int)sub_10020030(v253, v682, &v693);
          if ( !v683 )
            goto LABEL_10;
        }
        if ( ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
          && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
          && v693 < v690 )
        {
          v685 = 1;
          goto LABEL_585;
        }
        goto LABEL_584;
      case 23:
        v255 = *(v12 - 1);
        v682 = v255;
        v256 = *(v12 - 2);
        v257 = v255 & *(v12 - 2);
        v691 = (void **)*(v12 - 2);
        if ( !(v257 & 1) )
        {
          v261 = HIDWORD(v684);
          v262 = v684;
          if ( !(v256 & 7) && v256 )
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)((unsigned int)v691 & 0xFFFFFFF8)
                                                                                  + 4)
                                                                      + 36))(
                     v262,
                     (unsigned int)v691 & 0xFFFFFFF8,
                     4,
                     &v691);
            if ( !v683 )
              goto LABEL_10;
            v255 = v682;
            v256 = (signed int)v691;
          }
          if ( !(v255 & 7) && v255 )
          {
            *(_DWORD *)(v261 + 60) = v12;
            v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)(v682 & 0xFFFFFFF8) + 4)
                                                                      + 36))(
                     v262,
                     v682 & 0xFFFFFFF8,
                     4,
                     &v682);
            if ( !v683 )
              goto LABEL_10;
            v255 = v682;
            v256 = (signed int)v691;
          }
          v263 = v256 & 7;
          v695 = v256 & 7;
          if ( v263 == 4 )
          {
            if ( (v255 & 7) == 4 )
            {
              v685 = sub_1001AEA0(v256 & 0xFFFFFFF8, v255 & 0xFFFFFFF8) >= 0;
              goto LABEL_585;
            }
            v263 = v695;
          }
          if ( v256 & 1 && v256 != -2147483647 )
          {
            v688 = (char **)(v256 >> 1);
            v690 = (double)(v256 >> 1);
          }
          else if ( v263 == 2 )
          {
            v690 = *(double *)(v256 & 0xFFFFFFF8);
          }
          else
          {
            *(_DWORD *)(v261 + 60) = v12;
            v683 = (int)sub_10020030(v262, (signed int)v691, &v690);
            if ( !v683 )
              goto LABEL_10;
            v255 = v682;
          }
          if ( v255 & 1 && v255 != -2147483647 )
          {
            v688 = (char **)(v255 >> 1);
            v693 = (double)(v255 >> 1);
          }
          else if ( (v255 & 7) == 2 )
          {
            v693 = *(double *)(v255 & 0xFFFFFFF8);
          }
          else
          {
            *(_DWORD *)(v261 + 60) = v12;
            v683 = (int)sub_10020030(v262, v682, &v693);
            if ( !v683 )
              goto LABEL_10;
          }
          if ( ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
            && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
            && v693 <= v690 )
          {
            v685 = 1;
            goto LABEL_585;
          }
LABEL_584:
          v685 = 0;
LABEL_585:
          --v12;
          v12[-v689 - 1] = v687;
          *(v12 - 1) = 8 * v685 | 6;
          goto LABEL_44;
        }
        v258 = v255 ^ 0x80000001;
        v705 = v256 ^ 0x80000001;
        v699 = v255 ^ 0x80000001;
        if ( v256 == -2147483647 )
        {
          v259 = *(double *)*(_DWORD *)(v698 + 468);
          v690 = v259;
          if ( v258 )
          {
            v688 = (char **)(v255 >> 1);
            v260 = (double)(v255 >> 1);
LABEL_690:
            v693 = v260;
            if ( ((HIDWORD(v690) & 0x7FF00000) != 2146435072 || !LODWORD(v690) && !(HIDWORD(v690) & 0xFFFFF))
              && ((HIDWORD(v693) & 0x7FF00000) != 2146435072 || !LODWORD(v693) && !(HIDWORD(v693) & 0xFFFFF))
              && v260 <= v259 )
            {
              v685 = 1;
              goto LABEL_585;
            }
            goto LABEL_547;
          }
        }
        else
        {
          if ( v258 )
          {
            v685 = (signed int)(v256 & 0xFFFFFFFE) >= (signed int)(v255 & 0xFFFFFFFE);
            goto LABEL_585;
          }
          v688 = (char **)(v256 >> 1);
          v259 = (double)(v256 >> 1);
          v690 = v259;
        }
        v260 = *(double *)*(_DWORD *)(v698 + 468);
        goto LABEL_690;
      case 24:
        v264 = *(v12 - 1);
        if ( v264 & 1 && v264 != -2147483647 )
        {
          v704 = v264 >> 1;
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(__PAIR__(v264, (unsigned int)v684), &v704);
          if ( !v683 )
            goto LABEL_10;
        }
        v265 = *(v12 - 2);
        if ( v265 & 1 && v265 != -2147483647 )
        {
          v266 = v265 >> 1;
          v696 = v266;
          if ( !v683 )
            goto LABEL_10;
        }
        else
        {
          v271 = __PAIR__(v265, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v271, &v696);
          if ( !v683 )
            goto LABEL_10;
          v266 = v696;
        }
        v267 = v704 & 0x1F;
        v704 &= 0x1Fu;
        --v12;
        v688 = (char **)(v266 << v267);
        v268 = (double)(v266 << v267);
        v690 = v268;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v269 = (signed int)v268, v688 = (char **)(signed int)v268, (double)(signed int)v268 == v268)
          && (unsigned int)(v269 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v270 = 2 * v269 | 1;
          v730 = 2 * v269 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v268, (int)&v730);
          if ( !v683 )
            goto LABEL_10;
          v270 = v730;
        }
        goto LABEL_750;
      case 25:
        v272 = *(v12 - 1);
        if ( v272 & 1 && v272 != -2147483647 )
        {
          v704 = v272 >> 1;
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(__PAIR__(v272, (unsigned int)v684), &v704);
          if ( !v683 )
            goto LABEL_10;
        }
        v273 = *(v12 - 2);
        if ( v273 & 1 && v273 != -2147483647 )
        {
          v274 = v273 >> 1;
          v696 = v274;
          if ( !v683 )
            goto LABEL_10;
        }
        else
        {
          v278 = __PAIR__(v273, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v278, &v696);
          if ( !v683 )
            goto LABEL_10;
          v274 = v696;
        }
        v275 = v704 & 0x1F;
        v704 &= 0x1Fu;
        --v12;
        v688 = (char **)(v274 >> v275);
        v276 = (double)(v274 >> v275);
        v690 = v276;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v277 = (signed int)v276, v688 = (char **)(signed int)v276, (double)(signed int)v276 == v276)
          && (unsigned int)(v277 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v270 = 2 * v277 | 1;
          v717 = 2 * v277 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v276, (int)&v717);
          if ( !v683 )
            goto LABEL_10;
          v270 = v717;
        }
        goto LABEL_750;
      case 26:
        v279 = *(v12 - 1);
        if ( v279 & 1 && v279 != -2147483647 )
        {
          v280 = v684;
          v704 = v279 >> 1;
        }
        else
        {
          v280 = v684;
          v281 = __PAIR__(v279, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v281, &v704);
          if ( !v683 )
            goto LABEL_10;
        }
        v282 = *(v12 - 2);
        if ( v282 & 1 && v282 != -2147483647 && (v283 = v282 >> 1, v282 >> 1 >= 0) )
        {
          v726 = v282 >> 1;
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_100201D0(__PAIR__(v282, v280), &v726);
          if ( !v683 )
            goto LABEL_10;
          v283 = v726;
        }
        v284 = (char **)(v283 >> (v704 & 0x1F));
        v704 &= 0x1Fu;
        v688 = v284;
        v285 = (double)(unsigned int)v284;
        v690 = v285;
        --v12;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v286 = (signed int)v285, v688 = (char **)(signed int)v285, (double)(signed int)v285 == v285)
          && (unsigned int)(v286 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v78 = 2 * v286 | 1;
          v727 = 2 * v286 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v280, v285, (int)&v727);
          if ( !v683 )
            goto LABEL_10;
          v78 = v727;
        }
        goto LABEL_83;
      case 27:
        v287 = *(v12 - 1);
        v682 = *(v12 - 1);
        v691 = (void **)*(v12 - 2);
        v288 = (signed int)v691;
        if ( (unsigned __int8)v691 & 7 || !v691 )
        {
          v289 = (int)v691;
          v705 = (int)v691;
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)((unsigned int)v691 & 0xFFFFFFF8)
                                                                               + 4)
                                                                   + 36))(
                   v684,
                   (unsigned int)v691 & 0xFFFFFFF8,
                   0,
                   &v705);
          if ( !v683 )
            goto LABEL_10;
          v287 = v682;
          v289 = v705;
          v288 = (signed int)v691;
        }
        if ( v287 & 7 || !v287 )
        {
          v290 = v287;
          v699 = v287;
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(*(_DWORD *)(v682 & 0xFFFFFFF8) + 4)
                                                                    + 36))(
                   v684,
                   v682 & 0xFFFFFFF8,
                   0,
                   &v699);
          if ( !v683 )
            goto LABEL_10;
          v289 = v705;
          v288 = (signed int)v691;
          v290 = v699;
        }
        v685 = (v289 & 7) == 4;
        if ( (v289 & 7) == 4 )
        {
          v293 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v294 = v289 & 0xFFFFFFF8;
          v295 = (void *)sub_1001ACB0(v293, v699);
          v683 = v295 != 0;
        }
        else
        {
          if ( (v290 & 7) != 4 )
          {
            if ( v288 & 1 && v288 != -2147483647 )
            {
              v688 = (char **)(v288 >> 1);
              v690 = (double)(v288 >> 1);
            }
            else if ( (v288 & 7) == 2 )
            {
              v690 = *(double *)(v288 & 0xFFFFFFF8);
            }
            else
            {
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v683 = (int)sub_10020030(v684, (signed int)v691, &v690);
              if ( !v683 )
                goto LABEL_10;
            }
            if ( v682 & 1 && v682 != -2147483647 )
            {
              v688 = (char **)(v682 >> 1);
              v693 = (double)(v682 >> 1);
            }
            else if ( (v682 & 7) == 2 )
            {
              v693 = *(double *)(v682 & 0xFFFFFFF8);
            }
            else
            {
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v683 = (int)sub_10020030(v684, v682, &v693);
              if ( !v683 )
                goto LABEL_10;
            }
            --v12;
            v291 = v693 + v690;
            v690 = v693 + v690;
            if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
              && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
              && (v292 = (signed int)v291, v688 = (char **)(signed int)v291, (double)(signed int)v291 == v291)
              && (unsigned int)(v292 + 0x3FFFFFFF) <= 0x7FFFFFFE )
            {
              v270 = 2 * v292 | 1;
              v719 = 2 * v292 | 1;
            }
            else
            {
              v683 = sub_1001F5D0(v684, v291, (int)&v719);
              if ( !v683 )
                goto LABEL_10;
              v270 = v719;
            }
LABEL_750:
            v12[-v689 - 1] = v687;
            *(v12 - 1) = v270;
            goto LABEL_44;
          }
          v296 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v295 = (void *)(v290 & 0xFFFFFFF8);
          v294 = sub_1001ACB0(v296, v705);
          v683 = v294 != 0;
        }
        if ( !v683 )
          goto LABEL_10;
        v297 = sub_1001B450(v684, v294, v295);
        if ( !v297 )
          goto LABEL_9;
        --v12;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = (unsigned int)v297 | 4;
        goto LABEL_44;
      case 28:
        v298 = *(v12 - 1);
        if ( v298 & 1 && v298 != -2147483647 )
        {
          v688 = (char **)(v298 >> 1);
          v693 = (double)(v298 >> 1);
        }
        else if ( (v298 & 7) == 2 )
        {
          v693 = *(double *)(v298 & 0xFFFFFFF8);
        }
        else
        {
          v299 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v299, v298, &v693);
          if ( !v683 )
            goto LABEL_10;
        }
        v300 = *(v12 - 2);
        if ( v300 & 1 && v300 != -2147483647 )
        {
          v688 = (char **)(v300 >> 1);
          v301 = (double)(v300 >> 1);
        }
        else if ( (v300 & 7) == 2 )
        {
          v301 = *(double *)(v300 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v684, v300, &v690);
          if ( !v683 )
            goto LABEL_10;
          v301 = v690;
        }
        v302 = v301 - v693;
        --v12;
        v690 = v302;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v303 = (signed int)v302, v688 = (char **)(signed int)v302, (double)(signed int)v302 == v302)
          && (unsigned int)(v303 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v270 = 2 * v303 | 1;
          v725 = 2 * v303 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v302, (int)&v725);
          if ( !v683 )
            goto LABEL_10;
          v270 = v725;
        }
        goto LABEL_750;
      case 29:
        v304 = *(v12 - 1);
        if ( v304 & 1 && v304 != -2147483647 )
        {
          v688 = (char **)(v304 >> 1);
          v693 = (double)(v304 >> 1);
        }
        else if ( (v304 & 7) == 2 )
        {
          v693 = *(double *)(v304 & 0xFFFFFFF8);
        }
        else
        {
          v305 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v305, v304, &v693);
          if ( !v683 )
            goto LABEL_10;
        }
        v306 = *(v12 - 2);
        if ( v306 & 1 && v306 != -2147483647 )
        {
          v688 = (char **)(v306 >> 1);
          v307 = (double)(v306 >> 1);
        }
        else if ( (v306 & 7) == 2 )
        {
          v307 = *(double *)(v306 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v684, v306, &v690);
          if ( !v683 )
            goto LABEL_10;
          v307 = v690;
        }
        v308 = v307 * v693;
        --v12;
        v690 = v308;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v309 = (signed int)v308, v688 = (char **)(signed int)v308, (double)(signed int)v308 == v308)
          && (unsigned int)(v309 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v270 = 2 * v309 | 1;
          v721 = 2 * v309 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v308, (int)&v721);
          if ( !v683 )
            goto LABEL_10;
          v270 = v721;
        }
        goto LABEL_750;
      case 30:
        v310 = *(v12 - 1);
        if ( v310 & 1 && v310 != -2147483647 )
        {
          v688 = (char **)(v310 >> 1);
          v693 = (double)(v310 >> 1);
        }
        else if ( (v310 & 7) == 2 )
        {
          v693 = *(double *)(v310 & 0xFFFFFFF8);
        }
        else
        {
          v311 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v311, v310, &v693);
          if ( !v683 )
            goto LABEL_10;
        }
        v312 = *(v12 - 2);
        if ( v312 & 1 && v312 != -2147483647 )
        {
          v688 = (char **)(v312 >> 1);
          v313 = (double)(v312 >> 1);
          v690 = v313;
        }
        else if ( (v312 & 7) == 2 )
        {
          v313 = *(double *)(v312 & 0xFFFFFFF8);
          v690 = v313;
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v684, v312, &v690);
          if ( !v683 )
            goto LABEL_10;
          v313 = v690;
        }
        --v12;
        if ( v693 == 0.0 )
        {
          if ( (HIDWORD(v693) & 0x7FF00000) == 2146435072 && (LODWORD(v693) || HIDWORD(v693) & 0xFFFFF)
            || 0.0 == v313
            || (HIDWORD(v690) & 0x7FF00000) == 2146435072 && (LODWORD(v690) || HIDWORD(v690) & 0xFFFFF) )
          {
            v682 = *(_DWORD *)(v698 + 468) | 2;
          }
          else if ( (HIDWORD(v690) ^ HIDWORD(v693)) >= 0 )
          {
            v682 = *(_DWORD *)(v698 + 476) | 2;
          }
          else
          {
            v682 = *(_DWORD *)(v698 + 472) | 2;
          }
          goto LABEL_986;
        }
        v314 = v313 / v693;
        v690 = v314;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v315 = (signed int)v314, v688 = (char **)(signed int)v314, (double)(signed int)v314 == v314)
          && (unsigned int)(v315 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v78 = 2 * v315 | 1;
          v729 = 2 * v315 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v314, (int)&v729);
          if ( !v683 )
            goto LABEL_10;
          v78 = v729;
        }
        goto LABEL_83;
      case 31:
        v316 = *(v12 - 1);
        if ( v316 & 1 && v316 != -2147483647 )
        {
          v688 = (char **)(v316 >> 1);
          v693 = (double)(v316 >> 1);
        }
        else if ( (v316 & 7) == 2 )
        {
          v693 = *(double *)(v316 & 0xFFFFFFF8);
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v684, v316, &v693);
          if ( !v683 )
            goto LABEL_10;
        }
        v317 = *(v12 - 2);
        if ( v317 & 1 && v317 != -2147483647 )
        {
          v688 = (char **)(v317 >> 1);
          v318 = (double)(v317 >> 1);
          v690 = v318;
        }
        else if ( (v317 & 7) == 2 )
        {
          v318 = *(double *)(v317 & 0xFFFFFFF8);
          v690 = v318;
        }
        else
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v684, v317, &v690);
          if ( !v683 )
            goto LABEL_10;
          v318 = v690;
        }
        --v12;
        if ( v693 == 0.0 )
        {
          v319 = v698;
          v12[-v689 - 1] = v687;
          *(v12 - 1) = *(_DWORD *)(v319 + 468) | 2;
          goto LABEL_44;
        }
        v320 = HIDWORD(v690);
        if ( (HIDWORD(v690) & 0x7FF00000) == 2146435072 || (HIDWORD(v693) & 0x7FFFFFFF) != 2146435072 || LODWORD(v693) )
        {
          v318 = fmod(v318, v693);
          v690 = v318;
          v320 = HIDWORD(v690);
        }
        if ( (v320 & 0x7FF00000) != 2146435072
          && (v320 != 0x80000000 || LODWORD(v690))
          && (v321 = (signed int)v318, v688 = (char **)(signed int)v318, (double)(signed int)v318 == v318)
          && (unsigned int)(v321 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v270 = 2 * v321 | 1;
          v723 = 2 * v321 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v318, (int)&v723);
          if ( !v683 )
            goto LABEL_10;
          v270 = v723;
        }
        goto LABEL_750;
      case 32:
        v682 = *(v12 - 1);
        if ( v682 )
        {
          if ( (v682 & 7) == 6 )
          {
            v685 = v682 >> 3;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = sub_1002D390(v684, v682, &v685);
            if ( !v683 )
              goto LABEL_10;
          }
        }
        else
        {
          v685 = 0;
        }
        v322 = v12 - 1;
        v322[-v689] = v687;
        *v322 = 8 * (v685 == 0) | 6;
        v12 = v322 + 1;
        goto LABEL_44;
      case 33:
        v323 = *(v12 - 1);
        if ( v323 & 1 && v323 != -2147483647 )
        {
          v324 = v323 >> 1;
          v696 = v324;
        }
        else
        {
          v325 = __PAIR__(v323, (unsigned int)v684);
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020180(v325, &v696);
          if ( !v683 )
            goto LABEL_10;
          v324 = v696;
        }
        v688 = (char **)~v324;
        v326 = (double)~v324;
        v690 = v326;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v327 = (signed int)v326, v688 = (char **)(signed int)v326, (double)(signed int)v326 == v326)
          && (unsigned int)(v327 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v270 = 2 * v327 | 1;
          v716 = 2 * v327 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v326, (int)&v716);
          if ( !v683 )
            goto LABEL_10;
          v270 = v716;
        }
        goto LABEL_750;
      case 34:
        v328 = *(v12 - 1);
        if ( v328 & 1 && v328 != -2147483647 )
        {
          v688 = (char **)(v328 >> 1);
          v329 = (double)(v328 >> 1);
        }
        else if ( (v328 & 7) == 2 )
        {
          v329 = *(double *)(v328 & 0xFFFFFFF8);
        }
        else
        {
          v330 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v330, v328, &v690);
          if ( !v683 )
            goto LABEL_10;
          v329 = v690;
        }
        v331 = -v329;
        v690 = v331;
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v332 = (signed int)v331, v688 = (char **)(signed int)v331, (double)(signed int)v331 == v331)
          && (unsigned int)(v332 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v270 = 2 * v332 | 1;
          v718 = 2 * v332 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v331, (int)&v718);
          if ( !v683 )
            goto LABEL_10;
          v270 = v718;
        }
        goto LABEL_750;
      case 82:
        v333 = *(v12 - 1);
        if ( v333 & 1 && v333 != -2147483647 )
        {
          v688 = (char **)(v333 >> 1);
          v334 = (double)(v333 >> 1);
          v690 = v334;
        }
        else if ( (v333 & 7) == 2 )
        {
          v334 = *(double *)(v333 & 0xFFFFFFF8);
          v690 = v334;
        }
        else
        {
          v335 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (int)sub_10020030(v335, v333, &v690);
          if ( !v683 )
            goto LABEL_10;
          v334 = v690;
        }
        if ( (HIDWORD(v690) & 0x7FF00000) != 2146435072
          && (HIDWORD(v690) != 0x80000000 || LODWORD(v690))
          && (v336 = (signed int)v334, v688 = (char **)(signed int)v334, (double)(signed int)v334 == v334)
          && (unsigned int)(v336 + 0x3FFFFFFF) <= 0x7FFFFFFE )
        {
          v270 = 2 * v336 | 1;
          v720 = 2 * v336 | 1;
        }
        else
        {
          v683 = sub_1001F5D0(v684, v334, (int)&v720);
          if ( !v683 )
            goto LABEL_10;
          v270 = v720;
        }
        goto LABEL_750;
      case 35:
        HIBYTE(v337) = *(_BYTE *)(v687 + 1);
        LOBYTE(v337) = *(_BYTE *)(v687 + 2);
        v701 = (void **)v337;
        goto LABEL_1546;
      case 36:
        v338 = v687;
        v339 = v684;
        HIBYTE(v340) = *(_BYTE *)(v687 + 1);
        LOBYTE(v340) = *(_BYTE *)(v687 + 2);
        v341 = sub_10038D40(v684, v694 + 16, v340);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v692 = v341;
        v683 = sub_10016010(v339, (int)v341, (unsigned int *)&v686, &v703, &v706);
        if ( !v683 )
          goto LABEL_10;
        v682 = 14;
        if ( v706 )
        {
          v342 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)v703 + 4) + 52);
          if ( v342 )
            v342(v339, v703, v706);
          v683 = (*(int (__cdecl **)(int, void **, int *, int *))(*((_DWORD *)*v686 + 1) + 32))(v339, v686, v692, &v682);
          if ( !v683 )
            goto LABEL_10;
        }
        v12[-v689] = v338;
        *v12 = v682;
        ++v12;
        goto LABEL_44;
      case 37:
        v343 = v684;
        HIBYTE(v344) = *(_BYTE *)(v687 + 1);
        LOBYTE(v344) = *(_BYTE *)(v687 + 2);
        v345 = sub_10038D40(v684, v694 + 16, v344);
        v346 = *(v12 - 1);
        v692 = v345;
        v691 = (void **)v346;
        if ( v346 & 7 || !v346 )
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v686 = (void **)sub_10017540(v343, (signed int)v691);
          if ( !v686 )
            goto LABEL_9;
        }
        else
        {
          v686 = (void **)(v346 & 0xFFFFFFF8);
        }
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*((_DWORD *)*v686 + 1) + 32))(
                 v343,
                 v686,
                 v345,
                 &v682);
        if ( !v683 )
          goto LABEL_10;
LABEL_986:
        v12[-v689 - 1] = v687;
        *(v12 - 1) = v682;
        goto LABEL_44;
      case 38:
        v692 = (int *)*(v12 - 1);
        v347 = v692;
        if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
        {
          v349 = HIDWORD(v684);
          v348 = v684;
        }
        else
        {
          v349 = HIDWORD(v684);
          v348 = v684;
          v350 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v351 = (int *)sub_10038B20(v350, (signed int)v347);
          if ( !v351 )
            goto LABEL_9;
          v692 = v351;
          v347 = v351;
        }
        v691 = (void **)*(v12 - 2);
        if ( (unsigned __int8)v691 & 7 || !v691 )
        {
          *(_DWORD *)(v349 + 60) = v12;
          v686 = (void **)sub_10017540(v348, (signed int)v691);
          if ( !v686 )
            goto LABEL_9;
          v347 = v692;
        }
        else
        {
          v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
        }
        *(_DWORD *)(v349 + 60) = v12;
        v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*((_DWORD *)*v686 + 1) + 32))(
                 v348,
                 v686,
                 v347,
                 &v682);
        if ( !v683 )
          goto LABEL_10;
        --v12;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = v682;
        goto LABEL_44;
      case 39:
        v352 = *(v12 - 1);
        v353 = (unsigned int *)(v12 - 1);
        v682 = v352;
        v354 = sub_100101E0(v684, v352);
        v355 = *(_DWORD *)(*(_DWORD *)(v698 + 4 * v354 + 124) + 8) & 0xFFFFFFF8 | 4;
        v353[-v689] = v687;
        *v353 = v355;
        v12 = (int *)(v353 + 1);
        goto LABEL_44;
      case 40:
        --v12;
        goto LABEL_1001;
      case 41:
      case 44:
      case 47:
      case 50:
        v356 = v684;
        HIBYTE(v357) = *(_BYTE *)(v687 + 1);
        LOBYTE(v357) = *(_BYTE *)(v687 + 2);
        v358 = sub_10038D40(v684, v694 + 16, v357);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v692 = v358;
        v683 = sub_10016010(v356, (int)v358, (unsigned int *)&v686, &v703, &v706);
        if ( !v683 )
          goto LABEL_10;
        if ( !v706 )
          goto LABEL_1630;
        v359 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)v703 + 4) + 52);
        if ( v359 )
          v359(v356, v703, v706);
        v360 = (int)v686;
        goto LABEL_1015;
      case 42:
      case 45:
      case 48:
      case 51:
        v356 = v684;
        HIBYTE(v361) = *(_BYTE *)(v687 + 1);
        LOBYTE(v361) = *(_BYTE *)(v687 + 2);
        v692 = sub_10038D40(v684, v694 + 16, v361);
        --v12;
        goto LABEL_1014;
      case 43:
      case 46:
      case 49:
      case 52:
        v692 = (int *)*(v12 - 1);
        v362 = v692;
        if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
        {
          v356 = v684;
        }
        else
        {
          v356 = v684;
          v363 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v364 = (int *)sub_10038B20(v363, (signed int)v362);
          if ( !v364 )
            goto LABEL_9;
          v692 = v364;
        }
        v12 -= 2;
LABEL_1014:
        v360 = *v12;
LABEL_1015:
        v691 = (void **)v360;
        if ( v360 & 7 || !v360 )
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v686 = (void **)sub_10017540(v356, (signed int)v691);
          if ( !v686 )
            goto LABEL_9;
        }
        else
        {
          v686 = (void **)(v360 & 0xFFFFFFF8);
        }
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v365 = (unsigned int)v686;
        v366 = (int)*v686;
        v695 = v366;
        v367 = *(_DWORD *)(v366 + 4);
        if ( (int (__cdecl **)(int, int, int, int, int))v367 != &off_101614B0
          && (!v367 || *(int (__cdecl **)(int, int, int, int, int))v367 != off_101614B0)
          || (v368 = *(_DWORD *)(v698
                               + 8 * (((unsigned __int16)v692 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                               + 592)) == 0
          || *(void ***)(v698
                       + 8 * (((unsigned __int16)v692 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                       + 588) != v686
          || *(int **)v368 != v692 )
        {
          v683 = (*(int (__cdecl **)(int, void **, int *, int *))(v367 + 16))(v356, v686, v692, &v682);
          goto LABEL_1045;
        }
        v702 = *(_DWORD *)(v368 + 12);
        if ( v702 == -1 )
          v369 = -2147483647;
        else
          v369 = *((_DWORD *)v686[1] + v702);
        v682 = v369;
        if ( *(_BYTE *)(v368 + 16) & 0x10 )
        {
          v683 = sub_10030390(v356, (int)v686, *(_DWORD *)v368, *(_DWORD *)(v368 + 4), 4, 0, 0, (int)&v682);
          if ( !v683 )
            goto LABEL_10;
          v369 = v682;
          v365 = (unsigned int)v686;
        }
        else
        {
          if ( *(_DWORD *)(v368 + 4) )
          {
            if ( *(_BYTE *)(v368 + 17) & 8 )
            {
              v697 = 2 * *(_WORD *)(v368 + 18) | 1;
            }
            else if ( *(_DWORD *)v368 & 1 )
            {
              v697 = *(_DWORD *)v368;
            }
            else
            {
              v697 = *(_DWORD *)(*(_DWORD *)v368 + 8);
            }
            v370 = *(int (__cdecl **)(int, void **))(*((_DWORD *)*v686 + 1) + 48);
            if ( v370 )
              v365 = v370(v356, v686);
            if ( !(*(int (__cdecl **)(int, unsigned int, int, int *))(v368 + 4))(v356, v365, v697, &v682) )
              goto LABEL_9;
            v369 = v682;
            v365 = (unsigned int)v686;
          }
          v683 = 1;
        }
        if ( *(_DWORD *)(v368 + 12) < *(_DWORD *)(v695 + 12) )
        {
          *(_DWORD *)(*(_DWORD *)(v365 + 4) + 4 * v702) = v369;
LABEL_1045:
          v369 = v682;
          v365 = (unsigned int)v686;
        }
        if ( !v683 )
          goto LABEL_10;
        if ( v369 & 1 && v369 != -2147483647 && v369 != -2147483645 && v369 != 0x7FFFFFFF )
        {
          v371 = v701[3];
          if ( (unsigned __int16)v371 & 0x400 )
          {
            v699 = v369;
            if ( (unsigned __int16)v371 & 0x200 )
            {
              v372 = v369 + 2;
              v682 = v372;
            }
            else
            {
              v372 = v369 - 2;
              v682 = v372;
            }
          }
          else if ( (unsigned __int16)v371 & 0x200 )
          {
            v372 = v369 + 2;
            v682 = v372;
            v699 = v372;
          }
          else
          {
            v372 = v369 - 2;
            v682 = v372;
            v699 = v372;
          }
        }
        else
        {
          if ( v369 & 1 && v369 != -2147483647 )
          {
            v373 = v684;
            v688 = (char **)(v369 >> 1);
            v374 = (double)(v369 >> 1);
            v690 = v374;
          }
          else
          {
            v373 = v684;
            if ( (v369 & 7) == 2 )
            {
              v374 = *(double *)(v369 & 0xFFFFFFF8);
              v690 = v374;
            }
            else
            {
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v683 = (int)sub_10020030(v373, v682, &v690);
              if ( !v683 )
                goto LABEL_10;
              v369 = v682;
              v374 = v690;
            }
          }
          v375 = (int)v701;
          v376 = v701[3];
          if ( (unsigned __int16)v376 & 0x400 )
          {
            v699 = v369;
            if ( (!(v369 & 1) || v369 == -2147483647) && (v369 & 7) != 2 )
            {
              v683 = sub_1001F600(v373, v374, (int)&v699);
              if ( !v683 )
                goto LABEL_10;
              v374 = v690;
            }
            if ( *(_DWORD *)(v375 + 12) & 0x200 )
              v377 = v374 + 1.0;
            else
              v377 = v374 - 1.0;
            v690 = v377;
            v378 = sub_1001F600(v373, v377, (int)&v682);
            v372 = v682;
          }
          else
          {
            if ( (unsigned __int16)v376 & 0x200 )
              v379 = v374 + 1.0;
            else
              v379 = v374 - 1.0;
            v690 = v379;
            v378 = sub_1001F600(v373, v379, (int)&v682);
            v372 = v682;
            v699 = v682;
          }
          v683 = v378;
          if ( !v378 )
            goto LABEL_10;
          v365 = (unsigned int)v686;
        }
        v380 = *(_DWORD *)(*(_DWORD *)v365 + 4);
        v695 = *(_DWORD *)v365;
        v702 = v380;
        if ( (int (__cdecl **)(int, int, int, int, int))v380 != &off_101614B0
          && (!v380 || *(int (__cdecl **)(int, int, int, int, int))v380 != off_101614B0) )
        {
          goto LABEL_1106;
        }
        v738 = *(_DWORD *)(v698 + 8 * (((unsigned __int16)v692 ^ (unsigned __int16)(v365 >> 3)) & 0x3FF) + 588);
        v381 = *(_DWORD *)(v698 + 8 * (((unsigned __int16)v692 ^ (unsigned __int16)(v365 >> 3)) & 0x3FF) + 592);
        if ( !v381 )
          goto LABEL_1106;
        if ( v738 != v365 )
          goto LABEL_1106;
        v382 = *(_DWORD *)v381;
        if ( *(int **)v381 != v692 )
          goto LABEL_1106;
        if ( *(_BYTE *)(v381 + 16) & 2 || *(_BYTE *)(v695 + 20) & 2 )
        {
          v380 = v702;
LABEL_1106:
          v683 = (*(int (__cdecl **)(_DWORD, unsigned int, int *, int *))(v380 + 20))(v684, v365, v692, &v682);
        }
        else
        {
          v383 = *(_BYTE *)(v381 + 16);
          if ( v383 & 0x20 )
          {
            v683 = sub_10030390(v684, v365, v382, *(_DWORD *)(v381 + 8), 8, 1, (int)&v682, (int)&v682);
            if ( !v683 )
              goto LABEL_10;
            v372 = v682;
            v365 = (unsigned int)v686;
          }
          else
          {
            if ( v383 & 0x10 )
            {
              sub_100110F0(v684, (int)sub_1003ED50, 0, 160, 0);
              goto LABEL_9;
            }
            if ( *(_DWORD *)(v381 + 8) )
            {
              if ( *(_BYTE *)(v381 + 17) & 8 )
              {
                v385 = 2 * *(_WORD *)(v381 + 18) | 1;
              }
              else
              {
                v385 = *(_DWORD *)v381;
                if ( !(v382 & 1) )
                  v385 = *(_DWORD *)(v382 + 8);
              }
              v386 = *(int (__cdecl **)(_DWORD, unsigned int))(*(_DWORD *)(v695 + 4) + 48);
              if ( v386 )
                v365 = v386(v684, v365);
              if ( !(*(int (__cdecl **)(_DWORD, unsigned int, int, int *))(v381 + 8))(v684, v365, v385, &v682) )
                goto LABEL_9;
              v372 = v682;
              v365 = (unsigned int)v686;
            }
            v683 = 1;
          }
          v384 = *(_DWORD *)(v381 + 12);
          if ( v384 < *(_DWORD *)(v695 + 12) )
          {
            *(_DWORD *)(*(_DWORD *)(v365 + 4) + 4 * v384) = v372;
            *(_BYTE *)(*(_DWORD *)(v684 + 24) + 96) = 1;
          }
        }
        if ( !v683 )
          goto LABEL_10;
        v12[-v689] = v687;
        *v12 = v699;
        ++v12;
        goto LABEL_44;
      case 95:
        v387 = v687;
        v388 = HIDWORD(v684);
        HIBYTE(v389) = *(_BYTE *)(v687 + 1);
        LOBYTE(v389) = *(_BYTE *)(v687 + 2);
        v390 = (int *)(*(_DWORD *)(HIDWORD(v684) + 28) + 4 * v389);
        v391 = *v390;
        v392 = *v390 & 1;
        v682 = *v390;
        if ( !(v682 & 1) || v391 == -2147483647 || v391 == 0x7FFFFFFF )
          goto LABEL_1138;
        v393 = v689;
        v682 = v391 + 2;
        *v390 = v391 + 2;
        v12[-v393] = v387;
        *v12 = v682;
        ++v12;
        goto LABEL_44;
      case 97:
        v388 = HIDWORD(v684);
        v394 = *(_DWORD *)(HIDWORD(v684) + 28);
        goto LABEL_1114;
      case 99:
        v388 = HIDWORD(v684);
        v398 = *(_DWORD *)(HIDWORD(v684) + 28);
        goto LABEL_1120;
      case 101:
        v388 = HIDWORD(v684);
        v401 = *(_DWORD *)(HIDWORD(v684) + 28);
        goto LABEL_1127;
      case 96:
        v387 = v687;
        v388 = HIDWORD(v684);
        HIBYTE(v403) = *(_BYTE *)(v687 + 1);
        LOBYTE(v403) = *(_BYTE *)(v687 + 2);
        v390 = (int *)(*(_DWORD *)(HIDWORD(v684) + 40) + 4 * v403);
        v391 = *v390;
        v392 = *v390 & 1;
        v682 = *v390;
        if ( !(v682 & 1) || v391 == -2147483647 || v391 == 0x7FFFFFFF )
          goto LABEL_1138;
        v396 = v391 + 2;
        goto LABEL_1118;
      case 98:
        v388 = HIDWORD(v684);
        v394 = *(_DWORD *)(HIDWORD(v684) + 40);
LABEL_1114:
        v387 = v687;
        HIBYTE(v395) = *(_BYTE *)(v687 + 1);
        LOBYTE(v395) = *(_BYTE *)(v687 + 2);
        v390 = (int *)(v394 + 4 * v395);
        v391 = *v390;
        v392 = *v390 & 1;
        v682 = *v390;
        if ( !(v682 & 1) || v391 == -2147483647 || v391 == -2147483645 )
          goto LABEL_1138;
        v396 = v391 - 2;
LABEL_1118:
        v397 = v689;
        v682 = v396;
        *v390 = v396;
        v12[-v397] = v387;
        *v12 = v682;
        ++v12;
        goto LABEL_44;
      case 100:
        v388 = HIDWORD(v684);
        v398 = *(_DWORD *)(HIDWORD(v684) + 40);
LABEL_1120:
        v387 = v687;
        HIBYTE(v399) = *(_BYTE *)(v687 + 1);
        LOBYTE(v399) = *(_BYTE *)(v687 + 2);
        v390 = (int *)(v398 + 4 * v399);
        v391 = *v390;
        v392 = *v390 & 1;
        v682 = *v390;
        if ( !(v682 & 1) || v391 == -2147483647 || v391 == 0x7FFFFFFF )
          goto LABEL_1138;
        v699 = v391;
        v400 = v391 + 2;
        goto LABEL_1124;
      case 102:
        v388 = HIDWORD(v684);
        v401 = *(_DWORD *)(HIDWORD(v684) + 40);
LABEL_1127:
        v387 = v687;
        HIBYTE(v402) = *(_BYTE *)(v687 + 1);
        LOBYTE(v402) = *(_BYTE *)(v687 + 2);
        v390 = (int *)(v401 + 4 * v402);
        v391 = *v390;
        v392 = *v390 & 1;
        v682 = *v390;
        if ( v682 & 1 && v391 != -2147483647 && v391 != -2147483645 )
        {
          v699 = v391;
          v400 = v391 - 2;
LABEL_1124:
          v682 = v400;
          *v390 = v400;
        }
        else
        {
LABEL_1138:
          if ( v392 && v391 != -2147483647 )
          {
            v688 = (char **)(v391 >> 1);
            v404 = (double)(v391 >> 1);
            v690 = v404;
          }
          else if ( (v391 & 7) == 2 )
          {
            v404 = *(double *)(v391 & 0xFFFFFFF8);
            v690 = v404;
          }
          else
          {
            *(_DWORD *)(v388 + 60) = v12;
            v683 = (int)sub_10020030(v684, v682, &v690);
            if ( !v683 )
              goto LABEL_10;
            v391 = v682;
            v404 = v690;
          }
          v405 = v701[3];
          if ( (unsigned __int16)v405 & 0x400 )
          {
            v699 = v391;
            if ( (!(v391 & 1) || v391 == -2147483647) && (v391 & 7) != 2 )
            {
              v683 = sub_1001F600(v684, v404, (int)&v699);
              if ( !v683 )
                goto LABEL_10;
              v404 = v690;
            }
            if ( (unsigned int)v701[3] & 0x200 )
              v406 = v404 + 1.0;
            else
              v406 = v404 - 1.0;
            v690 = v406;
            v683 = sub_1001F600(v684, v406, (int)&v682);
          }
          else
          {
            if ( (unsigned __int16)v405 & 0x200 )
              v407 = v404 + 1.0;
            else
              v407 = v404 - 1.0;
            v690 = v407;
            v683 = sub_1001F600(v684, v407, (int)&v682);
            v699 = v682;
          }
          if ( !v683 )
            goto LABEL_10;
          *v390 = v682;
        }
        v12[-v689] = v387;
        *v12 = v699;
        ++v12;
        goto LABEL_44;
      case 53:
        v408 = v684;
        HIBYTE(v409) = *(_BYTE *)(v687 + 1);
        LOBYTE(v409) = *(_BYTE *)(v687 + 2);
        v410 = sub_10038D40(v684, v694 + 16, v409);
        v411 = *(v12 - 1);
        v692 = v410;
        v691 = (void **)v411;
        if ( v411 & 7 || !v411 )
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v686 = (void **)sub_10017540(v408, (signed int)v691);
          if ( !v686 )
            goto LABEL_9;
        }
        else
        {
          v686 = (void **)(v411 & 0xFFFFFFF8);
        }
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v412 = (int)v686;
        v413 = *((_DWORD *)*v686 + 1);
        v695 = (int)*v686;
        if ( (int (__cdecl **)(int, int, int, int, int))v413 != &off_101614B0
          && (!v413 || *(int (__cdecl **)(int, int, int, int, int))v413 != off_101614B0) )
        {
          v414 = (*(int (__cdecl **)(int, void **, int *, int *))(v413 + 16))(v408, v686, v410, &v682);
LABEL_1191:
          v683 = v414;
          goto LABEL_1192;
        }
        v737 = *(void ***)(v698
                         + 8 * (((unsigned __int16)v410 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                         + 588);
        v415 = *(_DWORD *)(v698
                         + 8 * (((unsigned __int16)v410 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                         + 592);
        if ( !v415 || v737 != v686 || *(int **)v415 != v410 )
        {
          v414 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(v413 + 16))(v684, v686, v410, &v682);
          goto LABEL_1191;
        }
        v702 = *(_DWORD *)(v415 + 12);
        v416 = v702;
        if ( v702 == -1 )
          v682 = -2147483647;
        else
          v682 = *((_DWORD *)v686[1] + v702);
        if ( *(_BYTE *)(v415 + 16) & 0x10 )
        {
          v683 = sub_10030390(v684, (int)v686, *(_DWORD *)v415, *(_DWORD *)(v415 + 4), 4, 0, 0, (int)&v682);
          if ( !v683 )
            goto LABEL_10;
          v412 = (int)v686;
        }
        else
        {
          if ( *(_DWORD *)(v415 + 4) )
          {
            if ( *(_BYTE *)(v415 + 17) & 8 )
            {
              v417 = 2 * *(_WORD *)(v415 + 18) | 1;
            }
            else
            {
              v417 = *(_DWORD *)v415;
              if ( !(*(_DWORD *)v415 & 1) )
                v417 = *(_DWORD *)(v417 + 8);
            }
            v418 = *(int (__cdecl **)(_DWORD, void **))(*((_DWORD *)*v686 + 1) + 48);
            if ( v418 )
              v412 = v418(v684, v686);
            if ( !(*(int (__cdecl **)(_DWORD, int, int, int *))(v415 + 4))(v684, v412, v417, &v682) )
              goto LABEL_9;
            v412 = (int)v686;
            v416 = v702;
          }
          v683 = 1;
        }
        if ( *(_DWORD *)(v415 + 12) < *(_DWORD *)(v695 + 12) )
          *(_DWORD *)(*(_DWORD *)(v412 + 4) + 4 * v416) = v682;
LABEL_1192:
        if ( !v683 )
          goto LABEL_10;
LABEL_1193:
        v12[-v689 - 1] = v687;
        *(v12 - 1) = v682;
        goto LABEL_44;
      case 54:
        v419 = v684;
        v682 = *(v12 - 1);
        HIBYTE(v420) = *(_BYTE *)(v687 + 1);
        LOBYTE(v420) = *(_BYTE *)(v687 + 2);
        v421 = sub_10038D40(v684, v694 + 16, v420);
        v422 = *(v12 - 2);
        v692 = v421;
        v691 = (void **)v422;
        if ( v422 & 7 || !v422 )
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v686 = (void **)sub_10017540(v419, (signed int)v691);
          if ( !v686 )
            goto LABEL_9;
        }
        else
        {
          v686 = (void **)(v422 & 0xFFFFFFF8);
        }
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v423 = (int)v686;
        v424 = *((_DWORD *)*v686 + 1);
        v695 = (int)*v686;
        v702 = v424;
        if ( (int (__cdecl **)(int, int, int, int, int))v424 != &off_101614B0
          && (!v424 || *(int (__cdecl **)(int, int, int, int, int))v424 != off_101614B0) )
        {
          v425 = (*(int (__cdecl **)(int, void **, int *, int *))(v424 + 20))(v419, v686, v421, &v682);
          goto LABEL_1225;
        }
        v734 = *(void ***)(v698
                         + 8 * (((unsigned __int16)v421 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                         + 588);
        v426 = *(_DWORD *)(v698
                         + 8 * (((unsigned __int16)v421 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                         + 592);
        if ( !v426 )
          goto LABEL_1224;
        if ( v734 != v686 )
          goto LABEL_1224;
        v427 = *(_DWORD *)v426;
        if ( *(int **)v426 != v421 )
          goto LABEL_1224;
        if ( *(_BYTE *)(v426 + 16) & 2 || *(_BYTE *)(v695 + 20) & 2 )
        {
          v424 = v702;
LABEL_1224:
          v425 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(v424 + 20))(v684, v686, v421, &v682);
LABEL_1225:
          v683 = v425;
          goto LABEL_1226;
        }
        v428 = *(_BYTE *)(v426 + 16);
        if ( v428 & 0x20 )
        {
          v683 = sub_10030390(v684, (int)v686, v427, *(_DWORD *)(v426 + 8), 8, 1, (int)&v682, (int)&v682);
          if ( !v683 )
            goto LABEL_10;
          v423 = (int)v686;
        }
        else
        {
          if ( v428 & 0x10 )
          {
            sub_100110F0(v684, (int)sub_1003ED50, 0, 160, 0);
            goto LABEL_9;
          }
          if ( *(_DWORD *)(v426 + 8) )
          {
            if ( *(_BYTE *)(v426 + 17) & 8 )
            {
              v431 = 2 * *(_WORD *)(v426 + 18) | 1;
            }
            else
            {
              v431 = *(_DWORD *)v426;
              if ( !(v427 & 1) )
                v431 = *(_DWORD *)(v427 + 8);
            }
            v432 = *(int (__cdecl **)(_DWORD, void **))(v702 + 48);
            if ( v432 )
              v423 = v432(v684, v686);
            if ( !(*(int (__cdecl **)(_DWORD, int, int, int *))(v426 + 8))(v684, v423, v431, &v682) )
              goto LABEL_9;
            v423 = (int)v686;
          }
          v683 = 1;
        }
        v429 = *(_DWORD *)(v426 + 12);
        if ( v429 < *(_DWORD *)(v695 + 12) )
        {
          v430 = v684;
          *(_DWORD *)(*(_DWORD *)(v423 + 4) + 4 * v429) = v682;
          *(_BYTE *)(*(_DWORD *)(v430 + 24) + 96) = 1;
        }
LABEL_1226:
        if ( !v683 )
          goto LABEL_10;
        --v12;
        goto LABEL_1193;
      case 55:
        v692 = (int *)*(v12 - 1);
        v433 = v692;
        if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
        {
          v434 = HIDWORD(v684);
        }
        else
        {
          v434 = HIDWORD(v684);
          v435 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v436 = (int *)sub_10038B20(v435, (signed int)v433);
          if ( !v436 )
            goto LABEL_9;
          v692 = v436;
          v433 = v436;
        }
        v691 = (void **)*(v12 - 2);
        if ( (unsigned __int8)v691 & 7 || !v691 )
        {
          v437 = v684;
          *(_DWORD *)(v434 + 60) = v12;
          v686 = (void **)sub_10017540(v437, (signed int)v691);
          if ( !v686 )
            goto LABEL_9;
        }
        else
        {
          v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
        }
        *(_DWORD *)(v434 + 60) = v12;
        v438 = (int)v686;
        v439 = *((_DWORD *)*v686 + 1);
        v695 = (int)*v686;
        if ( (int (__cdecl **)(int, int, int, int, int))v439 != &off_101614B0
          && (!v439 || *(int (__cdecl **)(int, int, int, int, int))v439 != off_101614B0)
          || (v735 = *(void ***)(v698
                               + 8 * (((unsigned __int16)v433 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                               + 588),
              (v440 = *(_DWORD *)(v698
                                + 8 * (((unsigned __int16)v433 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                                + 592)) == 0)
          || v735 != v686
          || *(int **)v440 != v433 )
        {
          v425 = (*(int (__cdecl **)(_DWORD, void **, int *, int *))(v439 + 16))(v684, v686, v433, &v682);
          goto LABEL_1225;
        }
        v702 = *(_DWORD *)(v440 + 12);
        v441 = v702;
        if ( v702 == -1 )
          v682 = -2147483647;
        else
          v682 = *((_DWORD *)v686[1] + v702);
        if ( *(_BYTE *)(v440 + 16) & 0x10 )
        {
          v683 = sub_10030390(v684, (int)v686, *(_DWORD *)v440, *(_DWORD *)(v440 + 4), 4, 0, 0, (int)&v682);
          if ( !v683 )
            goto LABEL_10;
          v438 = (int)v686;
        }
        else
        {
          if ( *(_DWORD *)(v440 + 4) )
          {
            if ( *(_BYTE *)(v440 + 17) & 8 )
            {
              v442 = 2 * *(_WORD *)(v440 + 18) | 1;
            }
            else
            {
              v442 = *(_DWORD *)v440;
              if ( !(*(_DWORD *)v440 & 1) )
                v442 = *(_DWORD *)(v442 + 8);
            }
            v443 = *(int (__cdecl **)(_DWORD, void **))(*((_DWORD *)*v686 + 1) + 48);
            if ( v443 )
              v438 = v443(v684, v686);
            if ( !(*(int (__cdecl **)(_DWORD, int, int, int *))(v440 + 4))(v684, v438, v442, &v682) )
              goto LABEL_9;
            v438 = (int)v686;
            v441 = v702;
          }
          v683 = 1;
        }
        if ( *(_DWORD *)(v440 + 12) < *(_DWORD *)(v695 + 12) )
          *(_DWORD *)(*(_DWORD *)(v438 + 4) + 4 * v441) = v682;
        goto LABEL_1226;
      case 56:
        v682 = *(v12 - 1);
        v692 = (int *)*(v12 - 2);
        v444 = v692;
        if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
        {
          v445 = HIDWORD(v684);
        }
        else
        {
          v445 = HIDWORD(v684);
          v446 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v447 = (int *)sub_10038B20(v446, (signed int)v444);
          if ( !v447 )
            goto LABEL_9;
          v692 = v447;
          v444 = v447;
        }
        v691 = (void **)*(v12 - 3);
        if ( (unsigned __int8)v691 & 7 || !v691 )
        {
          v448 = v684;
          *(_DWORD *)(v445 + 60) = v12;
          v686 = (void **)sub_10017540(v448, (signed int)v691);
          if ( !v686 )
            goto LABEL_9;
        }
        else
        {
          v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
        }
        *(_DWORD *)(v445 + 60) = v12;
        v449 = (int)v686;
        v450 = *((_DWORD *)*v686 + 1);
        v695 = (int)*v686;
        v702 = v450;
        if ( (int (__cdecl **)(int, int, int, int, int))v450 != &off_101614B0
          && (!v450 || *(int (__cdecl **)(int, int, int, int, int))v450 != off_101614B0) )
        {
          goto LABEL_1296;
        }
        v736 = *(void ***)(v698
                         + 8 * (((unsigned __int16)v444 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                         + 588);
        v451 = *(_DWORD *)(v698
                         + 8 * (((unsigned __int16)v444 ^ (unsigned __int16)((unsigned int)v686 >> 3)) & 0x3FF)
                         + 592);
        if ( !v451 )
          goto LABEL_1296;
        if ( v736 != v686 )
          goto LABEL_1296;
        v452 = *(_DWORD *)v451;
        if ( *(int **)v451 != v444 )
          goto LABEL_1296;
        if ( *(_BYTE *)(v451 + 16) & 2 || *(_BYTE *)(v695 + 20) & 2 )
        {
          v450 = v702;
LABEL_1296:
          v683 = (*(int (__cdecl **)(_DWORD, void **, int *, int *))(v450 + 20))(v684, v686, v444, &v682);
        }
        else
        {
          v453 = *(_BYTE *)(v451 + 16);
          if ( v453 & 0x20 )
          {
            v683 = sub_10030390(v684, (int)v686, v452, *(_DWORD *)(v451 + 8), 8, 1, (int)&v682, (int)&v682);
            if ( !v683 )
              goto LABEL_10;
            v449 = (int)v686;
          }
          else
          {
            if ( v453 & 0x10 )
            {
LABEL_1615:
              sub_100110F0(v684, (int)sub_1003ED50, 0, 160, 0);
              goto LABEL_9;
            }
            if ( *(_DWORD *)(v451 + 8) )
            {
              if ( *(_BYTE *)(v451 + 17) & 8 )
              {
                v456 = 2 * *(_WORD *)(v451 + 18) | 1;
              }
              else
              {
                v456 = *(_DWORD *)v451;
                if ( !(v452 & 1) )
                  v456 = *(_DWORD *)(v452 + 8);
              }
              v457 = *(int (__cdecl **)(_DWORD, void **))(v702 + 48);
              if ( v457 )
                v449 = v457(v684, v686);
              if ( !(*(int (__cdecl **)(_DWORD, int, int, int *))(v451 + 8))(v684, v449, v456, &v682) )
                goto LABEL_9;
              v449 = (int)v686;
            }
            v683 = 1;
          }
          v454 = *(_DWORD *)(v451 + 12);
          if ( v454 < *(_DWORD *)(v695 + 12) )
          {
            v455 = v684;
            *(_DWORD *)(*(_DWORD *)(v449 + 4) + 4 * v454) = v682;
            *(_BYTE *)(*(_DWORD *)(v455 + 24) + 96) = 1;
          }
        }
        if ( !v683 )
          goto LABEL_10;
        v12 -= 2;
        goto LABEL_1193;
      case 122:
        v692 = (int *)*(v12 - 1);
        v458 = v692;
        if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
        {
          v460 = HIDWORD(v684);
          v459 = v684;
        }
        else
        {
          v460 = HIDWORD(v684);
          v459 = v684;
          v461 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v462 = (int *)sub_10038B20(v461, (signed int)v458);
          if ( !v462 )
            goto LABEL_9;
          v692 = v462;
          v458 = v462;
        }
        v691 = (void **)*(v12 - 2);
        if ( (unsigned __int8)v691 & 7 || !v691 )
        {
          *(_DWORD *)(v460 + 60) = v12;
          v686 = (void **)sub_10017540(v459, (signed int)v691);
          if ( !v686 )
            goto LABEL_9;
          v458 = v692;
        }
        else
        {
          v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
        }
        v682 = *(v12 - 3);
        *(_DWORD *)(v460 + 60) = v12;
        v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*((_DWORD *)*v686 + 1) + 20))(
                 v459,
                 v686,
                 v458,
                 &v682);
        if ( !v683 )
          goto LABEL_10;
        v12 -= 3;
        goto LABEL_44;
      case 57:
        if ( v686 != (void **)1 )
          goto LABEL_1313;
        v686 = (void **)sub_100270E0(v680, SHIDWORD(v684));
        if ( v686 )
          goto LABEL_1313;
        goto LABEL_9;
      case 131:
        goto LABEL_1329;
      case 132:
        v467 = v687;
        v468 = v684;
        HIBYTE(v469) = *(_BYTE *)(v687 + 1);
        LOBYTE(v469) = *(_BYTE *)(v687 + 2);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v470 = sub_1002FC40(v468, v469, 0);
        v471 = *(int (__cdecl **)(_DWORD, int))(v468 + 272);
        v683 = v470;
        v12 = *(int **)(HIDWORD(v684) + 60);
        v707 = v471;
        v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
        if ( !v470 )
          goto LABEL_10;
        if ( !*(_BYTE *)(v468 + 292) )
        {
          sub_100110F0(v468, (int)sub_1003ED50, 0, 129, v681);
          goto LABEL_9;
        }
        v12[-v689] = v467;
        *v12 = *(_DWORD *)(v468 + 288);
        ++v12;
        *(_BYTE *)(v468 + 292) = 0;
        v686 = 0;
        goto LABEL_44;
      case 59:
        v356 = v684;
        HIBYTE(v472) = *(_BYTE *)(v687 + 1);
        LOBYTE(v472) = *(_BYTE *)(v687 + 2);
        v358 = sub_10038D40(v684, v694 + 16, v472);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v692 = v358;
        v683 = sub_10016010(v356, (int)v358, (unsigned int *)&v686, &v703, &v706);
        if ( !v683 )
          goto LABEL_10;
        v473 = v706;
        if ( !v706 )
        {
          for ( i = (_BYTE *)(v687 + v700); ; ++i )
          {
            if ( (unsigned int)i >= v713 )
            {
LABEL_1630:
              v668 = sub_10038330(v356, (int)v358);
              if ( v668 )
                sub_1003F160(v356, v668);
              goto LABEL_9;
            }
            v475 = *i;
            if ( v475 == 39 )
              break;
            if ( v475 != 131 )
              goto LABEL_1630;
          }
LABEL_1001:
          v12[-v689] = v687;
          *v12 = -2147483647;
          ++v12;
          goto LABEL_44;
        }
        v476 = (int (__cdecl **)(int, int, int, int, int))*((_DWORD *)*v686 + 1);
        v477 = v703;
        if ( v476 != &off_101614B0 )
        {
          if ( !v476 )
            goto LABEL_1348;
          if ( *v476 != off_101614B0 )
            goto LABEL_1347;
          v477 = v703;
        }
        v478 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v477 + 4);
        if ( v478 != &off_101614B0 )
        {
          if ( !v478 )
            goto LABEL_1348;
          if ( *v478 != off_101614B0 )
          {
LABEL_1347:
            v477 = v703;
LABEL_1348:
            v479 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v477 + 4) + 52);
            if ( v479 )
              v479(v356, v477, v706);
            v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*((_DWORD *)*v686 + 1) + 16))(
                     v356,
                     v686,
                     v358,
                     &v682);
            if ( !v683 )
              goto LABEL_10;
            goto LABEL_224;
          }
          v477 = v703;
        }
        v480 = (int)v686;
        v697 = v706 + 12;
        v702 = *(_DWORD *)(v706 + 12);
        if ( v702 == -1 )
        {
          v682 = -2147483647;
        }
        else
        {
          v682 = *(_DWORD *)(*(_DWORD *)(v477 + 4) + 4 * v702);
          v480 = (int)v686;
        }
        if ( *(_BYTE *)(v706 + 16) & 0x10 )
        {
          v683 = sub_10030390(v356, v480, *(_DWORD *)v706, *(_DWORD *)(v706 + 4), 4, 0, 0, (int)&v682);
          if ( !v683 )
            goto LABEL_1619;
          v473 = v706;
          v477 = v703;
        }
        else
        {
          v91 = *(_DWORD *)(v706 + 4) == 0;
          v688 = (char **)(v706 + 4);
          if ( !v91 )
          {
            if ( *(_BYTE *)(v706 + 17) & 8 )
            {
              v482 = 2 * *(_WORD *)(v706 + 18) | 1;
            }
            else
            {
              v482 = *(_DWORD *)v706;
              if ( !(*(_DWORD *)v706 & 1) )
                v482 = *(_DWORD *)(*(_DWORD *)v706 + 8);
            }
            v483 = *(int (__cdecl **)(int, int))(*(_DWORD *)(*(_DWORD *)v480 + 4) + 48);
            if ( v483 )
              v484 = v483(v356, v480);
            else
              v484 = v480;
            if ( !((int (__cdecl *)(int, int, int, int *))*v688)(v356, v484, v482, &v682) )
            {
              v683 = 0;
LABEL_1619:
              v660 = *(void (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(*(_DWORD *)v703 + 4) + 52);
              if ( v660 )
                v660(v356, v703, v706);
              goto LABEL_10;
            }
            v473 = v706;
            v477 = v703;
          }
          v683 = 1;
        }
        if ( *(_DWORD *)v697 < *(_DWORD *)(*(_DWORD *)v477 + 12) )
        {
          *(_DWORD *)(*(_DWORD *)(v477 + 4) + 4 * v702) = v682;
          v473 = v706;
          v477 = v703;
        }
        v481 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v477 + 4) + 52);
        if ( v481 )
          v481(v356, v477, v473);
        goto LABEL_224;
      case 88:
        HIBYTE(v485) = *(_BYTE *)(v687 + 1);
        LOBYTE(v485) = *(_BYTE *)(v687 + 2);
        v696 = v485;
        v682 = 2 * v485 | 1;
        v12[-v689] = v687;
        *v12 = v682;
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 60:
      case 61:
        v486 = v687;
        HIBYTE(v487) = *(_BYTE *)(v687 + 1);
        LOBYTE(v487) = *(_BYTE *)(v687 + 2);
        v488 = sub_10038D40(v684, v694 + 16, v487);
        v12[-v689] = v486;
        *v12 = v488[2];
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 80:
        v489 = v687;
        HIBYTE(v490) = *(_BYTE *)(v687 + 1);
        LOBYTE(v490) = *(_BYTE *)(v687 + 2);
        v682 = sub_10038D40(v684, v694 + 16, v490)[2];
        v12[-v689] = v489;
        *v12 = v682;
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 62:
        v12[-v689] = v687;
        *v12 = 1;
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 63:
        v12[-v689] = v687;
        *v12 = 3;
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 64:
        v12[-v689] = v687;
        *v12 = 0;
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 65:
        v491 = HIDWORD(v684);
        v12[-v689] = v687;
        *v12 = *(_DWORD *)(v491 + 20);
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 66:
        v12[-v689] = v687;
        *v12 = 6;
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 67:
        v12[-v689] = v687;
        *v12 = 14;
        ++v12;
        v686 = 0;
        goto LABEL_44;
      case 70:
        v492 = v687;
        LOBYTE(v493) = 0;
        HIBYTE(v493) = *(_BYTE *)(v687 + 1);
        v494 = v684;
        v700 = *(_BYTE *)(v687 + 2) | v493;
        v495 = *(_DWORD *)(v684 + 16);
        if ( v495 && v495 < 140 )
        {
          v496 = *(v12 - 1);
          if ( v496 & 1 && v496 != -2147483647 )
          {
            v497 = v496 >> 1;
            v696 = v496 >> 1;
            --v12;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (int)sub_10020180(__PAIR__(v496, v494), &v696);
            if ( !v683 )
              goto LABEL_10;
            v497 = v696;
            --v12;
          }
        }
        else
        {
          v498 = *(v12 - 1);
          --v12;
          v682 = v498;
          if ( !(v498 & 1) || v498 == -2147483647 )
            goto LABEL_44;
          v492 = v687;
          v497 = v498 >> 1;
          v696 = v497;
        }
        LOBYTE(v499) = 0;
        HIBYTE(v499) = *(_BYTE *)(v492 + 3);
        v500 = *(_BYTE *)(v492 + 6);
        v501 = *(_BYTE *)(v492 + 4) | v499;
        LOBYTE(v499) = 0;
        HIBYTE(v499) = *(_BYTE *)(v492 + 5);
        v502 = v497 - v501;
        v696 = v502;
        if ( v502 < (v500 | (unsigned int)v499) - v501 + 1 )
        {
          LOBYTE(v503) = 0;
          HIBYTE(v503) = *(_BYTE *)(v492 + 2 * v502 + 7);
          v504 = *(_BYTE *)(v492 + 2 * v502 + 8);
          if ( v504 | v503 )
            v700 = v504 | v503;
        }
        goto LABEL_44;
      case 71:
        v505 = *(v12 - 1);
        v506 = v687;
        --v12;
        LOBYTE(v507) = 0;
        v691 = (void **)v505;
        HIBYTE(v507) = *(_BYTE *)(v687 + 1);
        v700 = *(_BYTE *)(v687 + 2) | v507;
        if ( v505 & 1 && v505 != -2147483647 )
          goto LABEL_1402;
        v508 = v505 & 7;
        if ( v508 == 2 || v508 == 4 )
          goto LABEL_1402;
        if ( v508 != 6 )
          goto LABEL_44;
        v506 = v687;
LABEL_1402:
        HIWORD(v511) = 0;
        BYTE1(v511) = *(_BYTE *)(v506 + 3);
        v509 = v506 + 4;
        v510 = v505 & 7;
        LOBYTE(v511) = *(_BYTE *)v509;
        if ( v510 == 4 )
        {
          v701 = (void **)(v505 & 0xFFFFFFF8);
          if ( !v511 )
            goto LABEL_44;
          v695 = v694 + 16;
          while ( 1 )
          {
            HIBYTE(v512) = *(_BYTE *)(v509 + 1);
            LOBYTE(v512) = *(_BYTE *)(v509 + 2);
            v513 = sub_10038D40(v684, v695, v512)[2];
            v682 = v513;
            if ( (v513 & 7) == 4 )
            {
              v514 = v513 & 0xFFFFFFF8;
              if ( (void **)v514 == v701 || !sub_1001AEA0(v514, (int)v701) )
                goto LABEL_1410;
            }
            v509 += 4;
            if ( !--v511 )
              goto LABEL_44;
          }
        }
        if ( v510 == 2 )
        {
          v690 = *(double *)(v505 & 0xFFFFFFF8);
          if ( v511 )
          {
            v695 = v694 + 16;
            while ( 1 )
            {
              HIBYTE(v516) = *(_BYTE *)(v509 + 1);
              LOBYTE(v516) = *(_BYTE *)(v509 + 2);
              v517 = sub_10038D40(v684, v695, v516)[2];
              v682 = v517;
              if ( (v517 & 7) == 2 && v690 == *(double *)(v517 & 0xFFFFFFF8) )
                break;
              v509 += 4;
              if ( !--v511 )
                goto LABEL_44;
            }
            LOBYTE(v518) = 0;
            HIBYTE(v518) = *(_BYTE *)(v509 + 3);
            v700 = *(_BYTE *)(v509 + 4) | v518;
          }
        }
        else if ( v511 )
        {
          v695 = v694 + 16;
          while ( 1 )
          {
            HIBYTE(v519) = *(_BYTE *)(v509 + 1);
            LOBYTE(v519) = *(_BYTE *)(v509 + 2);
            v682 = sub_10038D40(v684, v695, v519)[2];
            if ( v691 == (void **)v682 )
              break;
            v509 += 4;
            if ( !--v511 )
              goto LABEL_44;
          }
LABEL_1410:
          LOBYTE(v515) = 0;
          HIBYTE(v515) = *(_BYTE *)(v509 + 3);
          v700 = *(_BYTE *)(v509 + 4) | v515;
          goto LABEL_44;
        }
        goto LABEL_44;
      case 147:
        v520 = v687;
        HIBYTE(v521) = *(_BYTE *)(v687 + 1);
        LOBYTE(v521) = *(_BYTE *)(v687 + 2);
        v700 = *(_BYTE *)(v687 + 4) | ((*(_BYTE *)(v687 + 3) | (v521 << 8)) << 8);
        v522 = v684;
        v523 = *(_DWORD *)(v684 + 16);
        if ( v523 && v523 < 140 )
        {
          v524 = *(v12 - 1);
          if ( v524 & 1 && v524 != -2147483647 )
          {
            v525 = v524 >> 1;
            v696 = v525;
            --v12;
          }
          else
          {
            *(_DWORD *)(HIDWORD(v684) + 60) = v12;
            v683 = (int)sub_10020180(__PAIR__(v524, v522), &v696);
            if ( !v683 )
              goto LABEL_10;
            v525 = v696;
            --v12;
          }
        }
        else
        {
          v526 = *(v12 - 1);
          --v12;
          v682 = v526;
          if ( !(v526 & 1) || v526 == -2147483647 )
            goto LABEL_44;
          v520 = v687;
          v525 = v526 >> 1;
          v696 = v525;
        }
        v527 = *(_BYTE *)(v520 + 8);
        LOBYTE(v528) = 0;
        HIBYTE(v528) = *(_BYTE *)(v520 + 5);
        v529 = *(_BYTE *)(v520 + 6) | v528;
        LOBYTE(v530) = 0;
        HIBYTE(v530) = *(_BYTE *)(v520 + 7);
        v531 = v525 - v529;
        v696 = v531;
        if ( v531 < (v527 | (unsigned int)v530) - v529 + 1 )
        {
          HIBYTE(v532) = *(_BYTE *)(v520 + 4 * v531 + 9);
          LOBYTE(v532) = *(_BYTE *)(v520 + 4 * v531 + 10);
          v533 = *(_BYTE *)(v520 + 4 * v531 + 12) | ((*(_BYTE *)(v520 + 4 * v531 + 11) | (v532 << 8)) << 8);
          if ( v533 )
            v700 = v533;
        }
        goto LABEL_44;
      case 148:
        v534 = *(v12 - 1);
        --v12;
        v691 = (void **)v534;
        HIBYTE(v535) = *(_BYTE *)(v687 + 1);
        LOBYTE(v535) = *(_BYTE *)(v687 + 2);
        v700 = *(_BYTE *)(v687 + 4) | ((*(_BYTE *)(v687 + 3) | (v535 << 8)) << 8);
        if ( !(v534 & 1) || v534 == -2147483647 )
        {
          v536 = v534 & 7;
          if ( v536 != 2 && v536 != 4 && v536 != 6 )
            goto LABEL_44;
        }
        HIWORD(v539) = 0;
        BYTE1(v539) = *(_BYTE *)(v687 + 5);
        v537 = v687 + 6;
        v538 = v534 & 7;
        LOBYTE(v539) = *(_BYTE *)(v687 + 6);
        if ( v538 == 4 )
        {
          v701 = (void **)(v534 & 0xFFFFFFF8);
          if ( !v539 )
            goto LABEL_44;
          v695 = v694 + 16;
          while ( 1 )
          {
            HIBYTE(v540) = *(_BYTE *)(v537 + 1);
            LOBYTE(v540) = *(_BYTE *)(v537 + 2);
            v541 = sub_10038D40(v684, v695, v540)[2];
            v682 = v541;
            if ( (v541 & 7) == 4 )
            {
              v542 = v541 & 0xFFFFFFF8;
              if ( (void **)v542 == v701 || !sub_1001AEA0(v542, (int)v701) )
                goto LABEL_1450;
            }
            v537 += 6;
            if ( !--v539 )
              goto LABEL_44;
          }
        }
        if ( v538 == 2 )
        {
          v690 = *(double *)(v534 & 0xFFFFFFF8);
          if ( v539 )
          {
            v695 = v694 + 16;
            while ( 1 )
            {
              HIBYTE(v544) = *(_BYTE *)(v537 + 1);
              LOBYTE(v544) = *(_BYTE *)(v537 + 2);
              v545 = sub_10038D40(v684, v695, v544)[2];
              v682 = v545;
              if ( (v545 & 7) == 2 && v690 == *(double *)(v545 & 0xFFFFFFF8) )
                break;
              v537 += 6;
              if ( !--v539 )
                goto LABEL_44;
            }
            HIBYTE(v546) = *(_BYTE *)(v537 + 3);
            LOBYTE(v546) = *(_BYTE *)(v537 + 4);
            v700 = *(_BYTE *)(v537 + 6) | ((*(_BYTE *)(v537 + 5) | (v546 << 8)) << 8);
          }
        }
        else if ( v539 )
        {
          v695 = v694 + 16;
          while ( 1 )
          {
            HIBYTE(v547) = *(_BYTE *)(v537 + 1);
            LOBYTE(v547) = *(_BYTE *)(v537 + 2);
            v682 = sub_10038D40(v684, v695, v547)[2];
            if ( v691 == (void **)v682 )
              break;
            v537 += 6;
            if ( !--v539 )
              goto LABEL_44;
          }
LABEL_1450:
          HIBYTE(v543) = *(_BYTE *)(v537 + 3);
          LOBYTE(v543) = *(_BYTE *)(v537 + 4);
          v700 = *(_BYTE *)(v537 + 6) | ((*(_BYTE *)(v537 + 5) | (v543 << 8)) << 8);
          goto LABEL_44;
        }
        goto LABEL_44;
      case 9:
        v548 = (_DWORD *)HIDWORD(v684);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v549 = sub_10028530(v684, v548, &v682);
        goto LABEL_1466;
      case 136:
        v550 = v687;
        v551 = HIDWORD(v684);
        HIBYTE(v552) = *(_BYTE *)(v687 + 1);
        LOBYTE(v552) = *(_BYTE *)(v687 + 2);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v692 = (int *)(2 * v552 | 1);
        v683 = sub_10026F80(v684, v551, (signed int)v692, (unsigned int *)&v686, &v682);
        if ( !v683 )
          goto LABEL_10;
        if ( !v686 )
          v686 = (void **)1;
        v12[-v689] = v550;
        *v12 = v682;
        ++v12;
        goto LABEL_44;
      case 137:
        v692 = *(int **)(v698 + 264);
        v553 = v692;
        v554 = v684;
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v549 = sub_10026F80(v554, SHIDWORD(v554), (signed int)v553, (unsigned int *)&v686, &v682);
LABEL_1466:
        v683 = v549;
        if ( !v549 )
          goto LABEL_10;
        v12[-v689] = v687;
        *v12 = v682;
        ++v12;
        goto LABEL_44;
      case 84:
        HIBYTE(v555) = *(_BYTE *)(v687 + 1);
        v556 = (unsigned int *)&v12[-v689];
        ++v12;
        LOBYTE(v555) = *(_BYTE *)(v687 + 2);
        *v556 = v687;
        *(v12 - 1) = *(_DWORD *)(*(_DWORD *)(HIDWORD(v684) + 28) + 4 * v555);
        v686 = 0;
        goto LABEL_44;
      case 85:
        HIWORD(v557) = 0;
        BYTE1(v557) = *(_BYTE *)(v687 + 1);
        LOBYTE(v557) = *(_BYTE *)(v687 + 2);
        v558 = *(_DWORD *)(HIDWORD(v684) + 28);
        goto LABEL_1475;
      case 86:
        HIBYTE(v559) = *(_BYTE *)(v687 + 1);
        v560 = (unsigned int *)&v12[-v689];
        ++v12;
        LOBYTE(v559) = *(_BYTE *)(v687 + 2);
        *v560 = v687;
        *(v12 - 1) = *(_DWORD *)(*(_DWORD *)(HIDWORD(v684) + 40) + 4 * v559);
        v686 = 0;
        goto LABEL_44;
      case 87:
        HIWORD(v557) = 0;
        BYTE1(v557) = *(_BYTE *)(v687 + 1);
        LOBYTE(v557) = *(_BYTE *)(v687 + 2);
        v558 = *(_DWORD *)(HIDWORD(v684) + 40);
LABEL_1475:
        *(_BYTE *)(*(_DWORD *)(v684 + 24) + 96) = 1;
        *(_DWORD *)(v558 + 4 * v557) = *(v12 - 1);
        v686 = 0;
        goto LABEL_44;
      case 126:
      case 127:
        v561 = v684;
        HIBYTE(v562) = *(_BYTE *)(v687 + 1);
        LOBYTE(v562) = *(_BYTE *)(v687 + 2);
        v563 = sub_10038D40(v684, v694 + 16, v562);
        v564 = *(_DWORD *)(HIDWORD(v684) + 8);
        v565 = (int)v563;
        v566 = 1;
        v686 = *(void ***)(HIDWORD(v684) + 8);
        v708 = 1;
        if ( !(*(_BYTE *)(HIDWORD(v684) + 76) & 0x20) )
        {
          v566 = 5;
          v708 = 5;
        }
        if ( v702 == 126 )
        {
          v566 |= 2u;
          v708 = v566;
        }
        v692 = (int *)v565;
        v683 = sub_10030430(v561, v564, v565, v566, &v731);
        if ( !v683 )
          goto LABEL_10;
        if ( v731 )
          goto LABEL_44;
        v84 = (*(int (__cdecl **)(int, _DWORD, int, signed int, _DWORD, _DWORD, int, _DWORD))(*((_DWORD *)*v686 + 1) + 12))(
                v561,
                v686,
                v565,
                -2147483647,
                0,
                0,
                v708,
                0);
        goto LABEL_90;
      case 125:
        v567 = v684;
        HIBYTE(v568) = *(_BYTE *)(v687 + 1);
        LOBYTE(v568) = *(_BYTE *)(v687 + 2);
        v686 = (void **)(sub_10038D40(v684, v694 + 16, v568)[2] & 0xFFFFFFF8);
        v569 = sub_10010550(v567, (int)v686);
        v570 = v569;
        v692 = *(int **)(v569 + 24);
        v571 = *(_DWORD *)(HIDWORD(v684) + 52);
        if ( (*((_DWORD *)v686[1] + 1) & 0xFFFFFFF8) != v571 )
        {
          v686 = (void **)sub_100289F0(v567, (int)v686, v571);
          if ( !v686 )
            goto LABEL_9;
        }
        v572 = 1;
        v708 = 1;
        if ( !(*(_BYTE *)(HIDWORD(v684) + 76) & 0x20) )
        {
          v572 = 5;
          v708 = 5;
        }
        v573 = *(_BYTE *)(v570 + 22) & 0x30;
        v697 = *(_BYTE *)(v570 + 22) & 0x30;
        if ( v697 )
        {
          v572 |= v573 | 0x40;
          v708 = v572;
        }
        v574 = *(_DWORD *)(HIDWORD(v684) + 8);
        v683 = sub_10030430(v567, v574, (int)v692, v572, &v685);
        if ( !v683 )
          goto LABEL_10;
        v701 = (void **)-2147483647;
        if ( !v697 )
          v701 = v686;
        v84 = (*(int (__cdecl **)(int, int, int *, void **, unsigned int, unsigned int, int, _DWORD))(*(_DWORD *)(*(_DWORD *)v574 + 4) + 12))(
                v567,
                v574,
                v692,
                v701,
                (v697 & 0x10) != 0 ? (unsigned int)v686 : 0,
                (v697 & 0x20) != 0 ? (unsigned int)v686 : 0,
                v708,
                0);
        goto LABEL_90;
      case 138:
        v575 = v684;
        HIBYTE(v576) = *(_BYTE *)(v687 + 3);
        HIWORD(v577) = 0;
        BYTE1(v577) = *(_BYTE *)(v687 + 1);
        LOBYTE(v576) = *(_BYTE *)(v687 + 4);
        LOBYTE(v577) = *(_BYTE *)(v687 + 2);
        v686 = (void **)(sub_10038D40(v684, v694 + 16, v576)[2] & 0xFFFFFFF8);
        sub_10010550(v575, (int)v686);
        v578 = (int)v686;
        if ( (*((_DWORD *)v686[1] + 1) & 0xFFFFFFF8) != *(_DWORD *)(HIDWORD(v684) + 52) )
        {
          v578 = sub_100289F0(v575, (int)v686, *(_DWORD *)(HIDWORD(v684) + 52));
          v686 = (void **)v578;
          if ( !v578 )
            goto LABEL_9;
        }
        *(_DWORD *)(*(_DWORD *)(HIDWORD(v684) + 40) + 4 * v577) = v578;
        goto LABEL_44;
      case 128:
        v141 = v687;
        v579 = v684;
        HIBYTE(v580) = *(_BYTE *)(v687 + 1);
        LOBYTE(v580) = *(_BYTE *)(v687 + 2);
        v581 = sub_10038D40(v684, v694 + 16, v580)[2] & 0xFFFFFFF8;
        v686 = (void **)v581;
        if ( (*(_DWORD *)(*(_DWORD *)(v581 + 4) + 4) & 0xFFFFFFF8) != *(_DWORD *)(HIDWORD(v684) + 52) )
        {
          v145 = sub_100289F0(v579, v581, *(_DWORD *)(HIDWORD(v684) + 52));
LABEL_230:
          v686 = (void **)v145;
          if ( !v145 )
            goto LABEL_9;
        }
        v12[-v689] = v141;
        *v12 = (int)v686;
        ++v12;
        goto LABEL_44;
      case 129:
        v582 = v684;
        HIBYTE(v583) = *(_BYTE *)(v687 + 1);
        LOBYTE(v583) = *(_BYTE *)(v687 + 2);
        v682 = sub_10038D40(v684, v694 + 16, v583)[2];
        v584 = *(_DWORD *)(HIDWORD(v684) + 52);
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v585 = sub_10017DE0(v582, (const char **)&off_10161510, 0, v584, 0, 0);
        v586 = v585;
        if ( !v585 )
          goto LABEL_9;
        v587 = sub_100289F0(v582, v682 & 0xFFFFFFF8, v585);
        v686 = (void **)v587;
        if ( !v587 )
          goto LABEL_9;
        v588 = sub_10010550(v582, v587);
        v589 = *(_BYTE *)(v588 + 22) & 0x30;
        v695 = v588;
        v708 = v589;
        if ( v589 && (v589 |= 0x40u, (v708 = v589) != 0) )
          v697 = -2147483647;
        else
          v697 = (int)v686;
        v683 = (*(int (__cdecl **)(int, unsigned int, _DWORD, int, unsigned int, unsigned int, int, _DWORD))(*(_DWORD *)(*(_DWORD *)v586 + 4) + 12))(
                 v582,
                 v586,
                 *(_DWORD *)(v695 + 24),
                 v697,
                 (v589 & 0x10) != 0 ? (unsigned int)v686 : 0,
                 (v589 & 0x20) != 0 ? (unsigned int)v686 : 0,
                 v589 | 7,
                 0);
        if ( !v683 )
        {
          *(_DWORD *)(v582 + 92) = 0;
          goto LABEL_10;
        }
LABEL_1313:
        v12[-v689] = v687;
        *v12 = (int)v686;
        ++v12;
        goto LABEL_44;
      case 74:
        v590 = v684;
        HIBYTE(v591) = *(_BYTE *)(v687 + 1);
        LOBYTE(v591) = *(_BYTE *)(v687 + 2);
        v592 = sub_10038D40(v684, v694 + 16, v591);
        v593 = HIDWORD(v684);
        v594 = v592[2] & 0xFFFFFFF8;
        v686 = (void **)v594;
        if ( (*(_DWORD *)(*(_DWORD *)(v594 + 4) + 4) & 0xFFFFFFF8) != *(_DWORD *)(HIDWORD(v684) + 52) )
        {
          v594 = sub_100289F0(v590, v594, *(_DWORD *)(HIDWORD(v684) + 52));
          v686 = (void **)v594;
          if ( !v594 )
            goto LABEL_9;
        }
        v595 = sub_10010550(v590, v594);
        v596 = *(_BYTE *)(v595 + 22) & 0x30;
        v695 = v595;
        v708 = v596;
        if ( v596 && (v596 |= 0x40u, (v708 = v596) != 0) )
          v697 = -2147483647;
        else
          v697 = (int)v686;
        v683 = (*(int (__cdecl **)(int, _DWORD, _DWORD, int, unsigned int, unsigned int, int, _DWORD))(*(_DWORD *)(**(_DWORD **)(v593 + 8) + 4) + 12))(
                 v590,
                 *(_DWORD *)(v593 + 8),
                 *(_DWORD *)(v695 + 24),
                 v697,
                 (v596 & 0x10) != 0 ? (unsigned int)v686 : 0,
                 (v596 & 0x20) != 0 ? (unsigned int)v686 : 0,
                 v596 | 1,
                 0);
        if ( !v683 )
          goto LABEL_1515;
        goto LABEL_44;
      case 123:
      case 124:
        v597 = *(_BYTE *)(v687 + 1);
        v598 = v687 + 1;
        v599 = &off_100D1E40 + 4 * v597;
        v701 = v599;
        v600 = *((_BYTE *)v599 + 8);
        ++v687;
        v700 = v600;
        switch ( v597 )
        {
          case 54:
          case 109:
            v601 = v684;
            HIBYTE(v602) = *(_BYTE *)(v598 + 1);
            LOBYTE(v602) = *(_BYTE *)(v598 + 2);
            v603 = sub_10038D40(v684, v694 + 16, v602);
            v696 = -1;
            v604 = *(v12 - 1);
            v692 = v603;
            v682 = v604;
            goto LABEL_1523;
          case 56:
            v682 = *(v12 - 1);
            v696 = -2;
            v692 = (int *)*(v12 - 2);
            v605 = v692;
            if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
            {
              v601 = v684;
            }
            else
            {
              v601 = v684;
              v606 = v684;
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v607 = (int *)sub_10038B20(v606, (signed int)v605);
              if ( !v607 )
                goto LABEL_9;
              v692 = v607;
            }
LABEL_1523:
            v691 = (void **)v12[v696 - 1];
            if ( (unsigned __int8)v691 & 7 || !v691 )
            {
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v686 = (void **)sub_10017540(v601, (signed int)v691);
              if ( !v686 )
                goto LABEL_9;
            }
            else
            {
              v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
            }
LABEL_1536:
            if ( sub_100101E0(v601, v682) != 2 )
            {
              v670 = "getter";
              if ( v702 != 123 )
                v670 = "setter";
              sub_100110F0(v601, (int)sub_1003ED50, 0, 151, (char)v670);
              goto LABEL_9;
            }
            v683 = (*(int (__cdecl **)(int, void **, int *, signed int, int *, int *))(*((_DWORD *)*v686 + 1) + 44))(
                     v601,
                     v686,
                     v692,
                     3,
                     &v699,
                     &v708);
            if ( !v683 )
              goto LABEL_10;
            if ( v702 == 123 )
            {
              v612 = v682 & 0xFFFFFFF8;
              v697 = 0;
              v613 = 16;
            }
            else
            {
              v612 = 0;
              v697 = v682 & 0xFFFFFFF8;
              v613 = 32;
            }
            v708 = v613 | 0x41;
            v683 = sub_10030430(v601, (int)v686, (int)v692, v613 | 0x41, &v685);
            if ( !v683 )
              goto LABEL_10;
            v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, unsigned int, int, _DWORD, _DWORD))(*((_DWORD *)*v686 + 1) + 12))(
                     v601,
                     v686,
                     v692,
                     -2147483647,
                     v612,
                     v697,
                     v708,
                     0);
            if ( !v683 )
              goto LABEL_10;
            v12 += v696;
            if ( *((_BYTE *)v701 + 10) )
              goto LABEL_1193;
            break;
          case 91:
            v601 = v684;
            v696 = -1;
            v682 = *(v12 - 1);
            HIBYTE(v608) = *(_BYTE *)(v598 + 1);
            LOBYTE(v608) = *(_BYTE *)(v598 + 2);
            v692 = sub_10038D40(v684, v694 + 16, v608);
            goto LABEL_1534;
          case 92:
            v682 = *(v12 - 1);
            v696 = -2;
            v692 = (int *)*(v12 - 2);
            v609 = v692;
            if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
            {
              v601 = v684;
            }
            else
            {
              v601 = v684;
              v610 = v684;
              *(_DWORD *)(HIDWORD(v684) + 60) = v12;
              v611 = (int *)sub_10038B20(v610, (signed int)v609);
              if ( !v611 )
                goto LABEL_9;
              v692 = v611;
            }
LABEL_1534:
            v691 = (void **)v12[v696 - 1];
            v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
            goto LABEL_1536;
          default:
            v601 = v684;
            goto LABEL_1536;
        }
        goto LABEL_44;
      case 89:
        ++*(_DWORD *)(HIDWORD(v684) + 68);
        v701 = 0;
LABEL_1546:
        v614 = 4 * (_DWORD)v701 + 8;
        v703 = 0;
        v615 = *(int *)((char *)v12 - v614);
        v702 = (int)v12 - v614;
        v695 = 0;
        v691 = (void **)v615;
        if ( !(v615 & 7)
          && (v616 = v615 & 0xFFFFFFF8, (v703 = v616) != 0)
          && (char **)(*(_DWORD *)(*(_DWORD *)(v616 + 4) + 8) & 0xFFFFFFFE) != &off_101621B8
          && *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v616 + 4) + 60) )
        {
          v590 = v684;
        }
        else
        {
          v590 = v684;
          v617 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v695 = sub_10028AB0(v617, (int *)((char *)v12 - v614), 1);
          if ( !v695 )
          {
            v683 = 0;
            goto LABEL_10;
          }
          v616 = v703;
        }
        v688 = &off_10161510;
        if ( v616 )
        {
          v683 = (*(int (__cdecl **)(int, unsigned int, _DWORD, int *))(*(_DWORD *)(*(_DWORD *)v616 + 4) + 16))(
                   v590,
                   v616,
                   *(_DWORD *)(v698 + 232),
                   &v682);
          if ( !v683 )
            goto LABEL_10;
          if ( v682 & 7 )
            v697 = 0;
          else
            v697 = v682 & 0xFFFFFFF8;
          v619 = *(_DWORD *)(v703 + 4);
          v618 = *(_DWORD *)(v619 + 4) & 0xFFFFFFF8;
          if ( (char **)(*(_DWORD *)(v619 + 8) & 0xFFFFFFFE) == &off_101621B8 )
          {
            v620 = *(char ***)(sub_10010550(v590, v703) + 28);
            if ( v620 )
              v688 = v620;
          }
        }
        else
        {
          v618 = 0;
          v697 = 0;
          v695 = 0;
        }
        v621 = sub_10017C40(v590, (int)v688, v697, v618);
        v686 = (void **)v621;
        if ( !v621 )
          goto LABEL_9;
        v622 = HIDWORD(v684);
        v623 = (unsigned int)v701;
        *(_DWORD *)(v702 + 4) = v621;
        *(_DWORD *)(v622 + 60) = v12;
        v624 = sub_1002FC40(v590, v623, 1);
        v625 = *(int (__cdecl **)(_DWORD, int))(v590 + 272);
        v683 = v624;
        v12 = *(int **)(v622 + 60);
        v707 = v625;
        v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v698 + 492);
        if ( !v624 )
        {
LABEL_1515:
          *(_DWORD *)(v590 + 92) = 0;
          goto LABEL_10;
        }
        v626 = *(_DWORD *)v702;
        v682 = *(_DWORD *)v702;
        if ( v682 & 7 || !v626 )
        {
          if ( !v695 )
          {
            v627 = *(_DWORD *)(v590 + 16);
            if ( !v627 || v627 >= 130 )
            {
              v671 = sub_1001ACB0(v590, v626);
              if ( v671 )
              {
                v672 = (unsigned int)sub_10010FF0(v671);
                sub_100110F0(v590, (int)sub_1003ED50, 0, 28, v672);
              }
              goto LABEL_9;
            }
          }
          *(_DWORD *)v702 = v686;
        }
        else
        {
          v686 = (void **)(v626 & 0xFFFFFFF8);
        }
        goto LABEL_44;
      case 90:
        v628 = HIDWORD(v684);
        v91 = *(_DWORD *)(HIDWORD(v684) + 68) == 1;
        --*(_DWORD *)(v628 + 68);
        if ( v91 )
          *(_DWORD *)(v628 + 72) = 0;
        v691 = (void **)*(v12 - 1);
        *(_DWORD *)(v684 + 92) = (unsigned int)v691 & 0xFFFFFFF8;
        goto LABEL_44;
      case 91:
        v682 = *(v12 - 1);
        HIBYTE(v629) = *(_BYTE *)(v687 + 1);
        LOBYTE(v629) = *(_BYTE *)(v687 + 2);
        v692 = sub_10038D40(v684, v694 + 16, v629);
        v630 = -1;
        goto LABEL_1580;
      case 92:
        v682 = *(v12 - 1);
        v692 = (int *)*(v12 - 2);
        v631 = v692;
        if ( (unsigned __int8)v692 & 1 && v692 != (int *)-2147483647 )
          goto LABEL_1579;
        v632 = v684;
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v633 = (int *)sub_10038B20(v632, (signed int)v631);
        if ( !v633 )
          goto LABEL_9;
        v692 = v633;
LABEL_1579:
        v630 = -2;
LABEL_1580:
        v696 = v630;
        v691 = (void **)v12[v630 - 1];
        v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
        v683 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(*((_DWORD *)*v686 + 1) + 20))(
                 v684,
                 v686,
                 v692,
                 &v682);
        if ( !v683 )
          goto LABEL_10;
        v12 += v696;
        goto LABEL_44;
      case 93:
        v634 = HIDWORD(v684);
        v686 = *(void ***)(HIDWORD(v684) + 72);
        v635 = (int)v686;
        if ( v686 )
          goto LABEL_1585;
        v636 = sub_1002EAB0(v684, 0, 0);
        v686 = (void **)v636;
        if ( !v636 )
          goto LABEL_9;
        *(_DWORD *)(v634 + 72) = v636;
        v635 = (int)v686;
LABEL_1585:
        HIBYTE(v637) = *(_BYTE *)(v687 + 1);
        LOBYTE(v637) = *(_BYTE *)(v687 + 2);
        v696 = v637;
        v638 = *(v12 - 1);
        v692 = (int *)(2 * v637 | 1);
        v682 = v638;
        if ( v638 & 7 || !v638 )
        {
          sub_10050B00((int)&v740, 12, "%u", v637);
          sub_100110F0(v684, (int)sub_1003ED50, 0, 29, (unsigned int)&v740);
          goto LABEL_9;
        }
        v84 = (*(int (__cdecl **)(_DWORD, int, int, int *))(*(_DWORD *)(*(_DWORD *)v635 + 4) + 20))(
                v684,
                v635,
                2 * v637 | 1,
                &v682);
        goto LABEL_90;
      case 94:
        v639 = v687;
        HIBYTE(v640) = *(_BYTE *)(v687 + 1);
        LOBYTE(v640) = *(_BYTE *)(v687 + 2);
        v696 = v640;
        v641 = *(_DWORD *)(HIDWORD(v684) + 72);
        v692 = (int *)(2 * v640 | 1);
        v686 = (void **)v641;
        if ( v641 )
        {
          v683 = (*(int (__cdecl **)(_DWORD, int, int, int *))(*(_DWORD *)(*(_DWORD *)v641 + 4) + 16))(
                   v684,
                   v641,
                   2 * v640 | 1,
                   &v682);
          if ( !v683 )
            goto LABEL_10;
          LOBYTE(v640) = v696;
        }
        else
        {
          v682 = -2147483647;
        }
        if ( v682 & 7 )
        {
          sub_10050B00((int)&v741, 12, "%u", v640);
          sub_100110F0(v684, (int)sub_1003ED50, 0, 30, (unsigned int)&v741);
          goto LABEL_9;
        }
        v12[-v689] = v639;
        *v12 = v682;
        ++v12;
        goto LABEL_44;
      case 117:
        HIBYTE(v642) = *(_BYTE *)(v687 + 1);
        LOBYTE(v642) = *(_BYTE *)(v687 + 2);
        v696 = v642;
        v12 = (int *)(*(_DWORD *)(HIDWORD(v684) + 64) + 4 * v642);
        goto LABEL_44;
      case 114:
        LOBYTE(v643) = 0;
        v696 = v687 + v700 - *(_DWORD *)(v694 + 8);
        HIBYTE(v643) = *(_BYTE *)(v687 + 1);
        v700 = *(_BYTE *)(v687 + 2) | v643;
        *v12 = 2 * v696 | 1;
        ++v12;
        goto LABEL_44;
      case 144:
        v696 = v687 + v700 - *(_DWORD *)(v694 + 8);
        HIBYTE(v644) = *(_BYTE *)(v687 + 1);
        LOBYTE(v644) = *(_BYTE *)(v687 + 2);
        v700 = *(_BYTE *)(v687 + 4) | ((*(_BYTE *)(v687 + 3) | (v644 << 8)) << 8);
        *v12 = 2 * v696 | 1;
        ++v12;
        goto LABEL_44;
      case 115:
        v645 = *(v12 - 1);
        --v12;
        v682 = v645;
        v696 = v645 >> 1;
        v687 = (v645 >> 1) + *(_DWORD *)(v694 + 8);
        v700 = 0;
        goto LABEL_44;
      case 116:
        *v12 = *(_DWORD *)(v684 + 296);
        ++v12;
        goto LABEL_44;
      case 130:
        v646 = *(v12 - 1);
        v647 = v684;
        --v12;
        v682 = v646;
        HIBYTE(v648) = *(_BYTE *)(v687 + 1);
        LOBYTE(v648) = *(_BYTE *)(v687 + 2);
        v649 = sub_10038D40(v684, v694 + 16, v648);
        v691 = (void **)*(v12 - 1);
        v686 = (void **)((unsigned int)v691 & 0xFFFFFFF8);
        v650 = *(_DWORD *)(*(_DWORD *)((unsigned int)v691 & 0xFFFFFFF8) + 4);
        v692 = v649;
        v84 = (*(int (__cdecl **)(int, unsigned int, int *, int, _DWORD, _DWORD, signed int, _DWORD))(v650 + 12))(
                v647,
                (unsigned int)v691 & 0xFFFFFFF8,
                v649,
                v682,
                0,
                0,
                4,
                0);
        goto LABEL_90;
      case 112:
        v682 = *(v12 - 1);
        if ( v682 & 7 || !v682 )
        {
          v674 = v684;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v675 = sub_1004F8E0(v674, -1, v682, 0);
          if ( v675 )
          {
            v676 = (unsigned int)sub_10010FF0((unsigned int)v675);
            sub_100110F0(v674, (int)sub_1003ED50, 0, 31, v676);
          }
          goto LABEL_9;
        }
        v686 = (void **)(v682 & 0xFFFFFFF8);
        v691 = (void **)*(v12 - 2);
        v685 = 0;
        if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v682 & 0xFFFFFFF8) + 4) + 68) )
        {
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = (*(int (__cdecl **)(_DWORD, void **, void **, int *))(*((_DWORD *)*v686 + 1) + 68))(
                   v684,
                   v686,
                   v691,
                   &v685);
          if ( !v683 )
            goto LABEL_10;
        }
        --v12;
        v12[-v689 - 1] = v687;
        *(v12 - 1) = 8 * v685 | 6;
        goto LABEL_44;
      case 113:
        v651 = v698;
        v652 = *(int (__cdecl **)(int, int, unsigned int, int *, _DWORD))(v698 + 516);
        if ( !v652 )
          goto LABEL_44;
        v653 = v684;
        *(_DWORD *)(HIDWORD(v684) + 60) = v12;
        v654 = v651;
        v655 = v652(v653, v694, v687, &v682, *(_DWORD *)(v651 + 520));
        if ( !v655 )
          goto LABEL_9;
        v656 = v655 - 2;
        if ( !v656 )
        {
          *(_DWORD *)(HIDWORD(v684) + 32) = v682;
          goto LABEL_10;
        }
        if ( v656 == 1 )
        {
          v677 = v682;
          *(_BYTE *)(v653 + 294) = 1;
          *(_DWORD *)(v653 + 296) = v677;
          goto LABEL_9;
        }
        v709 = *(int (__cdecl **)(_DWORD, int, unsigned int, int *, _DWORD))(v654 + 492);
        goto LABEL_44;
      case 5:
        v657 = v707;
        if ( v707 )
        {
          v658 = v694;
          *(_DWORD *)(HIDWORD(v684) + 60) = v12;
          v683 = v657(v684, v658);
          if ( !v683 )
            goto LABEL_10;
        }
        v659 = *(v12 - 1);
        --v12;
        *(_DWORD *)(HIDWORD(v684) + 32) = v659;
        goto LABEL_1613;
      case 153:
LABEL_1613:
        if ( !v710 )
          goto LABEL_10;
        v13 = HIDWORD(v684);
        v14 = v684;
        goto LABEL_26;
      case 110:
        v673 = v684;
        --v12;
        *(_BYTE *)(v684 + 294) = 1;
        *(_DWORD *)(v673 + 296) = *v12;
        goto LABEL_9;
      default:
        sub_10050B00((int)&v742, 12, "%d", v702);
        sub_100110F0(v684, (int)sub_1003ED50, 0, 32, (unsigned int)&v742);
        goto LABEL_9;
    }
  }
}
// 100305F0: too many cbuild loops
// 100D1E40: using guessed type void *off_100D1E40;
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);
// 10161510: using guessed type char *off_10161510;
// 101616B0: using guessed type char *off_101616B0;
// 101621B8: using guessed type char *off_101621B8;
// 10162A98: using guessed type char *off_10162A98;

//----- (10038170) --------------------------------------------------------
int __cdecl sub_10038170(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // esi@1
  int (__cdecl *v7)(int, int *, signed int, _DWORD, _DWORD); // ecx@1
  int v8; // eax@1
  int v9; // ebp@1
  int v10; // edi@1
  int v11; // ecx@3
  unsigned int i; // eax@4
  int result; // eax@16
  void (__cdecl *v14)(int, int *, _DWORD, int *, int); // ecx@17
  int (__cdecl *v15)(int, int *, signed int, _DWORD, _DWORD); // [sp+10h] [bp-5Ch]@1
  int v16; // [sp+14h] [bp-58h]@1
  int v17; // [sp+18h] [bp-54h]@1
  int v18; // [sp+1Ch] [bp-50h]@2
  int v19; // [sp+20h] [bp-4Ch]@1
  int v20; // [sp+24h] [bp-48h]@2
  int v21; // [sp+28h] [bp-44h]@2
  int v22; // [sp+2Ch] [bp-40h]@2
  int v23; // [sp+30h] [bp-3Ch]@2
  int v24; // [sp+34h] [bp-38h]@8
  int v25; // [sp+38h] [bp-34h]@2
  int v26; // [sp+3Ch] [bp-30h]@2
  int v27; // [sp+40h] [bp-2Ch]@8
  int v28; // [sp+44h] [bp-28h]@2
  int v29; // [sp+48h] [bp-24h]@8
  int v30; // [sp+4Ch] [bp-20h]@8
  int v31; // [sp+50h] [bp-1Ch]@9
  int v32; // [sp+54h] [bp-18h]@11
  int v33; // [sp+58h] [bp-14h]@11
  int v34; // [sp+5Ch] [bp-10h]@2
  int v35; // [sp+60h] [bp-Ch]@11
  int v36; // [sp+64h] [bp-8h]@11
  int v37; // [sp+68h] [bp-4h]@11

  v6 = a1;
  v7 = *(int (__cdecl **)(int, int *, signed int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 24) + 532);
  v8 = a4;
  v9 = 0;
  v10 = *(_DWORD *)(a1 + 56);
  v19 = a3;
  v15 = v7;
  v17 = 0;
  v16 = 0;
  if ( a4 )
  {
    v18 = *(_DWORD *)(a4 + 8);
    v20 = *(_DWORD *)(a4 + 16);
    v21 = *(_DWORD *)(a4 + 20);
    v22 = *(_DWORD *)(a4 + 24);
    v23 = *(_DWORD *)(a4 + 28);
    v25 = *(_DWORD *)(a4 + 36);
    v26 = *(_DWORD *)(a4 + 40);
    v28 = *(_DWORD *)(a4 + 48);
    v34 = *(_DWORD *)(a4 + 72);
  }
  else
  {
    v11 = a2;
    if ( *(_BYTE *)(a1 + 300) & 4 )
    {
      for ( i = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) & 0xFFFFFFF8; i; i = *(_DWORD *)(*(_DWORD *)(i + 4) + 4) & 0xFFFFFFF8 )
        v11 = i;
      v8 = a4;
    }
    v18 = v11;
    v20 = 0;
    v21 = a2;
    v25 = 0;
    v22 = 0;
    v26 = 0;
    v23 = 0;
    v28 = 0;
    v34 = 0;
  }
  v24 = -2147483647;
  v27 = v8;
  v29 = a2;
  v30 = 0;
  if ( v10 )
    v31 = *(_DWORD *)(v10 + 60);
  else
    v31 = 0;
  v32 = 0;
  v33 = 0;
  v35 = a5;
  v36 = 0;
  v37 = 0;
  if ( v10 && v10 != v8 )
  {
    *(_DWORD *)(v10 + 80) = *(_DWORD *)(a1 + 284);
    *(_DWORD *)(v6 + 284) = v10;
  }
  *(_DWORD *)(v6 + 56) = &v16;
  if ( v15 )
    v9 = v15(v6, &v16, 1, 0, *(_DWORD *)(*(_DWORD *)(v6 + 24) + 536));
  result = sub_100305F0(v6, &v24);
  a1 = result;
  *a6 = v24;
  if ( v9 )
  {
    v14 = *(void (__cdecl **)(int, int *, _DWORD, int *, int))(*(_DWORD *)(v6 + 24) + 532);
    if ( v14 )
    {
      v14(v6, &v16, 0, &a1, v9);
      result = a1;
    }
  }
  *(_DWORD *)(v6 + 56) = v10;
  if ( v10 )
  {
    if ( v10 != a4 )
    {
      *(_DWORD *)(v6 + 284) = *(_DWORD *)(v10 + 80);
      *(_DWORD *)(v10 + 80) = 0;
      result = a1;
    }
  }
  return result;
}

//----- (10038330) --------------------------------------------------------
int __cdecl sub_10038330(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@2

  result = sub_1004C310(a1, *(_DWORD *)(a2 + 8) & 0xFFFFFFF8, 0);
  if ( result )
  {
    v3 = sub_1001B200(result);
    if ( !v3 )
      sub_10011170(a1);
    result = v3;
  }
  return result;
}

//----- (10038370) --------------------------------------------------------
unsigned int __cdecl sub_10038370(signed int a1)
{
  unsigned int result; // eax@1
  int v2; // ecx@1

  result = a1;
  v2 = a1 & 7;
  if ( v2 == 4 )
  {
    result = sub_1001AE10(a1 & 0xFFFFFFF8);
  }
  else if ( a1 & 1 && a1 != -2147483647 )
  {
    result = a1 >> 1;
  }
  else if ( v2 == 2 )
  {
    result = *(_DWORD *)(a1 & 0xFFFFFFF8) ^ *(_DWORD *)((a1 & 0xFFFFFFF8) + 4);
  }
  else if ( a1 & 7 )
  {
    if ( v2 == 6 )
      result = a1 >> 3;
  }
  else
  {
    result = (unsigned int)a1 >> 3;
  }
  return result;
}

//----- (100383C0) --------------------------------------------------------
signed int __cdecl sub_100383C0(int a1, int a2)
{
  int v2; // esi@1
  signed int result; // eax@3
  double v4; // st7@6
  double v5; // st6@6
  double v6; // [sp+4h] [bp-10h]@6
  double v7; // [sp+Ch] [bp-8h]@6

  v2 = a1 & 7;
  if ( v2 == 4 && (a2 & 7) == 4 )
    return sub_1001AEA0(a1 & 0xFFFFFFF8, a2 & 0xFFFFFFF8) == 0;
  if ( v2 != 2 || (a2 & 7) != 2 )
  {
    result = a1 == a2;
  }
  else
  {
    v4 = *(double *)(a1 & 0xFFFFFFF8);
    v6 = v4;
    v5 = *(double *)(a2 & 0xFFFFFFF8);
    v7 = v5;
    if ( (HIDWORD(v6) & 0x7FF00000) == 2146435072 && (LODWORD(v6) || HIDWORD(v6) & 0xFFFFF) )
    {
      if ( (HIDWORD(v7) & 0x7FF00000) != 2146435072 || !LODWORD(v7) && !(HIDWORD(v7) & 0xFFFFF) )
        return 0;
    }
    else if ( v5 != v4 )
    {
      return 0;
    }
    result = 1;
  }
  return result;
}

//----- (10038490) --------------------------------------------------------
signed int sub_10038490()
{
  return 1;
}

//----- (100384A0) --------------------------------------------------------
int __cdecl sub_100384A0(int a1, unsigned int a2)
{
  return sub_10053CF0(a2, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100384C0) --------------------------------------------------------
int *__cdecl sub_100384C0(int a1, unsigned int a2)
{
  return sub_10053E10(a2, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100384E0) --------------------------------------------------------
int __cdecl sub_100384E0(int a1, int a2)
{
  int result; // eax@1

  result = sub_10053CF0(0x18u, dword_10658DEC);
  if ( result )
  {
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 8) = a2;
    *(_DWORD *)(result + 20) = (*(_DWORD *)(a1 + 8))++;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10038520) --------------------------------------------------------
int *__cdecl sub_10038520(int a1, unsigned int a2, int a3)
{
  int *result; // eax@2

  if ( a3 == 1 )
    result = sub_10053E10(a2, dword_10658DEC);
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10038540) --------------------------------------------------------
void *__cdecl sub_10038540(int a1, void *a2)
{
  if ( *((_DWORD *)a2 + 1) )
    sub_100512D0(*((_DWORD *)a2 + 1));
  return memset(a2, 0, 0x13Cu);
}

//----- (10038570) --------------------------------------------------------
int __cdecl sub_10038570(int a1, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@2

  v3 = *(_DWORD *)(a1 + 8) & 7;
  if ( v3 == 4 )
  {
    sub_1001AC30(*(_DWORD *)a3, *(_DWORD *)(a1 + 8) & 0xFFFFFFF8);
    result = 0;
  }
  else
  {
    if ( !v3 )
      ++*(_DWORD *)(a3 + 4);
    result = 0;
  }
  return result;
}

//----- (100385B0) --------------------------------------------------------
void *__cdecl sub_100385B0(void *a1)
{
  void *result; // eax@1
  int v2; // [sp+4h] [bp-8h]@2
  int v3; // [sp+8h] [bp-4h]@2

  result = (void *)*((_DWORD *)a1 + 1);
  if ( result )
  {
    v2 = *(_DWORD *)a1;
    v3 = 0;
    sub_100515D0((int)result, (int (__cdecl *)(_DWORD *, int, int))sub_10038570, (int)&v2);
    result = sub_10038540(0, a1);
  }
  return result;
}

//----- (100385F0) --------------------------------------------------------
int __cdecl sub_100385F0(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // eax@3

  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 & 3 || *(_BYTE *)a3 & 1 )
  {
    *(_DWORD *)(a1 + 16) = v3 | 4;
    v4 = *(_DWORD *)(a1 + 8);
    if ( !(v4 & 1) && (v4 & 7) != 6 )
      (*(void (__cdecl **)(unsigned int, _DWORD))(a3 + 4))(v4 & 0xFFFFFFF8, *(_DWORD *)(a3 + 8));
  }
  return 0;
}

//----- (10038630) --------------------------------------------------------
int __cdecl sub_10038630(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@2
  int v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = *(_DWORD *)(a1 + 4);
  if ( result )
  {
    v6 = a3;
    v5 = a2;
    v7 = a4;
    result = sub_100515D0(result, (int (__cdecl *)(_DWORD *, int, int))sub_100385F0, (int)&v5);
  }
  return result;
}

//----- (10038670) --------------------------------------------------------
signed int __cdecl sub_10038670(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int result; // eax@2

  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 & 4 )
  {
    *(_DWORD *)(a1 + 16) = v3 & 0xFFFFFFFB;
    ++*(_DWORD *)(a3 + 12);
    result = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    result = 2;
  }
  return result;
}

//----- (100386A0) --------------------------------------------------------
int __cdecl sub_100386A0(int a1)
{
  int result; // eax@1
  int v2; // ecx@1

  result = a1;
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 12) = 0;
  if ( v2 )
    result = sub_100515D0(v2, (int (__cdecl *)(_DWORD *, int, int))sub_10038670, a1);
  return result;
}

//----- (100386D0) --------------------------------------------------------
int __cdecl sub_100386D0(int a1)
{
  *(_DWORD *)(a1 + 16) &= 0xFFFFFFFE;
  return 0;
}

//----- (100386E0) --------------------------------------------------------
int __cdecl sub_100386E0(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 4);
  if ( result )
    result = sub_100515D0(result, (int (__cdecl *)(_DWORD *, int, int))sub_100386D0, 0);
  return result;
}

//----- (10038700) --------------------------------------------------------
int __usercall sub_10038700@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4)
{
  int v4; // esi@1
  int *v5; // eax@1
  int *v6; // ecx@1
  int result; // eax@1
  int v8; // [sp+0h] [bp-10h]@0
  int v9; // [sp+4h] [bp-Ch]@0

  v4 = *(_DWORD *)(*(_DWORD *)(a3 + 24) + 112);
  v5 = sub_10051360(v4, v8, v9);
  v6 = v5;
  result = *v5;
  if ( result || (result = sub_100513D0(v4, v6, a2, a1, 0)) != 0 )
  {
    *(_DWORD *)(result + 16) |= a4;
    *(_DWORD *)(a3 + 124) = result;
  }
  else
  {
    sub_10011170(a3);
    result = 0;
  }
  return result;
}

//----- (10038750) --------------------------------------------------------
int __cdecl sub_10038750(int a1, unsigned int a2, int a3)
{
  return sub_10038700(a2, a2 >> 3, a1, a3);
}

//----- (10038770) --------------------------------------------------------
int __cdecl sub_10038770(int a1, int a2, int a3)
{
  return sub_10038700(8 * a2 | 6, a2, a1, a3);
}

//----- (100387A0) --------------------------------------------------------
int __cdecl sub_100387A0(int a1, int a2, int a3)
{
  return sub_10038700(2 * a2 | 1, a2, a1, a3);
}

//----- (100387D0) --------------------------------------------------------
int __cdecl sub_100387D0(int a1, double a2, int a3)
{
  char v3; // sp@1
  char v4; // cl@1
  char *v5; // eax@1
  int v6; // esi@1
  int v7; // edx@1
  int v8; // ebx@1
  int *v9; // eax@1
  int *v10; // ebp@1
  int result; // eax@1
  int v12; // [sp+1Ch] [bp-18h]@1
  char v13[8]; // [sp+28h] [bp-Ch]@1

  v4 = v3 + 12;
  v5 = &v13[-(v4 & 7)];
  *(double *)v5 = a2;
  v6 = *(_DWORD *)v5 ^ *((_DWORD *)v5 + 1);
  v7 = *(_DWORD *)(a1 + 24);
  v12 = (unsigned int)v5 | 2;
  v8 = *(_DWORD *)(v7 + 112);
  v9 = sub_10051360(*(_DWORD *)(v7 + 112), v6, (unsigned int)v5 | 2);
  v10 = v9;
  result = *v9;
  if ( !result )
  {
    if ( !sub_1001F5D0(a1, a2, (int)&v12) )
      return 0;
    result = sub_100513D0(v8, v10, v6, v12, 0);
    if ( !result )
    {
      sub_10011170(a1);
      return 0;
    }
  }
  *(_DWORD *)(result + 16) |= a3;
  *(_DWORD *)(a1 + 124) = result;
  return result;
}
// 100387D0: using guessed type char var_C[8];

//----- (10038890) --------------------------------------------------------
int __cdecl sub_10038890(int a1, int a2, char a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // ebp@1
  int v6; // ebx@1
  int v7; // esi@1
  int *v8; // eax@1
  int result; // eax@1
  char *v10; // eax@4
  int v11; // [sp+14h] [bp+4h]@1
  int *v12; // [sp+18h] [bp+8h]@1

  v3 = a2;
  v4 = sub_1001AE10(a2);
  v5 = a1;
  v6 = v4;
  v7 = a2 | 4;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 112);
  v8 = sub_10051360(v11, v4, a2 | 4);
  v12 = v8;
  result = *v8;
  if ( !result )
  {
    if ( a3 >= 0 )
    {
      if ( !sub_100110A0(v5, v3) )
        return 0;
    }
    else
    {
      if ( a3 & 0x40 )
        v10 = (char *)sub_1001AB10(v5, *(_DWORD *)(v3 + 4), *(_DWORD *)v3, 0);
      else
        v10 = sub_1001AB60(v5, *(void **)(v3 + 4), *(_DWORD *)v3, 0);
      if ( !v10 )
        return 0;
      v7 = (unsigned int)v10 | 4;
    }
    result = sub_100513D0(v11, v12, v6, v7, 0);
    if ( !result )
    {
      sub_10011170(v5);
      return 0;
    }
  }
  *(_DWORD *)(result + 16) |= a3 & 3;
  *(_DWORD *)(v5 + 124) = result;
  return result;
}

//----- (10038950) --------------------------------------------------------
char *__cdecl sub_10038950(int a1, int a2, unsigned int a3, char a4)
{
  char v4; // cl@2
  char *v5; // esi@2
  char *result; // eax@3
  char v7; // sp@5
  char *v8; // eax@5
  int v9; // edi@5
  char v10[8]; // [sp+14h] [bp-4Ch]@5
  char v11; // [sp+1Ch] [bp-44h]@2

  if ( a3 >= 0x20 )
  {
    result = (char *)sub_1001B0E0(a1, a2, a3);
    v5 = result;
    if ( !result )
      return result;
    v4 = a4 | 0x40;
  }
  else
  {
    sub_1001B0A0(&v11, a2, a3);
    v4 = a4;
    v5 = &v11;
  }
  v8 = &v10[-((v7 + 12) & 7)];
  *((_DWORD *)v8 + 1) = v5;
  *(_DWORD *)v8 = a3;
  v9 = sub_10038890(a1, (int)v8, v4 | 0x80);
  if ( v5 != &v11 && (!v9 || *(char **)((*(_DWORD *)(v9 + 8) & 0xFFFFFFF8) + 4) != v5) )
    sub_10010340(a1, (unsigned int)v5);
  return (char *)v9;
}
// 10038950: using guessed type char var_4C[8];

//----- (10038A10) --------------------------------------------------------
int __cdecl sub_10038A10(int a1, int a2, int a3, char a4)
{
  char v4; // sp@1
  char *v5; // eax@1
  char v7[8]; // [sp+8h] [bp-Ch]@1

  v5 = &v7[-(v4 & 7)];
  *((_DWORD *)v5 + 1) = a2;
  *(_DWORD *)v5 = a3;
  return sub_10038890(a1, (int)v5, a4 | 0x80);
}
// 10038A10: using guessed type char var_C[8];

//----- (10038A60) --------------------------------------------------------
int __cdecl sub_10038A60(int a1, int a2, int a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = a2 & 7;
  if ( v3 == 4 )
  {
    result = sub_10038890(a1, a2 & 0xFFFFFFF8, a3);
  }
  else if ( a2 & 1 && a2 != -2147483647 )
  {
    result = sub_100387A0(a1, a2 >> 1, a3);
  }
  else if ( v3 == 2 )
  {
    result = sub_100387D0(a1, *(double *)(a2 & 0xFFFFFFF8), a3);
  }
  else if ( a2 & 7 )
  {
    if ( v3 == 6 )
      result = sub_10038770(a1, a2 >> 3, a3);
    else
      result = sub_10038700(a2, a2, a1, a3);
  }
  else
  {
    result = sub_10038750(a1, a2 & 0xFFFFFFF8, a3);
  }
  return result;
}

//----- (10038B20) --------------------------------------------------------
int __cdecl sub_10038B20(int a1, signed int a2)
{
  int result; // eax@1

  result = sub_1001ACB0(a1, a2);
  if ( result )
    result = sub_10038890(a1, result, 0);
  return result;
}

//----- (10038B50) --------------------------------------------------------
int __cdecl sub_10038B50(int a1)
{
  return *(_DWORD *)(a1 + 20);
}

//----- (10038B60) --------------------------------------------------------
int __cdecl sub_10038B60(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // esi@1
  unsigned int v4; // eax@1

  v2 = *(_DWORD *)(a1 + 76);
  v3 = *(_DWORD *)(v2 + 12);
  v4 = (a2 + 3) & 0xFFFFFFFC;
  if ( v3 + v4 <= *(_DWORD *)(v2 + 8) )
    *(_DWORD *)(v2 + 12) = v3 + v4;
  else
    v3 = sub_1003E2D0(a1 + 60, v4);
  if ( !v3 )
    sub_10011170(a1);
  return v3;
}

//----- (10038BC0) --------------------------------------------------------
int __cdecl sub_10038BC0(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 76);
  result = *(_DWORD *)(v1 + 12);
  if ( (unsigned int)(result + 16) <= *(_DWORD *)(v1 + 8) )
    *(_DWORD *)(v1 + 12) = result + 16;
  else
    result = sub_1003E2D0(a1 + 60, 0x10u);
  if ( !result )
  {
    sub_10011170(a1);
    result = 0;
  }
  return result;
}

//----- (10038C10) --------------------------------------------------------
int __cdecl sub_10038C10(int a1, int a2, int a3)
{
  int v3; // eax@1
  int *v4; // eax@2
  int *v5; // ecx@2
  int result; // eax@2
  _DWORD *v7; // edx@4
  int v8; // ecx@13
  int v9; // eax@15
  int v10; // esi@16
  int v11; // ecx@17
  int v12; // ebx@17
  int v13; // ST10_4@17
  _DWORD *v14; // eax@17
  int v15; // eax@18

  v3 = *(_DWORD *)(a3 + 4);
  if ( v3 )
  {
    v4 = sub_10051360(v3, *(_DWORD *)(a2 + 20), a2);
    v5 = v4;
    result = *v4;
    if ( !result )
      goto LABEL_10;
  }
  else
  {
    result = *(_DWORD *)a3;
    v5 = 0;
    v7 = (_DWORD *)a3;
    if ( !*(_DWORD *)a3 )
      goto LABEL_10;
    while ( *(_DWORD *)(result + 8) != a2 )
    {
      v7 = (_DWORD *)result;
      result = *(_DWORD *)result;
      if ( !result )
        goto LABEL_10;
    }
    *v7 = *(_DWORD *)result;
    *(_DWORD *)result = *(_DWORD *)a3;
    *(_DWORD *)a3 = result;
  }
  if ( result )
    return result;
LABEL_10:
  if ( *(_DWORD *)(a3 + 8) >= 0xAu )
  {
    if ( !*(_DWORD *)(a3 + 4) )
    {
      v9 = sub_100511F0(8u, (int)sub_10038B50, (int)sub_100516C0, (int)sub_100516C0, &off_10162B10, a1);
      *(_DWORD *)(a3 + 4) = v9;
      if ( !v9 )
        return 0;
      v10 = *(_DWORD *)a3;
      if ( *(_DWORD *)a3 )
      {
        do
        {
          v11 = *(_DWORD *)(*(_DWORD *)(v10 + 8) + 20);
          v12 = *(_DWORD *)v10;
          v13 = *(_DWORD *)(v10 + 8);
          *(_DWORD *)(v10 + 4) = v11;
          v14 = sub_10051360(*(_DWORD *)(a3 + 4), v11, v13);
          *(_DWORD *)v10 = *v14;
          *v14 = v10;
          v10 = v12;
        }
        while ( v12 );
      }
      v15 = *(_DWORD *)(a3 + 4);
      *(_DWORD *)a3 = 0;
      v5 = sub_10051360(v15, *(_DWORD *)(a2 + 20), a2);
    }
    result = sub_100513D0(*(_DWORD *)(a3 + 4), v5, *(_DWORD *)(a2 + 20), a2, 0);
    if ( !result )
      return 0;
    *(_DWORD *)(result + 12) = (*(_DWORD *)(a3 + 8))++;
  }
  else
  {
    result = sub_10038BC0(a1);
    if ( !result )
      return 0;
    *(_DWORD *)(result + 8) = a2;
    *(_DWORD *)result = *(_DWORD *)a3;
    v8 = *(_DWORD *)(a3 + 8);
    *(_DWORD *)a3 = result;
    *(_DWORD *)(result + 12) = v8;
    ++*(_DWORD *)(a3 + 8);
  }
  return result;
}
// 10162B10: using guessed type int (__cdecl *off_10162B10)(int, int);

//----- (10038D40) --------------------------------------------------------
int *__cdecl sub_10038D40(int a1, int a2, unsigned int a3)
{
  int *result; // eax@3
  char v4; // [sp+4h] [bp-10h]@4

  if ( *(_DWORD *)a2 && a3 < *(_DWORD *)(a2 + 4) )
  {
    result = *(int **)(*(_DWORD *)a2 + 4 * a3);
  }
  else
  {
    sub_10050B00((int)&v4, 12, "%lu", a3);
    sub_100110F0(a1, (int)sub_1003ED50, 0, 13, (unsigned int)&v4);
    dword_10572690 = 0;
    dword_10572694 = 0;
    dword_10572698 = 0;
    dword_1057269C = 0;
    dword_105726A0 = 0;
    dword_105726A4 = 0;
    result = &dword_10572690;
  }
  return result;
}
// 10572690: using guessed type int dword_10572690;
// 10572694: using guessed type int dword_10572694;
// 10572698: using guessed type int dword_10572698;
// 1057269C: using guessed type int dword_1057269C;
// 105726A0: using guessed type int dword_105726A0;
// 105726A4: using guessed type int dword_105726A4;

//----- (10038DE0) --------------------------------------------------------
int __cdecl sub_10038DE0(int a1, int a2, int a3)
{
  *(_DWORD *)(a3 + 4 * *(_DWORD *)(a1 + 12)) = *(_DWORD *)(a1 + 8);
  return 0;
}

//----- (10038E00) --------------------------------------------------------
int __usercall sub_10038E00@<eax>(char a1@<bpl>, int a2, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@3
  unsigned int v6; // ebp@4
  int v7; // ebx@6
  int v8; // eax@7
  char v9; // [sp-4h] [bp-Ch]@4

  v4 = *(_DWORD *)a4;
  if ( *(_DWORD *)a4 || *(_DWORD *)(a4 + 4) )
  {
    v9 = a1;
    v6 = *(_DWORD *)(a4 + 8);
    if ( v6 < 0x10000 )
    {
      result = sub_10011830(a2, 4 * v6);
      v7 = result;
      if ( result )
      {
        v8 = *(_DWORD *)(a4 + 4);
        if ( v8 )
        {
          sub_100515D0(v8, (int (__cdecl *)(_DWORD *, int, int))sub_10038DE0, v7);
        }
        else
        {
          do
          {
            *(_DWORD *)(v7 + 4 * *(_DWORD *)(v4 + 12)) = *(_DWORD *)(v4 + 8);
            v4 = *(_DWORD *)v4;
          }
          while ( v4 );
        }
        *(_DWORD *)a4 = 0;
        *(_DWORD *)(a4 + 4) = 0;
        *(_DWORD *)(a4 + 8) = 0;
        *(_DWORD *)a3 = v7;
        *(_DWORD *)(a3 + 4) = v6;
        result = 1;
      }
    }
    else
    {
      sub_100110F0(a2, (int)sub_1003ED50, 0, 14, v9);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    result = 1;
  }
  return result;
}
// 10038E00: could not find valid save-restore pair for ebp

//----- (10038EB0) --------------------------------------------------------
int *__cdecl sub_10038EB0(int a1, int a2)
{
  int *result; // eax@1

  result = *(int **)a2;
  if ( *(_DWORD *)a2 )
  {
    result = sub_10010340(a1, *(_DWORD *)a2);
    *(_DWORD *)a2 = 0;
  }
  *(_DWORD *)(a2 + 4) = 0;
  return result;
}

//----- (10038EE0) --------------------------------------------------------
signed int __cdecl sub_10038EE0(int a1, int a2)
{
  int v2; // eax@1
  char **v3; // ebp@1
  char *v4; // eax@2
  char *v5; // eax@4
  char *v6; // eax@5
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@8
  char *v10; // eax@9
  char *v11; // eax@10
  char *v12; // eax@11
  char *v13; // eax@12
  char *v14; // eax@13
  char *v15; // eax@14
  char *v16; // eax@15
  char *v17; // eax@16
  char *v18; // eax@17
  char *v19; // eax@18
  char *v20; // eax@19
  char *v21; // eax@20
  char *v22; // eax@21
  char *v23; // eax@22
  char *v24; // eax@23
  char *v25; // eax@24
  char *v26; // eax@25
  char *v27; // eax@26
  char *v28; // eax@27
  char *v29; // eax@28
  char *v30; // eax@29
  char *v31; // eax@30
  char *v32; // eax@31
  char *v33; // eax@32
  char *v34; // eax@33
  char *v35; // eax@34
  char *v36; // eax@35
  char *v37; // eax@36
  char *v38; // eax@37
  char *v39; // eax@38
  char *v40; // eax@39
  char *v41; // eax@40
  char *v42; // eax@41
  char *v43; // eax@42
  char *v44; // eax@43
  unsigned int v46; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v3 = (char **)(a2 + 16);
  v46 = 0;
  while ( 1 )
  {
    v4 = sub_10038950(a1, *(int *)((char *)off_10162AE0 + v2), strlen(*(char **)((char *)off_10162AE0 + v2)), 1);
    *v3 = v4;
    if ( !v4 )
      break;
    v2 = v46 + 4;
    ++v3;
    v46 += 4;
    if ( v46 >= 0x18 )
    {
      v5 = sub_10038950(a1, (int)"false", strlen("false"), 1);
      *(_DWORD *)(a2 + 40) = v5;
      if ( v5 )
      {
        v6 = sub_10038950(a1, (int)"true", strlen("true"), 1);
        *(_DWORD *)(a2 + 44) = v6;
        if ( v6 )
        {
          v7 = sub_10038950(a1, (int)"null", strlen("null"), 1);
          *(_DWORD *)(a2 + 48) = v7;
          if ( v7 )
          {
            v8 = sub_10038950(a1, (int)"Arguments", 9u, 1);
            *(_DWORD *)(a2 + 52) = v8;
            if ( v8 )
            {
              v9 = sub_10038950(a1, (int)"Array", 5u, 1);
              *(_DWORD *)(a2 + 56) = v9;
              if ( v9 )
              {
                v10 = sub_10038950(a1, (int)"Boolean", 7u, 1);
                *(_DWORD *)(a2 + 60) = v10;
                if ( v10 )
                {
                  v11 = sub_10038950(a1, (int)"Call", 4u, 1);
                  *(_DWORD *)(a2 + 64) = v11;
                  if ( v11 )
                  {
                    v12 = sub_10038950(a1, (int)"Date", 4u, 1);
                    *(_DWORD *)(a2 + 68) = v12;
                    if ( v12 )
                    {
                      v13 = sub_10038950(a1, (int)"Error", strlen("Error"), 1);
                      *(_DWORD *)(a2 + 72) = v13;
                      if ( v13 )
                      {
                        v14 = sub_10038950(a1, (int)"Function", 8u, 1);
                        *(_DWORD *)(a2 + 76) = v14;
                        if ( v14 )
                        {
                          v15 = sub_10038950(a1, (int)"Math", 4u, 1);
                          *(_DWORD *)(a2 + 80) = v15;
                          if ( v15 )
                          {
                            v16 = sub_10038950(a1, (int)"Number", 6u, 1);
                            *(_DWORD *)(a2 + 84) = v16;
                            if ( v16 )
                            {
                              v17 = sub_10038950(a1, (int)"Object", 6u, 1);
                              *(_DWORD *)(a2 + 88) = v17;
                              if ( v17 )
                              {
                                v18 = sub_10038950(a1, (int)"RegExp", 6u, 1);
                                *(_DWORD *)(a2 + 92) = v18;
                                if ( v18 )
                                {
                                  v19 = sub_10038950(a1, (int)"Script", 6u, 1);
                                  *(_DWORD *)(a2 + 96) = v19;
                                  if ( v19 )
                                  {
                                    v20 = sub_10038950(a1, (int)"String", 6u, 1);
                                    *(_DWORD *)(a2 + 100) = v20;
                                    if ( v20 )
                                    {
                                      v21 = sub_10038950(a1, (int)"anonymous", 9u, 1);
                                      *(_DWORD *)(a2 + 104) = v21;
                                      if ( v21 )
                                      {
                                        v22 = sub_10038950(a1, (int)"arguments", 9u, 1);
                                        *(_DWORD *)(a2 + 108) = v22;
                                        if ( v22 )
                                        {
                                          v23 = sub_10038950(a1, (int)"arity", 5u, 1);
                                          *(_DWORD *)(a2 + 112) = v23;
                                          if ( v23 )
                                          {
                                            v24 = sub_10038950(a1, (int)"callee", 6u, 1);
                                            *(_DWORD *)(a2 + 116) = v24;
                                            if ( v24 )
                                            {
                                              v25 = sub_10038950(a1, (int)"caller", 6u, 1);
                                              *(_DWORD *)(a2 + 120) = v25;
                                              if ( v25 )
                                              {
                                                v26 = sub_10038950(a1, (int)"prototype", 9u, 1);
                                                *(_DWORD *)(a2 + 124) = v26;
                                                if ( v26 )
                                                {
                                                  v27 = sub_10038950(a1, (int)"constructor", 0xBu, 1);
                                                  *(_DWORD *)(a2 + 128) = v27;
                                                  if ( v27 )
                                                  {
                                                    v28 = sub_10038950(a1, (int)"__count__", 9u, 1);
                                                    *(_DWORD *)(a2 + 132) = v28;
                                                    if ( v28 )
                                                    {
                                                      v29 = sub_10038950(a1, (int)"eval", 4u, 1);
                                                      *(_DWORD *)(a2 + 136) = v29;
                                                      if ( v29 )
                                                      {
                                                        v30 = sub_10038950(a1, (int)"get", 3u, 1);
                                                        *(_DWORD *)(a2 + 140) = v30;
                                                        if ( v30 )
                                                        {
                                                          v31 = sub_10038950(a1, (int)"getter", 6u, 1);
                                                          *(_DWORD *)(a2 + 144) = v31;
                                                          if ( v31 )
                                                          {
                                                            v32 = sub_10038950(a1, (int)"index", 5u, 1);
                                                            *(_DWORD *)(a2 + 148) = v32;
                                                            if ( v32 )
                                                            {
                                                              v33 = sub_10038950(a1, (int)"input", 5u, 1);
                                                              *(_DWORD *)(a2 + 152) = v33;
                                                              if ( v33 )
                                                              {
                                                                v34 = sub_10038950(a1, (int)"length", 6u, 1);
                                                                *(_DWORD *)(a2 + 156) = v34;
                                                                if ( v34 )
                                                                {
                                                                  v35 = sub_10038950(a1, (int)"name", 4u, 1);
                                                                  *(_DWORD *)(a2 + 160) = v35;
                                                                  if ( v35 )
                                                                  {
                                                                    v36 = sub_10038950(
                                                                            a1,
                                                                            (int)"__noSuchMethod__",
                                                                            0x10u,
                                                                            1);
                                                                    *(_DWORD *)(a2 + 164) = v36;
                                                                    if ( v36 )
                                                                    {
                                                                      v37 = sub_10038950(a1, (int)"__parent__", 0xAu, 1);
                                                                      *(_DWORD *)(a2 + 168) = v37;
                                                                      if ( v37 )
                                                                      {
                                                                        v38 = sub_10038950(a1, (int)"__proto__", 9u, 1);
                                                                        *(_DWORD *)(a2 + 172) = v38;
                                                                        if ( v38 )
                                                                        {
                                                                          v39 = sub_10038950(a1, (int)"set", 3u, 1);
                                                                          *(_DWORD *)(a2 + 176) = v39;
                                                                          if ( v39 )
                                                                          {
                                                                            v40 = sub_10038950(a1, (int)"setter", 6u, 1);
                                                                            *(_DWORD *)(a2 + 180) = v40;
                                                                            if ( v40 )
                                                                            {
                                                                              v41 = sub_10038950(
                                                                                      a1,
                                                                                      (int)"toSource",
                                                                                      8u,
                                                                                      1);
                                                                              *(_DWORD *)(a2 + 188) = v41;
                                                                              if ( v41 )
                                                                              {
                                                                                v42 = sub_10038950(
                                                                                        a1,
                                                                                        (int)"toString",
                                                                                        8u,
                                                                                        1);
                                                                                *(_DWORD *)(a2 + 192) = v42;
                                                                                if ( v42 )
                                                                                {
                                                                                  v43 = sub_10038950(
                                                                                          a1,
                                                                                          (int)"toLocaleString",
                                                                                          0xEu,
                                                                                          1);
                                                                                  *(_DWORD *)(a2 + 184) = v43;
                                                                                  if ( v43 )
                                                                                  {
                                                                                    v44 = sub_10038950(
                                                                                            a1,
                                                                                            (int)"valueOf",
                                                                                            7u,
                                                                                            1);
                                                                                    *(_DWORD *)(a2 + 196) = v44;
                                                                                    if ( v44 )
                                                                                    {
                                                                                      memset(
                                                                                        (void *)(a2 + 200),
                                                                                        0,
                                                                                        0x74u);
                                                                                      return 1;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return 0;
    }
  }
  return 0;
}
// 10162AE0: using guessed type char *off_10162AE0[8];

//----- (10039470) --------------------------------------------------------
int __cdecl sub_10039470(int a1, void *a2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = sub_100511F0(0x400u, (int)sub_10038370, (int)sub_100383C0, (int)sub_10038490, off_10162B00, (int)a2);
  *((_DWORD *)a2 + 1) = v2;
  if ( v2 )
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 24);
    if ( sub_10038EE0(a1, (int)a2) )
    {
      result = 1;
    }
    else
    {
      sub_10038540(a1, a2);
      result = 0;
    }
  }
  else
  {
    sub_10011170(a1);
    result = 0;
  }
  return result;
}
// 10162B00: using guessed type int (__cdecl *off_10162B00[3])(int, int);

//----- (100394E0) --------------------------------------------------------
int __usercall sub_100394E0@<eax>(int result@<eax>)
{
  *(_WORD *)(result + 22) = 28;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 36) = 0;
  return result;
}

//----- (10039500) --------------------------------------------------------
int __cdecl sub_10039500(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // esi@1

  result = sub_10011830(a1, 0x28u);
  v6 = result;
  if ( result )
  {
    sub_10015820(result, a2, a3, a4);
    *(_DWORD *)(v6 + 16) = a5;
    *(_WORD *)(v6 + 20) = 0;
    result = sub_100394E0(v6);
  }
  return result;
}

//----- (10039550) --------------------------------------------------------
int *__cdecl sub_10039550(int a1, unsigned int a2)
{
  if ( *(_DWORD *)(a2 + 32) )
    sub_10010340(a1, *(_DWORD *)(a2 + 32));
  return sub_10010340(a1, a2);
}

//----- (10039580) --------------------------------------------------------
unsigned int *__cdecl sub_10039580(int a1, signed int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ecx@2
  unsigned int *result; // eax@2
  signed int v6; // esi@7
  unsigned int v7; // esi@9
  __int16 v8; // bp@9
  unsigned int v9; // edx@9
  int v10; // eax@9
  unsigned int *v11; // ebx@9
  char v12; // cl@14
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // edi@19
  int v16; // eax@19
  unsigned int v17; // ecx@19
  unsigned int v18; // ebp@20
  unsigned int *v19; // [sp+4h] [bp-Ch]@15
  unsigned int v20; // [sp+8h] [bp-8h]@11
  int v21; // [sp+Ch] [bp-4h]@14

  v3 = *(_DWORD *)(a1 + 32);
  if ( v3 )
  {
    if ( a2 & 1 )
      v6 = a2 >> 1;
    else
      v6 = *(_DWORD *)(a2 + 20);
    v7 = -1640531527 * v6;
    v8 = *(_WORD *)(a1 + 22);
    v9 = v7 >> *(_WORD *)(a1 + 22);
    v10 = *(_DWORD *)(v3 + 4 * v9);
    v11 = (unsigned int *)(v3 + 4 * v9);
    if ( v10 )
    {
      v20 = v10 & 0xFFFFFFFE;
      if ( v10 & 0xFFFFFFFE && *(_DWORD *)v20 == a2 )
      {
        result = v11;
      }
      else
      {
        v12 = 32 - v8;
        v13 = (v7 << (32 - v8) >> v8) | 1;
        v21 = v13;
        v14 = (1 << v12) - 1;
        if ( v10 == 1 )
        {
          v19 = v11;
        }
        else
        {
          v19 = 0;
          if ( a3 && !(v10 & 1) )
            *v11 = v20 | 1;
        }
        v15 = v14 & (v9 - v13);
        v16 = *(_DWORD *)(a1 + 32);
        v17 = *(_DWORD *)(v16 + 4 * v15);
        result = (unsigned int *)(v16 + 4 * v15);
        if ( v17 )
        {
          while ( 1 )
          {
            v18 = v17 & 0xFFFFFFFE;
            if ( v17 & 0xFFFFFFFE )
            {
              if ( *(_DWORD *)v18 == a2 )
                break;
            }
            if ( v17 == 1 )
            {
              if ( !v19 )
                v19 = result;
            }
            else if ( a3 && !(v17 & 1) )
            {
              *result = v18 | 1;
            }
            v15 = v14 & (v15 - v21);
            result = (unsigned int *)(*(_DWORD *)(a1 + 32) + 4 * v15);
            v17 = *result;
            if ( !*result )
              goto LABEL_29;
          }
        }
        else
        {
LABEL_29:
          if ( a3 && v19 )
            result = v19;
        }
      }
    }
    else
    {
      result = v11;
    }
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 36);
    for ( result = (unsigned int *)(a1 + 36); v4; v4 = *(_DWORD *)(v4 + 20) )
    {
      if ( *(_DWORD *)v4 == a2 )
        break;
      result = (unsigned int *)(v4 + 20);
    }
  }
  return result;
}

//----- (100396D0) --------------------------------------------------------
signed int __usercall sub_100396D0@<eax>(__int16 a1@<dx>, int a2@<edi>, int a3)
{
  __int16 v3; // cx@1
  __int16 v4; // bx@1
  signed int v5; // esi@1
  void *v6; // eax@1
  signed int result; // eax@2
  _DWORD *v8; // ebp@3
  signed int *v9; // ebx@5
  _DWORD *v10; // [sp+8h] [bp-4h]@3

  v3 = 32 - *(_WORD *)(a2 + 22);
  v4 = v3 + a1;
  v5 = 1 << v3;
  v6 = sub_10053DA0(4 * (1 << (v3 + a1)), 1u, dword_10658DEC);
  if ( v6 )
  {
    v8 = *(_DWORD **)(a2 + 32);
    *(_WORD *)(a2 + 22) = 32 - v4;
    *(_DWORD *)(a2 + 28) = 0;
    v10 = v8;
    *(_DWORD *)(a2 + 32) = v6;
    if ( v5 )
    {
      do
      {
        if ( *v8 & 0xFFFFFFFE )
        {
          v9 = (signed int *)(*v8 & 0xFFFFFFFE);
          *sub_10039580(a2, *v9, 1) = (unsigned int)v9;
        }
        --v5;
        ++v8;
      }
      while ( v5 );
      v8 = v10;
    }
    sub_10010340(a3, (unsigned int)v8);
    result = 1;
  }
  else
  {
    sub_10011170(a3);
    result = 0;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10039780) --------------------------------------------------------
unsigned int __cdecl sub_10039780(int a1, int a2)
{
  unsigned int v2; // ecx@1
  int v3; // eax@3
  unsigned int v4; // eax@5
  unsigned int v5; // ecx@5
  unsigned int v6; // eax@5

  v2 = 0;
  if ( *(_DWORD *)(a2 + 4) )
    v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 8);
  if ( v3 )
    v2 = v3 ^ 16 * v2 ^ (v2 >> 28);
  v4 = 16 * v2 ^ (v2 >> 28) ^ *(_BYTE *)(a2 + 17) & 0xFC;
  v5 = 16 * v4 ^ (v4 >> 28) ^ *(_BYTE *)(a2 + 16);
  v6 = 16 * v5 ^ (v5 >> 28) ^ *(_WORD *)(a2 + 18);
  return *(_DWORD *)a2 ^ 16 * (*(_DWORD *)(a2 + 12) ^ 16 * v6 ^ (v6 >> 28)) ^ ((*(_DWORD *)(a2 + 12) ^ 16 * v6 ^ (v6 >> 28)) >> 28);
}

//----- (10039800) --------------------------------------------------------
BOOL __cdecl sub_10039800(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = *(_DWORD *)(a2 + 4);
  return *(_DWORD *)v3 == *(_DWORD *)a3
      && *(_DWORD *)(v3 + 4) == *(_DWORD *)(a3 + 4)
      && *(_DWORD *)(v3 + 8) == *(_DWORD *)(a3 + 8)
      && *(_DWORD *)(v3 + 12) == *(_DWORD *)(a3 + 12)
      && *(_BYTE *)(v3 + 16) == *(_BYTE *)(a3 + 16)
      && !((*(_BYTE *)(a3 + 17) ^ *(_BYTE *)(v3 + 17)) & 0xFFFFFFFC)
      && *(_WORD *)(v3 + 18) == *(_WORD *)(a3 + 18);
}

//----- (10039860) --------------------------------------------------------
int __usercall sub_10039860@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int result; // eax@1
  int v3; // ecx@2
  int v4; // ecx@4

  v1 = a1;
  result = *(_DWORD *)(a1 + 8832);
  if ( result )
  {
    **(_DWORD **)(result + 8) = *(_DWORD *)(result + 4);
    v3 = *(_DWORD *)(result + 4);
    if ( v3 )
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(result + 8);
  }
  else
  {
    v4 = *(_DWORD *)(v1 + 8852);
    result = *(_DWORD *)(v4 + 12);
    if ( (unsigned int)(result + 28) <= *(_DWORD *)(v4 + 8) )
      *(_DWORD *)(v4 + 12) = result + 28;
    else
      result = sub_1003E2D0(v1 + 8836, 0x1Cu);
  }
  return result;
}

//----- (100398C0) --------------------------------------------------------
void *sub_100398C0()
{
  return sub_10053DA0(1u, 0x2Cu, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100398E0) --------------------------------------------------------
int *__thiscall sub_100398E0(void *this)
{
  return sub_10053E10((unsigned int)this, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100398F0) --------------------------------------------------------
signed int __usercall sub_100398F0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // esi@1
  unsigned int *v4; // eax@2
  int v6; // ebx@6
  _DWORD *v7; // esi@6
  unsigned int v8; // ebx@8
  unsigned int v9; // ecx@9
  _DWORD *v10; // eax@9
  _DWORD *v11; // edi@12
  _DWORD *v12; // eax@13
  _DWORD *v13; // eax@15

  v3 = a2;
  if ( a2 )
  {
    v6 = *(_DWORD *)(a2 + 24);
    v7 = (_DWORD *)(a2 + 24);
    if ( v6 )
    {
      if ( v6 & 1 )
      {
        v8 = v6 & 0xFFFFFFFE;
LABEL_9:
        v9 = 0;
        v10 = (_DWORD *)v8;
        while ( 1 )
        {
          v7 = v10;
          if ( !*v10 )
            break;
          ++v9;
          ++v10;
          if ( v9 >= 0xA )
          {
            v11 = (_DWORD *)(v8 + 40);
            v8 = *(_DWORD *)(v8 + 40);
            if ( v8 )
              goto LABEL_9;
            v12 = sub_100398C0();
            if ( v12 )
            {
              *v11 = v12;
              *v12 = a3;
              *(_DWORD *)(a3 + 20) = a2;
              return 1;
            }
            return 0;
          }
        }
      }
      else
      {
        v13 = sub_100398C0();
        if ( !v13 )
          return 0;
        *v7 = (unsigned int)v13 | 1;
        *v13 = v6;
        v7 = v13 + 1;
      }
    }
    *v7 = a3;
    v3 = a2;
  }
  else
  {
    v4 = sub_1003F720(a1 + 8800, a3, 1);
    if ( !v4 )
      return 0;
    if ( !v4[1] )
    {
      v4[1] = a3;
      *(_DWORD *)(a3 + 20) = a2;
      return 1;
    }
  }
  *(_DWORD *)(a3 + 20) = v3;
  return 1;
}

//----- (100399B0) --------------------------------------------------------
unsigned int __usercall sub_100399B0@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // edi@1
  int v3; // esi@2
  unsigned int result; // eax@2
  unsigned int v5; // esi@5
  int *v6; // ebx@5
  unsigned int v7; // edx@6
  int v8; // edi@11
  _DWORD *v9; // ecx@11
  unsigned int v10; // eax@12
  bool v11; // zf@23
  unsigned int v12; // [sp+8h] [bp-8h]@5
  int v13; // [sp+Ch] [bp-4h]@1

  v2 = a1;
  v13 = *(_DWORD *)(a1 + 20);
  if ( !v13 )
  {
    v3 = a2 + 8800;
    result = (unsigned int)sub_1003F720(a2 + 8800, a1, 0);
    if ( *(_DWORD *)(result + 4) == v2 )
      result = sub_1003F580(v3, (int *)result);
    return result;
  }
  result = *(_DWORD *)(v13 + 24);
  if ( !(result & 1) )
  {
    if ( result == v2 )
      *(_DWORD *)(v13 + 24) = 0;
    return result;
  }
  result &= 0xFFFFFFFE;
  v5 = result;
  v12 = result;
  v6 = (int *)&v12;
  while ( 2 )
  {
    v7 = 0;
    do
    {
      if ( *(_DWORD *)(v5 + 4 * v7) == v2 )
      {
        v8 = v5 + 40;
        v9 = (_DWORD *)v5;
        if ( *(_DWORD *)(v5 + 40) )
        {
          v10 = 0;
          do
          {
            v6 = (int *)v8;
            v9 = *(_DWORD **)v8;
            v11 = *(_DWORD *)(*(_DWORD *)v8 + 40) == 0;
            v8 = *(_DWORD *)v8 + 40;
          }
          while ( !v11 );
        }
        else
        {
          v10 = v7 + 1;
          if ( v7 + 1 >= 0xA )
          {
LABEL_15:
            result = v10 - 1;
            if ( (_DWORD *)v5 != v9 || result > v7 )
              *(_DWORD *)(v5 + 4 * v7) = v9[result];
            v9[result] = 0;
            if ( !result )
            {
              *v6 = 0;
              if ( !v12 )
                *(_DWORD *)(v13 + 24) = 0;
              result = (unsigned int)sub_100398E0(v9);
            }
            return result;
          }
        }
        do
        {
          if ( !v9[v10] )
            break;
          ++v10;
        }
        while ( v10 < 0xA );
        goto LABEL_15;
      }
      ++v7;
    }
    while ( v7 < 0xA );
    v6 = (int *)(v5 + 40);
    v5 = *(_DWORD *)(v5 + 40);
    if ( v5 )
      continue;
    return result;
  }
}

//----- (10039AA0) --------------------------------------------------------
int __usercall sub_10039AA0@<eax>(int a1@<esi>, int a2, int a3)
{
  unsigned int *v3; // eax@2
  unsigned int v4; // edi@3
  int result; // eax@4
  unsigned int v6; // edi@8
  int v7; // ecx@9
  unsigned int *v8; // [sp+8h] [bp-8h]@2
  int v9; // [sp+Ch] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 24);
  if ( !a3 )
  {
    v3 = sub_1003F720(*(_DWORD *)(a2 + 24) + 8800, a1, 1);
    v8 = v3;
    if ( !v3 )
      goto LABEL_32;
    v4 = v3[1];
    if ( v4 )
      return v4;
    goto LABEL_28;
  }
  result = *(_DWORD *)(a3 + 24);
  v8 = 0;
  if ( !result )
    goto LABEL_28;
  if ( result & 1 )
  {
    v6 = result & 0xFFFFFFFE;
LABEL_9:
    v7 = 0;
    while ( 1 )
    {
      result = *(_DWORD *)(v6 + 4 * v7);
      if ( !result )
        goto LABEL_28;
      if ( *(_DWORD *)result == *(_DWORD *)a1
        && *(_DWORD *)(result + 4) == *(_DWORD *)(a1 + 4)
        && *(_DWORD *)(result + 8) == *(_DWORD *)(a1 + 8)
        && *(_DWORD *)(result + 12) == *(_DWORD *)(a1 + 12)
        && *(_BYTE *)(result + 16) == *(_BYTE *)(a1 + 16)
        && !((*(_BYTE *)(a1 + 17) ^ *(_BYTE *)(result + 17)) & 0xFFFFFFFC)
        && *(_WORD *)(result + 18) == *(_WORD *)(a1 + 18) )
      {
        return result;
      }
      if ( (unsigned int)++v7 >= 0xA )
      {
        v6 = *(_DWORD *)(v6 + 40);
        if ( v6 )
          goto LABEL_9;
        goto LABEL_28;
      }
    }
  }
  if ( *(_DWORD *)result != *(_DWORD *)a1
    || *(_DWORD *)(result + 4) != *(_DWORD *)(a1 + 4)
    || *(_DWORD *)(result + 8) != *(_DWORD *)(a1 + 8)
    || *(_DWORD *)(result + 12) != *(_DWORD *)(a1 + 12)
    || *(_BYTE *)(result + 16) != *(_BYTE *)(a1 + 16)
    || (*(_BYTE *)(a1 + 17) ^ *(_BYTE *)(result + 17)) & 0xFFFFFFFC
    || *(_WORD *)(result + 18) != *(_WORD *)(a1 + 18) )
  {
LABEL_28:
    result = sub_10039860(v9);
    v4 = result;
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)a1;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
      *(_BYTE *)(result + 16) = *(_BYTE *)(a1 + 16);
      *(_BYTE *)(result + 17) = *(_BYTE *)(a1 + 17);
      *(_WORD *)(result + 18) = *(_WORD *)(a1 + 18);
      *(_DWORD *)(result + 24) = 0;
      *(_DWORD *)(result + 20) = 0;
      if ( !a3 )
      {
        v8[1] = result;
        return result;
      }
      if ( sub_100398F0(v9, a3, result) )
        return v4;
    }
LABEL_32:
    sub_10011170(a2);
    result = 0;
  }
  return result;
}

//----- (10039C40) --------------------------------------------------------
int __usercall sub_10039C40@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax@1
  char v3; // al@2
  int result; // eax@2

  v2 = sub_1001ACB0(a1, *(_DWORD *)(a2 + 16));
  if ( v2 )
  {
    v3 = (unsigned int)sub_10010FF0(v2);
    result = sub_100110F0(a1, (int)sub_1003ED50, 0, 19, v3);
  }
  else
  {
    result = sub_100110F0(
               a1,
               (int)sub_1003ED50,
               0,
               19,
               *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 4) + 8) & 0xFFFFFFFE));
  }
  return result;
}

//----- (10039C90) --------------------------------------------------------
int __cdecl sub_10039C90(int a1, int a2)
{
  unsigned int v2; // eax@1

  v2 = *(_DWORD *)(a2 + 32);
  if ( v2 )
    sub_10053E10(v2, dword_10658DEC);
  *(_WORD *)(a2 + 20) &= 0xFFFEu;
  return sub_100394E0(a2);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10039CC0) --------------------------------------------------------
unsigned int __cdecl sub_10039CC0(int a1)
{
  int v1; // esi@1
  unsigned int v2; // ebx@1
  unsigned int result; // eax@1
  unsigned int v4; // ebp@4
  unsigned int v5; // edi@4
  char v6; // al@6
  int v7; // eax@8
  int v8; // ebp@9
  unsigned int v9; // ebx@10
  unsigned int v10; // esi@11
  unsigned int v11; // esi@14
  int v12; // edx@18
  unsigned int i; // eax@23
  int v14; // ecx@24
  int v15; // [sp+8h] [bp-10h]@4
  unsigned int *v16; // [sp+Ch] [bp-Ch]@1
  unsigned int v17; // [sp+10h] [bp-8h]@1
  unsigned int v18; // [sp+14h] [bp-4h]@4

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 8836);
  result = a1 + 8836;
  v16 = (unsigned int *)(a1 + 8836);
  v17 = v2;
  if ( v2 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(v2 + 12);
      v5 = *(_DWORD *)(v2 + 4);
      v18 = *(_DWORD *)(v2 + 12);
      v15 = 0;
      if ( v5 >= v4 )
        goto LABEL_34;
      do
      {
        if ( *(_DWORD *)v5 )
        {
          v6 = *(_BYTE *)(v5 + 17);
          if ( v6 & 1 )
          {
            ++v15;
            *(_BYTE *)(v5 + 17) = v6 & 0xFE;
          }
          else
          {
            sub_100399B0(v5, v1);
            v7 = *(_DWORD *)(v5 + 24);
            if ( v7 )
            {
              v8 = *(_DWORD *)(v5 + 20);
              *(_DWORD *)(v5 + 24) = 0;
              if ( v7 & 1 )
              {
                v9 = v7 & 0xFFFFFFFE;
                do
                {
                  v10 = 0;
                  do
                  {
                    if ( !*(_DWORD *)(v9 + 4 * v10) )
                      break;
                    sub_100398F0(a1, v8, *(_DWORD *)(v9 + 4 * v10++));
                  }
                  while ( v10 < 0xA );
                  v11 = *(_DWORD *)(v9 + 40);
                  sub_100398E0((void *)v9);
                  v9 = v11;
                }
                while ( v11 );
                v2 = v17;
                v1 = a1;
              }
              else
              {
                sub_100398F0(v1, v8, v7);
              }
              v4 = v18;
            }
            *(_DWORD *)v5 = 0;
            *(_DWORD *)(v5 + 4) = *(_DWORD *)(v1 + 8832);
            *(_DWORD *)(v5 + 8) = v1 + 8832;
            v12 = *(_DWORD *)(v1 + 8832);
            if ( v12 )
              *(_DWORD *)(v12 + 8) = v5 + 4;
            *(_DWORD *)(v1 + 8832) = v5;
          }
        }
        v5 += 28;
      }
      while ( v5 < v4 );
      if ( v15 )
      {
        v16 = (unsigned int *)v2;
      }
      else
      {
LABEL_34:
        for ( i = *(_DWORD *)(v2 + 4); i < v4; i += 28 )
        {
          **(_DWORD **)(i + 8) = *(_DWORD *)(i + 4);
          v14 = *(_DWORD *)(i + 4);
          if ( v14 )
            *(_DWORD *)(v14 + 8) = *(_DWORD *)(i + 8);
        }
        if ( *(_DWORD *)(v1 + 8852) == v2 )
          *(_DWORD *)(v1 + 8852) = v1 + 8836;
        *v16 = *(_DWORD *)v2;
        sub_10053E10(v2, dword_10658DEC);
      }
      result = *v16;
      v17 = *v16;
      if ( !*v16 )
        break;
      v2 = *v16;
    }
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10039E40) --------------------------------------------------------
void *__cdecl sub_10039E40(int a1)
{
  void *result; // eax@1

  result = sub_1003F260(a1 + 8800, off_100CF9C0, 0, 8, 0x10u);
  if ( result )
  {
    sub_1003E280(a1 + 8836, (int)"properties", 7168, 4u);
    result = (void *)1;
  }
  else
  {
    *(_DWORD *)(a1 + 8800) = 0;
  }
  return result;
}
// 100CF9C0: using guessed type int (__cdecl *off_100CF9C0[4])(int, int);

//----- (10039E90) --------------------------------------------------------
_DWORD *__cdecl sub_10039E90(int a1)
{
  if ( *(_DWORD *)(a1 + 8800) )
  {
    sub_1003F300(a1 + 8800);
    *(_DWORD *)(a1 + 8800) = 0;
  }
  return sub_1003E6D0((_DWORD **)(a1 + 8836));
}

//----- (10039ED0) --------------------------------------------------------
_DWORD *__cdecl sub_10039ED0(int a1, int a2)
{
  _DWORD *v2; // ebx@1
  _DWORD *result; // eax@2
  _DWORD *v4; // edi@3

  v2 = *(_DWORD **)a2;
  if ( *(_DWORD *)(*(_DWORD *)a2 + 16) == a2 )
  {
    result = *(_DWORD **)a2;
  }
  else
  {
    result = (_DWORD *)sub_10039500(a1, 0, v2[1], *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) & 0xFFFFFFFE, a2);
    v4 = result;
    if ( result )
    {
      *(_DWORD *)a2 = sub_10015880(a1, result);
      sub_10015890(a1, (int)v2, a2);
      result = v4;
    }
  }
  return result;
}

//----- (10039F30) --------------------------------------------------------
void *__usercall sub_10039F30@<eax>(int a1@<edi>)
{
  unsigned int v1; // eax@1
  signed __int16 v2; // si@2
  void *result; // eax@4
  __int16 v4; // cx@5
  int v5; // esi@5
  unsigned int *v6; // eax@6

  v1 = *(_DWORD *)(a1 + 24);
  if ( v1 <= 6 )
  {
    v2 = 4;
  }
  else
  {
    v2 = sub_10052D80(2 * v1);
    *(_WORD *)(a1 + 22) = 32 - v2;
  }
  result = sub_10053DA0(1 << v2, 4u, dword_10658DEC);
  *(_DWORD *)(a1 + 32) = result;
  if ( result )
  {
    v4 = 32 - v2;
    v5 = *(_DWORD *)(a1 + 36);
    for ( *(_WORD *)(a1 + 22) = v4; v5; v5 = *(_DWORD *)(v5 + 20) )
    {
      v6 = sub_10039580(a1, *(_DWORD *)v5, 1);
      *v6 = v5 | *v6 & 1;
    }
    result = (void *)1;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10039FC0) --------------------------------------------------------
unsigned int __cdecl sub_10039FC0(int a1, int a2, signed int a3, signed int (*a4)(), signed int (*a5)(), signed int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  unsigned int result; // eax@2
  signed int (*v11)(); // esi@3
  signed int v12; // ebx@7
  unsigned int *v13; // eax@7
  unsigned int *v14; // ebp@7
  signed int v15; // esi@8
  unsigned int v16; // ecx@8
  unsigned int v17; // eax@8
  bool v18; // zf@25
  signed int *v19; // esi@25
  int v20; // eax@39
  unsigned int v21; // ebx@41
  int v22; // ebp@41
  int v23; // esi@44
  void *v24; // eax@48
  int v25; // esi@52
  signed int *v26; // eax@55
  unsigned int *v27; // eax@56
  int v28; // eax@67
  int v29; // eax@70
  int v30; // esi@70
  int v31; // edx@71
  int v32; // eax@72
  int v33; // eax@77
  unsigned int v34; // eax@87
  unsigned int v35; // [sp+8h] [bp-28h]@39
  int v36; // [sp+Ch] [bp-24h]@7
  unsigned int *v37; // [sp+10h] [bp-20h]@7
  int v38; // [sp+14h] [bp-1Ch]@70
  signed int (*v39)(); // [sp+18h] [bp-18h]@70
  signed int (*v40)(); // [sp+1Ch] [bp-14h]@70
  int v41; // [sp+20h] [bp-10h]@70
  char v42; // [sp+24h] [bp-Ch]@70
  char v43; // [sp+25h] [bp-Bh]@70
  __int16 v44; // [sp+26h] [bp-Ah]@70
  void *v45; // [sp+38h] [bp+8h]@40

  v9 = a2;
  if ( *(_BYTE *)(a2 + 20) & 2 )
  {
    sub_10039C40(a1, a2);
    return 0;
  }
  v11 = a4;
  if ( a4 == sub_100104C0 )
  {
    v11 = 0;
    a4 = 0;
  }
  if ( a5 == sub_100104C0 )
    a5 = 0;
  v12 = a3;
  v13 = sub_10039580(a2, a3, 1);
  v14 = v13;
  result = *v13 & 0xFFFFFFFE;
  v37 = v14;
  v36 = result;
  if ( result )
  {
    if ( !(a7 & 0x40) && a6 == -1 && *(_DWORD *)(result + 12) < *(_DWORD *)(a2 + 12) )
      a6 = *(_DWORD *)(result + 12);
    if ( *(signed int (**)())(result + 4) == v11
      && *(signed int (**)())(result + 8) == a5
      && *(_DWORD *)(result + 12) == a6
      && *(_BYTE *)(result + 16) == a7
      && !((a8 ^ *(_BYTE *)(result + 17)) & 0xFFFFFFFC)
      && *(_WORD *)(result + 18) == a9 )
    {
      return result;
    }
    if ( a8 & 2 )
    {
      *(_BYTE *)(result + 17) |= 2u;
    }
    else if ( result == *(_DWORD *)(a2 + 36) )
    {
      do
      {
        v18 = (*(_BYTE *)(a2 + 20) & 1) == 0;
        v19 = *(signed int **)(*(_DWORD *)(a2 + 36) + 20);
        *(_DWORD *)(a2 + 36) = v19;
      }
      while ( !v18 && v19 && (signed int *)(*sub_10039580(a2, *v19, 0) & 0xFFFFFFFE) != v19 );
    }
    else if ( !(*(_BYTE *)(a2 + 20) & 1) )
    {
      if ( !*(_DWORD *)(a2 + 32) )
      {
        if ( !sub_10039F30(a2) )
        {
          sub_10011170(a1);
          return 0;
        }
        v14 = sub_10039580(a2, a3, 1);
        v37 = v14;
        v36 = *v14 & 0xFFFFFFFE;
      }
      *(_WORD *)(a2 + 20) |= 1u;
    }
    if ( *(_DWORD *)(a2 + 32) )
      *v14 &= 1u;
    --*(_DWORD *)(a2 + 24);
  }
  else
  {
    v15 = 1 << (32 - *(_WORD *)(a2 + 22));
    v16 = *(_DWORD *)(a2 + 28);
    v17 = (unsigned int)(1 << (32 - *(_WORD *)(a2 + 22))) >> 2;
    if ( v16 + *(_DWORD *)(a2 + 24) >= (1 << (32 - *(_WORD *)(a2 + 22))) - v17 )
    {
      if ( !sub_100396D0(v16 < v17, a2, a1) && *(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24) == v15 - 1 )
        return 0;
      v37 = sub_10039580(a2, a3, 1);
    }
  }
  if ( *(_BYTE *)(a2 + 20) & 1 )
  {
    v20 = *(_DWORD *)(a2 + 24);
    v35 = *(_DWORD *)(a2 + 24);
    if ( v20 )
    {
      v45 = (void *)sub_10011830(a1, 4 * v20);
      if ( v45 )
      {
        v21 = v35;
        v22 = *(_DWORD *)(v9 + 36);
        while ( 1 )
        {
          if ( *sub_10039580(v9, *(_DWORD *)v22, 0) & 0xFFFFFFFE )
          {
            if ( !v21 )
            {
              v23 = v22;
              do
              {
                if ( *sub_10039580(v9, *(_DWORD *)v23, 0) & 0xFFFFFFFE )
                  ++v21;
                v23 = *(_DWORD *)(v23 + 20);
              }
              while ( v23 );
              v24 = sub_10011870(a1, v45, 4 * (v21 + v35));
              if ( !v24 )
              {
                sub_10010340(a1, (unsigned int)v45);
                break;
              }
              v45 = v24;
              memcpy_0((char *)v24 + 4 * v21, v24, 4 * v35);
              v35 += v21;
            }
            *((_DWORD *)v45 + --v21) = v22;
          }
          v22 = *(_DWORD *)(v22 + 20);
          if ( !v22 )
          {
            while ( 1 )
            {
              v25 = *((_DWORD *)v45 + v21);
              if ( *(_DWORD *)(v25 + 20) == v22 )
              {
                v22 = *((_DWORD *)v45 + v21);
              }
              else
              {
                v26 = (signed int *)sub_10039AA0(v25, a1, v22);
                v22 = (int)v26;
                if ( !v26 )
                {
                  sub_10010340(a1, (unsigned int)v45);
                  goto LABEL_71;
                }
                v27 = sub_10039580(v9, *v26, 0);
                *v27 = v22 | *v27 & 1;
              }
              if ( ++v21 >= v35 )
              {
                sub_10010340(a1, (unsigned int)v45);
                v12 = a3;
                *(_DWORD *)(v9 + 36) = v22;
                goto LABEL_59;
              }
            }
          }
        }
      }
LABEL_71:
      v31 = v36;
      if ( v36 )
      {
        v32 = *(_DWORD *)(v9 + 36);
        if ( v32 )
        {
          while ( v32 != v36 )
          {
            v32 = *(_DWORD *)(v32 + 20);
            if ( !v32 )
              goto LABEL_75;
          }
        }
        else
        {
LABEL_75:
          if ( *(_DWORD *)(v36 + 20) == *(_DWORD *)(v9 + 36) )
          {
            *(_DWORD *)(v9 + 36) = v36;
          }
          else
          {
            v33 = sub_10039AA0(v36, a1, *(_DWORD *)(v9 + 36));
            if ( v33 )
              *(_DWORD *)(v9 + 36) = v33;
            v31 = v33;
          }
        }
        if ( v31 )
        {
          if ( *(_DWORD *)(v9 + 32) )
            *v37 = v31 | *v37 & 1;
          ++*(_DWORD *)(v9 + 24);
        }
      }
      return 0;
    }
LABEL_59:
    *(_WORD *)(v9 + 20) &= 0xFFFEu;
  }
  if ( !(a8 & 4) )
  {
    if ( a7 & 0x40 )
    {
      a6 = -1;
    }
    else if ( a6 == -1 )
    {
      if ( !sub_10015A30(a1, *(_DWORD *)(v9 + 16), &a6) )
        goto LABEL_71;
      v12 = a3;
    }
  }
  v28 = *(_DWORD *)(a1 + 24);
  if ( *(_DWORD *)(v28 + 580) != v28 + 580 )
  {
    if ( sub_10051890(v28, v9, v12) )
    {
      a5 = (signed int (*)())sub_10051C00(a1, v12, a7, (int)a5);
      if ( !a5 )
        goto LABEL_71;
    }
  }
  v39 = a4;
  v40 = a5;
  v38 = a3;
  v42 = a7;
  v29 = *(_DWORD *)(v9 + 36);
  v43 = a8;
  v41 = a6;
  v44 = a9;
  v30 = sub_10039AA0((int)&v38, a1, v29);
  if ( !v30 )
    goto LABEL_71;
  if ( *(_DWORD *)(v9 + 32) )
    *v37 = v30 | *v37 & 1;
  ++*(_DWORD *)(v9 + 24);
  v18 = *(_DWORD *)(v9 + 32) == 0;
  v34 = *(_DWORD *)(v9 + 24);
  *(_DWORD *)(v9 + 36) = v30;
  if ( v18 && v34 >= 6 )
    sub_10039F30(v9);
  return v30;
}

//----- (1003A470) --------------------------------------------------------
unsigned int *__cdecl sub_1003A470(int a1, int a2, int a3, int a4, char a5, signed int (*a6)(), signed int (*a7)())
{
  int v7; // ecx@1
  signed int (*v8)(); // eax@1
  signed int (*v9)(); // esi@3
  unsigned int *result; // eax@8
  int v11; // edx@9
  bool v12; // zf@9
  int v13; // ebp@9
  char v14; // dl@9
  int v15; // esi@13
  unsigned int *v16; // eax@14
  int v17; // [sp+8h] [bp-1Ch]@9
  signed int (*v18)(); // [sp+Ch] [bp-18h]@9
  signed int (*v19)(); // [sp+10h] [bp-14h]@9
  int v20; // [sp+14h] [bp-10h]@9
  char v21; // [sp+18h] [bp-Ch]@9
  char v22; // [sp+19h] [bp-Bh]@9
  __int16 v23; // [sp+1Ah] [bp-Ah]@9

  v7 = (unsigned __int8)(a5 & *(_BYTE *)(a3 + 16)) | a4;
  v8 = a6;
  if ( a6 == sub_100104C0 )
    v8 = 0;
  v9 = a7;
  if ( a7 == sub_100104C0 )
    v9 = 0;
  if ( *(_BYTE *)(a3 + 16) == v7 && *(signed int (**)())(a3 + 4) == v8 && *(signed int (**)())(a3 + 8) == v9 )
    return (unsigned int *)a3;
  v11 = *(_DWORD *)(a3 + 12);
  v23 = *(_WORD *)(a3 + 18);
  v12 = *(_DWORD *)(a2 + 36) == a3;
  v13 = *(_DWORD *)a3;
  v20 = v11;
  v14 = *(_BYTE *)(a3 + 17);
  v17 = v13;
  v18 = v8;
  v19 = v9;
  v21 = v7;
  v22 = v14;
  if ( !v12 )
    return (unsigned int *)sub_10039FC0(a1, a2, v13, v8, v9, v20, (unsigned __int8)v7, (unsigned __int8)v14, v23);
  if ( *(_BYTE *)(a3 + 16) & 0x40 )
  {
    if ( !(v7 & 0x40) )
    {
      result = sub_10015A30(a1, *(_DWORD *)(a2 + 16), &v20);
      if ( !result )
        return result;
    }
  }
  v15 = sub_10039AA0((int)&v17, a1, *(_DWORD *)(a3 + 20));
  if ( !v15 )
    return (unsigned int *)v15;
  v16 = sub_10039580(a2, *(_DWORD *)a3, 0);
  if ( *(_DWORD *)(a2 + 32) )
    *v16 = v15 | *v16 & 1;
  *(_DWORD *)(a2 + 36) = v15;
  return (unsigned int *)v15;
}

//----- (1003A590) --------------------------------------------------------
signed int __cdecl sub_1003A590(int a1, int a2, signed int a3)
{
  unsigned int *v4; // ebp@3
  unsigned int v5; // ebx@3
  unsigned int v6; // esi@3
  bool v7; // zf@16
  signed int *v8; // esi@16
  __int16 v9; // ax@20
  unsigned int v10; // eax@22

  if ( *(_BYTE *)(a2 + 20) & 2 )
  {
    sub_10039C40(a1, a2);
    return 0;
  }
  v4 = sub_10039580(a2, a3, 0);
  v5 = *v4;
  v6 = *v4 & 0xFFFFFFFE;
  if ( v6 )
  {
    if ( !*(_DWORD *)(a2 + 32) && v6 != *(_DWORD *)(a2 + 36) )
    {
      if ( !sub_10039F30(a2) )
      {
        sub_10011170(a1);
        return 0;
      }
      v4 = sub_10039580(a2, a3, 0);
      v5 = *v4;
      v6 = *v4 & 0xFFFFFFFE;
    }
    if ( *(_DWORD *)(v6 + 12) < *(_DWORD *)(a2 + 12) )
      sub_10015AB0(a1, *(_DWORD *)(a2 + 16), *(_DWORD *)(v6 + 12));
    if ( v5 & 1 )
    {
      *v4 = 1;
      ++*(_DWORD *)(a2 + 28);
    }
    else if ( *(_DWORD *)(a2 + 32) )
    {
      *v4 = 0;
    }
    --*(_DWORD *)(a2 + 24);
    if ( v6 == *(_DWORD *)(a2 + 36) )
    {
      do
      {
        v7 = (*(_BYTE *)(a2 + 20) & 1) == 0;
        v8 = *(signed int **)(*(_DWORD *)(a2 + 36) + 20);
        *(_DWORD *)(a2 + 36) = v8;
      }
      while ( !v7 && v8 && (signed int *)(*sub_10039580(a2, *v8, 0) & 0xFFFFFFFE) != v8 );
    }
    else
    {
      v9 = *(_WORD *)(a2 + 20);
      if ( !(v9 & 1) )
        *(_WORD *)(a2 + 20) = v9 | 1;
    }
    v10 = 1 << (32 - *(_WORD *)(a2 + 22));
    if ( v10 > 0x10 && *(_DWORD *)(a2 + 24) <= v10 >> 2 )
      sub_100396D0(-1, a2, a1);
  }
  return 1;
}

//----- (1003A6D0) --------------------------------------------------------
int __usercall sub_1003A6D0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int result; // eax@1
  int v3; // edx@2
  unsigned int v4; // ecx@2
  int v5; // edi@2
  unsigned int v6; // esi@2
  unsigned int v7; // edx@2

  v1 = a1;
  result = sub_1003E2D0(a1, 0x2400u);
  if ( result )
  {
    v3 = *(_DWORD *)(v1 + 16);
    v4 = (*(_DWORD *)(v3 + 4) + 1024) & 0xFFFFFC00;
    v5 = v4 + 8;
    *(_DWORD *)(v3 + 12) = v4 + 16;
    v6 = v4;
    v7 = v4 + 0x2000;
    do
    {
      *(_DWORD *)(v4 + 4) = result;
      *(_DWORD *)v4 = v6;
      v4 += 1024;
      result += 128;
    }
    while ( v4 < v7 );
    result = v5;
  }
  return result;
}

//----- (1003A730) --------------------------------------------------------
unsigned int __cdecl sub_1003A730(unsigned int a1)
{
  unsigned int result; // eax@1

  result = *(_DWORD *)((a1 & 0xFFFFFC00) + 4) + ((a1 >> 3) & 0x7F);
  if ( result >= *(_DWORD *)(a1 & 0xFFFFFC00) )
    result += 0x2000;
  return result;
}

//----- (1003A750) --------------------------------------------------------
void *__cdecl sub_1003A750(int a1, int a2)
{
  int (__cdecl **v2)(int, int); // eax@3
  void *result; // eax@3

  if ( !dword_105726A8[0] )
  {
    dword_105726A8[0] = (int)sub_100159B0;
    dword_105726AC = (int)sub_1001DFA0;
    dword_105726B4 = (int)sub_1001DFA0;
  }
  sub_1003E280(a1 + 4, (int)"gc-arena", 9216, 8u);
  v2 = sub_1003F250();
  result = sub_1003F260(a1 + 32, v2, 0, 12, 0x100u);
  if ( result )
  {
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 84) = a2;
    result = (void *)1;
  }
  else
  {
    *(_DWORD *)(a1 + 32) = 0;
  }
  return result;
}
// 105726A8: using guessed type int dword_105726A8[];
// 105726AC: using guessed type int dword_105726AC;
// 105726B4: using guessed type int dword_105726B4;

//----- (1003A7D0) --------------------------------------------------------
int *__cdecl sub_1003A7D0(int a1)
{
  int *result; // eax@3

  sub_1003E6D0((_DWORD **)(a1 + 4));
  sub_1003E6F0();
  if ( *(_DWORD *)(a1 + 32) )
  {
    sub_1003F300(a1 + 32);
    *(_DWORD *)(a1 + 32) = 0;
  }
  result = *(int **)(a1 + 64);
  if ( result )
  {
    result = sub_1003F700(*(_DWORD *)(a1 + 64));
    *(_DWORD *)(a1 + 64) = 0;
  }
  *(_DWORD *)(a1 + 68) = 0;
  return result;
}

//----- (1003A820) --------------------------------------------------------
signed int __cdecl sub_1003A820(int a1, int a2, unsigned int a3)
{
  unsigned int *v3; // eax@1
  signed int result; // eax@2

  v3 = sub_1003F720(a1 + 32, a2, 1);
  if ( v3 )
  {
    v3[1] = a2;
    v3[2] = a3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003A860) --------------------------------------------------------
signed int __cdecl sub_1003A860(int a1, int a2)
{
  signed int result; // eax@1

  sub_1003F720(a1 + 32, a2, 2);
  result = 1;
  *(_BYTE *)(a1 + 96) = 1;
  return result;
}

//----- (1003A890) --------------------------------------------------------
signed int __cdecl sub_1003A890(int a1, unsigned int a2)
{
  signed int result; // eax@2
  _BYTE *v3; // eax@3
  _BYTE *v4; // edi@3
  char v5; // bl@3
  char v6; // al@3
  int (__cdecl **v7)(int, int); // eax@7
  int v8; // eax@7
  unsigned int *v9; // eax@8
  unsigned int *v10; // eax@12

  if ( !a2 )
    return 1;
  v3 = (_BYTE *)sub_1003A730(a2);
  v4 = v3;
  v5 = *v3;
  v6 = *v3 & 0xE0;
  if ( v6 == -32 )
    return 1;
  if ( v5 & 7 )
    goto LABEL_10;
  if ( v6 )
  {
    v10 = sub_1003F720(*(_DWORD *)(a1 + 64), a2, 0);
    if ( !*v10 )
      return 1;
    ++v10[2];
    result = 1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 64)
      || (v7 = sub_1003F250(), v8 = sub_1003F6B0(v7, 0, 12, 0x100u), (*(_DWORD *)(a1 + 64) = v8) != 0) )
    {
      v9 = sub_1003F720(*(_DWORD *)(a1 + 64), a2, 1);
      if ( v9 )
      {
        v9[1] = a2;
        v9[2] = 1;
LABEL_10:
        *v4 = v5 + 32;
        return 1;
      }
    }
    result = 0;
  }
  return result;
}

//----- (1003A950) --------------------------------------------------------
signed int __cdecl sub_1003A950(int a1, unsigned int a2)
{
  signed int result; // eax@2
  _BYTE *v3; // eax@3
  _BYTE *v4; // esi@3
  char v5; // bl@3
  char v6; // al@3
  unsigned int *v7; // eax@6
  bool v8; // zf@7

  if ( !a2 )
    return 1;
  v3 = (_BYTE *)sub_1003A730(a2);
  v4 = v3;
  v5 = *v3;
  v6 = *v3 & 0xE0;
  if ( v6 != -32 )
  {
    if ( v5 & 7 )
    {
      *v4 = v5 - 32;
    }
    else if ( v6 )
    {
      v7 = sub_1003F720(*(_DWORD *)(a1 + 64), a2, 0);
      if ( *v7 )
      {
        v8 = v7[2]-- == 1;
        if ( v8 )
        {
          sub_1003F720(*(_DWORD *)(a1 + 64), a2, 2);
          *v4 = v5 & 0x1F;
          result = 1;
          *(_BYTE *)(a1 + 96) = 1;
          return result;
        }
      }
    }
  }
  result = 1;
  *(_BYTE *)(a1 + 96) = 1;
  return result;
}

//----- (1003A9D0) --------------------------------------------------------
void __cdecl sub_1003A9D0(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // edx@1
  int v4; // edi@2
  int v5; // edx@3
  char *v6; // esi@3
  char v7; // cl@3
  char v8; // al@4
  int v9; // ecx@4
  int *v10; // esi@9
  int v11; // eax@10
  int (__cdecl *v12)(int, int, int); // ecx@10
  unsigned int v13; // eax@11
  unsigned int v14; // ecx@12
  unsigned int i; // edi@14
  int v16; // eax@15

  v3 = a2;
  if ( a2 )
  {
    v4 = a3;
    while ( 1 )
    {
      v6 = (char *)sub_1003A730(v3);
      v7 = *v6;
      if ( *v6 & 8 )
        break;
      v8 = v7 | 8;
      v9 = v7 & 7;
      *v6 = v8;
      if ( !v9 )
      {
        v10 = *(int **)(v5 + 4);
        if ( v10 )
        {
          v11 = *(_DWORD *)v5;
          v12 = *(int (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v5 + 4) + 80);
          if ( v12 )
          {
            v13 = v12(a1, v5, v4);
          }
          else
          {
            v14 = *(_DWORD *)(v11 + 12);
            v13 = *(_DWORD *)(v11 + 8);
            if ( v14 < v13 )
              v13 = v14;
          }
          for ( i = (unsigned int)&v10[v13]; (unsigned int)v10 < i; ++v10 )
          {
            v16 = *v10;
            if ( !(*v10 & 1) && (v16 & 7) != 6 )
              sub_1003A9D0(a1, v16 & 0xFFFFFFF8, 0);
          }
        }
        return;
      }
      if ( v9 == 3 )
      {
        if ( *(_DWORD *)v5 & 0x40000000 )
        {
          v3 = *(_DWORD *)(v5 + 4);
          v4 = 0;
          if ( v3 )
            continue;
        }
      }
      return;
    }
  }
}

//----- (1003AA80) --------------------------------------------------------
int __cdecl sub_1003AA80(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1

  v4 = **(_DWORD **)(a2 + 4);
  if ( v4 && !(v4 & 1) && (v4 & 7) != 6 )
    sub_1003A9D0(a4, v4 & 0xFFFFFFF8, 0);
  return 0;
}

//----- (1003AAC0) --------------------------------------------------------
int __cdecl sub_1003AAC0(int a1, int a2, int a3, int a4)
{
  sub_1003A9D0(a4, *(_DWORD *)(a2 + 4), 0);
  return 0;
}

//----- (1003AAE0) --------------------------------------------------------
int sub_1003AAE0()
{
  int result; // eax@1

  result = 0;
  dword_105726A8[0] = 0;
  dword_105726AC = 0;
  dword_105726B0 = 0;
  dword_105726B4 = 0;
  dword_105726B8 = 0;
  dword_105726BC = 0;
  dword_105726C0 = 0;
  dword_105726C4 = 0;
  return result;
}
// 105726A8: using guessed type int dword_105726A8[];
// 105726AC: using guessed type int dword_105726AC;
// 105726B0: using guessed type int dword_105726B0;
// 105726B4: using guessed type int dword_105726B4;
// 105726B8: using guessed type int dword_105726B8;
// 105726BC: using guessed type int dword_105726BC;
// 105726C0: using guessed type int dword_105726C0;
// 105726C4: using guessed type int dword_105726C4;

//----- (1003AB10) --------------------------------------------------------
signed int __cdecl sub_1003AB10(int a1, int a2, unsigned int a3)
{
  signed int result; // eax@1
  signed int v4; // esi@1

  result = sub_1003A820(*(_DWORD *)(a1 + 24), a2, a3);
  v4 = result;
  if ( !result )
  {
    sub_10011170(a1);
    result = v4;
  }
  return result;
}

//----- (1003AB40) --------------------------------------------------------
signed int __cdecl sub_1003AB40(int a1, unsigned int a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1

  result = sub_1003A890(*(_DWORD *)(a1 + 24), a2);
  v3 = result;
  if ( !result )
  {
    sub_10011170(a1);
    result = v3;
  }
  return result;
}

//----- (1003AB70) --------------------------------------------------------
void __cdecl sub_1003AB70(unsigned int a1, int a2)
{
  sub_1003A9D0(a2, a1, 0);
}

//----- (1003AB90) --------------------------------------------------------
void __cdecl sub_1003AB90(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@2

  v2 = *(_DWORD *)(a2 + 16);
  if ( !(v2 & 4) )
  {
    *(_DWORD *)(a2 + 16) = v2 | 4;
    v3 = *(_DWORD *)(a2 + 8);
    if ( !(v3 & 1) && (v3 & 7) != 6 )
      sub_1003A9D0(a1, v3 & 0xFFFFFFF8, 0);
  }
}

//----- (1003ABD0) --------------------------------------------------------
void __cdecl sub_1003ABD0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int (__cdecl *v4)(int, _DWORD); // eax@3
  bool v5; // zf@8
  int v6; // eax@11
  int v7; // ebp@14
  unsigned int v8; // eax@20
  unsigned int v9; // eax@22
  int v10; // eax@24
  int *v11; // esi@25
  signed int v12; // eax@26
  int v13; // eax@27
  unsigned int j; // ebx@29
  int v15; // eax@30
  int *v16; // esi@34
  int v17; // ecx@35
  unsigned int v18; // eax@35
  unsigned int v19; // ecx@36
  unsigned int k; // ebx@38
  int v21; // eax@39
  int v22; // eax@43
  int *v23; // esi@46
  unsigned int l; // ebx@47
  int v25; // eax@48
  unsigned int v26; // eax@52
  int v27; // eax@55
  unsigned int v28; // edi@55
  int v29; // ebx@55
  unsigned int v30; // esi@55
  int v31; // eax@56
  int v32; // eax@62
  unsigned int *v33; // esi@64
  signed int v34; // edi@64
  int v35; // eax@66
  int v36; // eax@70
  int v37; // eax@74
  int m; // ebp@77
  int *v39; // esi@78
  unsigned int v40; // edi@78
  int v41; // eax@79
  int v42; // edi@85
  void (__cdecl *v43)(int, signed int); // eax@85
  int v44; // ecx@87
  char *v45; // esi@88
  unsigned int v46; // edx@88
  unsigned int v47; // ebp@88
  unsigned int v48; // ebx@88
  char v49; // al@91
  unsigned int v50; // ecx@94
  void (__cdecl *v51)(int, unsigned int); // edi@94
  unsigned int *v52; // ebp@103
  unsigned int v53; // esi@103
  unsigned int *v54; // edi@104
  _BYTE *v55; // ecx@105
  unsigned int v56; // ebx@105
  unsigned int v57; // edx@105
  unsigned int v58; // eax@105
  void (__cdecl *v59)(int, signed int); // eax@120
  void (__cdecl *v60)(int, signed int); // eax@124
  int v61; // edx@124
  int v62; // [sp+8h] [bp-14h]@1
  _DWORD *i; // [sp+Ch] [bp-10h]@13
  int v64; // [sp+Ch] [bp-10h]@103
  int v65; // [sp+10h] [bp-Ch]@14
  int n; // [sp+10h] [bp-Ch]@87
  signed int v67; // [sp+10h] [bp-Ch]@104
  int v68; // [sp+14h] [bp-8h]@13
  unsigned int v69; // [sp+18h] [bp-4h]@88

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 24);
  v62 = *(_DWORD *)(a1 + 24);
  if ( *(_DWORD *)v3 == 2 || a2 & 2 )
  {
    v4 = *(int (__cdecl **)(int, _DWORD))(v3 + 100);
    if ( !v4 || v4(a1, 0) || a2 & 2 )
    {
      if ( *(_BYTE *)(v3 + 96) )
      {
        if ( ++*(_DWORD *)(v3 + 88) <= 1u )
        {
          v5 = *(_DWORD *)(v3 + 72) == 0;
          *(_BYTE *)(v3 + 97) = 1;
          if ( !v5 )
            a2 |= 1u;
          *(_DWORD *)(v3 + 104) = 0;
          sub_1002F720(a1);
          sub_1002F6E0(a1);
          while ( 1 )
          {
            ++*(_DWORD *)(v3 + 92);
            sub_1003F5C0(v3 + 32, (int (__cdecl *)(int, int *, int, int))sub_1003AA80, v2);
            v6 = *(_DWORD *)(v3 + 64);
            if ( v6 )
              sub_1003F5C0(v6, (int (__cdecl *)(int, int *, int, int))sub_1003AAC0, v2);
            sub_10038630(v3 + 108, a2, (int)sub_1003AB70, v2);
            sub_10051830(v3);
            v68 = 0;
            for ( i = sub_1003E8A0(v3, 1, (_DWORD **)&v68); i; i = sub_1003E8A0(v62, 1, (_DWORD **)&v68) )
            {
              v7 = i[14];
              v65 = i[14];
              if ( v7 )
              {
                *(_DWORD *)(v7 + 80) = i[71];
              }
              else
              {
                v7 = i[71];
                v65 = i[71];
              }
              if ( v7 )
              {
                while ( 1 )
                {
                  if ( *(_DWORD *)v7 )
                    sub_1003A9D0(a1, *(_DWORD *)v7, 0);
                  v8 = *(_DWORD *)(v7 + 4);
                  if ( v8 )
                    sub_1003A9D0(a1, v8, 0);
                  v9 = *(_DWORD *)(v7 + 8);
                  if ( v9 )
                    sub_1003A9D0(a1, v9, 0);
                  v10 = *(_DWORD *)(v7 + 12);
                  if ( v10 )
                  {
                    sub_100213B0(a1, v10);
                    v11 = *(int **)(v7 + 64);
                    if ( v11 )
                    {
                      v12 = *(_DWORD *)(v7 + 60) - (_DWORD)v11;
                      v13 = v12 >= (unsigned int)(4 * *(_DWORD *)(*(_DWORD *)(v7 + 12) + 32)) ? *(_DWORD *)(*(_DWORD *)(v7 + 12) + 32) : v12 >> 2;
                      for ( j = (unsigned int)&v11[v13]; (unsigned int)v11 < j; ++v11 )
                      {
                        v15 = *v11;
                        if ( !(*v11 & 1) && (v15 & 7) != 6 )
                          sub_1003A9D0(a1, v15 & 0xFFFFFFF8, 0);
                      }
                    }
                  }
                  sub_1003A9D0(a1, *(_DWORD *)(v7 + 20), 0);
                  v16 = *(int **)(v7 + 28);
                  if ( v16 )
                  {
                    v17 = *(_DWORD *)(v7 + 16);
                    v18 = *(_DWORD *)(v7 + 24);
                    if ( v17 )
                    {
                      v19 = *(_WORD *)(v17 + 16);
                      if ( v19 > v18 )
                        v18 = v19;
                    }
                    for ( k = (unsigned int)&v16[v18]; (unsigned int)v16 < k; ++v16 )
                    {
                      v21 = *v16;
                      if ( !(*v16 & 1) && (v21 & 7) != 6 )
                        sub_1003A9D0(a1, v21 & 0xFFFFFFF8, 0);
                    }
                  }
                  v22 = *(_DWORD *)(v7 + 32);
                  if ( !(v22 & 1) && (v22 & 7) != 6 )
                    sub_1003A9D0(a1, v22 & 0xFFFFFFF8, 0);
                  v23 = *(int **)(v7 + 40);
                  if ( v23 )
                  {
                    for ( l = (unsigned int)&v23[*(_DWORD *)(v7 + 36)]; (unsigned int)v23 < l; ++v23 )
                    {
                      v25 = *v23;
                      if ( !(*v23 & 1) && (v25 & 7) != 6 )
                        sub_1003A9D0(a1, v25 & 0xFFFFFFF8, 0);
                    }
                  }
                  sub_1003A9D0(a1, *(_DWORD *)(v7 + 52), 0);
                  v26 = *(_DWORD *)(v7 + 72);
                  if ( v26 )
                    sub_1003A9D0(a1, v26, 0);
                  if ( *(_DWORD *)(v7 + 84) )
                  {
                    v27 = *(_DWORD *)(v7 + 84);
                    v28 = *(_DWORD *)(v27 + 4);
                    v29 = *(_DWORD *)v27;
                    v30 = 0;
                    if ( v28 )
                    {
                      do
                      {
                        v31 = *(_DWORD *)(v29 + 4 * v30);
                        if ( v31 && !(*(_BYTE *)(v31 + 16) & 4) )
                          sub_1003AB90(a1, v31);
                        ++v30;
                      }
                      while ( v30 < v28 );
                    }
                  }
                  v7 = *(_DWORD *)(v7 + 44);
                  if ( !v7 )
                  {
                    v65 = *(_DWORD *)(v65 + 80);
                    v7 = v65;
                    if ( !v65 )
                      break;
                  }
                }
              }
              v32 = i[14];
              if ( v32 )
                *(_DWORD *)(v32 + 80) = 0;
              sub_1003A9D0(a1, i[22], 0);
              sub_1003A9D0(a1, i[23], 0);
              sub_1003A9D0(a1, i[24], 0);
              sub_1003A9D0(a1, i[25], 0);
              sub_1003A9D0(a1, i[26], 0);
              v33 = i + 27;
              v34 = 4;
              do
              {
                sub_1003A9D0(a1, *v33, 0);
                ++v33;
                --v34;
              }
              while ( v34 );
              v35 = i[31];
              if ( v35 && !(*(_BYTE *)(v35 + 16) & 4) )
                sub_1003AB90(a1, v35);
              if ( *((_BYTE *)i + 294) )
              {
                v36 = i[74];
                if ( !(v36 & 1) && (v36 & 7) != 6 )
                  sub_1003A9D0(a1, v36 & 0xFFFFFFF8, 0);
              }
              if ( *((_BYTE *)i + 292) )
              {
                v37 = i[72];
                if ( !(v37 & 1) && (v37 & 7) != 6 )
                  sub_1003A9D0(a1, v37 & 0xFFFFFFF8, 0);
              }
              for ( m = i[78]; m; m = *(_DWORD *)(m + 4) )
              {
                v39 = (int *)(m + 8);
                v40 = m + 8 + 4 * *(_DWORD *)m;
                if ( m + 8 < v40 )
                {
                  do
                  {
                    v41 = *v39;
                    if ( !(*v39 & 1) && (v41 & 7) != 6 )
                      sub_1003A9D0(a1, v41 & 0xFFFFFFF8, 0);
                    ++v39;
                  }
                  while ( (unsigned int)v39 < v40 );
                }
              }
            }
            v42 = v62;
            v43 = *(void (__cdecl **)(int, signed int))(v62 + 100);
            if ( v43 )
              v43(a1, 2);
            sub_100386A0(v62 + 108);
            sub_10039CC0(v62);
            sub_10021240(v62);
            v44 = *(_DWORD *)(v62 + 4);
            for ( n = *(_DWORD *)(v62 + 4); v44; n = v44 )
            {
              v45 = *(char **)(v44 + 4);
              v47 = (unsigned int)(v45 + 1024) & 0xFFFFFC00;
              v69 = *(_DWORD *)(v44 + 12);
              v46 = v69;
              v48 = (unsigned int)(v45 + 1024) & 0xFFFFFC00;
              if ( v47 < v69 )
              {
                do
                {
                  if ( !(v48 & 0x3FF) )
                  {
                    ++v45;
                    v48 += 8;
                  }
                  v49 = *v45;
                  if ( *v45 & 8 )
                  {
                    *v45 = v49 & 0xF7;
                  }
                  else if ( !(v49 & 0xF0) )
                  {
                    v50 = v49 & 7;
                    v51 = (void (__cdecl *)(int, unsigned int))dword_105726A8[v50];
                    if ( v51 )
                    {
                      *v45 = v49 | 0x10;
                      if ( v50 >= 4 )
                        sub_1001ABE0(v48);
                      v51(a1, v48);
                    }
                    v46 = v69;
                    v44 = n;
                    *v45 = 16;
                    *(_DWORD *)(v62 + 76) -= 9;
                    v42 = v62;
                  }
                  if ( ++v45 == (char *)v47 )
                    v45 += 0x2000;
                  v48 += 8;
                }
                while ( v48 < v46 );
              }
              v44 = *(_DWORD *)v44;
            }
            v52 = (unsigned int *)(v42 + 4);
            v53 = *(_DWORD *)(v42 + 4);
            v64 = v42 + 4;
            if ( v53 )
            {
              v54 = (unsigned int *)(v62 + 68);
              v67 = 1;
              v69 = (unsigned int)v54;
              *v54 = 0;
              do
              {
                v55 = *(_BYTE **)(v53 + 4);
                v56 = *(_DWORD *)(v53 + 12);
                v57 = (unsigned int)(v55 + 1024) & 0xFFFFFC00;
                v58 = (unsigned int)(v55 + 1024) & 0xFFFFFC00;
                if ( v57 < v56 )
                {
                  do
                  {
                    if ( !(v58 & 0x3FF) )
                    {
                      ++v55;
                      v58 += 8;
                    }
                    if ( *v55 == 16 )
                    {
                      *(_DWORD *)(v58 + 4) = v55;
                      *v54 = v58;
                      v54 = (unsigned int *)v58;
                    }
                    else
                    {
                      v52 = (unsigned int *)v64;
                      v67 = 0;
                    }
                    if ( ++v55 == (_BYTE *)v57 )
                      v55 += 0x2000;
                    v58 += 8;
                  }
                  while ( v58 < v56 );
                }
                if ( v67 )
                {
                  if ( *(_DWORD *)(v62 + 20) == v53 )
                    *(_DWORD *)(v62 + 20) = v62 + 4;
                  *v52 = *(_DWORD *)v53;
                  sub_10053E10(v53, dword_10658DEC);
                  v54 = (unsigned int *)v69;
                }
                else
                {
                  v52 = (unsigned int *)v53;
                  v64 = v53;
                  v67 = 1;
                  v69 = (unsigned int)v54;
                }
                v53 = *v52;
              }
              while ( *v52 );
              *v54 = 0;
              v59 = *(void (__cdecl **)(int, signed int))(v62 + 100);
              if ( v59 )
                v59(a1, 3);
            }
            v3 = v62;
            v2 = a1;
            if ( *(_DWORD *)(v62 + 88) <= 1u )
              break;
            *(_DWORD *)(v62 + 88) = 1;
          }
          sub_1002F740(a1);
          v60 = *(void (__cdecl **)(int, signed int))(v62 + 100);
          v61 = *(_DWORD *)(v62 + 76);
          *(_DWORD *)(v62 + 88) = 0;
          *(_DWORD *)(v62 + 80) = v61;
          *(_BYTE *)(v62 + 97) = 0;
          *(_BYTE *)(v62 + 96) = 0;
          if ( v60 )
            v60(a1, 1);
        }
      }
    }
  }
}
// 105726A8: using guessed type int dword_105726A8[];
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003B230) --------------------------------------------------------
int __cdecl sub_1003B230(int a1, char a2)
{
  int v2; // esi@1
  signed int v3; // ebp@1
  int result; // eax@2
  int v5; // edx@3
  unsigned int v6; // eax@4
  int v7; // edi@7
  int v8; // ecx@7
  _BYTE *v9; // eax@15

  v2 = *(_DWORD *)(a1 + 24);
  v3 = 0;
  if ( *(_BYTE *)(v2 + 97) )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(v2 + 68);
    if ( v5 )
    {
LABEL_15:
      *(_DWORD *)(v2 + 68) = *(_DWORD *)v5;
      v9 = *(_BYTE **)(v5 + 4);
    }
    else
    {
      while ( 1 )
      {
        v6 = *(_DWORD *)(v2 + 84);
        if ( *(_DWORD *)(v2 + 76) < v6 && (v3 || *(_DWORD *)(v2 + 104) < v6) )
        {
          v7 = *(_DWORD *)(v2 + 20);
          v5 = *(_DWORD *)(v7 + 12);
          v8 = v5 + 8;
          if ( v5 + 8 <= (*(_DWORD *)(v7 + 8) & 0xFFFFFC00) )
          {
            if ( !(v5 & 0x3FF) )
            {
              v5 += 8;
              v8 += 8;
            }
            *(_DWORD *)(v7 + 12) = v8;
          }
          else
          {
            v5 = sub_1003A6D0(v2 + 4);
          }
        }
        if ( v5 )
          break;
        if ( v3 )
        {
          sub_10011170(a1);
          return 0;
        }
        *(_BYTE *)(v2 + 96) = 1;
        sub_1003ABD0(a1, 5);
        v5 = *(_DWORD *)(v2 + 68);
        v3 = 1;
        if ( v5 )
          goto LABEL_15;
      }
      v9 = (_BYTE *)sub_1003A730(v5);
    }
    *v9 = a2;
    *(_DWORD *)(v2 + 76) += 9;
    *(_DWORD *)(a1 + 4 * (a2 & 7) + 92) = v5;
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    result = v5;
  }
  return result;
}

//----- (1003B310) --------------------------------------------------------
_DWORD *__cdecl sub_1003B310(int a1, int a2)
{
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 116) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_BYTE *)(*(_DWORD *)(a1 + 24) + 96) = 1;
  sub_1003ABD0(a1, a2);
  return sub_1003E6F0();
}

//----- (1003B350) --------------------------------------------------------
int __usercall sub_1003B350@<eax>(int a1@<edi>)
{
  int result; // eax@1

  result = dword_105726D0[a1];
  if ( result )
  {
    dword_105726D0[a1] = *(_DWORD *)result;
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  else
  {
    result = sub_10053CF0(4 * (1 << a1) + 20, dword_10658DEC);
    if ( result )
    {
      *(_DWORD *)(result + 8) = 1 << a1;
      *(_DWORD *)(result + 4) = a1;
      *(_DWORD *)(result + 16) = 0;
      *(_DWORD *)(result + 12) = 0;
    }
  }
  return result;
}
// 105726D0: using guessed type int dword_105726D0[];
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003B3C0) --------------------------------------------------------
int __usercall sub_1003B3C0@<eax>(int result@<eax>)
{
  int v1; // ecx@2

  if ( result )
  {
    v1 = *(_DWORD *)(result + 4);
    *(_DWORD *)result = dword_105726D0[v1];
    dword_105726D0[v1] = result;
  }
  return result;
}
// 105726D0: using guessed type int dword_105726D0[];

//----- (1003B3E0) --------------------------------------------------------
int __cdecl sub_1003B3E0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // ebx@1
  unsigned int v4; // edi@1
  _DWORD *v5; // esi@1
  int v6; // ebp@1
  unsigned __int64 v7; // rax@2
  int v8; // esi@3
  int v9; // edi@5
  int v11; // [sp+10h] [bp-Ch]@1

  v11 = *(_DWORD *)(a1 + 16);
  v3 = a3;
  v4 = (unsigned __int64)(signed int)a3 >> 32;
  v5 = (_DWORD *)(a1 + 20);
  v6 = 0;
  do
  {
    v7 = __PAIR__(v4, v3) + *v5 * (signed __int64)a2;
    *v5 = v7;
    ++v6;
    v4 = 0;
    ++v5;
    v3 = HIDWORD(v7);
  }
  while ( v6 < v11 );
  v8 = a1;
  if ( HIDWORD(v7) )
  {
    if ( v11 >= *(_DWORD *)(a1 + 8) )
    {
      v9 = sub_1003B350(*(_DWORD *)(a1 + 4) + 1);
      if ( !v9 )
      {
        sub_1003B3C0(a1);
        return 0;
      }
      memcpy((void *)(v9 + 12), (const void *)(a1 + 12), 4 * *(_DWORD *)(a1 + 16) + 8);
      sub_1003B3C0(a1);
      v8 = v9;
    }
    *(_DWORD *)(v8 + 4 * v11 + 20) = v3;
    *(_DWORD *)(v8 + 16) = v11 + 1;
  }
  return v8;
}

//----- (1003B4B0) --------------------------------------------------------
int __usercall sub_1003B4B0@<eax>(int a1@<eax>, signed int a2@<ebx>, signed int a3, int a4)
{
  int v4; // esi@1
  int v5; // edi@1
  int v6; // eax@1
  signed int i; // ecx@1
  int result; // eax@3
  signed int v9; // edi@4
  _BYTE *v10; // esi@5
  _BYTE *v11; // esi@8

  v4 = a1;
  v5 = 0;
  v6 = (a3 + 8) / 9;
  for ( i = 1; v6 > i; ++v5 )
    i *= 2;
  result = sub_1003B350(v5);
  if ( !result )
    return 0;
  v9 = 9;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 16) = 1;
  if ( a2 > 9 )
  {
    v10 = (_BYTE *)(v4 + 9);
    while ( 1 )
    {
      result = sub_1003B3E0(result, 10, *v10++ - 48);
      if ( !result )
        return 0;
      if ( ++v9 >= a2 )
      {
        v11 = v10 + 1;
        goto LABEL_10;
      }
    }
  }
  v11 = (_BYTE *)(v4 + 10);
LABEL_10:
  if ( v9 < a3 )
  {
    while ( 1 )
    {
      result = sub_1003B3E0(result, 10, *v11++ - 48);
      if ( !result )
        break;
      if ( ++v9 >= a3 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (1003B560) --------------------------------------------------------
signed int __fastcall sub_1003B560(int a1)
{
  signed int result; // eax@1

  result = 0;
  if ( !(a1 & 0xFFFF0000) )
  {
    result = 16;
    a1 <<= 16;
  }
  if ( !(a1 & 0xFF000000) )
  {
    result += 8;
    a1 <<= 8;
  }
  if ( !(a1 & 0xF0000000) )
  {
    result += 4;
    a1 *= 16;
  }
  if ( !(a1 & 0xC0000000) )
  {
    result += 2;
    a1 *= 4;
  }
  if ( a1 >= 0 )
  {
    ++result;
    if ( !(a1 & 0x40000000) )
      result = 32;
  }
  return result;
}

//----- (1003B5C0) --------------------------------------------------------
signed int __usercall sub_1003B5C0@<eax>(unsigned int *a1@<esi>)
{
  unsigned int v1; // ecx@1
  signed int result; // eax@3

  v1 = *a1;
  if ( *a1 & 7 )
  {
    if ( v1 & 1 )
      return 0;
    if ( v1 & 2 )
    {
      v1 >>= 1;
      result = 1;
LABEL_6:
      *a1 = v1;
      return result;
    }
    result = 2;
    *a1 = v1 >> 2;
  }
  else
  {
    result = 0;
    if ( !(_WORD)v1 )
    {
      result = 16;
      v1 >>= 16;
    }
    if ( !(_BYTE)v1 )
    {
      result += 8;
      v1 >>= 8;
    }
    if ( !(v1 & 0xF) )
    {
      result += 4;
      v1 >>= 4;
    }
    if ( !(v1 & 3) )
    {
      result += 2;
      v1 >>= 2;
    }
    if ( v1 & 1 )
      goto LABEL_6;
    ++result;
    v1 >>= 1;
    if ( v1 )
      goto LABEL_6;
    result = 32;
  }
  return result;
}

//----- (1003B640) --------------------------------------------------------
int __cdecl sub_1003B640(int a1)
{
  int result; // eax@1

  result = sub_1003B350(1);
  if ( result )
  {
    *(_DWORD *)(result + 16) = 1;
    *(_DWORD *)(result + 20) = a1;
  }
  return result;
}

//----- (1003B660) --------------------------------------------------------
int __usercall sub_1003B660@<eax>(int a1@<eax>, int a2)
{
  int v2; // ecx@1
  int v3; // ebx@1
  int v4; // ebp@3
  int v5; // edi@3
  int v6; // ebp@3
  int result; // eax@5
  unsigned int v8; // esi@6
  unsigned int v9; // ecx@6
  int v10; // edi@8
  unsigned int *v11; // eax@8
  unsigned int v12; // edx@8
  bool v13; // cf@8
  unsigned int v14; // ecx@9
  unsigned int v15; // ebx@10
  int v16; // edi@10
  unsigned __int64 v17; // rax@12
  _DWORD *i; // ecx@15
  int v19; // [sp+Ch] [bp-1Ch]@3
  unsigned int v20; // [sp+Ch] [bp-1Ch]@8
  int v21; // [sp+10h] [bp-18h]@3
  unsigned int v22; // [sp+10h] [bp-18h]@9
  int v23; // [sp+14h] [bp-14h]@3
  int v24; // [sp+18h] [bp-10h]@8
  unsigned int *v25; // [sp+1Ch] [bp-Ch]@9
  int v26; // [sp+20h] [bp-8h]@8
  int v27; // [sp+24h] [bp-4h]@5
  unsigned int v28; // [sp+2Ch] [bp+4h]@8

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16) )
  {
    v3 = a2;
    a2 = a1;
    v2 = a1;
  }
  v4 = *(_DWORD *)(v2 + 16);
  v5 = *(_DWORD *)(v3 + 4);
  v21 = v4;
  v6 = *(_DWORD *)(v3 + 16) + v4;
  v19 = *(_DWORD *)(v3 + 16);
  v23 = v6;
  if ( v6 > *(_DWORD *)(v3 + 8) )
    ++v5;
  result = sub_1003B350(v5);
  v27 = result;
  if ( result )
  {
    v8 = result + 20;
    v9 = result + 20 + 4 * v6;
    if ( result + 20 < v9 )
      memset((void *)v8, 0, 4 * (((v9 - v8 - 1) >> 2) + 1));
    v10 = v3 + 20;
    v11 = (unsigned int *)(a2 + 20);
    v20 = v3 + 20 + 4 * v19;
    v12 = a2 + 20 + 4 * v21;
    v13 = a2 + 20 < v12;
    v24 = v3 + 20;
    v26 = a2 + 20 + 4 * v21;
    v28 = v8;
    if ( v13 )
    {
      do
      {
        v14 = *v11;
        ++v11;
        v22 = v14;
        v25 = v11;
        if ( v14 )
        {
          v15 = 0;
          v16 = v10 - v8;
          while ( 1 )
          {
            v17 = v15 + *(_DWORD *)v8 + *(_DWORD *)(v16 + v8) * (unsigned __int64)v14;
            *(_DWORD *)v8 = v17;
            v8 += 4;
            v15 = HIDWORD(v17);
            if ( v16 + v8 >= v20 )
              break;
            v14 = v22;
          }
          v6 = v23;
          v10 = v24;
          v11 = v25;
          v12 = v26;
          *(_DWORD *)v8 = v15;
          v8 = v28;
        }
        v8 += 4;
        v28 = v8;
      }
      while ( (unsigned int)v11 < v12 );
    }
    result = v27;
    for ( i = (_DWORD *)(v27 + 4 * v6 + 20); v6 > 0; --v6 )
    {
      --i;
      if ( *i )
        break;
    }
    *(_DWORD *)(v27 + 16) = v6;
  }
  return result;
}

//----- (1003B790) --------------------------------------------------------
int __usercall sub_1003B790@<eax>(signed int a1@<eax>, int a2)
{
  signed int v2; // ebx@1
  int v3; // eax@1
  int v4; // ebp@1
  int result; // eax@2
  signed int v6; // ebx@3
  _DWORD *v7; // esi@5
  _DWORD *v8; // eax@6
  int v9; // edi@10
  _DWORD *v10; // eax@13

  v2 = a1;
  v3 = a1 & 3;
  v4 = a2;
  if ( v3 )
  {
    result = sub_1003B3E0(a2, dword_100CF9FC[v3], 0);
    v4 = result;
    if ( !result )
      return result;
  }
  v6 = v2 >> 2;
  if ( !v6 )
    return v4;
  v7 = (_DWORD *)dword_105726C8;
  if ( dword_105726C8 )
    goto LABEL_9;
  v8 = (_DWORD *)sub_1003B640(625);
  dword_105726C8 = (int)v8;
  v7 = v8;
  if ( !v8 )
  {
    sub_1003B3C0(v4);
    return 0;
  }
  *v8 = 0;
  while ( 1 )
  {
LABEL_9:
    if ( v6 & 1 )
    {
      v9 = sub_1003B660(v4, (int)v7);
      sub_1003B3C0(v4);
      if ( !v9 )
        return 0;
      v4 = v9;
    }
    v6 >>= 1;
    if ( !v6 )
      return v4;
    v10 = (_DWORD *)*v7;
    if ( !*v7 )
      break;
LABEL_16:
    v7 = v10;
  }
  v10 = (_DWORD *)sub_1003B660((int)v7, (int)v7);
  if ( v10 )
  {
    *v10 = 0;
    *v7 = v10;
    goto LABEL_16;
  }
  sub_1003B3C0(v4);
  return 0;
}
// 100CF9FC: using guessed type int dword_100CF9FC[];
// 105726C8: using guessed type int dword_105726C8;

//----- (1003B860) --------------------------------------------------------
int __cdecl sub_1003B860(int a1, signed int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1
  int v4; // ecx@1
  int v5; // eax@1
  int v6; // edi@1
  int v7; // eax@3
  int v8; // edi@3
  char *v9; // edx@4
  _DWORD *v10; // eax@6
  int v11; // ebp@6
  unsigned int v12; // ebx@6
  char v13; // di@7
  int v14; // esi@7
  int v15; // ebp@9
  int i; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+14h] [bp-8h]@3
  int v19; // [sp+24h] [bp+8h]@6

  v2 = a1;
  v3 = a2 >> 5;
  v4 = (a2 >> 5) + *(_DWORD *)(a1 + 16) + 1;
  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 4);
  for ( i = (a2 >> 5) + *(_DWORD *)(a1 + 16) + 1; v4 > v5; ++v6 )
    v5 *= 2;
  v7 = sub_1003B350(v6);
  v8 = v7;
  v18 = v7;
  if ( v7 )
  {
    v9 = (char *)(v7 + 20);
    if ( v3 > 0 )
    {
      memset(v9, 0, 4 * v3);
      v9 += 4 * v3;
    }
    v10 = (_DWORD *)(a1 + 20);
    v11 = a2 & 0x1F;
    v12 = a1 + 20 + 4 * *(_DWORD *)(a1 + 16);
    v19 = v11;
    if ( v11 )
    {
      v13 = 32 - v11;
      v14 = 0;
      while ( 1 )
      {
        v15 = *v10 << v11;
        ++v10;
        v9 += 4;
        *((_DWORD *)v9 - 1) = v14 | v15;
        v14 = *(v10 - 1) >> v13;
        if ( (unsigned int)v10 >= v12 )
          break;
        LOBYTE(v11) = v19;
      }
      *(_DWORD *)v9 = v14;
      if ( v14 )
        ++i;
    }
    else
    {
      do
      {
        *(_DWORD *)v9 = *v10;
        ++v10;
        v9 += 4;
      }
      while ( (unsigned int)v10 < v12 );
    }
    v2 = a1;
    *(_DWORD *)(v18 + 16) = i - 1;
    v8 = v18;
  }
  sub_1003B3C0(v2);
  return v8;
}

//----- (1003B940) --------------------------------------------------------
signed int __usercall sub_1003B940@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  int v3; // ecx@1
  signed int result; // eax@1
  unsigned int v5; // edx@2
  _DWORD *v6; // eax@2
  _DWORD *v7; // ecx@2
  int v8; // esi@4

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 16);
  result = *(_DWORD *)(a2 + 16) - v3;
  if ( *(_DWORD *)(a2 + 16) == v3 )
  {
    v5 = a2 + 20;
    v6 = (_DWORD *)(v5 + 4 * v3 - 4);
    v7 = (_DWORD *)(v2 + 4 * v3 + 16);
    if ( *v6 == *v7 )
    {
      while ( (unsigned int)v6 > v5 )
      {
        v8 = *(v6 - 1);
        --v6;
        --v7;
        if ( v8 != *v7 )
          goto LABEL_5;
      }
      result = 0;
    }
    else
    {
LABEL_5:
      result = *v6 < *v7 ? -1 : 1;
    }
  }
  return result;
}

//----- (1003B990) --------------------------------------------------------
int __usercall sub_1003B990@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int v3; // ebx@1
  signed int v4; // eax@1
  signed int v5; // ebp@1
  int result; // eax@2
  int v7; // eax@6
  int v8; // eax@7
  int v9; // ecx@8
  _DWORD *v10; // esi@8
  _DWORD *v11; // edx@8
  _DWORD *v12; // edi@8
  unsigned int v13; // eax@9
  int v14; // ecx@9
  int v15; // ebx@9
  unsigned __int64 v16; // kr08_8@11
  int v17; // ecx@12
  _DWORD *i; // edx@12
  int v19; // [sp+10h] [bp-18h]@8
  unsigned int v20; // [sp+14h] [bp-14h]@8
  unsigned int v21; // [sp+18h] [bp-10h]@8
  int v22; // [sp+1Ch] [bp-Ch]@7
  unsigned int v23; // [sp+20h] [bp-8h]@8

  v2 = a2;
  v3 = a1;
  v4 = sub_1003B940(a1, a2);
  v5 = 0;
  if ( v4 )
  {
    if ( v4 < 0 )
    {
      v7 = v2;
      v2 = v3;
      v3 = v7;
      v5 = 1;
    }
    v8 = sub_1003B350(*(_DWORD *)(v2 + 4));
    v22 = v8;
    if ( !v8 )
      return 0;
    *(_DWORD *)(v8 + 12) = v5;
    v9 = *(_DWORD *)(v2 + 16);
    v10 = (_DWORD *)(v2 + 20);
    v19 = v9;
    v21 = (unsigned int)&v10[v9];
    v11 = (_DWORD *)(v8 + 20);
    v20 = v3 + 4 * *(_DWORD *)(v3 + 16) + 20;
    v23 = 0;
    v12 = (_DWORD *)(v3 + 20);
    do
    {
      v14 = (*v10 - (unsigned __int64)*v12) >> 32;
      v13 = *v10 - *v12;
      *v11 = v13 - v23;
      ++v12;
      ++v10;
      v15 = ((_BYTE)v14 - (v13 < v23)) & 1;
      ++v11;
      v23 = ((_BYTE)v14 - (v13 < v23)) & 1;
    }
    while ( (unsigned int)v12 < v20 );
    for ( ; (unsigned int)v10 < v21; v15 = BYTE4(v16) & 1 )
    {
      v16 = *v10 - (unsigned __int64)(unsigned int)v15;
      ++v10;
      *v11 = v16;
      ++v11;
    }
    v17 = v19;
    for ( i = v11 - 1; !*i; --v17 )
      --i;
    result = v22;
    *(_DWORD *)(v22 + 16) = v17;
  }
  else
  {
    result = sub_1003B350(0);
    if ( !result )
      return 0;
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 16) = 1;
  }
  return result;
}

//----- (1003BAA0) --------------------------------------------------------
double __cdecl sub_1003BAA0(double a1)
{
  int v1; // eax@1
  double result; // st7@2
  int v3; // eax@3
  int v4; // eax@5
  double v5; // [sp+4h] [bp+4h]@4

  v1 = (HIDWORD(a1) & 0x7FF00000) - 54525952;
  if ( v1 <= 0 )
  {
    v3 = -v1 >> 20;
    if ( v3 >= 20 )
    {
      v4 = v3 - 20;
      if ( v4 < 31 )
        result = COERCE_DOUBLE(1 << (31 - v4));
      else
        result = COERCE_DOUBLE(1i64);
    }
    else
    {
      LODWORD(v5) = 0;
      HIDWORD(v5) = 0x80000 >> v3;
      result = v5;
    }
  }
  else
  {
    result = COERCE_DOUBLE(__PAIR__(v1, 0));
  }
  return result;
}

//----- (1003BB20) --------------------------------------------------------
double __usercall sub_1003BB20@<st0>(int a1@<eax>, _DWORD *a2)
{
  unsigned int v2; // edi@1
  int *v3; // esi@1
  signed int v4; // eax@1
  unsigned int v5; // edx@1
  double result; // st7@3
  unsigned int v7; // ecx@6
  int v8; // eax@8
  unsigned int v9; // esi@10
  double v10; // ST10_8@12
  double v11; // [sp+10h] [bp-8h]@2

  v2 = a1 + 20;
  v3 = (int *)(a1 + 20 + 4 * *(_DWORD *)(a1 + 16) - 4);
  v4 = sub_1003B560(*v3);
  *a2 = 32 - v4;
  if ( v4 >= 11 )
  {
    if ( (unsigned int)v3 <= v2 )
    {
      v7 = 0;
    }
    else
    {
      v7 = *(v3 - 1);
      --v3;
    }
    v8 = v4 - 11;
    if ( v8 )
    {
      if ( (unsigned int)v3 <= v2 )
        v9 = 0;
      else
        v9 = *(v3 - 1);
      LODWORD(v10) = (v7 << v8) | (v9 >> (32 - v8));
      HIDWORD(v10) = (v5 << v8) | (v7 >> (32 - v8)) | 0x3FF00000;
      result = v10;
    }
    else
    {
      result = COERCE_DOUBLE(__PAIR__(v5 | 0x3FF00000, v7));
    }
  }
  else
  {
    HIDWORD(v11) = (v5 >> (11 - v4)) | 0x3FF00000;
    if ( (unsigned int)v3 <= v2 )
    {
      LODWORD(v11) = v5 << (v4 + 21);
      result = v11;
    }
    else
    {
      LODWORD(v11) = ((unsigned int)*(v3 - 1) >> (11 - v4)) | (v5 << (v4 + 21));
      result = v11;
    }
  }
  return result;
}

//----- (1003BC20) --------------------------------------------------------
int __cdecl sub_1003BC20(int a1, int a2, _DWORD *a3, int *a4)
{
  int result; // eax@1
  int v5; // edi@1
  unsigned int v6; // ebx@2
  unsigned int v7; // ebp@2
  signed int v8; // eax@5
  unsigned int v9; // edx@6
  unsigned int v10; // ebx@6
  int v11; // edx@6
  signed int v12; // eax@8
  int v13; // ecx@10
  signed int v14; // eax@11
  int v15; // edx@11
  int v16; // [sp+4h] [bp-8h]@4
  unsigned int v17; // [sp+8h] [bp-4h]@2

  result = sub_1003B350(1);
  v5 = result;
  if ( result )
  {
    v6 = a2 & 0xFFFFF;
    v17 = a2 & 0xFFFFF;
    v7 = (a2 & 0x7FFFFFFFu) >> 20;
    if ( v7 )
    {
      v6 |= 0x100000u;
      v17 = v6;
    }
    v16 = a1;
    if ( a1 )
    {
      v8 = sub_1003B5C0((unsigned int *)&v16);
      if ( v8 )
      {
        v9 = v6 << (32 - v8);
        v10 = v6 >> v8;
        *(_DWORD *)(v5 + 20) = v16 | v9;
        *(_DWORD *)(v5 + 24) = v10;
        v11 = (v10 != 0) + 1;
      }
      else
      {
        *(_DWORD *)(v5 + 20) = v16;
        *(_DWORD *)(v5 + 24) = v6;
        v11 = (v6 != 0) + 1;
      }
    }
    else
    {
      v12 = sub_1003B5C0(&v17);
      *(_DWORD *)(v5 + 20) = v17;
      v11 = 1;
      v8 = v12 + 32;
    }
    *(_DWORD *)(v5 + 16) = v11;
    if ( v7 )
    {
      *a3 = v8 + v7 - 1075;
      v13 = 53 - v8;
      result = v5;
      *a4 = v13;
    }
    else
    {
      *a3 = v8 - 1074;
      v14 = sub_1003B560(*(_DWORD *)(v5 + 4 * v11 + 16));
      *a4 = 32 * v15 - v14;
      result = v5;
    }
  }
  return result;
}

//----- (1003BD30) --------------------------------------------------------
double __usercall sub_1003BD30@<st0>(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax@1
  double result; // st7@2
  int v4; // [sp+0h] [bp-18h]@1
  int v5; // [sp+4h] [bp-14h]@1
  double v6; // [sp+8h] [bp-10h]@1
  double v7; // [sp+10h] [bp-8h]@1

  v6 = sub_1003BB20(a1, &v5);
  v7 = sub_1003BB20(a2, &v4);
  v2 = v5 + 32 * (*(_DWORD *)(a1 + 16) - *(_DWORD *)(a2 + 16)) - v4;
  if ( v2 <= 0 )
  {
    HIDWORD(v7) += -1048576 * v2;
    result = v6 / v7;
  }
  else
  {
    HIDWORD(v6) += v2 << 20;
    result = v6 / v7;
  }
  return result;
}

//----- (1003BDA0) --------------------------------------------------------
int *sub_1003BDA0()
{
  int *v0; // esi@1
  int *i; // eax@2
  unsigned int v2; // ST04_4@3
  int *result; // eax@5

  v0 = dword_105726D0;
  do
  {
    for ( i = (int *)*v0; *v0; i = (int *)*v0 )
    {
      v2 = dword_10658DEC;
      *v0 = *i;
      sub_10053E10((unsigned int)i, v2);
    }
    *v0 = 0;
    ++v0;
  }
  while ( (signed int)v0 <= (signed int)&unk_1057270C );
  for ( result = (int *)dword_105726C8; dword_105726C8; result = (int *)dword_105726C8 )
  {
    dword_105726C8 = *result;
    sub_10053E10((unsigned int)result, dword_10658DEC);
  }
  return result;
}
// 105726C8: using guessed type int dword_105726C8;
// 105726D0: using guessed type int dword_105726D0[];
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003BE10) --------------------------------------------------------
double __cdecl sub_1003BE10(_BYTE *a1, _DWORD *a2, _DWORD *a3)
{
  double result; // st7@1
  signed int v4; // ecx@1
  double v5; // st6@1
  unsigned int v6; // eax@1
  _BYTE *v7; // edx@1
  signed int v8; // eax@5
  int v9; // edi@9
  int v10; // esi@9
  signed int v11; // ebx@9
  int v12; // eax@34
  int v13; // ecx@36
  signed int v14; // edi@37
  signed int v15; // ecx@43
  int v16; // esi@49
  int v17; // eax@55
  signed int v18; // edi@55
  _BYTE *v19; // esi@64
  int v20; // ecx@64
  signed int v21; // eax@64
  int v22; // esi@80
  signed int v23; // ecx@82
  int v24; // eax@95
  double v25; // st7@96
  signed int v26; // eax@98
  signed int v27; // eax@100
  int v28; // ecx@100
  int v29; // eax@110
  signed int v30; // eax@112
  signed int v31; // eax@113
  double *v32; // ecx@117
  int v33; // ecx@123
  int v34; // eax@130
  int v35; // ebx@134
  signed int v36; // eax@137
  int v37; // edi@137
  int v38; // ecx@143
  signed int v39; // edi@145
  signed int v40; // ebx@145
  signed int v41; // ecx@145
  signed int v42; // esi@147
  int v43; // eax@152
  int v44; // esi@153
  int v45; // eax@163
  int v46; // edi@164
  int v47; // ebx@164
  signed int v48; // eax@164
  double v49; // st7@166
  double v50; // st7@168
  double v51; // st6@175
  unsigned int v52; // edi@177
  double v53; // st7@178
  double v54; // st7@178
  int v55; // esi@186
  double v56; // st7@189
  double v57; // st7@194
  double v58; // st6@197
  int v59; // esi@206
  double v60; // st7@228
  double v61; // st7@234
  _BYTE *v62; // [sp+40h] [bp-50h]@1
  int v63; // [sp+44h] [bp-4Ch]@1
  int v64; // [sp+48h] [bp-48h]@69
  int v65; // [sp+48h] [bp-48h]@80
  int v66; // [sp+4Ch] [bp-44h]@1
  int v67; // [sp+50h] [bp-40h]@1
  int v68; // [sp+54h] [bp-3Ch]@1
  int v69; // [sp+58h] [bp-38h]@9
  double v70; // [sp+58h] [bp-38h]@178
  signed int v71; // [sp+60h] [bp-30h]@1
  int v72; // [sp+60h] [bp-30h]@86
  unsigned int v73; // [sp+64h] [bp-2Ch]@9
  signed int v74; // [sp+64h] [bp-2Ch]@95
  int v75; // [sp+68h] [bp-28h]@9
  int v76; // [sp+6Ch] [bp-24h]@1
  double v77; // [sp+70h] [bp-20h]@26
  double v78; // [sp+78h] [bp-18h]@9
  int v79; // [sp+84h] [bp-Ch]@1
  double v80; // [sp+88h] [bp-8h]@84

  result = 0.0;
  v4 = 0;
  v5 = 0.0;
  *a3 = 0;
  v6 = *a1;
  v7 = a1;
  v68 = 0;
  v63 = 0;
  v67 = 0;
  v66 = 0;
  v71 = 0;
  v76 = 0;
  v79 = 0;
  v62 = a1;
  while ( 2 )
  {
    switch ( v6 )
    {
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0x20u:
        v6 = (v7++)[1];
        if ( v6 <= 0x2D )
          continue;
        goto LABEL_4;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Cu:
LABEL_4:
        v62 = v7;
        goto LABEL_5;
      case 0x2Du:
        v79 = 1;
        goto LABEL_14;
      case 0x2Bu:
LABEL_14:
        v62 = ++v7;
        if ( !*v7 )
          goto LABEL_15;
        goto LABEL_5;
      case 0u:
LABEL_15:
        v7 = a1;
        goto LABEL_16;
      default:
LABEL_5:
        LOBYTE(v8) = *v7;
        if ( *v7 == 48 )
        {
          v76 = 1;
          do
            ++v7;
          while ( *v7 == 48 );
          LOBYTE(v8) = *v7;
          v62 = v7;
          if ( !*v7 )
            goto LABEL_16;
        }
        v8 = (unsigned __int8)v8;
        v9 = 0;
        v10 = 0;
        v11 = 0;
        LODWORD(v78) = v7;
        v73 = 0;
        v69 = 0;
        v75 = 0;
        if ( (signed int)(unsigned __int8)v8 >= 48 )
        {
          do
          {
            if ( v8 > 57 )
              break;
            if ( v11 >= 9 )
            {
              if ( v11 < 16 )
                v10 = v8 + 10 * v10 - 48;
            }
            else
            {
              v9 = v8 + 10 * v9 - 48;
            }
            v8 = (v7++)[1];
            ++v11;
          }
          while ( v8 >= 48 );
          v69 = v9;
          v73 = v10;
          v62 = v7;
        }
        LODWORD(v77) = v11;
        if ( v8 != 46 )
          goto LABEL_49;
        v8 = (v7++)[1];
        v62 = v7;
        if ( v11 )
          goto LABEL_33;
        if ( v8 == 48 )
        {
          do
          {
            v8 = (v7++)[1];
            ++v4;
          }
          while ( v8 == 48 );
          v62 = v7;
          v71 = v4;
        }
        if ( (unsigned int)(v8 - 49) > 8 )
          goto LABEL_49;
        v75 = v4;
        LODWORD(v78) = v7;
        v4 = 0;
        break;
    }
    break;
  }
  do
  {
    ++v4;
    v12 = v8 - 48;
    v71 = v4;
    if ( v12 )
    {
      v75 += v4;
      if ( v4 > 1 )
      {
        v13 = v4 - 1;
        do
        {
          v14 = v11++;
          if ( v14 >= 9 )
          {
            if ( v11 <= 16 )
              v10 *= 10;
          }
          else
          {
            v69 *= 10;
          }
          --v13;
        }
        while ( v13 );
        v73 = v10;
      }
      v15 = v11++;
      if ( v15 < 9 )
      {
        v4 = 0;
        ++v7;
        v69 = v12 + 10 * v69;
        v8 = *v7;
        v71 = 0;
        v62 = v7;
        continue;
      }
      if ( v11 <= 16 )
      {
        v10 = v12 + 10 * v10;
        v73 = v10;
      }
      v4 = 0;
      v71 = 0;
    }
    v8 = (v7++)[1];
    v62 = v7;
LABEL_33:
    ;
  }
  while ( (unsigned int)(v8 - 48) <= 9 );
LABEL_49:
  v16 = 0;
  if ( v8 == 101 || v8 == 69 )
  {
    if ( !v11 && !v4 && !v76 )
    {
      v7 = a1;
      goto LABEL_16;
    }
    v17 = v7[1];
    a1 = v7++;
    v18 = 0;
    v62 = v7;
    if ( v17 == 43 )
    {
LABEL_58:
      v17 = (v7++)[1];
      v62 = v7;
    }
    else if ( v17 == 45 )
    {
      v18 = 1;
      goto LABEL_58;
    }
    if ( (unsigned int)(v17 - 48) > 9 )
    {
      v7 = a1;
      v62 = a1;
    }
    else
    {
      if ( v17 == 48 )
      {
        do
          v17 = (v7++)[1];
        while ( v17 == 48 );
        v62 = v7;
      }
      if ( (unsigned int)(v17 - 49) > 8 )
      {
        v64 = 0;
      }
      else
      {
        v19 = v7++;
        v20 = v17 - 48;
        v21 = *v7;
        v62 = v7;
        if ( v21 >= 48 )
        {
          do
          {
            if ( v21 > 57 )
              break;
            ++v7;
            v20 = v21 + 10 * v20 - 48;
            v21 = *v7;
          }
          while ( v21 >= 48 );
          v62 = v7;
        }
        if ( v7 - v19 > 8 || (v64 = v20, v20 > 19999) )
          v64 = 19999;
        if ( v18 )
          v64 = -v64;
      }
      v16 = v64;
    }
  }
  if ( v11 )
  {
    v22 = v16 - v75;
    v65 = v22;
    if ( !LODWORD(v77) )
      LODWORD(v77) = v11;
    v23 = v11;
    if ( v11 >= 16 )
      v23 = 16;
    v5 = (double)(unsigned int)v69;
    v80 = v5;
    if ( v23 > 9 )
    {
      v5 = v5 * dbl_100CF9D8[v23] + (double)v73;
      v80 = v5;
    }
    v72 = 0;
    if ( v11 <= 15 )
    {
      if ( !v22 )
      {
LABEL_16:
        result = v5;
        goto LABEL_17;
      }
      if ( v22 <= 0 )
      {
        if ( v22 >= -22 )
        {
          result = v5 / dbl_100CFA20[-v22];
          goto LABEL_17;
        }
      }
      else
      {
        if ( v22 <= 22 )
        {
          result = v5 * dbl_100CFA20[v22];
          goto LABEL_17;
        }
        if ( v22 <= 15 - v11 + 22 )
        {
          result = v5 * dbl_100CFA20[15 - v11] * dbl_100CFA20[v22 - (15 - v11)];
          goto LABEL_17;
        }
      }
    }
    v24 = v11 + v22 - v23;
    v74 = 0;
    if ( v24 <= 0 )
    {
      if ( v24 < 0 )
      {
        v29 = -v24;
        if ( v29 & 0xF )
        {
          v5 = v5 / dbl_100CFA20[v29 & 0xF];
          v80 = v5;
        }
        v30 = v29 & 0xFFFFFFF0;
        if ( v30 )
        {
          v31 = v30 >> 4;
          if ( v31 >= 32 )
            goto LABEL_239;
          if ( v31 & 0x10 )
            v74 = 53;
          if ( v31 > 0 )
          {
            v32 = (double *)&unk_100CFB00;
            do
            {
              if ( v31 & 1 )
                v5 = v5 * *v32;
              v31 >>= 1;
              ++v32;
            }
            while ( v31 > 0 );
            v80 = v5;
          }
          if ( v74 )
          {
            v33 = 54 - ((HIDWORD(v80) >> 20) & 0x7FF);
            if ( v33 > 0 )
            {
              if ( v33 < 32 )
              {
                LODWORD(v80) &= -1 << v33;
              }
              else
              {
                LODWORD(v80) = 0;
                HIDWORD(v80) &= -1 << (v33 - 32);
                if ( !HIDWORD(v80) )
                  HIDWORD(v80) = 1;
              }
              v5 = v80;
            }
          }
          if ( 0.0 == v5 )
          {
LABEL_239:
            *a3 = 1;
            if ( !v72 )
            {
              v7 = v62;
              goto LABEL_17;
            }
            goto LABEL_245;
          }
        }
      }
    }
    else
    {
      v25 = v5;
      if ( v24 & 0xF )
      {
        v25 = v5 * dbl_100CFA20[v24 & 0xF];
        v80 = v25;
      }
      v26 = v24 & 0xFFFFFFF0;
      if ( v26 )
      {
        if ( v26 <= 308 )
        {
          v27 = v26 >> 4;
          v28 = 0;
          if ( v27 > 1 )
          {
            do
            {
              if ( v27 & 1 )
                v25 = v25 * dbl_100CFAD8[v28];
              v27 >>= 1;
              ++v28;
            }
            while ( v27 > 1 );
            v80 = v25;
          }
          HIDWORD(v80) -= 55574528;
          v80 = dbl_100CFAD8[v28] * v80;
          if ( (HIDWORD(v80) & 0x7FF00000u) <= 0x7CA00000 )
          {
            if ( (HIDWORD(v80) & 0x7FF00000u) <= 0x7C900000 )
              HIDWORD(v80) += 55574528;
            else
              v80 = 1.797693134862316e308;
            goto LABEL_130;
          }
        }
LABEL_241:
        v80 = 1.797693134862316e308/*+Inf*/;
        result = 1.797693134862316e308/*+Inf*/;
        *a3 = 1;
        if ( !v72 )
        {
          v7 = v62;
          goto LABEL_17;
        }
LABEL_245:
        sub_1003B3C0(v66);
        sub_1003B3C0(v67);
        sub_1003B3C0(v63);
        sub_1003B3C0(v72);
        sub_1003B3C0(v68);
        v7 = v62;
        goto LABEL_17;
      }
    }
LABEL_130:
    v34 = sub_1003B4B0(SLODWORD(v78), SLODWORD(v77), v11, v69);
    v72 = v34;
    if ( !v34 || (v67 = sub_1003B350(*(_DWORD *)(v34 + 4))) == 0 )
    {
LABEL_211:
      sub_1003B3C0(v66);
      sub_1003B3C0(v67);
      sub_1003B3C0(v63);
      sub_1003B3C0(v72);
      sub_1003B3C0(v68);
      result = 0.0;
      *a3 = 2;
      return result;
    }
    while ( 1 )
    {
      memcpy((void *)(v67 + 12), (const void *)(v72 + 12), 4 * *(_DWORD *)(v72 + 16) + 8);
      v35 = 0;
      v66 = sub_1003BC20(SLODWORD(v80), SHIDWORD(v80), &v76, &v75);
      if ( !v66 )
        goto LABEL_211;
      v63 = sub_1003B640(1);
      if ( !v63 )
        goto LABEL_211;
      if ( v22 < 0 )
      {
        v36 = -v22;
        v37 = -v22;
        LODWORD(v78) = 0;
      }
      else
      {
        v36 = 0;
        v37 = 0;
        LODWORD(v78) = v22;
        v35 = v22;
      }
      if ( v76 < 0 )
        v35 -= v76;
      else
        v37 += v76;
      LODWORD(v77) = v37;
      if ( v75 + v76 - v74 - 1 >= -1022 )
        v38 = 54 - v75;
      else
        v38 = v76 - v74 + 1075;
      v39 = v38 + v37;
      v40 = v74 + v38 + v35;
      v41 = v39;
      if ( v39 >= v40 )
        v41 = v40;
      v42 = LODWORD(v77);
      if ( v41 > SLODWORD(v77) )
        v41 = LODWORD(v77);
      if ( v41 > 0 )
      {
        v39 -= v41;
        v40 -= v41;
        v42 = LODWORD(v77) - v41;
        LODWORD(v77) -= v41;
      }
      if ( v36 > 0 )
      {
        v43 = sub_1003B790(v36, v63);
        v63 = v43;
        if ( !v43 )
          goto LABEL_211;
        v44 = sub_1003B660(v43, v66);
        if ( !v44 )
          goto LABEL_211;
        sub_1003B3C0(v66);
        v66 = v44;
        v42 = LODWORD(v77);
      }
      if ( v39 > 0 )
      {
        v66 = sub_1003B860(v66, v39);
        if ( !v66 )
          goto LABEL_211;
      }
      if ( SLODWORD(v78) > 0 )
      {
        v67 = sub_1003B790(SLODWORD(v78), v67);
        if ( !v67 )
          goto LABEL_211;
      }
      if ( v40 > 0 )
      {
        v67 = sub_1003B860(v67, v40);
        if ( !v67 )
          goto LABEL_211;
      }
      if ( v42 > 0 )
      {
        v63 = sub_1003B860(v63, v42);
        if ( !v63 )
          goto LABEL_211;
      }
      v45 = sub_1003B990(v67, v66);
      v68 = v45;
      if ( !v45 )
        goto LABEL_211;
      v46 = v45;
      v47 = *(_DWORD *)(v45 + 12);
      *(_DWORD *)(v45 + 12) = 0;
      v48 = sub_1003B940(v63, v45);
      if ( v48 < 0 )
      {
        v59 = HIDWORD(v80);
        if ( v47 || LODWORD(v80) || HIDWORD(v80) & 0xFFFFF || (HIDWORD(v80) & 0x7FF00000u) <= 0x3600000 )
        {
          if ( !*(_DWORD *)(v46 + 20) && *(_DWORD *)(v46 + 16) == 1 )
            v47 = 2;
          goto LABEL_222;
        }
        v68 = sub_1003B860(v46, 1);
        if ( !v68 )
          goto LABEL_211;
        if ( sub_1003B940(v63, v68) <= 0 )
          goto LABEL_222;
LABEL_232:
        HIDWORD(v80) = ((v59 & 0x7FF00000) - 1) | 0xFFFFF;
        LODWORD(v80) = -1;
LABEL_221:
        v59 = HIDWORD(v80);
        goto LABEL_222;
      }
      if ( !v48 )
      {
        v59 = HIDWORD(v80);
        if ( v47 )
        {
          if ( (HIDWORD(v80) & 0xFFFFF) == 0xFFFFF && LODWORD(v80) == -1 )
          {
            v47 = 0;
            HIDWORD(v80) = (HIDWORD(v80) & 0x7FF00000) + 0x100000;
            LODWORD(v80) = 0;
            goto LABEL_221;
          }
LABEL_233:
          if ( LOBYTE(v80) & 1 )
          {
            v61 = sub_1003BAA0(v80);
            if ( v47 )
            {
              result = v61 + v80;
              v47 = 1 - v47;
              v80 = result;
              v59 = HIDWORD(v80);
            }
            else
            {
              result = v80 - v61;
              v80 = result;
              if ( 0.0 == result )
              {
                result = 0.0;
                goto LABEL_239;
              }
              v59 = HIDWORD(v80);
              v47 = 1;
            }
            goto LABEL_223;
          }
LABEL_222:
          result = v80;
LABEL_223:
          if ( !v74 )
            goto LABEL_245;
          if ( (v59 & 0x7FF00000u) <= 0x3500000 && LOBYTE(v80) & 1 && v47 != 2 )
          {
            if ( v47 )
            {
              v60 = sub_1003BAA0(result);
              result = (v60 + v80) * 1.110223024625157e-16;
              goto LABEL_245;
            }
            LODWORD(v80) &= 0xFFFFFFFE;
            result = v80;
          }
          result = result * 1.110223024625157e-16;
          goto LABEL_245;
        }
        if ( HIDWORD(v80) & 0xFFFFF || LODWORD(v80) )
          goto LABEL_233;
        v47 = 2;
        goto LABEL_232;
      }
      v49 = sub_1003BD30(v46, v63);
      if ( v49 <= 2.0 )
        break;
      v50 = v49 * 0.5;
      v77 = v50;
      if ( !v47 )
        goto LABEL_175;
      v78 = v50;
LABEL_177:
      v52 = HIDWORD(v80) & 0x7FF00000;
      if ( (HIDWORD(v80) & 0x7FF00000) == 2145386496 )
      {
        v53 = v80;
        HIDWORD(v80) -= 55574528;
        v70 = v53;
        v54 = sub_1003BAA0(v80);
        v80 = v54 * v78 + v80;
        if ( (HIDWORD(v80) & 0x7FF00000u) >= 0x7CA00000 )
        {
          if ( v70 == 1.797693134862316e308 )
            goto LABEL_241;
          v80 = 1.797693134862316e308;
          goto LABEL_204;
        }
        v55 = HIDWORD(v80) + 55574528;
        HIDWORD(v80) += 55574528;
        result = v80;
      }
      else
      {
        if ( v52 <= 0x3500000 && v50 > 1.0 )
        {
          v56 = (double)(signed int)(v50 + 0.5);
          v78 = v56;
          if ( !v47 )
            v78 = -v56;
        }
        if ( v74 && v52 <= 0x3500000 )
          HIDWORD(v78) += 56623104 - v52;
        v57 = sub_1003BAA0(v80);
        result = v57 * v78 + v80;
        v80 = result;
        v55 = HIDWORD(v80);
      }
      if ( !v74 && v52 == (v55 & 0x7FF00000) )
      {
        LODWORD(v78) = (signed int)v77;
        v58 = v77 - (double)(signed int)v77;
        if ( v47 || LODWORD(v80) || v55 & 0xFFFFF )
        {
          if ( v58 < 0.4999999 || v58 > 0.5000000999999999 )
            goto LABEL_245;
        }
        else if ( v58 < 0.24999995 )
        {
          goto LABEL_245;
        }
      }
LABEL_204:
      sub_1003B3C0(v66);
      sub_1003B3C0(v67);
      sub_1003B3C0(v63);
      sub_1003B3C0(v68);
      v68 = 0;
      v63 = 0;
      v66 = 0;
      v67 = sub_1003B350(*(_DWORD *)(v72 + 4));
      if ( !v67 )
        goto LABEL_211;
      v22 = v65;
    }
    if ( v47 )
    {
      v50 = 1.0;
      v78 = 1.0;
      v77 = 1.0;
      goto LABEL_177;
    }
    if ( LODWORD(v80) )
    {
      if ( *(_QWORD *)&v80 == 1i64 )
      {
        result = 0.0;
        goto LABEL_239;
      }
    }
    else if ( !(HIDWORD(v80) & 0xFFFFF) )
    {
      if ( v49 >= 1.0 )
        v50 = v49 * 0.5;
      else
        v50 = 0.5;
      v77 = v50;
LABEL_175:
      v51 = -v50;
LABEL_176:
      v78 = v51;
      goto LABEL_177;
    }
    v50 = 1.0;
    v77 = 1.0;
    v51 = -1.0;
    goto LABEL_176;
  }
  result = 0.0;
  if ( !v71 && !v76 )
    v7 = a1;
LABEL_17:
  if ( a2 )
    *a2 = v7;
  if ( v79 )
    result = -result;
  return result;
}
// 100CF9D8: using guessed type double dbl_100CF9D8[];
// 100CFA20: using guessed type double dbl_100CFA20[];
// 100CFAD8: using guessed type double dbl_100CFAD8[];

//----- (1003CAD0) --------------------------------------------------------
int __usercall sub_1003CAD0@<eax>(signed int a1@<eax>, int a2)
{
  signed int v2; // esi@1
  int v3; // ebx@1
  char v4; // di@1
  int result; // eax@2
  int v6; // edx@3
  int i; // esi@6
  int v8; // [sp+Ch] [bp-4h]@3

  v2 = a1 >> 5;
  v3 = *(_DWORD *)(a2 + 16) - (a1 >> 5);
  v4 = a1 & 0x1F;
  if ( v3 > 0 )
  {
    v6 = a2 + 20 + 4 * v2;
    v8 = *(_DWORD *)v6 >> v4;
    *(_DWORD *)v6 &= (1 << v4) - 1;
    if ( v3 == 2 && a1 & 0x1F )
      v8 |= *(_DWORD *)(v6 + 4) << (32 - v4);
    for ( i = v2 + 1; !*(_DWORD *)v6; --i )
    {
      if ( v6 == a2 + 20 )
        break;
      v6 -= 4;
    }
    result = v8;
    *(_DWORD *)(a2 + 16) = i;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003CB60) --------------------------------------------------------
unsigned int __cdecl sub_1003CB60(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  unsigned int result; // eax@2
  int v5; // eax@3
  _DWORD *v6; // esi@3
  _DWORD *v7; // ecx@3
  _DWORD *v8; // edi@3
  unsigned int v9; // ebx@3
  unsigned int v10; // ecx@3
  unsigned __int64 v11; // rax@6
  int v12; // ecx@6
  unsigned __int64 v13; // kr10_8@6
  int v14; // edx@8
  unsigned int *v15; // eax@8
  _DWORD *v16; // esi@14
  unsigned int v17; // ebx@14
  _DWORD *v18; // edi@14
  int v19; // edx@15
  int v20; // eax@15
  unsigned int v21; // ecx@15
  int v22; // edx@16
  unsigned int v23; // ecx@16
  _DWORD *i; // eax@17
  int v25; // [sp+4h] [bp-1Ch]@3
  unsigned int v26; // [sp+8h] [bp-18h]@3
  _DWORD *v27; // [sp+Ch] [bp-14h]@3
  unsigned int *v28; // [sp+10h] [bp-10h]@3
  unsigned int v29; // [sp+18h] [bp-8h]@4
  unsigned int v30; // [sp+18h] [bp-8h]@14

  v2 = *(_DWORD *)(a2 + 16);
  v3 = a1;
  if ( *(_DWORD *)(a1 + 16) >= v2 )
  {
    v5 = v2 - 1;
    v6 = (_DWORD *)(a2 + 20);
    v7 = (_DWORD *)(a2 + 20 + 4 * v5);
    v25 = v5;
    v27 = v7;
    v8 = (_DWORD *)(a1 + 20);
    v28 = (unsigned int *)(a1 + 20 + 4 * v5);
    v9 = 0;
    v10 = *v28 / (*v7 + 1);
    v26 = v10;
    if ( v10 )
    {
      v29 = 0;
      while ( 1 )
      {
        v11 = v9 + *v6 * (unsigned __int64)v10;
        v9 = HIDWORD(v11);
        ++v6;
        v13 = *v8 - (unsigned __int64)(unsigned int)v11;
        v12 = v13 >> 32;
        HIDWORD(v11) = v13;
        *v8 = HIDWORD(v11) - v29;
        ++v8;
        v29 = ((_BYTE)v12 - (HIDWORD(v11) < v29)) & 1;
        if ( v6 > v27 )
          break;
        v10 = v26;
      }
      v3 = a1;
      if ( !*v28 )
      {
        v14 = v25;
        v15 = v28 - 1;
        if ( (unsigned int)(v28 - 1) > a1 + 20 )
        {
          do
          {
            if ( *v15 )
              break;
            --v15;
            --v14;
          }
          while ( (unsigned int)v15 > a1 + 20 );
          v25 = v14;
        }
        *(_DWORD *)(a1 + 16) = v14;
      }
    }
    if ( sub_1003B940(a2, v3) >= 0 )
    {
      ++v26;
      v16 = (_DWORD *)(a2 + 20);
      v17 = 0;
      v30 = 0;
      v18 = (_DWORD *)(v3 + 20);
      do
      {
        v19 = v17 + *v16;
        v17 = (v17 + (unsigned __int64)*v16) >> 32;
        ++v16;
        v20 = (*v18 - (unsigned __int64)(unsigned int)v19) >> 32;
        v21 = *v18 - v19;
        *v18 = v21 - v30;
        ++v18;
        v30 = ((_BYTE)v20 - (v21 < v30)) & 1;
      }
      while ( v16 <= v27 );
      v22 = v25;
      v23 = a1 + 20;
      if ( !*(_DWORD *)(a1 + 20 + 4 * v25) )
      {
        for ( i = (_DWORD *)(a1 + 20 + 4 * v25 - 4); (unsigned int)i > v23; --v22 )
        {
          if ( *i )
            break;
          --i;
        }
        *(_DWORD *)(a1 + 16) = v22;
      }
    }
    result = v26;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003CCD0) --------------------------------------------------------
int __usercall sub_1003CCD0@<eax>(_DWORD *a1@<eax>, double a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // ebp@1
  unsigned int v10; // edi@1
  const char *v11; // eax@7
  bool v12; // cf@7
  int v13; // edx@10
  char v14; // cl@11
  int v15; // eax@13
  double v17; // st7@20
  int v18; // esi@20
  int v19; // esi@21
  int v20; // eax@22
  double v21; // st6@25
  signed int v22; // edx@25
  bool v23; // c3@26
  double v24; // st6@26
  int v25; // eax@33
  signed int v26; // eax@39
  signed int v27; // ecx@42
  int v28; // edi@44
  int v29; // ebx@44
  double v30; // st4@55
  _BYTE *v31; // esi@55
  double v32; // st4@57
  signed int v33; // edx@57
  double v34; // st3@58
  signed int v35; // eax@58
  double *v36; // ecx@61
  signed int v37; // eax@67
  int v38; // ecx@68
  signed int v39; // eax@68
  double *v40; // ecx@69
  double v41; // rt2@80
  double v42; // st4@80
  double v43; // st4@80
  int v44; // edi@89
  double v45; // st2@89
  _BYTE *v46; // esi@89
  double v47; // st7@89
  double v48; // rtt@91
  double v49; // rt0@94
  double v50; // st2@94
  double v51; // st7@94
  double v52; // st2@94
  signed int v53; // eax@94
  double v54; // st2@94
  double v55; // st3@96
  double v56; // st7@96
  int v57; // edi@97
  double v58; // st3@100
  bool v59; // c0@100
  bool v60; // c3@100
  double v61; // st3@107
  double v62; // st4@114
  signed int v63; // ecx@114
  double v64; // st7@114
  signed int v65; // edi@115
  double v66; // rt1@116
  double v67; // rt2@117
  double v68; // st4@117
  double v69; // st7@117
  double v70; // st4@117
  signed int v71; // eax@118
  double v72; // st4@118
  double v73; // st6@119
  double v74; // st7@120
  _BYTE *v75; // esi@126
  int v76; // ecx@132
  signed int v77; // edi@132
  signed int v78; // ebp@132
  int v79; // eax@135
  int v80; // eax@137
  int v81; // eax@139
  signed int v82; // ebx@142
  signed int v83; // eax@147
  int v84; // eax@153
  int v85; // edi@154
  int v86; // eax@157
  int v87; // eax@160
  signed int v88; // ebp@163
  signed int v89; // edx@167
  char v90; // cl@170
  int v91; // eax@172
  int v92; // eax@175
  signed int v93; // edi@188
  int v94; // eax@193
  signed int v95; // eax@194
  unsigned int v96; // ebx@207
  signed int v97; // ebp@207
  int v98; // edi@207
  int v99; // eax@222
  signed int v100; // eax@242
  unsigned int v101; // ecx@246
  int v102; // ebp@259
  signed int v103; // edi@259
  int v104; // eax@260
  signed int v105; // eax@263
  int v106; // [sp+20h] [bp-48h]@17
  int v107; // [sp+24h] [bp-44h]@17
  int v108; // [sp+28h] [bp-40h]@17
  signed int v109; // [sp+2Ch] [bp-3Ch]@25
  int v110; // [sp+30h] [bp-38h]@34
  int v111; // [sp+34h] [bp-34h]@44
  int v112; // [sp+38h] [bp-30h]@17
  signed int v113; // [sp+3Ch] [bp-2Ch]@57
  signed int v114; // [sp+3Ch] [bp-2Ch]@132
  int v115; // [sp+40h] [bp-28h]@36
  signed int v116; // [sp+44h] [bp-24h]@44
  signed int v117; // [sp+44h] [bp-24h]@207
  int v118; // [sp+48h] [bp-20h]@37
  signed int v119; // [sp+4Ch] [bp-1Ch]@37
  int v120; // [sp+50h] [bp-18h]@44
  signed int v121; // [sp+50h] [bp-18h]@209
  int v122; // [sp+54h] [bp-14h]@18
  double v123; // [sp+58h] [bp-10h]@20
  int v124; // [sp+60h] [bp-8h]@20
  int v125; // [sp+64h] [bp-4h]@18
  int v126; // [sp+6Ch] [bp+4h]@57
  double v127; // [sp+6Ch] [bp+4h]@79

  v9 = a8;
  v10 = HIDWORD(a2);
  if ( SHIDWORD(a2) >= 0 )
  {
    *a1 = 0;
  }
  else
  {
    v10 = HIDWORD(a2) & 0x7FFFFFFF;
    *a1 = 1;
    HIDWORD(a2) &= 0x7FFFFFFFu;
  }
  if ( (v10 & 0x7FF00000) == 2146435072 )
  {
    *(_DWORD *)a6 = 9999;
    if ( LODWORD(a2) || v10 & 0xFFFFF )
    {
      v11 = (const char *)&unk_100CFB78;
      v12 = (unsigned int)a9 < 4;
    }
    else
    {
      v11 = "Infinity";
      v12 = (unsigned int)a9 < 9;
    }
    if ( !v12 )
    {
      v13 = a8 - (_DWORD)v11;
      do
      {
        v14 = *v11;
        v11[v13] = *v11;
        ++v11;
      }
      while ( v14 );
      if ( a7 )
      {
        v15 = a8 + 3;
        if ( *(_BYTE *)(a8 + 3) )
          v15 = a8 + 8;
        *(_DWORD *)a7 = v15;
      }
      return 1;
    }
    return 0;
  }
  v106 = 0;
  v108 = 0;
  v107 = 0;
  v112 = 0;
  if ( a2 == 0.0 )
    goto LABEL_82;
  v106 = sub_1003BC20(SLODWORD(a2), SHIDWORD(a2), &v122, &v125);
  if ( !v106 )
    goto LABEL_227;
  if ( (v10 >> 20) & 0x7FF )
  {
    v17 = a2;
    v18 = ((v10 >> 20) & 0x7FF) - 1023;
    v123 = a2;
    HIDWORD(v123) = HIDWORD(v123) & 0xFFFFF | 0x3FF00000;
    v124 = 0;
  }
  else
  {
    v19 = v122 + v125 + 1074;
    if ( v19 <= 32 )
      v20 = LODWORD(a2) << (32 - v19);
    else
      v20 = (LODWORD(a2) >> (v122 + v125 + 18)) | (v10 << (64 - v19));
    v123 = (double)(unsigned int)v20;
    HIDWORD(v123) -= 32505856;
    v17 = a2;
    v18 = v122 + v125 - 1;
    v124 = 1;
  }
  v21 = (v123 - 1.5) * 0.289529654602168 + 0.1760912590558 + (double)v18 * 0.301029995663981;
  v22 = (signed int)v21;
  v109 = (signed int)v21;
  if ( v21 >= 0.0 )
  {
    v24 = 0.0;
  }
  else
  {
    v23 = (double)v109 == v21;
    v24 = 0.0;
    if ( !v23 )
      v109 = --v22;
  }
  LODWORD(v123) = 1;
  if ( (unsigned int)v22 <= 0x16 )
  {
    if ( dbl_100CFA20[v22] > v17 )
      v109 = --v22;
    LODWORD(v123) = 0;
  }
  v25 = v125 - v18 - 1;
  if ( v25 < 0 )
  {
    v110 = -v25;
    v25 = 0;
  }
  else
  {
    v110 = 0;
  }
  v115 = v25;
  if ( v22 < 0 )
  {
    v110 -= v22;
    v118 = -v22;
    v119 = 0;
  }
  else
  {
    v118 = 0;
    v119 = v22;
    v115 = v22 + v25;
  }
  v26 = a3;
  if ( a3 < 0 || a3 > 9 )
  {
    v26 = 0;
    a3 = 0;
  }
  v27 = 1;
  if ( v26 > 5 )
  {
    v26 -= 4;
    a3 = v26;
    v27 = 0;
  }
  v116 = 1;
  v28 = 0;
  v29 = 0;
  v120 = 0;
  v111 = 0;
  switch ( v26 )
  {
    case 0:
    case 1:
      v28 = -1;
      v29 = -1;
      v120 = -1;
      v111 = -1;
      v18 = 18;
      a5 = 0;
      break;
    case 2:
      v116 = 0;
      goto LABEL_47;
    case 4:
LABEL_47:
      v18 = a5;
      if ( a5 <= 0 )
      {
        v18 = 1;
        a5 = 1;
      }
      v28 = v18;
      v29 = v18;
      v120 = v18;
      v111 = v18;
      break;
    case 3:
      v116 = 0;
      goto LABEL_51;
    case 5:
LABEL_51:
      v18 = v22 + a5 + 1;
      v29 = v22 + a5 + 1;
      v28 = v22 + a5;
      v111 = v22 + a5 + 1;
      v120 = v22 + a5;
      if ( v18 <= 0 )
        v18 = 1;
      break;
    default:
      break;
  }
  if ( a9 <= (unsigned int)v18 )
  {
    sub_1003B3C0(v106);
    return 0;
  }
  v9 = a8;
  v30 = 5.0;
  v31 = (_BYTE *)a8;
  if ( (unsigned int)v29 > 0xE || !v27 )
  {
LABEL_105:
    if ( v122 >= 0 && v109 <= 14 )
    {
      v61 = dbl_100CFA20[v109];
      if ( a5 < 0 && v29 <= 0 )
      {
        v107 = 0;
        v108 = 0;
        if ( v29 < 0 || v30 * v61 > v17 )
          goto LABEL_82;
        if ( !a4 )
        {
          if ( v30 * v61 == v17 )
            goto LABEL_82;
          ++v109;
          *(_BYTE *)a8 = 49;
          v46 = (_BYTE *)(a8 + 1);
          goto LABEL_253;
        }
        goto LABEL_198;
      }
      v62 = v61;
      v63 = (signed int)(v17 / v61);
      *(_BYTE *)a8 = v63 + 48;
      v46 = (_BYTE *)(a8 + 1);
      v64 = v17 - (double)v63 * v61;
      if ( v29 != 1 )
      {
        v65 = 1;
        while ( 1 )
        {
          v67 = v62;
          v68 = v64;
          v69 = v67;
          v70 = v68 * 10.0;
          if ( v24 == v70 )
            goto LABEL_270;
          v71 = (signed int)(v70 / v69);
          v63 = (signed int)(v70 / v69);
          *v46 = v71 + 48;
          ++v65;
          ++v46;
          v72 = v70 - (double)v71 * v69;
          if ( v65 == v29 )
          {
            v73 = v69;
            v64 = v72;
            goto LABEL_120;
          }
          v66 = v72;
          v62 = v69;
          v64 = v66;
        }
      }
      v73 = v61;
LABEL_120:
      v74 = v64 + v64;
      if ( v73 < v74 || v73 == v74 && (v63 & 1 || a4) )
      {
LABEL_126:
        v75 = v46 - 1;
        if ( *v75 == 57 )
        {
          while ( v75 != (_BYTE *)a8 )
          {
            if ( *--v75 != 57 )
            {
              ++*v75;
              v46 = v75 + 1;
              goto LABEL_270;
            }
          }
          ++v109;
          *v75 = 48;
        }
        ++*v75;
        v46 = v75 + 1;
      }
LABEL_270:
      sub_1003B3C0(v106);
      *v46 = 0;
      if ( a7 )
        *(_DWORD *)a7 = v46;
      *(_DWORD *)a6 = v109 + 1;
      return 1;
    }
    v76 = v110;
    v77 = v118;
    v114 = v110;
    v78 = v118;
    if ( v116 )
    {
      if ( a3 >= 2 )
      {
        v80 = v29 - 1;
        if ( v118 < v29 - 1 )
        {
          v81 = v80 - v118;
          v119 += v81;
          v77 = v81 + v118;
          v118 += v81;
          v78 = 0;
        }
        else
        {
          v78 = v118 - v80;
        }
        v79 = v29;
        if ( v29 < 0 )
        {
          v114 = v110 - v29;
          v79 = 0;
        }
      }
      else if ( v124 )
      {
        v79 = v122 + 1075;
      }
      else
      {
        v79 = 54 - v125;
      }
      v110 += v79;
      v82 = v79 + v115;
      v115 += v79;
      v107 = sub_1003B640(1);
      if ( !v107 )
        goto LABEL_227;
      v76 = v114;
    }
    else
    {
      v82 = v115;
    }
    if ( v76 > 0 && v82 > 0 )
    {
      v83 = v76;
      if ( v76 >= v82 )
        v83 = v82;
      v110 -= v83;
      v82 -= v83;
      v114 = v76 - v83;
      v115 = v82;
    }
    if ( v77 <= 0 )
      goto LABEL_160;
    if ( v116 )
    {
      if ( v78 > 0 )
      {
        v84 = sub_1003B790(v78, v107);
        v107 = v84;
        if ( !v84 )
          goto LABEL_227;
        v85 = sub_1003B660(v84, v106);
        if ( !v85 )
          goto LABEL_227;
        sub_1003B3C0(v106);
        v82 = v115;
        v106 = v85;
        v77 = v118;
      }
      if ( v77 == v78 )
        goto LABEL_160;
      v86 = sub_1003B790(v77 - v78, v106);
    }
    else
    {
      v86 = sub_1003B790(v77, v106);
    }
    v106 = v86;
    if ( !v86 )
      goto LABEL_227;
LABEL_160:
    v87 = sub_1003B640(1);
    v108 = v87;
    if ( !v87 )
      goto LABEL_227;
    if ( v119 > 0 )
    {
      v108 = sub_1003B790(v119, v87);
      if ( !v108 )
        goto LABEL_227;
    }
    v88 = 0;
    if ( a3 >= 2 || LODWORD(a2) || HIDWORD(a2) & 0xFFFFF || !(HIDWORD(a2) & 0x7FE00000) )
    {
      v89 = v110;
    }
    else
    {
      v89 = v110 + 1;
      ++v82;
      v88 = 1;
    }
    if ( v119 )
      v90 = 32 - sub_1003B560(*(_DWORD *)(v108 + 4 * *(_DWORD *)(v108 + 16) + 16));
    else
      v90 = 1;
    v91 = (v90 + (_BYTE)v82) & 0x1F;
    if ( (v90 + (_BYTE)v82) & 0x1F )
      v91 = 32 - v91;
    if ( v91 <= 4 )
    {
      if ( v91 >= 4 )
      {
LABEL_179:
        if ( v89 > 0 )
        {
          v106 = sub_1003B860(v106, v89);
          if ( !v106 )
            goto LABEL_227;
        }
        if ( v82 > 0 )
        {
          v108 = sub_1003B860(v108, v82);
          if ( !v108 )
            goto LABEL_227;
        }
        if ( LODWORD(v123) && sub_1003B940(v108, v106) < 0 )
        {
          --v109;
          v106 = sub_1003B3E0(v106, 10, 0);
          if ( !v106 )
            goto LABEL_227;
          if ( v116 )
          {
            v107 = sub_1003B3E0(v107, 10, 0);
            if ( !v107 )
              goto LABEL_227;
          }
          v93 = v120;
          v111 = v120;
        }
        else
        {
          v93 = v111;
        }
        if ( v93 > 0 || a3 <= 2 )
        {
          if ( v116 )
          {
            if ( v114 <= 0 || (v107 = sub_1003B860(v107, v114)) != 0 )
            {
              v112 = v107;
              if ( !v88
                || (v107 = sub_1003B350(*(_DWORD *)(v107 + 4))) != 0
                && (memcpy((void *)(v107 + 12), (const void *)(v112 + 12), 4 * *(_DWORD *)(v112 + 16) + 8),
                    (v107 = sub_1003B860(v107, 1)) != 0) )
              {
                v117 = 1;
                v96 = sub_1003CB60(v106, v108) + 48;
                v97 = sub_1003B940(v112, v106);
                v98 = sub_1003B990(v107, v108);
                if ( v98 )
                {
                  while ( 1 )
                  {
                    if ( *(_DWORD *)(v98 + 12) )
                      v121 = 1;
                    else
                      v121 = sub_1003B940(v98, v106);
                    sub_1003B3C0(v98);
                    if ( !v121 && !a3 && !(LOBYTE(a2) & 1) )
                    {
                      if ( v96 == 57 )
                        goto LABEL_247;
                      if ( v97 > 0 )
                        LOBYTE(v96) = v96 + 1;
                      goto LABEL_237;
                    }
                    if ( v97 < 0 || !v97 && !a3 && !(LOBYTE(a2) & 1) )
                      break;
                    if ( v121 > 0 )
                    {
                      if ( v96 == 57 )
                        goto LABEL_247;
                      *v31 = v96 + 1;
                      goto LABEL_252;
                    }
                    *v31++ = v96;
                    if ( v117 == v111 )
                      goto LABEL_262;
                    v106 = sub_1003B3E0(v106, 10, 0);
                    if ( v106 )
                    {
                      if ( v112 == v107 )
                      {
                        v99 = sub_1003B3E0(v107, 10, 0);
                        v112 = v99;
                      }
                      else
                      {
                        v112 = sub_1003B3E0(v112, 10, 0);
                        if ( !v112 )
                          goto LABEL_227;
                        v99 = sub_1003B3E0(v107, 10, 0);
                      }
                      v107 = v99;
                      if ( v99 )
                      {
                        ++v117;
                        v96 = sub_1003CB60(v106, v108) + 48;
                        v97 = sub_1003B940(v112, v106);
                        v98 = sub_1003B990(v107, v108);
                        if ( v98 )
                          continue;
                      }
                    }
                    goto LABEL_227;
                  }
                  if ( v121 <= 0 )
                    goto LABEL_237;
                  v106 = sub_1003B860(v106, 1);
                  if ( v106 )
                  {
                    v100 = sub_1003B940(v108, v106);
                    if ( v100 > 0 || !v100 && (v96 & 1 || a4) )
                    {
                      v101 = v96;
                      LOBYTE(v96) = v96 + 1;
                      if ( v101 == 57 )
                      {
LABEL_247:
                        *v31++ = 57;
LABEL_248:
                        if ( *--v31 == 57 )
                        {
                          while ( v31 != (_BYTE *)a8 )
                          {
                            if ( *--v31 != 57 )
                              goto LABEL_251;
                          }
                          ++v109;
                          *v31 = 49;
                        }
                        else
                        {
LABEL_251:
                          ++*v31;
                        }
                        goto LABEL_252;
                      }
                    }
LABEL_237:
                    *v31 = v96;
                    goto LABEL_252;
                  }
                }
              }
            }
          }
          else
          {
            LOBYTE(v96) = sub_1003CB60(v106, v108) + 48;
            *(_BYTE *)a8 = v96;
            v31 = (_BYTE *)(a8 + 1);
            if ( v93 <= 1 )
            {
LABEL_262:
              v106 = sub_1003B860(v106, 1);
              if ( v106 )
              {
                v105 = sub_1003B940(v108, v106);
                if ( v105 > 0 || !v105 && (v96 & 1 || a4) )
                  goto LABEL_248;
                do
                  --v31;
                while ( *v31 == 48 );
LABEL_252:
                v46 = v31 + 1;
                goto LABEL_253;
              }
            }
            else
            {
              v102 = v106;
              v103 = 1;
              while ( 1 )
              {
                v104 = sub_1003B3E0(v102, 10, 0);
                v106 = v104;
                if ( !v104 )
                  break;
                v102 = v104;
                LOBYTE(v96) = sub_1003CB60(v104, v108) + 48;
                *v31 = v96;
                ++v103;
                ++v31;
                if ( v103 >= v111 )
                  goto LABEL_262;
              }
            }
          }
        }
        else
        {
          if ( v93 < 0 )
            goto LABEL_199;
          v94 = sub_1003B3E0(v108, 5, 0);
          v108 = v94;
          if ( v94 )
          {
            v95 = sub_1003B940(v94, v106);
            if ( v95 >= 0 && (v95 || a4) )
            {
              ++v109;
              *(_BYTE *)a8 = 49;
              v46 = (_BYTE *)(a8 + 1);
              goto LABEL_253;
            }
LABEL_199:
            v9 = a8;
            goto LABEL_82;
          }
        }
LABEL_227:
        sub_1003B3C0(v108);
        if ( v107 )
        {
          if ( v112 && v112 != v107 )
            sub_1003B3C0(v112);
          sub_1003B3C0(v107);
        }
        sub_1003B3C0(v106);
        return 0;
      }
      v92 = v91 + 28;
    }
    else
    {
      v92 = v91 - 4;
    }
    v114 += v92;
    v89 += v92;
    v82 += v92;
    goto LABEL_179;
  }
  v32 = v17;
  v33 = 2;
  v113 = v109;
  v111 = v29;
  v126 = 2;
  if ( v109 <= 0 )
  {
    v37 = -v109;
    if ( v109 )
    {
      v38 = v37 & 0xF;
      v39 = v37 >> 4;
      v17 = v17 * dbl_100CFA20[v38];
      if ( v39 )
      {
        v40 = dbl_100CFAD8;
        do
        {
          if ( v39 & 1 )
          {
            ++v33;
            v17 = v17 * *v40;
          }
          v39 >>= 1;
          ++v40;
        }
        while ( v39 );
        v126 = v33;
      }
    }
  }
  else
  {
    v34 = dbl_100CFA20[v109 & 0xF];
    v35 = v109 >> 4;
    if ( (v109 >> 4) & 0x10 )
    {
      v33 = 3;
      v35 = (v109 >> 4) & 0xF;
      v126 = 3;
      v17 = v17 / 1.0e256;
    }
    if ( v35 )
    {
      v36 = dbl_100CFAD8;
      do
      {
        if ( v35 & 1 )
        {
          v34 = v34 * *v36;
          ++v33;
        }
        v35 >>= 1;
        ++v36;
      }
      while ( v35 );
      v126 = v33;
    }
    v17 = v17 / v34;
  }
  if ( LODWORD(v123) && v17 < 1.0 && v29 > 0 )
  {
    if ( v28 <= 0 )
    {
LABEL_103:
      v17 = v32;
      goto LABEL_104;
    }
    --v109;
    v29 = v28;
    v17 = v17 * 10.0;
    v126 = v33 + 1;
  }
  v127 = (double)v126 * v17 + 7.0;
  HIDWORD(v127) -= 54525952;
  if ( v29 )
  {
    if ( v116 )
    {
      v44 = 0;
      v45 = 0.5 / dbl_100CFA18[v29] - v127;
      *(_BYTE *)a8 = (signed int)v17 + 48;
      v46 = (_BYTE *)(a8 + 1);
      v47 = v17 - (double)(signed int)v17;
      if ( v45 <= v47 )
      {
        while ( 1.0 - v47 >= v45 )
        {
          if ( ++v44 >= v29 )
            goto LABEL_103;
          v49 = v45 * 10.0;
          v50 = v47;
          v51 = v49;
          v52 = v50 * 10.0;
          v53 = (signed int)v52;
          v54 = v52 - (double)(signed int)v52;
          *v46++ = v53 + 48;
          if ( v54 < v49 )
            goto LABEL_270;
          v48 = v54;
          v45 = v51;
          v47 = v48;
        }
        goto LABEL_126;
      }
      goto LABEL_270;
    }
    v55 = dbl_100CFA18[v29] * v127;
    *(_BYTE *)a8 = (signed int)v17 + 48;
    v56 = v17 - (double)(signed int)v17;
    v46 = (_BYTE *)(a8 + 1);
    if ( v29 != 1 )
    {
      v57 = v29 - 1;
      do
      {
        *v46++ = (signed int)(v56 * 10.0) + 48;
        v56 = v56 * 10.0 - (double)(signed int)(v56 * 10.0);
        --v57;
      }
      while ( v57 );
    }
    if ( v55 + 0.5 < v56 )
      goto LABEL_126;
    v58 = 0.5 - v55;
    v59 = v58 < v56;
    v60 = v58 == v56;
    v17 = v32;
    if ( !v59 && !v60 )
    {
      do
        --v46;
      while ( *v46 == 48 );
      ++v46;
      goto LABEL_270;
    }
    goto LABEL_104;
  }
  v107 = 0;
  v41 = v32;
  v42 = v17;
  v17 = v41;
  v108 = 0;
  v43 = v42 - 5.0;
  if ( v127 < v43 )
  {
LABEL_198:
    ++v109;
    *(_BYTE *)a8 = 49;
    v46 = (_BYTE *)(a8 + 1);
LABEL_253:
    sub_1003B3C0(v108);
    if ( v107 )
    {
      if ( v112 && v112 != v107 )
        sub_1003B3C0(v112);
      sub_1003B3C0(v107);
    }
    goto LABEL_270;
  }
  if ( -v127 <= v43 )
  {
LABEL_104:
    v29 = v111;
    a2 = v17;
    v31 = (_BYTE *)a8;
    v109 = v113;
    v30 = 5.0;
    v24 = 0.0;
    goto LABEL_105;
  }
LABEL_82:
  *(_DWORD *)a6 = 1;
  if ( (unsigned int)a9 < 2 )
    return 0;
  *(_BYTE *)v9 = 48;
  *(_BYTE *)(v9 + 1) = 0;
  if ( a7 )
    *(_DWORD *)a7 = v9 + 1;
  sub_1003B3C0(v106);
  sub_1003B3C0(v108);
  if ( v107 )
    sub_1003B3C0(0);
  sub_1003B3C0(v107);
  return 1;
}
// 100CFA18: using guessed type double dbl_100CFA18[];
// 100CFA20: using guessed type double dbl_100CFA20[];
// 100CFAD8: using guessed type double dbl_100CFAD8[];

//----- (1003DB50) --------------------------------------------------------
int __cdecl sub_1003DB50(int a1, int a2, int a3, int a4, double a5)
{
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ebx@5
  int result; // eax@5
  _BYTE *v9; // eax@6
  int v10; // edx@6
  int v11; // ebp@6
  int v12; // ecx@7
  char v13; // cl@22
  int v14; // eax@26
  _BYTE *v15; // ecx@29
  _BYTE *v16; // eax@29
  char v17; // dl@30
  int v18; // [sp+30h] [bp-8h]@5
  int v19; // [sp+34h] [bp-4h]@5

  v5 = a3;
  v6 = a1 + 2;
  if ( a3 == 2 && (a5 >= 1.0e21 || a5 <= -1.0e21) )
    v5 = 0;
  v7 = a4;
  result = sub_1003CCD0(&v19, a5, *(&dword_100CFA0C + v5), v5 >= 2, a4, (int)&v18, (int)&a3, a1 + 2, a2 - 2);
  if ( result )
  {
    v9 = (_BYTE *)a3;
    v10 = v18;
    v11 = a3 - v6;
    if ( v18 != 9999 )
    {
      v12 = 0;
      a3 = 0;
      switch ( v5 )
      {
        case 0:
          if ( (unsigned int)(v18 + 5) > 0x1A )
            goto LABEL_15;
          goto LABEL_9;
        case 2:
          if ( v7 < 0 )
LABEL_9:
            v12 = v18;
          else
            v12 = v18 + v7;
          break;
        case 3:
          v12 = v7;
          goto LABEL_15;
        case 4:
          v12 = v7;
          if ( v18 < -5 || v18 > v7 )
            goto LABEL_15;
          break;
        case 1:
LABEL_15:
          a3 = 1;
          break;
        default:
          break;
      }
      if ( v11 < v12 )
      {
        v11 = v12;
        do
          *v9++ = 48;
        while ( v9 != (_BYTE *)(v12 + v6) );
        *v9 = 0;
      }
      if ( a3 )
      {
        if ( v11 != 1 )
        {
          v13 = *(_BYTE *)v6;
          v6 = a1 + 1;
          *(_BYTE *)v6 = v13;
          *(_BYTE *)(v6 + 1) = 46;
        }
        sub_10050B00((int)v9, a2 + a1 - (_DWORD)v9, "e%+d", v10 - 1);
      }
      else if ( v10 != v11 )
      {
        if ( v10 <= 0 )
        {
          v15 = v9;
          v16 = &v9[1 - v10];
          for ( *v16 = 0; v15 != (_BYTE *)v6; *v16 = v17 )
          {
            v17 = *(v15-- - 1);
            --v16;
          }
          if ( (_BYTE *)(a1 + 3) != v16 )
            memset((void *)(a1 + 3), 48, (size_t)&v16[-a1 - 3]);
          *(_BYTE *)v6 = 46;
          v6 = a1 + 1;
          *(_BYTE *)(a1 + 1) = 48;
        }
        else
        {
          v6 = a1 + 1;
          v14 = a1 + 1;
          do
          {
            *(_BYTE *)v14 = *(_BYTE *)(v14 + 1);
            ++v14;
            --v10;
          }
          while ( v10 );
          *(_BYTE *)v14 = 46;
        }
      }
    }
    if ( v19
      && (HIDWORD(a5) != 0x80000000 || LODWORD(a5))
      && ((HIDWORD(a5) & 0x7FF00000) != 2146435072 || !LODWORD(a5) && !(HIDWORD(a5) & 0xFFFFF)) )
    {
      *(_BYTE *)--v6 = 45;
    }
    result = v6;
  }
  return result;
}

//----- (1003DD40) --------------------------------------------------------
unsigned int __usercall sub_1003DD40@<eax>(unsigned int a1@<ebx>, int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // edx@1
  unsigned int *v4; // edi@2
  unsigned int v5; // ebp@3
  unsigned int v6; // ecx@3
  unsigned int v7; // eax@3
  unsigned int v8; // ecx@3
  unsigned int v9; // esi@3
  unsigned int v10; // ecx@3
  int v11; // [sp+0h] [bp-4h]@2

  result = *(_DWORD *)(a2 + 16);
  v3 = 0;
  if ( result )
  {
    v4 = (unsigned int *)(a2 + 20 + 4 * result);
    v11 = a2 + 20 + 4 * result;
    do
    {
      v5 = *(v4 - 1);
      --v4;
      v6 = (v3 << 16) | (v5 >> 16);
      v7 = v6 / a1;
      v8 = (unsigned __int16)v5 | ((v6 - a1 * (v6 / a1)) << 16);
      v9 = v8 / a1 | (v7 << 16);
      v10 = v8 - a1 * (v8 / a1);
      v3 = v10;
      *v4 = v9;
    }
    while ( v4 != (unsigned int *)(a2 + 20) );
    if ( !*(_DWORD *)(v11 - 4) )
      --*(_DWORD *)(a2 + 16);
    result = v10;
  }
  return result;
}

//----- (1003DDC0) --------------------------------------------------------
_BYTE *__cdecl sub_1003DDC0(int a1, double a2)
{
  int v2; // eax@1
  _BYTE *v3; // ebx@1
  _BYTE *v4; // edi@2
  double v5; // st7@2
  int v6; // eax@2
  const char *v7; // edx@9
  _BYTE *v8; // ecx@11
  char v9; // al@12
  char *v11; // ebp@14
  double v12; // st7@14
  unsigned int v13; // esi@15
  unsigned int v14; // eax@16
  unsigned int v15; // ecx@16
  char v16; // cl@17
  int v17; // eax@22
  int v18; // esi@22
  unsigned int v19; // eax@25
  char v20; // al@26
  char *i; // eax@30
  char v22; // cl@31
  unsigned __int64 v23; // st7@32
  int v24; // ebp@33
  int v25; // ebx@33
  int v26; // edi@33
  int v27; // esi@34
  signed int v28; // esi@36
  int v29; // eax@36
  int v30; // eax@42
  int v31; // eax@45
  int v32; // eax@51
  int v33; // esi@51
  bool v34; // zf@57
  bool v35; // sf@57
  unsigned __int8 v36; // of@57
  signed int v37; // eax@65
  char v38; // cl@70
  int v39; // ebx@79
  unsigned int v40; // [sp+20h] [bp-28h]@46
  int v41; // [sp+24h] [bp-24h]@33
  _BYTE *v42; // [sp+28h] [bp-20h]@33
  signed int v43; // [sp+2Ch] [bp-1Ch]@44
  signed int v44; // [sp+30h] [bp-18h]@36
  int v45; // [sp+38h] [bp-10h]@22
  __int64 v46; // [sp+3Ch] [bp-Ch]@15
  _BYTE *v47; // [sp+44h] [bp-4h]@1

  v2 = sub_10053CF0(0x436u, dword_10658DEC);
  v3 = (_BYTE *)v2;
  v47 = (_BYTE *)v2;
  if ( !v2 )
    return v3;
  v4 = (_BYTE *)v2;
  v5 = a2;
  v6 = HIDWORD(a2);
  if ( a2 < 0.0 && ((HIDWORD(a2) & 0x7FF00000) != 2146435072 || !(HIDWORD(a2) & 0xFFFFF) && !LODWORD(a2)) )
  {
    v5 = -a2;
    a2 = -a2;
    *v3 = 45;
    v6 = HIDWORD(a2);
    v4 = v3 + 1;
  }
  if ( (v6 & 0x7FF00000) == 2146435072 )
  {
    if ( LODWORD(a2) || (v7 = "Infinity", v6 & 0xFFFFF) )
      v7 = (const char *)&unk_100CFB78;
    v8 = v4;
    do
    {
      v9 = *v7;
      *v8++ = *v7++;
    }
    while ( v9 );
    return v3;
  }
  v11 = v4;
  v12 = floor(v5);
  if ( v12 > 4294967295.0 )
  {
    v17 = sub_1003BC20(SLODWORD(v12), *(unsigned __int64 *)&v12 >> 32, &v46, &v45);
    v18 = v17;
    if ( !v17 || (v18 = sub_1003B860(v17, v46)) == 0 )
    {
      sub_1003B3C0(v18);
      return 0;
    }
    do
    {
      v19 = sub_1003DD40(a1, v18);
      if ( v19 < 0xA )
        v20 = v19 + 48;
      else
        v20 = v19 + 87;
      *v4++ = v20;
    }
    while ( *(_DWORD *)(v18 + 16) );
    sub_1003B3C0(v18);
    v3 = v47;
  }
  else
  {
    v46 = (signed __int64)v12;
    v13 = (signed __int64)v12;
    if ( v13 )
    {
      do
      {
        v14 = v13 / a1;
        v15 = v13 - a1 * (v13 / a1);
        v13 /= (unsigned int)a1;
        if ( v15 < 0xA )
          v16 = v15 + 48;
        else
          v16 = v15 + 87;
        *v4++ = v16;
      }
      while ( v14 );
    }
    else
    {
      *v4++ = 48;
    }
  }
  for ( i = v4 - 1; i > v11; --i )
  {
    v22 = *v11;
    *v11 = *i;
    *i = v22;
    ++v11;
  }
  *(double *)&v23 = a2 - v12;
  if ( 0.0 == *(double *)&v23 )
  {
    *v4 = 0;
    return v3;
  }
  *v4 = 46;
  v24 = 0;
  v25 = 0;
  v41 = 0;
  v42 = v4 + 1;
  v26 = sub_1003BC20(v23, v23 >> 32, &v46, &v45);
  if ( v26 )
  {
    v27 = -((HIDWORD(a2) >> 20) & 0x7FF);
    if ( !((HIDWORD(a2) >> 20) & 0x7FF) )
      v27 = -1;
    v28 = v27 + 1076;
    v44 = v28;
    v29 = sub_1003B640(1);
    v24 = v29;
    if ( v29 )
    {
      v25 = v29;
      if ( LODWORD(a2)
        || HIDWORD(a2) & 0xFFFFF
        || !(HIDWORD(a2) & 0x7FE00000)
        || (++v28, v44 = v28, (v25 = sub_1003B640(2)) != 0) )
      {
        v26 = sub_1003B860(v26, v28 + v46);
        if ( v26 )
        {
          v30 = sub_1003B640(1);
          v41 = v30;
          if ( v30 )
          {
            v41 = sub_1003B860(v30, v28);
            if ( v41 )
            {
              v43 = 0;
              while ( 1 )
              {
                v31 = sub_1003B3E0(v26, a1, 0);
                v26 = v31;
                if ( !v31 )
                  goto LABEL_74;
                v40 = sub_1003CAD0(v28, v31);
                if ( v24 == v25 )
                {
                  v25 = sub_1003B3E0(v24, a1, 0);
                  v24 = v25;
                }
                else
                {
                  v24 = sub_1003B3E0(v24, a1, 0);
                  if ( !v24 )
                    goto LABEL_74;
                  v25 = sub_1003B3E0(v25, a1, 0);
                }
                if ( !v25 )
                  goto LABEL_74;
                LODWORD(v46) = sub_1003B940(v24, v26);
                v32 = sub_1003B990(v25, v41);
                v33 = v32;
                if ( !v32 )
                  goto LABEL_74;
                v45 = *(_DWORD *)(v32 + 12) ? 1 : sub_1003B940(v32, v26);
                sub_1003B3C0(v33);
                if ( !v45 && !(LOBYTE(a2) & 1) )
                  break;
                if ( (signed int)v46 < 0 || !(_DWORD)v46 && !(LOBYTE(a2) & 1) )
                {
                  if ( v45 > 0 )
                  {
                    v26 = sub_1003B860(v26, 1);
                    if ( !v26 )
                      goto LABEL_74;
                    v37 = sub_1003B940(v41, v26);
                    v36 = 0;
                    v34 = v37 == 0;
                    v35 = v37 < 0;
LABEL_66:
                    if ( !((unsigned __int8)(v35 ^ v36) | v34) )
                      ++v40;
                  }
                  v43 = 1;
                  goto LABEL_69;
                }
                if ( v45 > 0 )
                {
                  ++v40;
                  v43 = 1;
                }
LABEL_69:
                if ( v40 < 0xA )
                  v38 = v40 + 48;
                else
                  v38 = v40 + 87;
                *v42++ = v38;
                if ( v43 )
                {
                  sub_1003B3C0(v26);
                  sub_1003B3C0(v41);
                  if ( v24 != v25 )
                    sub_1003B3C0(v24);
                  sub_1003B3C0(v25);
                  v39 = (int)v47;
                  *v42 = 0;
                  return (_BYTE *)v39;
                }
                v28 = v44;
              }
              v36 = __OFSUB__((_DWORD)v46, v45);
              v34 = (_DWORD)v46 == v45;
              v35 = (signed int)v46 - v45 < 0;
              goto LABEL_66;
            }
          }
        }
      }
    }
  }
LABEL_74:
  sub_1003B3C0(v26);
  sub_1003B3C0(v41);
  if ( v24 != v25 )
    sub_1003B3C0(v24);
  sub_1003B3C0(v25);
  return 0;
}
// 10658DE8: using guessed type int dword_10658DE8;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003E260) --------------------------------------------------------
void *sub_1003E260()
{
  void *result; // eax@1

  result = memset(dword_105726D0, 0, 0x40u);
  dword_105726C8 = 0;
  return result;
}
// 105726C8: using guessed type int dword_105726C8;
// 105726D0: using guessed type int dword_105726D0[];

//----- (1003E280) --------------------------------------------------------
int __cdecl sub_1003E280(int a1, int a2, int a3, unsigned int a4)
{
  signed int v4; // eax@1
  char v5; // cl@3
  int result; // eax@3
  signed int v7; // edx@3
  unsigned int v8; // ecx@3

  v4 = a4;
  if ( a4 > 4 )
    v4 = 4;
  v5 = sub_10052D80(v4);
  result = a1;
  v7 = 1 << v5;
  v8 = (a1 + 19) & 0xFFFFFFFC;
  *(_DWORD *)(a1 + 8) = v8;
  *(_DWORD *)(a1 + 12) = v8;
  *(_DWORD *)(a1 + 4) = v8;
  *(_DWORD *)(a1 + 24) = v7 - 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(result + 16) = result;
  *(_DWORD *)(a1 + 20) = a3;
  return result;
}

//----- (1003E2D0) --------------------------------------------------------
int __cdecl sub_1003E2D0(int a1, unsigned int a2)
{
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // edi@1
  unsigned int v5; // edx@3
  unsigned int v6; // ecx@4
  int v7; // ebp@5
  unsigned int v8; // eax@8
  unsigned int v9; // esi@10
  int v10; // eax@10
  int *i; // edi@10
  unsigned int v12; // ecx@11
  int v13; // ecx@20
  unsigned int v14; // ecx@21
  int result; // eax@24
  int *v16; // [sp+10h] [bp-8h]@2
  int v17; // [sp+14h] [bp-4h]@8

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 16);
  v4 = a2;
  if ( a2 + *(_DWORD *)(v3 + 12) <= *(_DWORD *)(v3 + 8) )
  {
LABEL_24:
    result = *(_DWORD *)(v3 + 12);
    *(_DWORD *)(v3 + 12) = result + v4;
    return result;
  }
  while ( 1 )
  {
    v16 = (int *)v3;
    v3 = *(_DWORD *)v3;
    if ( !v3 )
      break;
LABEL_23:
    *(_DWORD *)(v2 + 16) = v3;
    if ( v4 + *(_DWORD *)(v3 + 12) <= *(_DWORD *)(v3 + 8) )
      goto LABEL_24;
  }
  v5 = *(_DWORD *)(v2 + 20);
  if ( v4 <= v5 )
  {
    v7 = 0;
  }
  else
  {
    v6 = *(_DWORD *)(v2 + 24);
    if ( v6 >= 3 )
      v7 = v6 - 3 + 4;
    else
      v7 = 3 - v6 + 4;
  }
  v17 = *(_DWORD *)(v2 + 24) + v7 + 16;
  v8 = v4;
  if ( v4 <= v5 )
    v8 = *(_DWORD *)(v2 + 20);
  v9 = v8 + *(_DWORD *)(v2 + 24) + v7 + 16;
  v10 = dword_10572710;
  for ( i = &dword_10572710; v10; v10 = *(_DWORD *)v10 )
  {
    v12 = *(_DWORD *)(v10 + 8) - v10;
    if ( v7 )
    {
      if ( v12 >= v9 && v12 <= v5 + v9 )
      {
LABEL_14:
        *i = *(_DWORD *)v10;
        goto LABEL_19;
      }
    }
    else if ( v12 == v9 )
    {
      goto LABEL_14;
    }
    i = (int *)v10;
  }
  v10 = sub_10053CF0(v9, dword_10658DEC);
  if ( v10 )
  {
    *(_DWORD *)(v10 + 8) = v10 + v9;
LABEL_19:
    v2 = a1;
    *(_DWORD *)v10 = 0;
    v3 = v10;
    *v16 = v10;
    if ( v7 )
    {
      v13 = (v10 + v17) & ~(*(_DWORD *)(a1 + 24) | 3);
      *(_DWORD *)(v10 + 12) = v13;
      *(_DWORD *)(v10 + 4) = v13;
      *(_DWORD *)(v13 - 4) = v16;
    }
    else
    {
      v14 = (v10 + 19) & 0xFFFFFFFC;
      *(_DWORD *)(v10 + 12) = v14;
      *(_DWORD *)(v10 + 4) = v14;
    }
    v4 = a2;
    goto LABEL_23;
  }
  return 0;
}
// 10572710: using guessed type int dword_10572710;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003E400) --------------------------------------------------------
int *__cdecl sub_1003E400(int a1, int a2, size_t a3, int a4)
{
  int v4; // ebx@1
  int v5; // eax@2
  size_t v6; // esi@5
  unsigned int v7; // ecx@5
  int v8; // edi@5
  int v9; // edx@6
  int v10; // ebp@8
  int *result; // eax@8
  int *v12; // esi@8
  int v13; // edx@9
  int v14; // eax@12
  int v15; // ecx@13
  void *v16; // ecx@16
  size_t v17; // [sp+10h] [bp-4h]@5
  int v18; // [sp+24h] [bp+10h]@8

  v4 = a1;
  if ( a3 <= *(_DWORD *)(a1 + 20) )
  {
    v5 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 16) )
    {
      do
      {
        a1 = v5;
        v5 = *(_DWORD *)v5;
      }
      while ( v5 != *(_DWORD *)(v4 + 16) );
    }
  }
  else
  {
    a1 = *(_DWORD *)(a2 - 4);
    v5 = *(_DWORD *)a1;
  }
  v6 = a3 + a4;
  v7 = *(_DWORD *)(v4 + 24);
  v8 = *(_DWORD *)(v5 + 4) - v5;
  v17 = a3 + a4;
  if ( v7 >= 3 )
    v9 = v7 - 3;
  else
    v9 = 3 - v7;
  v10 = v7 + v9 + 20;
  v18 = v6 + v10;
  result = (int *)sub_10053FC0((void *)v5, v6 + v10, dword_10658DEC);
  v12 = result;
  if ( result )
  {
    v13 = a1;
    if ( result != *(int **)a1 )
    {
      if ( *(_DWORD *)(v4 + 16) == *(_DWORD *)a1 )
        *(_DWORD *)(v4 + 16) = result;
      v14 = *result;
      if ( *v12 )
      {
        v15 = *(_DWORD *)(v14 + 4);
        if ( (unsigned int)(*(_DWORD *)(v14 + 12) - v15) > *(_DWORD *)(v4 + 20) )
          *(_DWORD *)(v15 - 4) = v12;
      }
      *(_DWORD *)a1 = v12;
    }
    v16 = (void *)(((unsigned int)v12 + v10) & ~(*(_DWORD *)(v4 + 24) | 3));
    v12[1] = (int)v16;
    v12[2] = (int)v12 + v18;
    v12[3] = ((unsigned int)v16 + v17 + 3) & 0xFFFFFFFC;
    if ( v8 != (_BYTE *)v16 - (_BYTE *)v12 )
    {
      memcpy_0(v16, (char *)v12 + v8, a3);
      v13 = a1;
    }
    *(_DWORD *)(v12[1] - 4) = v13;
    result = (int *)v12[1];
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003E510) --------------------------------------------------------
int *__cdecl sub_1003E510(int a1, void *a2, size_t a3, int a4)
{
  int *result; // eax@2
  int v5; // ecx@3
  char *v6; // esi@3
  unsigned int v7; // eax@3

  if ( a3 <= *(_DWORD *)(a1 + 20) )
  {
    v5 = *(_DWORD *)(a1 + 16);
    v6 = *(char **)(v5 + 12);
    v7 = (a3 + a4 + 3) & 0xFFFFFFFC;
    if ( (unsigned int)&v6[v7] <= *(_DWORD *)(v5 + 8) )
      *(_DWORD *)(v5 + 12) = &v6[v7];
    else
      v6 = (char *)sub_1003E2D0(a1, v7);
    if ( v6 )
      memcpy(v6, a2, a3);
    result = (int *)v6;
  }
  else
  {
    result = sub_1003E400(a1, (int)a2, a3, a4);
  }
  return result;
}

//----- (1003E580) --------------------------------------------------------
_DWORD *__usercall sub_1003E580@<eax>(_DWORD **a1@<esi>, int a2, int a3)
{
  _DWORD *result; // eax@1
  _DWORD **v4; // ecx@1

  result = *a1;
  v4 = a1;
  if ( *a1 )
  {
    if ( a3 )
    {
      do
      {
        *a1 = (_DWORD *)*result;
        sub_10053E10((unsigned int)result, dword_10658DEC);
        result = *a1;
      }
      while ( *a1 );
      result = (_DWORD *)a2;
      *(_DWORD *)(a2 + 16) = a1;
    }
    else
    {
      do
        v4 = (_DWORD **)*v4;
      while ( *v4 );
      *v4 = (_DWORD *)dword_10572710;
      dword_10572710 = (int)result;
      result = (_DWORD *)a2;
      *a1 = 0;
      *(_DWORD *)(a2 + 16) = a1;
    }
  }
  return result;
}
// 10572710: using guessed type int dword_10572710;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003E5E0) --------------------------------------------------------
_DWORD *__cdecl sub_1003E5E0(int a1, int a2)
{
  _DWORD *v2; // esi@1
  _DWORD *result; // eax@2

  v2 = (_DWORD *)a1;
  if ( a1 )
  {
    while ( 1 )
    {
      result = (_DWORD *)v2[1];
      if ( a2 - (signed int)result <= (unsigned int)(v2[3] - (_DWORD)result) )
        break;
      v2 = (_DWORD *)*v2;
      if ( !v2 )
        return result;
    }
    v2[3] = (a2 + 3) & 0xFFFFFFFC;
    result = sub_1003E580((_DWORD **)v2, a1, 1);
  }
  return result;
}

//----- (1003E630) --------------------------------------------------------
int *__cdecl sub_1003E630(int a1, int a2, unsigned int a3)
{
  int **v3; // edx@2
  int *result; // eax@2
  int *v5; // ecx@5
  bool v6; // zf@5
  int v7; // edi@6

  if ( a3 <= *(_DWORD *)(a1 + 20) )
  {
    result = *(int **)a1;
    v3 = (int **)a1;
    if ( *(_DWORD *)a1 )
    {
      while ( result[3] != ((a2 + a3 + 3) & 0xFFFFFFFC) )
      {
        v3 = (int **)result;
        result = (int *)*result;
        if ( !result )
          goto LABEL_3;
      }
      if ( result[1] != a2 )
      {
        result[3] = a2;
        return result;
      }
    }
  }
  else
  {
    v3 = *(int ***)(a2 - 4);
    result = *v3;
  }
LABEL_3:
  if ( *(int **)(a1 + 16) == result )
    *(_DWORD *)(a1 + 16) = a1;
  v5 = (int *)*result;
  v6 = *result == 0;
  *v3 = (int *)*result;
  if ( !v6 )
  {
    v7 = v5[1];
    if ( (unsigned int)(v5[3] - v7) > *(_DWORD *)(a1 + 20) )
      *(_DWORD *)(v7 - 4) = v3;
  }
  return sub_10053E10((unsigned int)result, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003E6B0) --------------------------------------------------------
_DWORD *__cdecl sub_1003E6B0(_DWORD **a1)
{
  return sub_1003E580(a1, (int)a1, 0);
}

//----- (1003E6D0) --------------------------------------------------------
_DWORD *__cdecl sub_1003E6D0(_DWORD **a1)
{
  return sub_1003E580(a1, (int)a1, 1);
}

//----- (1003E6F0) --------------------------------------------------------
_DWORD *sub_1003E6F0()
{
  _DWORD *result; // eax@1
  bool v1; // zf@1
  _DWORD *v2; // esi@2

  result = (_DWORD *)dword_10572710;
  v1 = dword_10572710 == 0;
  dword_10572710 = 0;
  if ( !v1 )
  {
    do
    {
      v2 = (_DWORD *)*result;
      sub_10053E10((unsigned int)result, dword_10658DEC);
      result = v2;
    }
    while ( v2 );
  }
  return result;
}
// 10572710: using guessed type int dword_10572710;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003E730) --------------------------------------------------------
void sub_1003E730()
{
  dword_10572710 = 0;
}
// 10572710: using guessed type int dword_10572710;

//----- (1003E740) --------------------------------------------------------
int *__cdecl sub_1003E740(int a1, int a2)
{
  int v2; // edi@1
  _DWORD *v3; // eax@1
  int v4; // ebx@1
  unsigned int v5; // eax@13
  unsigned int v6; // edi@15
  unsigned int v7; // eax@16

  v2 = *(_DWORD *)(a1 + 24);
  **(_DWORD **)(a1 + 4) = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)(a1 + 4);
  v3 = (_DWORD *)(v2 + 484);
  v4 = *v3 == (_DWORD)v3;
  if ( (_DWORD *)*v3 == v3 )
  {
    *(_DWORD *)v2 = 3;
    sub_100386E0(v2 + 108);
    sub_1001F560(a1);
    sub_1001AAE0(a1);
    sub_100517A0(a1);
    sub_10052070(a1);
  }
  sub_10025390(a1, a1 + 128);
  if ( v4 )
  {
    sub_1003B310(a1, 2);
    while ( *(_BYTE *)(v2 + 96) )
      sub_1003ABD0(a1, 2);
    if ( !*(_DWORD *)(v2 + 120) )
      sub_10038540(a1, (void *)(v2 + 108));
    sub_10021160(a1);
    *(_DWORD *)v2 = 0;
  }
  else if ( a2 == 2 )
  {
    sub_1003B310(a1, 0);
  }
  else if ( a2 == 1 )
  {
    sub_10010430(a1);
  }
  sub_1003E6D0((_DWORD **)(a1 + 28));
  sub_1003E6D0((_DWORD **)(a1 + 60));
  v5 = *(_DWORD *)(a1 + 268);
  if ( v5 )
    sub_10053E10(v5, dword_10658DEC);
  v6 = *(_DWORD *)(a1 + 264);
  while ( v6 )
  {
    v7 = v6;
    v6 = *(_DWORD *)(v6 + 12);
    sub_10010340(a1, v7);
  }
  if ( *(_DWORD *)(a1 + 308) )
  {
    sub_1003F700(*(_DWORD *)(a1 + 308));
    *(_DWORD *)(a1 + 308) = 0;
  }
  return sub_10053E10(a1, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003E8A0) --------------------------------------------------------
_DWORD *__cdecl sub_1003E8A0(int a1, int a2, _DWORD **a3)
{
  _DWORD *v3; // eax@1
  _DWORD *result; // eax@3

  v3 = *a3;
  if ( !*a3 )
    v3 = (_DWORD *)(a1 + 484);
  result = (_DWORD *)*v3;
  if ( result == (_DWORD *)(a1 + 484) )
    result = 0;
  *a3 = result;
  return result;
}

//----- (1003E8D0) --------------------------------------------------------
int __cdecl sub_1003E8D0(int a1, int (__cdecl *a2)(_DWORD, _DWORD, signed int))
{
  int (__cdecl *v2)(int, const char *, int *); // ebx@1
  const char **v3; // eax@1
  const char *v4; // edi@2
  int result; // eax@4
  int v6; // eax@11
  int (__cdecl *v7)(int, const char *, int *, _DWORD); // ecx@11
  int v8; // [sp+Ch] [bp-28h]@4
  int v9; // [sp+10h] [bp-24h]@4
  int v10; // [sp+14h] [bp-20h]@4
  int v11; // [sp+18h] [bp-1Ch]@4
  int v12; // [sp+1Ch] [bp-18h]@4
  int v13; // [sp+20h] [bp-14h]@4
  int v14; // [sp+24h] [bp-10h]@4
  int v15; // [sp+28h] [bp-Ch]@4
  int v16; // [sp+2Ch] [bp-8h]@4
  int v17; // [sp+30h] [bp-4h]@4

  v2 = *(int (__cdecl **)(int, const char *, int *))(a1 + 276);
  v3 = (const char **)a2(0, 0, 137);
  if ( v3 )
    v4 = *v3;
  else
    v4 = "Out of memory";
  v15 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v16 = 0;
  v17 = 0;
  v14 = 0;
  result = *(_DWORD *)(a1 + 56);
  v15 = 137;
  if ( result )
  {
    while ( !*(_DWORD *)(result + 12) || !*(_DWORD *)(result + 56) )
    {
      result = *(_DWORD *)(result + 44);
      if ( !result )
        goto LABEL_10;
    }
    v8 = *(_DWORD *)(*(_DWORD *)(result + 12) + 24);
    result = sub_10021490(a1, *(_DWORD *)(result + 12), *(_DWORD *)(result + 56));
    v9 = result;
  }
LABEL_10:
  if ( v2 )
  {
    v6 = *(_DWORD *)(a1 + 24);
    v7 = *(int (__cdecl **)(int, const char *, int *, _DWORD))(v6 + 564);
    if ( !v7 || (result = v7(a1, v4, &v8, *(_DWORD *)(v6 + 568))) != 0 )
      result = v2(a1, v4, &v8);
  }
  return result;
}

//----- (1003E9B0) --------------------------------------------------------
signed int __cdecl sub_1003E9B0(int a1, int (__cdecl *a2)(int, _DWORD, int), int a3, int a4, unsigned int *a5, int a6, int *a7, int a8, int a9)
{
  int v9; // ebp@1
  int v10; // esi@1
  bool v11; // zf@1
  unsigned int *v12; // edi@4
  int v13; // eax@5
  int v14; // ebx@6
  int v15; // eax@7
  int v16; // edi@8
  int i; // eax@9
  int *v18; // eax@11
  int v19; // eax@15
  char *v20; // edi@17
  const char *v21; // ebx@18
  char v22; // al@18
  int v23; // eax@21
  size_t v24; // ebp@21
  int v25; // eax@24
  _DWORD *v26; // eax@26
  int v27; // edi@27
  int v28; // eax@28
  void *v30; // eax@36
  const char *v31; // eax@37
  int v32; // eax@38
  unsigned int v33; // kr0C_4@42
  int v34; // eax@42
  int v35[47]; // [sp+0h] [bp-E8h]@21
  int v36; // [sp+BCh] [bp-2Ch]@6
  int v37[10]; // [sp+C0h] [bp-28h]@15
  const char **v38; // [sp+F0h] [bp+8h]@5
  int v39; // [sp+100h] [bp+18h]@6
  int *v40; // [sp+104h] [bp+1Ch]@11

  v9 = a1;
  v10 = a6;
  v11 = (*(_DWORD *)(a6 + 24) & 1) == 0;
  *a7 = *(_DWORD *)(a6 + 24) & 1;
  if ( !v11 && *(_BYTE *)(a1 + 300) & 2 )
  {
    *(_DWORD *)(a6 + 24) &= 0xFFFFFFFE;
    *a7 = 0;
  }
  v12 = a5;
  *a5 = 0;
  if ( !a2 )
  {
LABEL_42:
    v33 = strlen("No error message available for error number %d");
    v34 = sub_10011830(a1, v33 + 16);
    *v12 = v34;
    if ( !v34 )
      goto LABEL_26;
    sub_10050B00(v34, v33 + 16, "No error message available for error number %d", a4);
    return 1;
  }
  v13 = a2(a3, 0, a4);
  v38 = (const char **)v13;
  if ( !v13 )
  {
LABEL_41:
    if ( *v12 )
      return 1;
    goto LABEL_42;
  }
  v39 = 0;
  v36 = *(_DWORD *)(v13 + 4);
  v14 = v36;
  if ( v36 <= 0 )
  {
    v30 = *(void **)v13;
    if ( v30 )
    {
      v31 = (const char *)sub_100118A0(a1, v30);
      *a5 = (unsigned int)v31;
      if ( !v31 )
        goto LABEL_26;
      v32 = sub_1001B0E0(a1, (int)v31, strlen(v31));
      *(_DWORD *)(v10 + 32) = v32;
      if ( !v32 )
        goto LABEL_26;
    }
    goto LABEL_41;
  }
  v15 = sub_10011830(a1, 4 * v36 + 4);
  *(_DWORD *)(v10 + 36) = v15;
  if ( !v15 )
    return 0;
  v16 = 0;
  *(_DWORD *)(v15 + 4 * v14) = 0;
  if ( v14 > 0 )
  {
    for ( i = a9 - 4; ; i = (int)v40 )
    {
      v18 = (int *)(i + 4);
      v40 = v18;
      if ( a8 )
      {
        *(_DWORD *)(*(_DWORD *)(v10 + 36) + 4 * v16) = sub_1001B0E0(a1, *v18, strlen((const char *)*v18));
        if ( !*(_DWORD *)(*(_DWORD *)(v10 + 36) + 4 * v16) )
          goto LABEL_25;
        v14 = v36;
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)(v10 + 36) + 4 * v16) = *v18;
      }
      v19 = sub_1001AFC0(*(_WORD **)(*(_DWORD *)(v10 + 36) + 4 * v16));
      v39 += v19;
      v37[v16++] = v19;
      if ( v16 >= v14 )
        break;
    }
  }
  *(_DWORD *)(*(_DWORD *)(v10 + 36) + 4 * v16) = 0;
  if ( !*v38 )
  {
    v12 = a5;
    goto LABEL_41;
  }
  v20 = (char *)sub_10011830(a1, 2 * (v39 + strlen(*v38) - 3 * v14) + 2);
  *(_DWORD *)(v10 + 32) = v20;
  if ( !v20 )
    goto LABEL_25;
  v21 = *v38;
  v22 = **v38;
  if ( v22 )
  {
    do
    {
      if ( v22 == 123 && isdigit(v21[1]) )
      {
        v23 = v21[1];
        v24 = 2 * v35[v23];
        memcpy(v20, *(const void **)(*(_DWORD *)(v10 + 36) + 4 * (v23 - 48)), v24);
        v20 += v24;
        v9 = a1;
        v21 += 3;
      }
      else
      {
        *(_WORD *)v20 = *v21;
        v20 += 2;
        ++v21;
      }
      v22 = *v21;
    }
    while ( *v21 );
  }
  *(_WORD *)v20 = 0;
  v25 = sub_1001B130(v9, *(_DWORD *)(v10 + 32), (signed int)&v20[-*(_DWORD *)(v10 + 32)] >> 1);
  *a5 = v25;
  if ( !v25 )
  {
LABEL_25:
    v12 = a5;
LABEL_26:
    v26 = *(_DWORD **)(v10 + 36);
    if ( v26 )
    {
      v27 = 0;
      if ( *v26 )
      {
        v28 = 0;
        do
        {
          sub_10010340(v9, *(_DWORD *)(v28 + *(_DWORD *)(v10 + 36)));
          v28 = 4 * ++v27;
        }
        while ( *(_DWORD *)(4 * v27 + *(_DWORD *)(v10 + 36)) );
      }
      sub_10010340(v9, *(_DWORD *)(v10 + 36));
      v12 = a5;
      *(_DWORD *)(v10 + 36) = 0;
    }
    if ( *(_DWORD *)(v10 + 32) )
    {
      sub_10010340(v9, *(_DWORD *)(v10 + 32));
      *(_DWORD *)(v10 + 32) = 0;
    }
    if ( *v12 )
    {
      sub_10010340(v9, *v12);
      *v12 = 0;
    }
    return 0;
  }
  return 1;
}
// 1003E9B0: using guessed type int var_28[10];
// 1003E9B0: using guessed type int var_E8[47];

//----- (1003ECD0) --------------------------------------------------------
void __cdecl sub_1003ECD0(int a1, void *a2, int a3)
{
  unsigned int v3; // eax@2
  void *v4; // eax@4
  void (__cdecl *v5)(int, _DWORD, int); // ebx@5
  int v6; // ecx@6
  int (__cdecl *v7)(int, void *, int, _DWORD); // edx@6

  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 268);
    if ( v3 )
      sub_10053E10(v3, dword_10658DEC);
    v4 = sub_100118A0(a1, a2);
    *(_DWORD *)(a1 + 268) = v4;
    if ( v4 )
    {
      v5 = *(void (__cdecl **)(int, _DWORD, int))(a1 + 276);
      if ( v5 )
      {
        v6 = *(_DWORD *)(a1 + 24);
        v7 = *(int (__cdecl **)(int, void *, int, _DWORD))(v6 + 564);
        if ( !v7 || v7(a1, v4, a3, *(_DWORD *)(v6 + 568)) )
          v5(a1, *(_DWORD *)(a1 + 268), a3);
      }
    }
  }
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003ED50) --------------------------------------------------------
char **__cdecl sub_1003ED50(int a1, int a2, int a3)
{
  char **result; // eax@2

  if ( (unsigned int)(a3 - 1) > 0xA8 )
    result = 0;
  else
    result = &(&off_100D1068)[8 * a3];
  return result;
}
// 100D1068: using guessed type char *off_100D1068;

//----- (1003ED70) --------------------------------------------------------
_DWORD *__cdecl sub_1003ED70(int a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // esi@1
  _DWORD *v4; // eax@2
  int v5; // ebp@2
  int v6; // ecx@2
  signed int v7; // eax@10

  result = (_DWORD *)sub_10053CF0(0x140u, dword_10658DEC);
  v3 = result;
  if ( result )
  {
    memset(result, 0, 0x140u);
    v3[6] = a1;
    v4 = (_DWORD *)(a1 + 484);
    v5 = *v4 == (_DWORD)v4;
    v6 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 != 2 )
    {
      while ( v6 )
      {
        v5 = *v4 == (_DWORD)v4;
        if ( v6 == 2 )
          goto LABEL_7;
      }
      *(_DWORD *)a1 = 1;
    }
LABEL_7:
    *v3 = v4;
    v3[1] = *(_DWORD *)(a1 + 488);
    **(_DWORD **)(a1 + 488) = v3;
    *(_DWORD *)(a1 + 488) = v3;
    v3[4] = 0;
    *((_BYTE *)v3 + 20) = 18;
    *((_BYTE *)v3 + 21) = 19;
    sub_1003E280((int)(v3 + 7), (int)"stack", a2, 4u);
    sub_1003E280((int)(v3 + 15), (int)"temp", 1024, 8u);
    if ( !sub_10025370((int)v3, (int)(v3 + 32)) )
      goto LABEL_17;
    *((_BYTE *)v3 + 294) = 0;
    if ( v5 )
    {
      if ( *(_DWORD *)(a1 + 120) )
        v7 = sub_10038EE0((int)v3, a1 + 108);
      else
        v7 = sub_10039470((int)v3, (void *)(a1 + 108));
      if ( !v7 || !sub_100455A0((int)v3) || !sub_1001FF10((int)v3) || !sub_10021E20((int)v3) || !sub_1001DDA0((int)v3) )
      {
LABEL_17:
        sub_1003E740((int)v3, 0);
        return 0;
      }
      *(_DWORD *)a1 = 2;
    }
    result = v3;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003EEC0) --------------------------------------------------------
void __usercall sub_1003EEC0(void *a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax@6
  void (__cdecl *v4)(int, void *, int, _DWORD); // ecx@6

  if ( a2 && *(_DWORD *)(a2 + 28) == 147 )
    *(_DWORD *)(a2 + 24) |= 2u;
  if ( sub_10019EA0(a3, (const char *)a1, a2) )
  {
    v3 = *(_DWORD *)(a3 + 24);
    v4 = *(void (__cdecl **)(int, void *, int, _DWORD))(v3 + 564);
    if ( v4 )
    {
      if ( *(_DWORD *)(a3 + 276) )
        v4(a3, a1, a2, *(_DWORD *)(v3 + 568));
    }
  }
  else
  {
    sub_1003ECD0(a3, a1, a2);
  }
}

//----- (1003EF20) --------------------------------------------------------
signed int __cdecl sub_1003EF20(int a1, int a2, char *a3, int a4)
{
  int v4; // ebx@1
  signed int result; // eax@3
  void *v6; // ecx@4
  int v7; // eax@5
  int v8; // eax@10
  int v9; // ebp@11
  int v10; // [sp+8h] [bp-28h]@5
  int v11; // [sp+Ch] [bp-24h]@5
  int v12; // [sp+10h] [bp-20h]@5
  int v13; // [sp+14h] [bp-1Ch]@5
  int v14; // [sp+18h] [bp-18h]@5
  int v15; // [sp+1Ch] [bp-14h]@5
  int v16; // [sp+20h] [bp-10h]@5
  int v17; // [sp+24h] [bp-Ch]@5
  int v18; // [sp+28h] [bp-8h]@5
  int v19; // [sp+2Ch] [bp-4h]@5
  unsigned int v20; // [sp+38h] [bp+8h]@4

  v4 = a2;
  if ( !(a2 & 4) || *(_BYTE *)(a1 + 300) & 1 )
  {
    v6 = (void *)sub_100509D0(a3, a4);
    result = 0;
    v20 = (unsigned int)v6;
    if ( v6 )
    {
      v16 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v7 = *(_DWORD *)(a1 + 56);
      v16 = v4;
      if ( v7 )
      {
        while ( !*(_DWORD *)(v7 + 12) || !*(_DWORD *)(v7 + 56) )
        {
          v7 = *(_DWORD *)(v7 + 44);
          if ( !v7 )
            goto LABEL_11;
        }
        v10 = *(_DWORD *)(*(_DWORD *)(v7 + 12) + 24);
        v8 = sub_10021490(a1, *(_DWORD *)(v7 + 12), *(_DWORD *)(v7 + 56));
        v6 = (void *)v20;
        v11 = v8;
      }
LABEL_11:
      v9 = v16 & 1;
      if ( v16 & 1 )
      {
        if ( *(_BYTE *)(a1 + 300) & 2 )
        {
          v16 &= 0xFFFFFFFE;
          v9 = 0;
        }
      }
      sub_1003EEC0(v6, (int)&v10, a1);
      sub_10053E10(v20, dword_10658DEC);
      result = v9;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003F020) --------------------------------------------------------
signed int __cdecl sub_1003F020(int a1, int a2, int (__cdecl *a3)(int, _DWORD, int), int a4, int a5, int a6, int a7)
{
  signed int result; // eax@2
  int v8; // eax@3
  int v9; // edi@3
  int v10; // ebx@10
  unsigned int v11; // ecx@12
  int v12; // edi@13
  unsigned int *v13; // eax@14
  int v14; // [sp+4h] [bp-2Ch]@9
  int v15; // [sp+8h] [bp-28h]@3
  int v16; // [sp+Ch] [bp-24h]@3
  int v17; // [sp+10h] [bp-20h]@3
  int v18; // [sp+14h] [bp-1Ch]@3
  int v19; // [sp+18h] [bp-18h]@3
  int v20; // [sp+1Ch] [bp-14h]@3
  int v21; // [sp+20h] [bp-10h]@3
  int v22; // [sp+24h] [bp-Ch]@3
  unsigned int v23; // [sp+28h] [bp-8h]@3
  unsigned int *v24; // [sp+2Ch] [bp-4h]@3

  if ( !(a2 & 4) || (result = 1, *(_BYTE *)(a1 + 300) & 1) )
  {
    v21 = 0;
    v22 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v23 = 0;
    v24 = 0;
    v8 = *(_DWORD *)(a1 + 56);
    v9 = a5;
    v21 = a2;
    v22 = a5;
    if ( v8 )
    {
      while ( !*(_DWORD *)(v8 + 12) || !*(_DWORD *)(v8 + 56) )
      {
        v8 = *(_DWORD *)(v8 + 44);
        if ( !v8 )
          goto LABEL_9;
      }
      v15 = *(_DWORD *)(*(_DWORD *)(v8 + 12) + 24);
      v16 = sub_10021490(a1, *(_DWORD *)(v8 + 12), *(_DWORD *)(v8 + 56));
    }
LABEL_9:
    result = sub_1003E9B0(a1, a3, a4, v9, (unsigned int *)&a2, (int)&v15, &v14, a6, a7);
    if ( result )
    {
      v10 = a2;
      sub_1003EEC0((void *)a2, (int)&v15, a1);
      if ( v10 )
        sub_10010340(a1, v10);
      v11 = (unsigned int)v24;
      if ( v24 )
      {
        v12 = 0;
        if ( *v24 )
        {
          v13 = v24;
          do
          {
            sub_10010340(a1, *v13);
            v11 = (unsigned int)v24;
            v13 = &v24[++v12];
          }
          while ( *v13 );
        }
        sub_10010340(a1, v11);
      }
      if ( v23 )
        sub_10010340(a1, v23);
      result = v14;
    }
  }
  return result;
}

//----- (1003F160) --------------------------------------------------------
int __cdecl sub_1003F160(int a1, char a2)
{
  return sub_100110F0(a1, (int)sub_1003ED50, 0, 1, a2);
}

//----- (1003F180) --------------------------------------------------------
int __cdecl sub_1003F180(int a1, unsigned int a2)
{
  return sub_10053CF0(a2, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003F1A0) --------------------------------------------------------
int *__cdecl sub_1003F1A0(int a1, unsigned int a2)
{
  return sub_10053E10(a2, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003F1C0) --------------------------------------------------------
int __cdecl sub_1003F1C0(int a1, int a2)
{
  return *(_DWORD *)(a2 + 4);
}

//----- (1003F1D0) --------------------------------------------------------
unsigned int __cdecl sub_1003F1D0(int a1, unsigned int a2)
{
  return a2 >> 2;
}

//----- (1003F1E0) --------------------------------------------------------
BOOL __cdecl sub_1003F1E0(int a1, int a2, int a3)
{
  return *(_DWORD *)(a2 + 4) == a3;
}

//----- (1003F200) --------------------------------------------------------
void *__cdecl sub_1003F200(int a1, void *a2, void *a3)
{
  return memcpy(a3, a2, *(_DWORD *)(a1 + 12));
}

//----- (1003F220) --------------------------------------------------------
void *__cdecl sub_1003F220(int a1, void *a2)
{
  return memset(a2, 0, *(_DWORD *)(a1 + 12));
}

//----- (1003F250) --------------------------------------------------------
int (__cdecl **sub_1003F250())(int, int)
{
  return off_100D1608;
}
// 100D1608: using guessed type int (__cdecl *off_100D1608[4])(int, int);

//----- (1003F260) --------------------------------------------------------
void *__cdecl sub_1003F260(int a1, int (__cdecl **a2)(_DWORD, _DWORD), int a3, int a4, unsigned int a5)
{
  signed int v5; // eax@1
  __int16 v6; // ax@3
  signed int v7; // edx@3
  void *result; // eax@4
  size_t v9; // edi@5

  *(_DWORD *)(a1 + 4) = a3;
  v5 = a5;
  *(_DWORD *)a1 = a2;
  if ( a5 < 0x10 )
    v5 = 16;
  v6 = sub_10052D80(v5);
  v7 = 1 << v6;
  if ( (unsigned int)(1 << v6) < 0x1000000 )
  {
    *(_DWORD *)(a1 + 12) = a4;
    v9 = v7 * a4;
    *(_WORD *)(a1 + 8) = 32 - v6;
    *(_BYTE *)(a1 + 10) = -64;
    *(_BYTE *)(a1 + 11) = 64;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    result = (void *)(*a2)(a1, v7 * a4);
    *(_DWORD *)(a1 + 28) = result;
    if ( result )
    {
      memset(result, 0, v9);
      result = (void *)1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003F300) --------------------------------------------------------
int __cdecl sub_1003F300(int a1)
{
  int v1; // ebp@1
  char *v2; // esi@1
  unsigned int i; // edi@1

  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 28))(a1);
  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(char **)(a1 + 28);
  for ( i = (unsigned int)&v2[v1 * (1 << (32 - *(_WORD *)(a1 + 8)))]; (unsigned int)v2 < i; v2 += v1 )
  {
    if ( *(_DWORD *)v2 >= 2u )
      (*(void (__cdecl **)(int, char *))(*(_DWORD *)a1 + 24))(a1, v2);
  }
  return (*(int (__cdecl **)(int, _DWORD))(*(_DWORD *)a1 + 4))(a1, *(_DWORD *)(a1 + 28));
}

//----- (1003F360) --------------------------------------------------------
_DWORD *__usercall sub_1003F360@<eax>(int a1@<edi>, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // ebx@1
  _DWORD *i; // esi@1
  __int16 v6; // cx@4
  unsigned int v7; // ebp@4
  int v8; // edx@4
  int v9; // ebx@8
  _DWORD *result; // eax@18
  __int16 v11; // [sp+Ch] [bp-Ch]@1
  _DWORD *v12; // [sp+Ch] [bp-Ch]@5
  int (__cdecl *v13)(int, _DWORD *, int); // [sp+10h] [bp-8h]@2
  int v14; // [sp+14h] [bp-4h]@4

  v4 = a3 >> *(_WORD *)(a1 + 8);
  v11 = *(_WORD *)(a1 + 8);
  i = (_DWORD *)(*(_DWORD *)(a1 + 28) + v4 * *(_DWORD *)(a1 + 12));
  if ( !*i )
    goto LABEL_20;
  v13 = *(int (__cdecl **)(int, _DWORD *, int))(*(_DWORD *)a1 + 16);
  if ( (*i & 0xFFFFFFFE) == a3 )
  {
    if ( (*(int (__cdecl **)(int, _DWORD *, int))(*(_DWORD *)a1 + 16))(a1, i, a2) )
      goto LABEL_20;
  }
  v6 = 32 - *(_WORD *)(a1 + 8);
  v7 = (a3 << (32 - *(_WORD *)(a1 + 8)) >> v11) | 1;
  v8 = (1 << v6) - 1;
  v14 = (1 << v6) - 1;
  if ( *i == 1 )
  {
    v12 = i;
  }
  else
  {
    v12 = 0;
    if ( a4 == 1 )
      *i |= 1u;
  }
  v9 = v8 & (v4 - v7);
  for ( i = (_DWORD *)(*(_DWORD *)(a1 + 28) + v9 * *(_DWORD *)(a1 + 12));
        *i;
        i = (_DWORD *)(*(_DWORD *)(a1 + 28) + v9 * *(_DWORD *)(a1 + 12)) )
  {
    if ( (*i & 0xFFFFFFFE) == a3 )
    {
      if ( v13(a1, i, a2) )
        goto LABEL_20;
      v8 = v14;
    }
    if ( *i == 1 )
    {
      if ( !v12 )
        v12 = i;
    }
    else if ( a4 == 1 )
    {
      *i |= 1u;
    }
    v9 = v8 & (v9 - v7);
  }
  result = v12;
  if ( !v12 || a4 != 1 )
LABEL_20:
    result = i;
  return result;
}

//----- (1003F480) --------------------------------------------------------
void *__usercall sub_1003F480@<eax>(int a1@<eax>, __int16 a2@<dx>)
{
  int v2; // edi@1
  __int16 v3; // cx@1
  __int16 v4; // dx@1
  signed int v5; // ebp@1
  void *result; // eax@2
  int v7; // esi@3
  size_t v8; // esi@3
  void *v9; // ebx@3
  char *v10; // esi@4
  int v11; // eax@4
  int v12; // eax@5
  unsigned int v13; // ST10_4@6
  int v14; // eax@6
  _DWORD *v15; // ebx@6
  __int16 v16; // [sp+8h] [bp-10h]@1
  int (__cdecl *v17)(int, char *); // [sp+8h] [bp-10h]@4
  void (__cdecl *v18)(int, char *, _DWORD *); // [sp+Ch] [bp-Ch]@4
  int v19; // [sp+10h] [bp-8h]@3
  char *v20; // [sp+14h] [bp-4h]@4

  v2 = a1;
  v3 = 32 - *(_WORD *)(a1 + 8);
  v4 = v3 + a2;
  v5 = 1 << v3;
  v16 = v4;
  if ( (unsigned int)(1 << v4) < 0x1000000 )
  {
    v7 = *(_DWORD *)(a1 + 12);
    v19 = v7;
    v8 = (1 << v4) * v7;
    result = (void *)(**(int (__cdecl ***)(_DWORD, _DWORD))a1)(a1, v8);
    v9 = result;
    if ( result )
    {
      ++*(_DWORD *)(v2 + 24);
      *(_WORD *)(v2 + 8) = 32 - v16;
      *(_DWORD *)(v2 + 20) = 0;
      memset(result, 0, v8);
      v10 = *(char **)(v2 + 28);
      v11 = *(_DWORD *)v2;
      *(_DWORD *)(v2 + 28) = v9;
      v20 = v10;
      v17 = *(int (__cdecl **)(int, char *))(v11 + 8);
      v18 = *(void (__cdecl **)(int, char *, _DWORD *))(v11 + 20);
      if ( v5 )
      {
        do
        {
          v12 = *(_DWORD *)v10;
          if ( *(_DWORD *)v10 >= 2u )
          {
            v13 = v12 & 0xFFFFFFFE;
            *(_DWORD *)v10 = v12 & 0xFFFFFFFE;
            v14 = v17(v2, v10);
            v15 = sub_1003F360(v2, v14, v13, 1);
            v18(v2, v10, v15);
            *v15 = *(_DWORD *)v10;
          }
          v10 += v19;
          --v5;
        }
        while ( v5 );
        v10 = v20;
      }
      (*(void (__cdecl **)(int, char *))(*(_DWORD *)v2 + 4))(v2, v10);
      result = (void *)1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003F580) --------------------------------------------------------
int __cdecl sub_1003F580(int a1, int *a2)
{
  int v2; // ebx@1
  int result; // eax@1

  v2 = *a2;
  result = (*(int (__cdecl **)(int, int *))(*(_DWORD *)a1 + 24))(a1, a2);
  if ( v2 & 1 )
  {
    *a2 = 1;
    ++*(_DWORD *)(a1 + 20);
    --*(_DWORD *)(a1 + 16);
  }
  else
  {
    *a2 = 0;
    --*(_DWORD *)(a1 + 16);
  }
  return result;
}

//----- (1003F5C0) --------------------------------------------------------
int __cdecl sub_1003F5C0(int a1, int (__cdecl *a2)(int, int *, int, int), int a3)
{
  int v3; // edi@1
  int v4; // edx@1
  int *v5; // esi@1
  __int16 v6; // cx@1
  unsigned int v7; // eax@1
  int v8; // ebx@1
  unsigned int v9; // ebp@1
  char v10; // bl@3
  bool v11; // zf@5
  unsigned int v12; // eax@12
  __int16 v13; // ax@14
  signed int v15; // [sp+10h] [bp-Ch]@1
  signed int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1
  int v18; // [sp+20h] [bp+4h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(int **)(a1 + 28);
  v6 = 32 - *(_WORD *)(a1 + 8);
  v7 = 1 << v6;
  v8 = 0;
  v17 = v4;
  v18 = 0;
  v9 = (unsigned int)v5 + v4 * (1 << v6);
  v15 = 1 << v6;
  v16 = 0;
  if ( (unsigned int)v5 >= v9 )
    return v8;
  while ( (unsigned int)*v5 < 2 )
  {
LABEL_7:
    v5 = (int *)((char *)v5 + v4);
    if ( (unsigned int)v5 >= v9 )
      goto LABEL_8;
  }
  ++v18;
  v10 = a2(v3, v5, v8, a3);
  if ( v10 & 2 )
  {
    sub_1003F580(v3, v5);
    v16 = 1;
  }
  v7 = v15;
  v11 = (v10 & 1) == 0;
  v8 = v18;
  if ( v11 )
  {
    v4 = v17;
    goto LABEL_7;
  }
LABEL_8:
  if ( v16 && (*(_DWORD *)(v3 + 20) >= v7 >> 2 || v7 > 0x10 && *(_DWORD *)(v3 + 16) <= v7 * *(_BYTE *)(v3 + 11) >> 8) )
  {
    v12 = (*(_DWORD *)(v3 + 16) >> 1) + *(_DWORD *)(v3 + 16);
    if ( v12 < 0x10 )
      v12 = 16;
    v13 = sub_10052D80(v12);
    sub_1003F480(v3, v13 + *(_WORD *)(v3 + 8) - 32);
  }
  return v8;
}

//----- (1003F6B0) --------------------------------------------------------
int __cdecl sub_1003F6B0(int (__cdecl **a1)(_DWORD, _DWORD), int a2, int a3, unsigned int a4)
{
  int v4; // esi@1

  v4 = sub_10053CF0(0x20u, dword_10658DEC);
  if ( !v4 )
    return 0;
  if ( !sub_1003F260(v4, a1, a2, a3, a4) )
  {
    sub_10053E10(v4, dword_10658DEC);
    return 0;
  }
  return v4;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003F700) --------------------------------------------------------
int *__cdecl sub_1003F700(unsigned int a1)
{
  sub_1003F300(a1);
  return sub_10053E10(a1, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1003F720) --------------------------------------------------------
unsigned int *__cdecl sub_1003F720(int a1, int a2, int a3)
{
  unsigned int v3; // esi@1
  unsigned int v4; // esi@3
  int *v5; // eax@6
  unsigned int v6; // eax@7
  unsigned int v8; // eax@11
  unsigned int v9; // ebx@11
  unsigned int *v10; // eax@14
  unsigned int *v11; // ebx@14
  unsigned int v12; // eax@14
  int (__cdecl *v13)(int, unsigned int *, int); // eax@17

  v3 = -1640531527 * (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 12))(a1, a2);
  if ( v3 < 2 )
    v3 -= 2;
  v4 = v3 & 0xFFFFFFFE;
  if ( !a3 )
    return sub_1003F360(a1, a2, v4, 0);
  if ( a3 == 1 )
  {
    v8 = *(_DWORD *)(a1 + 20);
    v9 = 1 << (32 - *(_WORD *)(a1 + 8));
    if ( v8 + *(_DWORD *)(a1 + 16) >= v9 * *(_BYTE *)(a1 + 10) >> 8
      && !sub_1003F480(a1, v8 < v9 >> 2)
      && *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 20) == v9 - 1 )
    {
      return 0;
    }
    v10 = sub_1003F360(a1, a2, v4, 1);
    v11 = v10;
    v12 = *v10;
    if ( v12 < 2 )
    {
      if ( v12 == 1 )
      {
        --*(_DWORD *)(a1 + 20);
        v4 |= 1u;
      }
      v13 = *(int (__cdecl **)(int, unsigned int *, int))(*(_DWORD *)a1 + 32);
      if ( !v13 || v13(a1, v11, a2) )
      {
        *v11 = v4;
        ++*(_DWORD *)(a1 + 16);
        return v11;
      }
      memset(v11 + 1, 0, *(_DWORD *)(a1 + 12) - 4);
      return 0;
    }
    return v11;
  }
  if ( a3 == 2 )
  {
    v5 = sub_1003F360(a1, a2, v4, 2);
    if ( (unsigned int)*v5 >= 2 )
    {
      sub_1003F580(a1, v5);
      v6 = 1 << (32 - *(_WORD *)(a1 + 8));
      if ( v6 > 0x10 && *(_DWORD *)(a1 + 16) <= v6 * *(_BYTE *)(a1 + 11) >> 8 )
        sub_1003F480(a1, -1);
    }
  }
  return 0;
}

//----- (1003F880) --------------------------------------------------------
int __cdecl sub_1003F880(int a1, void *a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ecx@1
  int result; // eax@1

  memset(a2, 0, 0xC8u);
  *((_DWORD *)a2 + 7) = a3;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  *((_DWORD *)a2 + 5) = 0;
  *((_DWORD *)a2 + 6) = 0;
  *((_DWORD *)a2 + 8) = a4;
  *(_DWORD *)a2 = 1;
  *((_DWORD *)a2 + 9) = *(_DWORD *)(*(_DWORD *)(a3 + 16) + 12);
  *((_DWORD *)a2 + 10) = *(_DWORD *)(*(_DWORD *)(a4 + 16) + 12);
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 76) + 12);
  *((_DWORD *)a2 + 29) = a5;
  *((_DWORD *)a2 + 27) = a6;
  *((_DWORD *)a2 + 19) = a6;
  *((_DWORD *)a2 + 30) = a6;
  *((_DWORD *)a2 + 11) = v7;
  *((_DWORD *)a2 + 25) = 63;
  *((_DWORD *)a2 + 17) = 63;
  *((_DWORD *)a2 + 32) = 0;
  *((_DWORD *)a2 + 33) = 0;
  *((_DWORD *)a2 + 34) = 0;
  *((_DWORD *)a2 + 46) = 0;
  *((_DWORD *)a2 + 47) = 0;
  *((_DWORD *)a2 + 48) = 0;
  result = 1;
  *((_DWORD *)a2 + 28) = (char *)a2 + 80;
  *((_DWORD *)a2 + 31) = a7;
  return result;
}

//----- (1003F940) --------------------------------------------------------
_DWORD *__cdecl sub_1003F940(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@5
  int v6; // eax@5
  int v7; // edx@5
  _DWORD *result; // eax@9
  int v9; // esi@9

  v2 = *(_DWORD *)(a2 + 28);
  v3 = *(_DWORD *)(v2 + 16);
  v4 = *(_DWORD *)(a2 + 36);
  if ( v3 == v2 || v4 - *(_DWORD *)(v3 + 4) > (unsigned int)(*(_DWORD *)(v3 + 12) - *(_DWORD *)(v3 + 4)) )
    sub_1003E5E0(v2, *(_DWORD *)(a2 + 36));
  else
    *(_DWORD *)(v3 + 12) = (v4 + 3) & 0xFFFFFFFC;
  v5 = *(_DWORD *)(a2 + 32);
  v6 = *(_DWORD *)(v5 + 16);
  v7 = *(_DWORD *)(a2 + 40);
  if ( v6 == v5 || v7 - *(_DWORD *)(v6 + 4) > (unsigned int)(*(_DWORD *)(v6 + 12) - *(_DWORD *)(v6 + 4)) )
    sub_1003E5E0(v5, *(_DWORD *)(a2 + 40));
  else
    *(_DWORD *)(v6 + 12) = (v7 + 3) & 0xFFFFFFFC;
  result = *(_DWORD **)(a1 + 76);
  v9 = *(_DWORD *)(a2 + 44);
  if ( result == (_DWORD *)(a1 + 60) || v9 - result[1] > (unsigned int)(result[3] - result[1]) )
    result = sub_1003E5E0(a1 + 60, v9);
  else
    result[3] = (v9 + 3) & 0xFFFFFFFC;
  return result;
}

//----- (1003F9F0) --------------------------------------------------------
signed int __usercall sub_1003F9F0@<eax>(int a1@<edx>, int a2, int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  int v5; // esi@1
  unsigned int v6; // edi@1
  int v7; // ebx@1
  signed int v8; // ecx@3
  char v9; // al@4
  int v10; // esi@6
  int v11; // edx@6
  int v12; // eax@6
  unsigned int v13; // ecx@6
  int v14; // ebx@9
  size_t v15; // eax@9
  int v16; // edi@9
  int v17; // ecx@9
  unsigned int v18; // edx@10
  int *v19; // eax@13
  int v21; // [sp-10h] [bp-24h]@12
  void *v22; // [sp-Ch] [bp-20h]@12
  size_t v23; // [sp-8h] [bp-1Ch]@12
  int v24; // [sp-4h] [bp-18h]@12
  int v25; // [sp+10h] [bp-4h]@1
  signed int v26; // [sp+1Ch] [bp+8h]@3

  v3 = a3;
  v4 = *(_DWORD *)(a3 + 112);
  v5 = *(_DWORD *)v4;
  v6 = *(_DWORD *)(v4 + 4);
  v7 = *(_DWORD *)(v4 + 8) - *(_DWORD *)v4;
  v25 = *(_DWORD *)(v4 + 8) - *(_DWORD *)v4;
  if ( a1 + *(_DWORD *)(v4 + 8) <= v6 )
    return v7;
  if ( v7 + a1 > 256 )
  {
    v9 = sub_10052D80(v7 + a1);
    v26 = 1 << v9;
    v8 = 1 << v9;
  }
  else
  {
    v8 = 256;
    v26 = 256;
  }
  if ( !v5 )
  {
    v10 = *(_DWORD *)(v3 + 28);
    v11 = *(_DWORD *)(v10 + 16);
    v12 = *(_DWORD *)(v11 + 12);
    v13 = (v8 + 3) & 0xFFFFFFFC;
    if ( v12 + v13 <= *(_DWORD *)(v11 + 8) )
    {
      *(_DWORD *)(v11 + 12) = v12 + v13;
      v5 = v12;
    }
    else
    {
      v5 = sub_1003E2D0(v10, v13);
    }
    goto LABEL_18;
  }
  v14 = *(_DWORD *)(v3 + 28);
  v15 = v6 - v5;
  v16 = *(_DWORD *)(v14 + 16);
  v17 = v8 - v15;
  if ( *(_DWORD *)(v16 + 12) != v5 + ((v15 + 3) & 0xFFFFFFFC) )
  {
    v24 = v17;
    v23 = v15;
    v22 = (void *)v5;
    v21 = *(_DWORD *)(v3 + 28);
    goto LABEL_15;
  }
  v18 = v5 + ((v15 + v17 + 3) & 0xFFFFFFFC);
  if ( v18 > *(_DWORD *)(v16 + 8) )
  {
    v24 = v17;
    v23 = v15;
    v22 = (void *)v5;
    v21 = *(_DWORD *)(v3 + 28);
    if ( v5 == *(_DWORD *)(v16 + 4) )
    {
      v19 = sub_1003E400(v14, v5, v15, v17);
LABEL_16:
      v5 = (int)v19;
      goto LABEL_17;
    }
LABEL_15:
    v19 = sub_1003E510(v21, v22, v23, v24);
    goto LABEL_16;
  }
  *(_DWORD *)(v16 + 12) = v18;
LABEL_17:
  v7 = v25;
LABEL_18:
  if ( !v5 )
  {
    sub_10011170(a2);
    return -1;
  }
  **(_DWORD **)(v3 + 112) = v5;
  *(_DWORD *)(*(_DWORD *)(v3 + 112) + 4) = v5 + v26;
  *(_DWORD *)(*(_DWORD *)(v3 + 112) + 8) = v7 + v5;
  return v7;
}

//----- (1003FB00) --------------------------------------------------------
unsigned int __usercall sub_1003FB00@<eax>(int a1@<edx>, int a2@<edi>, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // eax@1
  void **v6; // esi@1
  int v7; // ecx@1
  unsigned __int16 v8; // cx@2
  bool v9; // sf@3
  const char *v10; // eax@4
  unsigned int result; // eax@7
  char v12; // [sp+8h] [bp-10h]@4

  v3 = **(_DWORD **)(a2 + 112);
  v4 = *(_BYTE *)(v3 + a1);
  v5 = a1 + v3;
  v6 = &off_100D1E40 + 4 * v4;
  v7 = *((_BYTE *)v6 + 9);
  if ( v7 < 0 )
  {
    HIBYTE(v8) = *(_BYTE *)(v5 + 1);
    LOBYTE(v8) = *(_BYTE *)(v5 + 2);
    v7 = v8 + 2;
  }
  v9 = *(_DWORD *)(a2 + 140) - v7 < 0;
  *(_DWORD *)(a2 + 140) -= v7;
  if ( v9 )
  {
    sub_10050B00((int)&v12, 12, "%d", a1);
    v10 = *(const char **)(a2 + 116);
    if ( !v10 )
      v10 = "stdin";
    sub_100110F0(a3, (int)sub_1003ED50, 0, 16, (char)v10);
  }
  *(_DWORD *)(a2 + 140) += *((_BYTE *)v6 + 10);
  result = *(_DWORD *)(a2 + 140);
  if ( result > *(_DWORD *)(a2 + 144) )
    *(_DWORD *)(a2 + 144) = result;
  return result;
}
// 100D1E40: using guessed type void *off_100D1E40;

//----- (1003FBB0) --------------------------------------------------------
int __cdecl sub_1003FBB0(int a1, int a2, char a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1003F9F0(1, a1, a2);
  v4 = result;
  if ( result >= 0 )
  {
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 112) + 8))++ = a3;
    sub_1003FB00(result, a2, a1);
    result = v4;
  }
  return result;
}

//----- (1003FC00) --------------------------------------------------------
signed int __cdecl sub_1003FC00(int a1, int a2, char a3, char a4, char a5)
{
  signed int result; // eax@1
  int v6; // esi@1
  int v7; // eax@2

  result = sub_1003F9F0(3, a1, a2);
  v6 = result;
  if ( result >= 0 )
  {
    v7 = *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8);
    *(_BYTE *)v7 = a3;
    *(_BYTE *)(v7 + 1) = a4;
    *(_BYTE *)(v7 + 2) = a5;
    *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8) = v7 + 3;
    sub_1003FB00(v6, a2, a1);
    result = v6;
  }
  return result;
}

//----- (1003FC60) --------------------------------------------------------
int __cdecl sub_1003FC60(int a1, int a2, char a3, size_t a4)
{
  int result; // eax@1
  int v5; // ebx@1
  int v6; // esi@2

  result = sub_1003F9F0(a4 + 1, a1, a2);
  v5 = result;
  if ( result >= 0 )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8);
    *(_BYTE *)v6 = a3;
    memset((void *)(v6 + 1), 0, a4);
    *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8) = a4 + 1 + v6;
    sub_1003FB00(v5, a2, a1);
    result = v5;
  }
  return result;
}

//----- (1003FCC0) --------------------------------------------------------
const char *__usercall sub_1003FCC0@<eax>(int a1@<eax>)
{
  _DWORD *v1; // eax@1
  const char *result; // eax@2

  v1 = *(_DWORD **)(a1 + 8);
  if ( v1 )
    result = off_10162B20[*v1];
  else
    result = "script";
  return result;
}
// 10162B20: using guessed type char *off_10162B20[13];

//----- (1003FCE0) --------------------------------------------------------
signed int __usercall sub_1003FCE0@<eax>(int a1@<eax>, int a2)
{
  char v2; // al@1

  v2 = (unsigned int)sub_1003FCC0(a1);
  return sub_100110F0(a2, (int)sub_1003ED50, 0, 17, v2);
}

//----- (1003FD00) --------------------------------------------------------
signed int __usercall sub_1003FD00@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // ebx@1
  int v2; // esi@1
  signed int v3; // eax@1
  int v4; // eax@2
  signed int v5; // edx@2
  int v6; // ecx@2
  int v7; // eax@5
  int v8; // edi@6
  int v9; // ecx@6
  signed int result; // eax@6
  int v11; // ecx@7
  int v12; // edi@7
  int v13; // eax@7

  v1 = a1;
  v2 = *a1;
  v3 = *(_DWORD *)(*a1 + 4);
  if ( v3 >= -1 )
  {
    if ( v3 <= 1 )
      return 0;
    v5 = 0;
    v6 = *(_DWORD *)(*(_DWORD *)(v2 + 12) + 4) < 0;
  }
  else
  {
    v4 = *(_DWORD *)(v2 + 8);
    v5 = 1;
    v6 = *(_DWORD *)(v4 + 4) < 0;
    LOBYTE(v6) = *(_DWORD *)(v4 + 4) > 0;
  }
  v7 = 1 - v5;
  if ( v6 )
  {
    v8 = *(_DWORD *)(v2 + 4 * v7 + 8);
    v9 = *(_DWORD *)(v8 + 4 * v5 + 8);
    *v1 = v9;
    *(_DWORD *)(v2 + 4 * v7 + 8) = *(_DWORD *)(v9 + 4 * v5 + 8);
    *(_DWORD *)(v9 + 4 * v5 + 8) = v2;
    *(_DWORD *)(v8 + 4 * v5 + 8) = *(_DWORD *)(v9 + 4 * v7 + 8);
    *(_DWORD *)(v9 + 4 * v7 + 8) = v8;
    *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4) = -(*(_DWORD *)(v9 + 4) <= 0 ? 0 : *(_DWORD *)(v9 + 4));
    *(_DWORD *)(*(_DWORD *)(v9 + 12) + 4) = -(*(_DWORD *)(v9 + 4) >= 0 ? 0 : *(_DWORD *)(v9 + 4));
    result = 1;
    *(_DWORD *)(v9 + 4) = 0;
  }
  else
  {
    v11 = *(_DWORD *)(v2 + 4 * v7 + 8);
    *v1 = v11;
    *(_DWORD *)(v2 + 4 * v7 + 8) = *(_DWORD *)(v11 + 4 * v5 + 8);
    *(_DWORD *)(v11 + 4 * v5 + 8) = v2;
    v12 = *(_DWORD *)(v11 + 4);
    v13 = v12 - 1;
    if ( v5 )
      v13 = v12 + 1;
    *(_DWORD *)(v11 + 4) = v13;
    *(_DWORD *)(v2 + 4) = -v13;
    result = v12 != 0;
  }
  return result;
}

//----- (1003FDF0) --------------------------------------------------------
int __cdecl sub_1003FDF0(int a1, int *a2)
{
  int *v2; // ebx@1
  int v3; // esi@1
  int v4; // edi@2
  int v5; // eax@2
  int v6; // ecx@4
  int result; // eax@9
  int v8; // ecx@12
  int v9; // eax@15
  int v10; // esi@18

  v2 = a2;
  v3 = *a2;
  if ( !*a2 )
  {
    v4 = *(_DWORD *)(a1 + 4);
    v5 = *(_DWORD *)(v4 + 168);
    if ( v5 )
    {
      *(_DWORD *)(v4 + 168) = *(_DWORD *)(v5 + 8);
LABEL_11:
      *(_DWORD *)v5 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(v5 + 4) = 0;
      *(_DWORD *)(v5 + 12) = 0;
      *(_DWORD *)(v5 + 8) = 0;
      ++*(_DWORD *)(v4 + 176);
      *(_DWORD *)(a1 + 12) = v5;
      *v2 = v5;
      return 1;
    }
    v6 = *(_DWORD *)(*(_DWORD *)a1 + 76);
    v5 = *(_DWORD *)(v6 + 12);
    if ( (unsigned int)(v5 + 16) <= *(_DWORD *)(v6 + 8) )
      *(_DWORD *)(v6 + 12) = v5 + 16;
    else
      v5 = sub_1003E2D0(*(_DWORD *)a1 + 60, 0x10u);
    if ( v5 )
    {
      v2 = a2;
      goto LABEL_11;
    }
    sub_10011170(*(_DWORD *)a1);
    return 0;
  }
  v8 = *(_DWORD *)(a1 + 8);
  if ( v8 == *(_DWORD *)v3 )
  {
    *(_DWORD *)(a1 + 12) = v3;
    result = 0;
  }
  else
  {
    if ( v8 >= *(_DWORD *)v3 )
      v9 = sub_1003FDF0(a1, (int *)(v3 + 12));
    else
      v9 = -sub_1003FDF0(a1, (int *)(v3 + 8));
    if ( !*(_DWORD *)(a1 + 12) )
      return 0;
    *(_DWORD *)(v3 + 4) += v9;
    v10 = *(_DWORD *)(v3 + 4);
    if ( v9 && v10 )
      result = 1 - sub_1003FD00(a2);
    else
      result = 0;
  }
  return result;
}

//----- (1003FEF0) --------------------------------------------------------
signed int __usercall sub_1003FEF0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>)
{
  int v5; // [sp+4h] [bp-10h]@2
  int v6; // [sp+8h] [bp-Ch]@2
  int v7; // [sp+Ch] [bp-8h]@2
  int v8; // [sp+10h] [bp-4h]@2

  if ( a3 + 2147483648 > 0xFFFFFFFF )
  {
    sub_1003FCE0(a1, a2);
  }
  else
  {
    v6 = a1;
    v5 = a2;
    v7 = a3 + *(_DWORD *)a4;
    v8 = 0;
    sub_1003FDF0((int)&v5, (int *)(a1 + 164));
    if ( v8 )
    {
      *(_DWORD *)(a4 + 12) = v8 | 1;
      return 1;
    }
  }
  return 0;
}

//----- (1003FF50) --------------------------------------------------------
signed int __usercall sub_1003FF50@<eax>(int a1@<edi>, int a2, _BYTE *a3, int a4, int a5)
{
  unsigned int v5; // ebx@1
  int *v7; // eax@4
  int v8; // esi@6
  unsigned int v9; // edx@7
  int v10; // ecx@9
  int v11; // esi@18
  int v12; // eax@18
  size_t v13; // [sp-Ch] [bp-14h]@12
  int v14; // [sp-8h] [bp-10h]@12

  v5 = *(_DWORD *)(a1 + 172);
  if ( v5 == -1 )
  {
    sub_1003FCE0(a1, a2);
    return 0;
  }
  if ( !((v5 - 1) & v5) )
  {
    v7 = *(int **)(a1 + 160);
    if ( v7 )
    {
      if ( v5 < 0x100 )
        goto LABEL_18;
      v8 = *(_DWORD *)(a2 + 76);
      if ( *(int **)(v8 + 12) == (int *)((char *)v7 + ((16 * v5 + 3) & 0xFFFFFFFC)) )
      {
        v9 = (unsigned int)v7 + ((32 * v5 + 3) & 0xFFFFFFFC);
        if ( v9 > *(_DWORD *)(v8 + 8) )
        {
          v14 = 16 * v5;
          v13 = 16 * v5;
          if ( v7 == *(int **)(v8 + 4) )
            v7 = sub_1003E400(a2 + 60, (int)v7, v13, v14);
          else
            v7 = sub_1003E510(a2 + 60, v7, v13, v14);
        }
        else
        {
          *(_DWORD *)(v8 + 12) = v9;
        }
      }
      else
      {
        v7 = sub_1003E510(a2 + 60, v7, 16 * v5, 16 * v5);
      }
    }
    else
    {
      v10 = *(_DWORD *)(a2 + 76);
      v7 = *(int **)(v10 + 12);
      if ( (unsigned int)(v7 + 1024) <= *(_DWORD *)(v10 + 8) )
        *(_DWORD *)(v10 + 12) = v7 + 1024;
      else
        v7 = (int *)sub_1003E2D0(a2 + 60, 0x1000u);
    }
    if ( !v7 )
      return 0;
    *(_DWORD *)(a1 + 160) = v7;
  }
LABEL_18:
  *(_DWORD *)(a1 + 172) = v5 + 1;
  v11 = *(_DWORD *)(a1 + 160) + 16 * v5;
  *(_DWORD *)v11 = &a3[-**(_DWORD **)(a1 + 112)];
  v12 = a4 - **(_DWORD **)(a1 + 112);
  *(_DWORD *)(v11 + 8) = v12;
  *(_DWORD *)(v11 + 4) = v12;
  if ( dword_100D1E4C[4 * *a3] & 0x4000 )
  {
    if ( a5 && a5 > 0x3FFFFFFF )
    {
      sub_1003FCE0(a1, a2);
      return 0;
    }
    *(_DWORD *)(v11 + 12) = 2 * a5;
  }
  else if ( a5 )
  {
    if ( !sub_1003FEF0(a1, a2, a5, v11) )
      return 0;
  }
  else
  {
    *(_DWORD *)(v11 + 12) = 1;
  }
  if ( v5 > 0xFFFE )
    LOWORD(v5) = -1;
  *(_BYTE *)(a4 + 2) = v5;
  *(_BYTE *)(a4 + 1) = BYTE1(v5);
  return 1;
}
// 100D1E4C: using guessed type int dword_100D1E4C[];

//----- (100400D0) --------------------------------------------------------
signed int __cdecl sub_100400D0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // esi@1
  void **v5; // eax@2
  int v6; // ebx@2
  int v7; // eax@2
  int v8; // eax@3
  __int16 v9; // ax@5
  unsigned __int16 v10; // ax@6
  int v11; // ebx@6
  int v12; // ebp@6
  int v13; // edx@7
  int v14; // ebx@7
  __int16 v15; // cx@7
  __int16 v16; // cx@10
  __int16 v17; // dx@11
  int v18; // ebx@11
  int v19; // eax@11
  int v20; // ebp@11
  __int16 v21; // dx@12
  __int16 v22; // ax@15
  int v24; // [sp+10h] [bp-8h]@11
  unsigned int v25; // [sp+14h] [bp-4h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 112);
  v4 = *(_DWORD *)v3;
  v25 = *(_DWORD *)(v3 + 8);
  if ( *(_DWORD *)v3 >= v25 )
    return 1;
  while ( 1 )
  {
    v5 = &off_100D1E40 + 4 * *(_BYTE *)v4;
    v6 = *((_BYTE *)v5 + 8);
    v7 = ((unsigned int)v5[3] & 0xF) - 1;
    if ( !v7 )
    {
      LOBYTE(v22) = 0;
      HIBYTE(v22) = *(_BYTE *)(v4 + 1);
      if ( !sub_1003FF50(v2, a1, (_BYTE *)v4, v4, *(_BYTE *)(v4 + 2) | v22) )
        return 0;
      goto LABEL_16;
    }
    v8 = v7 - 3;
    if ( !v8 )
      break;
    if ( v8 == 1 )
    {
      LOBYTE(v9) = 0;
      HIBYTE(v9) = *(_BYTE *)(v4 + 1);
      if ( !sub_1003FF50(v2, a1, (_BYTE *)v4, v4, *(_BYTE *)(v4 + 2) | v9) )
        return 0;
      HIBYTE(v10) = *(_BYTE *)(v4 + 3);
      v11 = v4 + 4;
      LOBYTE(v10) = *(_BYTE *)(v4 + 4);
      v12 = v10;
      if ( v10 )
      {
        do
        {
          v13 = *(_BYTE *)(v11 + 4);
          v14 = v11 + 2;
          LOBYTE(v15) = 0;
          HIBYTE(v15) = *(_BYTE *)(v14 + 1);
          if ( !sub_1003FF50(v2, a1, (_BYTE *)v4, v14, v13 | v15) )
            return 0;
          v11 = v14 + 2;
        }
        while ( --v12 );
      }
      v6 = v11 - v4 + 1;
    }
LABEL_16:
    v4 += v6;
    if ( v4 >= v25 )
      return 1;
  }
  LOBYTE(v16) = 0;
  HIBYTE(v16) = *(_BYTE *)(v4 + 1);
  if ( !sub_1003FF50(v2, a1, (_BYTE *)v4, v4, *(_BYTE *)(v4 + 2) | v16) )
    return 0;
  LOBYTE(v17) = 0;
  HIBYTE(v17) = *(_BYTE *)(v4 + 3);
  v18 = v4 + 6;
  v19 = *(_BYTE *)(v4 + 4) | v17;
  LOBYTE(v17) = 0;
  HIBYTE(v17) = *(_BYTE *)(v4 + 5);
  v24 = v19;
  v20 = *(_BYTE *)(v4 + 6) | v17;
  if ( v19 > v20 )
  {
LABEL_14:
    v2 = a2;
    v6 = v18 - v4 + 1;
    goto LABEL_16;
  }
  while ( 1 )
  {
    LOBYTE(v21) = 0;
    HIBYTE(v21) = *(_BYTE *)(v18 + 1);
    if ( !sub_1003FF50(a2, a1, (_BYTE *)v4, v18, *(_BYTE *)(v18 + 2) | v21) )
      return 0;
    v18 += 2;
    if ( ++v24 > v20 )
      goto LABEL_14;
  }
}
// 100D1E40: using guessed type void *off_100D1E40;

//----- (10040270) --------------------------------------------------------
int __fastcall sub_10040270(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@2
  int v4; // edi@3
  int v5; // esi@3
  int v6; // ebx@3
  int v7; // ebp@4
  int v8; // ecx@5
  int v9; // eax@5
  int v10; // edx@5

  HIWORD(v2) = 0;
  BYTE1(v2) = *(_BYTE *)(a1 + 1);
  LOBYTE(v2) = *(_BYTE *)(a1 + 2);
  if ( (unsigned __int16)v2 == 0xFFFF )
  {
    v4 = 0;
    v5 = *(_DWORD *)(a2 + 172) - 1;
    v6 = a1 - **(_DWORD **)(a2 + 112);
    if ( v5 < 0 )
    {
LABEL_10:
      result = 0;
    }
    else
    {
      v7 = *(_DWORD *)(a2 + 160);
      while ( 1 )
      {
        v8 = (v5 + v4) / 2;
        v9 = 16 * v8;
        v10 = *(_DWORD *)(v9 + v7 + 8);
        result = v7 + v9;
        if ( v10 == v6 )
          break;
        if ( v10 >= v6 )
          v5 = v8 - 1;
        else
          v4 = v8 + 1;
        if ( v4 > v5 )
          goto LABEL_10;
      }
    }
  }
  else
  {
    result = *(_DWORD *)(a2 + 160) + 16 * v2;
  }
  return result;
}

//----- (100402E0) --------------------------------------------------------
signed int __usercall sub_100402E0@<eax>(signed int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4@<esi>)
{
  signed int v4; // ebx@1
  int v5; // eax@1

  v4 = a1;
  v5 = *(_DWORD *)(a4 + 160);
  if ( !v5 && v4 < 0x7FFF )
  {
    *(_BYTE *)(a3 + 1) = BYTE1(v4);
    *(_BYTE *)(a3 + 2) = v4;
    return 1;
  }
  if ( v4 > 0x3FFFFFFF )
  {
    sub_1003FCE0(a4, a2);
    return 0;
  }
  if ( !v5 && !sub_100400D0(a2, a4) )
    return 0;
  *(_DWORD *)(sub_10040270(a3, a4) + 12) = 2 * v4;
  return 1;
}

//----- (10040350) --------------------------------------------------------
int __cdecl sub_10040350(int a1, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2

  v3 = a1;
  do
  {
    result = *(_DWORD *)v3;
    if ( *(_DWORD *)v3 > a2 )
    {
      *(_DWORD *)v3 = a3 + result;
      result = *(_DWORD *)(v3 + 8);
      if ( result )
        result = sub_10040350(result, a2, a3);
    }
    v3 = *(_DWORD *)(v3 + 12);
  }
  while ( v3 );
  return result;
}

//----- (10040390) --------------------------------------------------------
int __usercall sub_10040390@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // ebp@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // ecx@2
  int v9; // eax@2
  int v10; // edx@2
  int result; // eax@2

  v4 = *(_DWORD *)(a1 + 160);
  v5 = *(_DWORD *)(a1 + 172);
  v6 = a2;
  v7 = v5 - 1;
  if ( a2 > v5 - 1 )
  {
LABEL_7:
    if ( v6 == v5 )
      result = a4;
    else
      result = v4 + 16 * v6;
  }
  else
  {
    while ( 1 )
    {
      v8 = (v7 + v6) / 2;
      v9 = 16 * v8;
      v10 = *(_DWORD *)(v9 + v4 + 8);
      result = v4 + v9;
      if ( v10 == a3 )
        break;
      if ( v10 >= a3 )
        v7 = v8 - 1;
      else
        v6 = v8 + 1;
      if ( v6 > v7 )
        goto LABEL_7;
    }
  }
  return result;
}

//----- (10040400) --------------------------------------------------------
int __cdecl sub_10040400(int a1, int a2)
{
  int result; // eax@5

  if ( *(_DWORD *)(a2 + 8) )
    sub_10040400(a1, *(_DWORD *)(a2 + 8));
  if ( *(_DWORD *)(a2 + 12) )
    sub_10040400(a1, *(_DWORD *)(a2 + 12));
  result = *(_DWORD *)(a1 + 168);
  *(_DWORD *)(a2 + 8) = result;
  *(_DWORD *)(a1 + 168) = a2;
  return result;
}

//----- (10040440) --------------------------------------------------------
signed int __usercall sub_10040440@<eax>(int a1@<eax>, signed int a2@<esi>, int a3, char a4)
{
  int v4; // edi@1
  signed int result; // eax@4
  signed int v6; // eax@5
  signed int v7; // ebx@5

  v4 = a1;
  if ( a2 >= -32768 && a2 <= 0x7FFF || *(_DWORD *)(a1 + 160) || (result = sub_100400D0(a3, a1)) != 0 )
  {
    v6 = sub_1003FC00(a3, v4, a4, SBYTE1(a2), a2);
    v7 = v6;
    if ( v6 < 0
      || !*(_DWORD *)(v4 + 160)
      || (result = sub_1003FF50(v4, a3, (_BYTE *)(v6 + **(_DWORD **)(v4 + 112)), v6 + **(_DWORD **)(v4 + 112), a2)) != 0 )
    {
      result = v7;
    }
  }
  return result;
}

//----- (100404C0) --------------------------------------------------------
int __fastcall sub_100404C0(int a1, int a2)
{
  unsigned int v2; // esi@1
  __int16 v3; // ax@2
  int result; // eax@2
  int v5; // eax@3
  unsigned int v6; // ecx@3
  signed int v7; // eax@3
  int v8; // edx@5

  v2 = *(_DWORD *)(a2 + 160);
  if ( v2 )
  {
    v5 = sub_10040270(a1, a2);
    v6 = v5;
    v7 = *(_DWORD *)(v5 + 12);
    if ( v7 & 1 )
    {
      v8 = *(_DWORD *)v6;
      do
        v6 -= 16;
      while ( v6 >= v2 && *(_DWORD *)v6 == v8 );
      result = *(_DWORD *)(v7 & 0xFFFFFFFE) - *(_DWORD *)(v6 + 20);
    }
    else
    {
      result = v7 >> 1;
    }
  }
  else
  {
    LOBYTE(v3) = 0;
    HIBYTE(v3) = *(_BYTE *)(a1 + 1);
    result = *(_BYTE *)(a1 + 2) | v3;
  }
  return result;
}

//----- (10040510) --------------------------------------------------------
signed int __cdecl sub_10040510(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@3
  int v5; // eax@5

  if ( *(_DWORD *)(a2 + 160) )
    goto LABEL_8;
  if ( (unsigned int)(a4 + 0x8000) <= 0xFFFF )
  {
    *(_BYTE *)(a3 + 2) = a4;
    *(_BYTE *)(a3 + 1) = BYTE1(a4);
    return 1;
  }
  result = sub_100400D0(a1, a2);
  if ( result )
  {
LABEL_8:
    v5 = sub_10040270(a3, a2);
    result = sub_1003FEF0(a2, a1, a4, v5);
  }
  return result;
}

//----- (10040580) --------------------------------------------------------
signed int __cdecl sub_10040580(int a1)
{
  int v1; // eax@1
  signed int result; // eax@4

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 )
  {
    while ( *(_DWORD *)v1 != 5 )
    {
      v1 = *(_DWORD *)(v1 + 28);
      if ( !v1 )
        goto LABEL_4;
    }
    result = 1;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (100405B0) --------------------------------------------------------
signed int __cdecl sub_100405B0(int a1, int a2)
{
  int v2; // eax@1
  signed int result; // eax@5

  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 )
  {
    while ( *(_DWORD *)v2 != 7 || *(_DWORD *)(v2 + 24) != a2 )
    {
      v2 = *(_DWORD *)(v2 + 28);
      if ( !v2 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (100405E0) --------------------------------------------------------
int __cdecl sub_100405E0(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)a2 = a3;
  *(_DWORD *)(a2 + 16) = -1;
  *(_DWORD *)(a2 + 20) = -1;
  *(_DWORD *)(a2 + 12) = -1;
  *(_DWORD *)(a2 + 8) = -1;
  *(_DWORD *)(a2 + 4) = a4;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = a2;
  return result;
}

//----- (10040620) --------------------------------------------------------
signed int __usercall sub_10040620@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, char a5)
{
  int v5; // eax@1
  char *v6; // esi@1
  int v7; // ebp@1
  int v8; // ebx@2
  signed int result; // eax@4

  v5 = **(_DWORD **)(a2 + 112);
  v6 = (char *)(v5 + a1);
  v7 = v5 - 1;
  if ( v5 + a1 == v5 - 1 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      v8 = sub_100404C0((int)v6, a2);
      if ( !sub_10040510(a3, a2, (int)v6, a4 - (_DWORD)v6) )
        break;
      *v6 = a5;
      v6 -= v8;
      if ( v6 == (char *)v7 )
        goto LABEL_4;
    }
    result = 0;
  }
  return result;
}

//----- (10040680) --------------------------------------------------------
int __cdecl sub_10040680(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 28);
  return result;
}

//----- (10040690) --------------------------------------------------------
signed int __cdecl sub_10040690(int a1, int a2)
{
  int v2; // esi@1
  signed int result; // eax@3

  v2 = *(_DWORD *)(a2 + 8);
  if ( sub_10040620(*(_DWORD *)(v2 + 8), a2, a1, *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8), 6)
    && sub_10040620(*(_DWORD *)(v2 + 12), a2, a1, **(_DWORD **)(a2 + 112) + *(_DWORD *)(v2 + 4), 6) )
  {
    sub_10040680(a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100406F0) --------------------------------------------------------
signed int __cdecl sub_100406F0(int a1, int a2, int a3, int a4)
{
  double v4; // st7@2
  int v5; // ecx@5
  int v6; // esi@7
  int v7; // eax@7
  int v8; // edi@9
  int v10; // eax@11
  double v11; // [sp+14h] [bp-8h]@2

  if ( *(_DWORD *)a4 == 30 )
  {
    v4 = *(double *)(a4 + 24);
    v11 = v4;
    if ( (HIDWORD(v11) & 0x7FF00000) != 2146435072
      && (HIDWORD(v11) != 0x80000000 || LODWORD(v11))
      && (v5 = (signed int)v4, (double)(signed int)v4 == v4)
      && (unsigned int)(v5 + 0x3FFFFFFF) <= 0x7FFFFFFE )
    {
      v6 = a1;
      v7 = sub_100387A0(a1, v5, 0);
    }
    else
    {
      v6 = a1;
      v7 = sub_100387D0(a1, v4, 0);
    }
    v8 = v7;
    if ( !v7 )
      return 0;
    v10 = sub_10038C10(v6, a3, a2 + 184);
    if ( !v10 )
      return 0;
    *(_DWORD *)(v10 + 12) = *(_DWORD *)(v8 + 8);
  }
  return 1;
}

//----- (100407C0) --------------------------------------------------------
signed int __cdecl sub_100407C0(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // ebx@1
  int v5; // ebp@1
  int v6; // edi@1
  int v7; // esi@2
  int v8; // edx@2
  int v9; // eax@5
  int v10; // eax@6
  _DWORD *v11; // edx@8
  _DWORD *v12; // ecx@8
  int v13; // ecx@20
  void (__cdecl *v14)(int, int, int); // eax@21
  int v16; // [sp+10h] [bp-Ch]@1
  int v17; // [sp+14h] [bp-8h]@14
  int v18; // [sp+18h] [bp-4h]@17

  v4 = a1;
  v5 = a3;
  *a4 = -2147483647;
  v6 = 1;
  v16 = *(_DWORD *)(v4 + 56);
  while ( 1 )
  {
    v7 = *(_DWORD *)(v16 + 8);
    v8 = a2;
    if ( v7 != *(_DWORD *)(v16 + 52) || sub_10040580(a2) || sub_100405B0(v8, v5) )
      goto LABEL_26;
    v9 = *(_DWORD *)(v8 + 188);
    if ( v9 )
    {
      v10 = *sub_10051360(v9, *(_DWORD *)(v5 + 20), v5);
      if ( !v10 )
        goto LABEL_14;
    }
    else
    {
      v11 = (_DWORD *)(v8 + 184);
      v12 = v11;
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_14;
      while ( *(_DWORD *)(v10 + 8) != v5 )
      {
        v12 = (_DWORD *)v10;
        v10 = *(_DWORD *)v10;
        if ( !v10 )
          goto LABEL_14;
      }
      *v12 = *(_DWORD *)v10;
      *(_DWORD *)v10 = *v11;
      *v11 = v10;
    }
    if ( v10 )
      break;
LABEL_14:
    a1 = 0;
    v6 = (*(int (__cdecl **)(int, int, int, int *, int *))(*(_DWORD *)(*(_DWORD *)v7 + 4) + 8))(v4, v7, v5, &v17, &a1);
    if ( !v6 )
      return v6;
    if ( v17 == v7 )
    {
      if ( *(_BYTE *)(v16 + 76) & 0xA0 )
      {
        v6 = (*(int (__cdecl **)(int, int, int, int, int *))(*(_DWORD *)(*(_DWORD *)v7 + 4) + 24))(v4, v7, v5, a1, &v18);
        if ( v6 )
        {
          if ( !(~(_BYTE)v18 & 6) )
            v6 = (*(int (__cdecl **)(int, int, int, _DWORD *))(*(_DWORD *)(*(_DWORD *)v7 + 4) + 16))(v4, v7, v5, a4);
        }
      }
    }
    v13 = a1;
    if ( a1 )
    {
      v14 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v17 + 4) + 52);
      if ( v14 )
      {
        v14(v4, v17, a1);
        v13 = a1;
      }
    }
    if ( !v6 || v13 )
      return v6;
    v8 = a2;
LABEL_26:
    v16 = *(_DWORD *)(v16 + 44);
    a2 = *(_DWORD *)(v8 + 196);
    if ( !a2 )
      return v6;
  }
  *a4 = *(_DWORD *)(v10 + 12);
  return 1;
}

//----- (10040960) --------------------------------------------------------
int __usercall sub_10040960@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, char a4)
{
  int result; // eax@1

  result = sub_10038C10(a2, *(_DWORD *)(a1 + 24), a3 + 128);
  if ( result )
    result = sub_1003FC00(a2, a3, a4, *(_WORD *)(result + 12) >> 8, *(_BYTE *)(result + 12)) >= 0;
  return result;
}

//----- (100409A0) --------------------------------------------------------
int __usercall sub_100409A0@<eax>(int a1@<edi>, int a2, _BYTE *a3)
{
  int result; // eax@4
  int v4; // ecx@5
  unsigned int v5; // esi@5
  char **v6; // eax@5
  int v7; // ebp@8
  int v8; // edx@10
  int v9; // edx@12
  signed int v10; // eax@12
  int v11; // ebp@13
  signed int (*v12)(); // ecx@14
  void (__cdecl *v13)(int, int, int); // eax@37
  int v14; // [sp+0h] [bp-Ch]@8
  int v15; // [sp+4h] [bp-8h]@11
  int v16; // [sp+8h] [bp-4h]@11

  if ( *(_DWORD *)(a1 + 32) >= 0 || *(_DWORD *)(a1 + 12) == 9 )
  {
    result = 1;
  }
  else
  {
    if ( *a3 & 0x20 )
      return 1;
    v4 = *(_DWORD *)(a2 + 56);
    v5 = *(_DWORD *)(v4 + 8);
    v6 = (char **)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 8) & 0xFFFFFFFE);
    if ( v6 != &off_101621B8 && v6 != &off_10162110 )
      return 1;
    v7 = *(_DWORD *)(a1 + 24);
    v14 = *(_DWORD *)(a1 + 24);
    if ( *(_DWORD *)(v4 + 52) != v5 || sub_10040580((int)a3) || sub_100405B0((int)a3, v7) )
      return 1;
    result = sub_10015D00(v8, v5, v7, &v16, (unsigned int *)&v15);
    if ( !result )
      return result;
    v9 = v15;
    v10 = *(_DWORD *)(a1 + 12);
    if ( v15 )
    {
      v11 = v16;
      if ( v16 == v5 )
      {
        v12 = *(signed int (**)())(v15 + 4);
        if ( v12 == sub_1002FB00 )
        {
          switch ( v10 )
          {
            case 59:
              v10 = 84;
              break;
            case 109:
              v10 = 85;
              break;
            case 41:
              v10 = 95;
              break;
            case 47:
              v10 = 99;
              break;
            case 44:
              v10 = 97;
              break;
            case 50:
              v10 = 101;
              break;
            case 104:
              v10 = 10;
              break;
            case 36:
              goto LABEL_33;
            default:
              break;
          }
        }
        else if ( v12 == sub_1002FB80 || (char *)v12 == (char *)sub_10027800 )
        {
          switch ( v10 )
          {
            case 59:
              v10 = 86;
              break;
            case 14:
            case 109:
              v10 = 87;
              break;
            case 41:
              v10 = 96;
              break;
            case 47:
              v10 = 100;
              break;
            case 44:
              v10 = 98;
              break;
            case 50:
              v10 = 102;
              break;
            case 104:
              v10 = 11;
              break;
            case 36:
LABEL_33:
              v10 = 66;
              break;
            default:
              break;
          }
        }
        if ( v10 != *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v10;
          *(_DWORD *)(a1 + 32) = *(_WORD *)(v9 + 18);
        }
        *(_DWORD *)(a1 + 36) = *(_BYTE *)(v9 + 16);
      }
      v13 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v11 + 4) + 52);
      if ( v13 )
        v13(a2, v11, v9);
      v7 = v14;
    }
    if ( *(_DWORD *)(a1 + 32) >= 0 )
      return 1;
    if ( *(_DWORD *)(a1 + 12) == 59 && v7 == *(_DWORD *)(*(_DWORD *)(a2 + 24) + 216) )
    {
      *(_DWORD *)(a1 + 12) = 9;
      return 1;
    }
    *(_DWORD *)a3 |= 0x40u;
    result = 1;
  }
  return result;
}
// 10162110: using guessed type char *off_10162110;
// 101621B8: using guessed type char *off_101621B8;

//----- (10040C90) --------------------------------------------------------
signed int __cdecl sub_10040C90(int a1, _BYTE *a2, int a3, _DWORD *a4)
{
  signed int v4; // edi@1
  signed int result; // eax@5
  int v6; // eax@6
  int v7; // esi@9
  signed int v8; // eax@10
  signed int v9; // eax@14
  int v10; // edi@20
  int v11; // eax@26
  int v12; // edi@37

  v4 = 1;
  if ( !a3 || *a4 )
  {
    result = 1;
  }
  else
  {
    switch ( *(_DWORD *)(a3 + 20) + 3 )
    {
      case 0:
        if ( !*(_DWORD *)(sub_10010550(a1, *(_DWORD *)(*(_DWORD *)(a3 + 24) + 8) & 0xFFFFFFF8) + 24) )
          break;
        *a4 = 1;
        return 1;
      case 1:
        v6 = *(_DWORD *)a3;
        if ( *(_DWORD *)a3 == 51 || v6 == 27 || v6 == 23 )
          goto LABEL_46;
        v7 = *(_DWORD *)(a3 + 24);
        if ( !v7 )
          break;
        do
        {
          v8 = sub_10040C90(a1, a2, v7, a4);
          v7 = *(_DWORD *)(v7 + 40);
          v4 &= v8;
        }
        while ( v7 );
        return v4;
      case 6:
        if ( !sub_10040C90(a1, a2, *(_DWORD *)(a3 + 24), a4) || !sub_10040C90(a1, a2, *(_DWORD *)(a3 + 28), a4) )
          goto LABEL_17;
        v9 = sub_10040C90(a1, a2, *(_DWORD *)(a3 + 32), a4);
        goto LABEL_15;
      case 5:
        if ( *(_DWORD *)a3 == 4 )
          goto LABEL_46;
        if ( *(_DWORD *)a3 != 23 )
          goto LABEL_24;
        v10 = *(_DWORD *)(a3 + 24);
        if ( *(_DWORD *)v10 == 29 && !sub_100409A0(v10, a1, a2) )
          goto LABEL_40;
        if ( *(_DWORD *)(v10 + 12) != 9 )
          *a4 = 1;
        if ( !sub_10040C90(a1, a2, *(_DWORD *)(a3 + 24), a4) )
          goto LABEL_17;
LABEL_24:
        v9 = sub_10040C90(a1, a2, *(_DWORD *)(a3 + 28), a4);
LABEL_15:
        if ( v9 )
          result = 1;
        else
LABEL_17:
          result = 0;
        return result;
      case 4:
        v11 = *(_DWORD *)a3;
        if ( *(_DWORD *)a3 == 20 || v11 == 21 || v11 == 52 || v11 == 58 || v11 == 53 )
          goto LABEL_46;
        return sub_10040C90(a1, a2, *(_DWORD *)(a3 + 24), a4);
      case 2:
        if ( *(_DWORD *)a3 != 29 )
          goto LABEL_37;
        if ( !sub_100409A0(a3, a1, a2) )
          goto LABEL_40;
        if ( *(_DWORD *)(a3 + 32) < 0 && *(_DWORD *)(a3 + 12) != 9 )
          *a4 = 1;
LABEL_37:
        v12 = *(_DWORD *)(a3 + 28);
        if ( *(_DWORD *)a3 != 22 || *(_DWORD *)v12 != 29 )
          goto LABEL_44;
        if ( sub_100409A0(v12, a1, a2) )
        {
          if ( *(_DWORD *)(v12 + 12) != 9 || *(_DWORD *)(a3 + 24) != *(_DWORD *)(*(_DWORD *)(a1 + 24) + 264) )
            *a4 = 1;
LABEL_44:
          result = sub_10040C90(a1, a2, v12, a4);
        }
        else
        {
LABEL_40:
          result = 0;
        }
        return result;
      case 3:
        if ( *(_DWORD *)a3 == 60 )
LABEL_46:
          *a4 = 1;
        break;
      default:
        break;
    }
    result = 1;
  }
  return result;
}

//----- (10040F00) --------------------------------------------------------
int __usercall sub_10040F00@<eax>(int a1@<edi>, int a2@<esi>, double a3)
{
  unsigned int v3; // ecx@4
  int result; // eax@7
  int v5; // eax@12
  int v6; // eax@16
  int v7; // edx@17

  if ( (HIDWORD(a3) & 0x7FF00000) != 2146435072
    && (HIDWORD(a3) != 0x80000000 || LODWORD(a3))
    && (v3 = (signed int)a3, (double)(signed int)a3 == a3)
    && v3 + 0x3FFFFFFF <= 0x7FFFFFFE )
  {
    if ( !v3 )
      return sub_1003FBB0(a2, a1, 62) >= 0;
    if ( v3 == 1 )
      return sub_1003FBB0(a2, a1, 63) >= 0;
    if ( v3 < 0x10000 )
      return sub_1003FC00(a2, a1, 88, SBYTE1(v3), v3) >= 0;
    v5 = sub_100387A0(a2, v3, 0);
  }
  else
  {
    v5 = sub_100387D0(a2, a3, 0);
  }
  if ( v5 && (v6 = sub_10038C10(a2, v5, a1 + 128)) != 0 )
  {
    v7 = *(_DWORD *)(v6 + 12);
    result = sub_1003FC00(a2, a1, 60, SBYTE1(v7), *(_BYTE *)(v6 + 12)) >= 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10041010) --------------------------------------------------------
signed int __usercall sub_10041010@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  signed int v3; // ebp@1
  int v4; // edx@2
  int v5; // ecx@2
  int v6; // eax@2
  int v7; // edi@3
  int v8; // ecx@3
  int v9; // eax@3
  unsigned int v10; // ecx@3
  char *v11; // ecx@6
  int v12; // ebx@6
  unsigned int v13; // edi@7
  int *v14; // eax@10
  int v15; // eax@14
  signed int result; // eax@17

  v2 = *(_DWORD *)(a1 + 112);
  v3 = *(_DWORD *)(v2 + 16);
  if ( v3 & *(_DWORD *)(v2 + 20) )
    goto LABEL_18;
  v4 = *(_DWORD *)(a1 + 32);
  v5 = *(_DWORD *)(a1 + 112);
  v6 = *(_DWORD *)(v2 + 20) + 1;
  if ( !*(_DWORD *)(v5 + 12) )
  {
    v7 = *(_DWORD *)(v4 + 16);
    v8 = v6 + 3;
    v9 = *(_DWORD *)(v7 + 12);
    v10 = v8 & 0xFFFFFFFC;
    if ( v9 + v10 <= *(_DWORD *)(v7 + 8) )
    {
      *(_DWORD *)(v7 + 12) = v9 + v10;
      *(_DWORD *)(*(_DWORD *)(a1 + 112) + 12) = v9;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 112) + 12) = sub_1003E2D0(v4, v10);
    }
    goto LABEL_16;
  }
  v11 = *(char **)(v5 + 12);
  v12 = *(_DWORD *)(v4 + 16);
  if ( *(char **)(v12 + 12) == &v11[(v6 + 3) & 0xFFFFFFFC] )
  {
    v13 = (unsigned int)&v11[(2 * v6 + 3) & 0xFFFFFFFC];
    if ( v13 <= *(_DWORD *)(v12 + 8) )
    {
      *(_DWORD *)(v12 + 12) = v13;
      goto LABEL_14;
    }
    if ( v11 != *(char **)(v12 + 4) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 112) + 12) = sub_1003E510(v4, v11, v6, v6);
      goto LABEL_14;
    }
    v14 = sub_1003E400(v4, (int)v11, v6, v6);
  }
  else
  {
    v14 = sub_1003E510(v4, v11, v6, v6);
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 112) + 12) = v14;
LABEL_14:
  v15 = *(_DWORD *)(a1 + 112);
  if ( *(_DWORD *)(v15 + 12) )
    *(_DWORD *)(v15 + 20) = 2 * *(_DWORD *)(v15 + 20) | 1;
LABEL_16:
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 112) + 12) )
  {
    sub_10011170(a2);
    return -1;
  }
LABEL_18:
  result = v3;
  *(_DWORD *)(*(_DWORD *)(a1 + 112) + 16) = v3 + 1;
  return result;
}

//----- (10041100) --------------------------------------------------------
signed int __cdecl sub_10041100(int a1, int a2, int a3)
{
  signed int v3; // edi@1
  int v5; // ecx@3
  int v6; // edx@3
  int v7; // ebx@3
  _BYTE *v8; // eax@3
  signed int v9; // ecx@4
  signed int v10; // eax@6
  int v11; // ebx@8

  v3 = sub_10041010(a2, a1);
  if ( v3 < 0 )
    return -1;
  v5 = *(_DWORD *)(a2 + 112);
  v6 = *(_DWORD *)(v5 + 8) - *(_DWORD *)v5;
  v7 = v6 - *(_DWORD *)(v5 + 24);
  v8 = (_BYTE *)(v3 + *(_DWORD *)(v5 + 12));
  *(_DWORD *)(v5 + 24) = v6;
  if ( v7 < 8 )
  {
LABEL_8:
    *v8 = v7 & 7 | 8 * a3;
    v11 = (unsigned __int8)byte_10162B5C[8 * a3];
    if ( v11 <= 0 )
      return v3;
    while ( sub_10041100(a1, a2, 0) >= 0 )
    {
      if ( --v11 <= 0 )
        return v3;
    }
  }
  else
  {
    while ( 1 )
    {
      v9 = v7;
      if ( v7 >= 63 )
        v9 = 63;
      *v8 = v9 | 0xC0;
      v7 -= v9;
      v10 = sub_10041010(a2, a1);
      v3 = v10;
      if ( v10 < 0 )
        break;
      v8 = (_BYTE *)(v10 + *(_DWORD *)(*(_DWORD *)(a2 + 112) + 12));
      if ( v7 < 8 )
        goto LABEL_8;
    }
  }
  return -1;
}

//----- (100411C0) --------------------------------------------------------
signed int __usercall sub_100411C0@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // eax@1
  int v5; // edi@1
  int v6; // edx@1
  int v7; // ebx@2
  unsigned int v8; // ecx@2
  int v9; // edx@8
  signed int result; // eax@9
  int v11; // [sp-10h] [bp-1Ch]@4
  void *v12; // [sp-Ch] [bp-18h]@4
  size_t v13; // [sp-8h] [bp-14h]@4
  int v14; // [sp-4h] [bp-10h]@4

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 112);
  v4 = *(_DWORD *)(v3 + 20) + 1;
  v5 = *(_DWORD *)(v2 + 32);
  v6 = *(_DWORD *)(v5 + 16);
  if ( *(_DWORD *)(v6 + 12) == *(_DWORD *)(v3 + 12) + ((*(_DWORD *)(v3 + 20) + 4) & 0xFFFFFFFC) )
  {
    v7 = *(_DWORD *)(v3 + 12);
    v8 = v7 + ((2 * v4 + 3) & 0xFFFFFFFC);
    if ( v8 <= *(_DWORD *)(v6 + 8) )
    {
      *(_DWORD *)(v6 + 12) = v8;
      goto LABEL_8;
    }
    v14 = v4;
    v13 = v4;
    v12 = (void *)v7;
    v11 = *(_DWORD *)(v2 + 32);
    if ( v7 == *(_DWORD *)(v6 + 4) )
    {
      *(_DWORD *)(*(_DWORD *)(v2 + 112) + 12) = sub_1003E400(v5, v7, v4, v4);
      goto LABEL_8;
    }
  }
  else
  {
    v14 = *(_DWORD *)(v3 + 20) + 1;
    v13 = *(_DWORD *)(v3 + 20) + 1;
    v12 = *(void **)(v3 + 12);
    v11 = *(_DWORD *)(v2 + 32);
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 112) + 12) = sub_1003E510(v11, v12, v13, v14);
LABEL_8:
  v9 = *(_DWORD *)(v2 + 112);
  if ( *(_DWORD *)(v9 + 12) )
  {
    *(_DWORD *)(v9 + 20) = 2 * *(_DWORD *)(v9 + 20) | 1;
    result = 1;
  }
  else
  {
    sub_10011170(a2);
    result = 0;
  }
  return result;
}

//----- (10041260) --------------------------------------------------------
void *__cdecl sub_10041260(int a1, int a2, void *a3, int a4)
{
  char *v4; // esi@1
  unsigned __int8 v5; // dl@1
  char v6; // cl@1
  int v7; // ecx@2
  signed int v8; // ecx@4
  void *result; // eax@6
  char *v10; // ebp@8
  size_t v11; // ST08_4@11

  v4 = (char *)a3;
  v5 = *(_BYTE *)a3 >> 3;
  v6 = *(_BYTE *)a3;
  if ( v5 < 0x18u )
    v7 = v6 & 7;
  else
    v7 = v6 & 0x3F;
  v8 = a4 + v7;
  if ( v8 >= (v5 < 0x18u ? 8 : 64) )
  {
    v10 = (char *)a3 - *(_DWORD *)(a2 + 92);
    if ( !(*(_DWORD *)(a2 + 100) & *(_DWORD *)(a2 + 96)) )
    {
      result = (void *)sub_100411C0(a2, a1);
      if ( !result )
        return result;
      v4 = &v10[*(_DWORD *)(a2 + 92)];
    }
    v11 = (*(_DWORD *)(a2 + 96))++ - (_DWORD)v10;
    memcpy_0(v4 + 1, v4, v11);
    *v4 = a4 | 0xC0;
    result = v4 + 1;
  }
  else if ( v5 < 0x18u )
  {
    *(_BYTE *)a3 = v8 & 7 | 8 * (*(_BYTE *)a3 >> 3);
    result = a3;
  }
  else
  {
    *(_BYTE *)a3 = v8 | 0xC0;
    result = a3;
  }
  return result;
}

//----- (10041320) --------------------------------------------------------
int __cdecl sub_10041320(_BYTE *a1)
{
  unsigned int v1; // ecx@2
  int v2; // ecx@4
  _BYTE *i; // eax@4

  if ( (*a1 & 0xF8u) < 0xC0 )
    v1 = (unsigned int)*a1 >> 3;
  else
    v1 = 24;
  v2 = (unsigned __int8)byte_10162B5C[8 * v1];
  for ( i = a1 + 1; v2; --v2 )
  {
    if ( *i & 0x80 )
      i += 2;
    ++i;
  }
  return i - a1;
}

//----- (10041370) --------------------------------------------------------
int __cdecl sub_10041370(int a1, int a2)
{
  int v2; // eax@1
  int i; // ecx@1
  int result; // eax@5

  v2 = a2;
  for ( i = a1 + 1; v2; --v2 )
  {
    if ( *(_BYTE *)i & 0x80 )
      i += 2;
    ++i;
  }
  LOBYTE(result) = *(_BYTE *)i;
  if ( *(_BYTE *)i >= 0 )
    result = (unsigned __int8)result;
  else
    result = *(_BYTE *)(i + 2) | ((*(_BYTE *)(i + 1) | ((result & 0x7F) << 8)) << 8);
  return result;
}

//----- (100413C0) --------------------------------------------------------
signed int __cdecl sub_100413C0(int a1, int a2, int a3, int a4, signed int a5)
{
  signed int result; // eax@2
  int v6; // ecx@3
  int v7; // esi@3
  int i; // eax@3
  int v9; // edi@9
  int v10; // ecx@12
  _BYTE *v11; // esi@14

  if ( (unsigned int)a5 >= 0x800000 )
  {
    sub_1003FCE0(a2, a1);
    return 0;
  }
  v6 = *(_DWORD *)(a2 + 112);
  v7 = *(_DWORD *)(v6 + 12) + a3 + 1;
  for ( i = a4; i; --i )
  {
    if ( *(_BYTE *)v7 & 0x80 )
      v7 += 2;
    ++v7;
  }
  if ( a5 > 127 )
  {
    if ( !(*(_BYTE *)v7 & 0x80) )
    {
      v9 = v7 - *(_DWORD *)(v6 + 12);
      if ( (*(_DWORD *)(v6 + 20) & (unsigned int)(*(_DWORD *)(v6 + 16) + 1)) <= 1 )
      {
        result = sub_100411C0(a2, a1);
        if ( !result )
          return result;
        v7 = v9 + *(_DWORD *)(*(_DWORD *)(a2 + 112) + 12);
      }
      *(_DWORD *)(*(_DWORD *)(a2 + 112) + 16) += 2;
      v10 = *(_DWORD *)(a2 + 112);
      if ( *(_DWORD *)(v10 + 16) - v9 - 3 > 0 )
        memcpy_0((void *)(v7 + 3), (const void *)(v7 + 1), *(_DWORD *)(v10 + 16) - v9 - 3);
    }
    *(_BYTE *)v7 = (a5 >> 16) | 0x80;
    v11 = (_BYTE *)(v7 + 1);
    *v11 = BYTE1(a5);
    v7 = (int)(v11 + 1);
  }
  *(_BYTE *)v7 = a5;
  return 1;
}

//----- (100414A0) --------------------------------------------------------
signed int __cdecl sub_100414A0(int a1, int a2)
{
  int v2; // ebp@1
  size_t v3; // ebx@1
  unsigned int v4; // ecx@1
  int v6; // edi@3
  int v7; // edx@4
  int v8; // eax@4
  int v9; // esi@4
  unsigned int v10; // edi@4
  unsigned int v11; // esi@9
  int v12; // ecx@9
  int v13; // esi@9
  unsigned int v14; // eax@10
  int *v15; // eax@13
  int v16; // eax@17
  int v17; // [sp-18h] [bp-20h]@12
  void *v18; // [sp-14h] [bp-1Ch]@12
  size_t v19; // [sp-10h] [bp-18h]@12
  int v20; // [sp-Ch] [bp-14h]@12
  int v21; // [sp+10h] [bp+8h]@9

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 156);
  v4 = 12 * *(_DWORD *)(a2 + 4);
  if ( v4 <= v3 )
    return 1;
  v6 = *(_DWORD *)(a2 + 148);
  if ( !v6 )
  {
    v7 = *(_DWORD *)(a1 + 76);
    v8 = *(_DWORD *)(v7 + 12);
    v9 = 768 * ((v4 + 767) / 0x300);
    v10 = v8 + ((v9 + 3) & 0xFFFFFFFC);
    if ( v10 <= *(_DWORD *)(v7 + 8) )
      *(_DWORD *)(v7 + 12) = v10;
    else
      v8 = sub_1003E2D0(a1 + 60, (v9 + 3) & 0xFFFFFFFC);
    *(_DWORD *)(a2 + 148) = v8;
    if ( !v8 )
      return 0;
    goto LABEL_19;
  }
  v21 = *(_DWORD *)(a2 + 152) - v6;
  v11 = 3 * ((v4 - v3 + 767) / 0x300);
  v12 = *(_DWORD *)(a1 + 76);
  v13 = v11 << 8;
  if ( *(_DWORD *)(v12 + 12) != v6 + ((v3 + 3) & 0xFFFFFFFC) )
  {
    v20 = v13;
    v19 = v3;
    v18 = (void *)v6;
    v17 = a1 + 60;
    goto LABEL_15;
  }
  v14 = v6 + ((v13 + v3 + 3) & 0xFFFFFFFC);
  if ( v14 > *(_DWORD *)(v12 + 8) )
  {
    v20 = v13;
    v19 = v3;
    v18 = (void *)v6;
    v17 = a1 + 60;
    if ( v6 == *(_DWORD *)(v12 + 4) )
    {
      v15 = sub_1003E400(v17, v6, v3, v13);
LABEL_16:
      *(_DWORD *)(v2 + 148) = v15;
      goto LABEL_17;
    }
LABEL_15:
    v15 = sub_1003E510(v17, v18, v19, v20);
    goto LABEL_16;
  }
  *(_DWORD *)(v12 + 12) = v14;
LABEL_17:
  v16 = *(_DWORD *)(v2 + 148);
  if ( !v16 )
    return 0;
  v9 = v3 + v13;
  v8 = v21 + v16;
LABEL_19:
  *(_DWORD *)(v2 + 156) = v9;
  *(_DWORD *)(v2 + 152) = v8;
  return 1;
}

//----- (100415D0) --------------------------------------------------------
int __cdecl sub_100415D0(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 + 152);
  *(_DWORD *)(a2 + 152) = result + 12;
  *(_DWORD *)result = a3;
  *(_DWORD *)(result + 4) = a4 - a3;
  *(_DWORD *)(result + 8) = a5;
  return result;
}

//----- (10041600) --------------------------------------------------------
int __cdecl sub_10041600(int a1, int a2, void *a3)
{
  const void *v3; // edi@1
  int result; // eax@1
  int v5; // esi@2
  int v6; // ecx@2

  v3 = *(const void **)(a2 + 148);
  result = (*(_DWORD *)(a2 + 152) - (signed int)v3) / 12;
  if ( result )
  {
    v5 = 12 * result;
    memcpy(a3, v3, 12 * result);
    *(_DWORD *)((char *)a3 + v5) = 0;
    result = *(_DWORD *)(a2 + 112);
    v6 = *(_DWORD *)(result + 8) - *(_DWORD *)result;
    *(_DWORD *)((char *)a3 + v5 + 8) = 0;
    *(_DWORD *)((char *)a3 + v5 + 4) = v6;
  }
  return result;
}

//----- (10041660) --------------------------------------------------------
int __cdecl sub_10041660(int a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // ebx@1
  unsigned int v4; // esi@2
  signed int v5; // edx@2
  signed int v6; // edi@2
  int v7; // ebp@2
  signed int v8; // eax@3
  int v9; // eax@6
  unsigned int j; // ecx@19
  int v11; // ecx@24
  int v12; // edi@29
  unsigned int v13; // eax@29
  int *v14; // ebx@29
  int v15; // edx@29
  unsigned int v16; // ecx@29
  int v17; // edi@30
  size_t v18; // eax@30
  unsigned int v19; // edx@31
  bool v20; // zf@33
  int *v21; // eax@34
  signed int v23; // edi@43
  unsigned int v24; // esi@43
  unsigned int v25; // eax@45
  int v26; // ecx@49
  signed int v27; // ebx@49
  int v28; // edx@51
  int v29; // edi@51
  size_t v30; // eax@51
  int v31; // eax@56
  char *v32; // esi@56
  unsigned int v33; // ebx@56
  char v34; // al@57
  int v35; // eax@58
  unsigned int v36; // eax@60
  unsigned int v37; // ecx@62
  int *v38; // eax@62
  int v39; // edi@64
  unsigned int v40; // eax@69
  int v41; // ebp@72
  unsigned int v42; // edi@72
  int v43; // eax@73
  int v44; // ebx@74
  int v45; // edi@74
  int v46; // ecx@75
  int v47; // eax@77
  int v48; // esi@77
  int v49; // ecx@78
  unsigned int v50; // eax@81
  int v51; // eax@84
  unsigned int v52; // esi@88
  int v53; // ebx@89
  int v54; // eax@89
  int v55; // edi@89
  int v56; // ebp@89
  int v57; // eax@89
  int v58; // edi@91
  int v59; // eax@92
  unsigned int v60; // edx@94
  int v61; // ST0C_4@96
  int v62; // ecx@96
  int v63; // [sp-10h] [bp-5Ch]@33
  int *v64; // [sp-Ch] [bp-58h]@33
  size_t v65; // [sp-8h] [bp-54h]@33
  int v66; // [sp-4h] [bp-50h]@33
  int v67; // [sp+10h] [bp-3Ch]@1
  int v68; // [sp+10h] [bp-3Ch]@56
  int v69; // [sp+14h] [bp-38h]@1
  int v70; // [sp+14h] [bp-38h]@56
  int *v71; // [sp+18h] [bp-34h]@1
  unsigned int v72; // [sp+1Ch] [bp-30h]@1
  int v73; // [sp+20h] [bp-2Ch]@2
  signed int v74; // [sp+24h] [bp-28h]@2
  unsigned int v75; // [sp+24h] [bp-28h]@56
  unsigned int v76; // [sp+28h] [bp-24h]@2
  int v77; // [sp+28h] [bp-24h]@72
  unsigned int v78; // [sp+2Ch] [bp-20h]@1
  char *i; // [sp+30h] [bp-1Ch]@2
  int v80; // [sp+34h] [bp-18h]@8
  unsigned int v81; // [sp+34h] [bp-18h]@72
  signed int v82; // [sp+38h] [bp-14h]@2
  int v83; // [sp+38h] [bp-14h]@29
  signed int k; // [sp+38h] [bp-14h]@43
  unsigned int v85; // [sp+38h] [bp-14h]@62
  char *v86; // [sp+38h] [bp-14h]@71
  unsigned int l; // [sp+38h] [bp-14h]@88
  int v88; // [sp+3Ch] [bp-10h]@42
  int v89; // [sp+40h] [bp-Ch]@42
  int v90; // [sp+44h] [bp-8h]@42
  int v91; // [sp+48h] [bp-4h]@42

  v2 = *(_DWORD *)(a2 + 112);
  v71 = *(int **)v2;
  v3 = *(_DWORD *)(a2 + 160) + 16 * *(_DWORD *)(a2 + 172);
  v72 = *(_DWORD *)(a2 + 160);
  v78 = *(_DWORD *)(a2 + 160) + 16 * *(_DWORD *)(a2 + 172);
  v69 = *(_DWORD *)(v2 + 8) - *(_DWORD *)v2;
  v67 = 0;
  do
  {
    v4 = v72;
    v5 = 0;
    v6 = -1;
    v7 = 0;
    v82 = 1;
    v73 = 0;
    v74 = -1;
    v76 = 0;
    for ( i = 0; v4 < v3; v4 += 16 )
    {
      *(_DWORD *)(v4 + 4) += v73;
      v8 = *(_DWORD *)v4;
      if ( *(_DWORD *)v4 != v6 )
      {
        v6 = *(_DWORD *)v4;
        v74 = *(_DWORD *)(v4 + 4);
        v5 = *((_BYTE *)v71 + v8);
        i = (char *)v71 + v8;
        v7 = dword_100D1E4C[4 * v5] & 0xF;
        v76 = v4;
        if ( (unsigned int)(v7 - 9) <= 2 )
          continue;
      }
      if ( (unsigned int)(v7 - 9) > 2 )
      {
        v9 = *(_DWORD *)(*(_DWORD *)(v4 + 12) & 0xFFFFFFFE) - v74;
        if ( v9 < -32768 || v9 > 0x7FFF )
        {
          v80 = 0;
          v82 = 0;
          switch ( v5 )
          {
            case 6:
              v5 = 139;
              break;
            case 7:
              v5 = 140;
              break;
            case 8:
              v5 = 141;
              break;
            case 68:
              v5 = 142;
              break;
            case 69:
              v5 = 143;
              break;
            case 114:
              v5 = 144;
              break;
            case 119:
              v5 = 145;
              break;
            case 120:
              v5 = 146;
              break;
            case 70:
              v5 = 147;
              break;
            case 71:
              v5 = 148;
              break;
            default:
              break;
          }
          *i = v5;
          for ( j = v76; j < v3; j = v11 + 16 )
          {
            if ( *(_DWORD *)j != v6 )
              break;
            if ( j > v4 )
            {
              *(_DWORD *)(j + 4) += v73;
            }
            else
            {
              *(_DWORD *)(j + 4) += v80;
              v80 += 2;
            }
            v73 += 2;
            sub_10040350(*(_DWORD *)(a2 + 164), *(_DWORD *)(j + 4), 2);
          }
          v4 = j - 16;
        }
      }
    }
    v67 += v73;
  }
  while ( !v82 );
  if ( !v67 )
    goto LABEL_43;
  v12 = a2;
  v13 = *(_DWORD *)(*(_DWORD *)(a2 + 112) + 4);
  v14 = v71;
  v15 = v67 + v69;
  v16 = (unsigned int)v71 + v67 + v69;
  v83 = v67 + v69;
  if ( v16 > v13 )
  {
    v17 = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 16);
    v18 = v13 - (_DWORD)v71;
    if ( *(int **)(v17 + 12) == (int *)((char *)v71 + ((v18 + 3) & 0xFFFFFFFC)) )
    {
      v19 = (unsigned int)v71 + ((v67 + v69 + 3) & 0xFFFFFFFC);
      if ( v19 <= *(_DWORD *)(v17 + 8) )
      {
        *(_DWORD *)(v17 + 12) = v19;
        v12 = a2;
LABEL_38:
        if ( !v14 )
        {
          sub_10011170(a1);
          return 0;
        }
        v15 = v67 + v69;
        **(_DWORD **)(v12 + 112) = v14;
        v16 = (unsigned int)v14 + v83;
        *(_DWORD *)(*(_DWORD *)(v12 + 112) + 4) = (char *)v14 + v83;
        goto LABEL_42;
      }
      v20 = v71 == *(int **)(v17 + 4);
      v12 = a2;
      v66 = v67 + v69 - v18;
      v65 = v18;
      v64 = v71;
      v63 = *(_DWORD *)(a2 + 28);
      if ( v20 )
      {
        v21 = sub_1003E400(v63, (int)v71, v18, v66);
LABEL_37:
        v14 = v21;
        v71 = v21;
        goto LABEL_38;
      }
    }
    else
    {
      v12 = a2;
      v66 = v67 + v69 - v18;
      v65 = v18;
      v64 = v71;
      v63 = *(_DWORD *)(a2 + 28);
    }
    v21 = sub_1003E510(v63, v64, v65, v66);
    goto LABEL_37;
  }
LABEL_42:
  *(_DWORD *)(*(_DWORD *)(v12 + 112) + 8) = v16;
  v88 = -1;
  v89 = v15;
  v90 = v69;
  v91 = 0;
LABEL_43:
  v23 = -1;
  v24 = v4 - 16;
  for ( k = -1; v24 >= v72; v24 -= 16 )
  {
    if ( *(_DWORD *)v24 != v23 )
    {
      v23 = *(_DWORD *)v24;
      v25 = v24 - 16;
      v7 = dword_100D1E4C[4 * *((_BYTE *)v71 + *(_DWORD *)v24)] & 0xF;
      for ( k = *(_DWORD *)v24; v25 >= v72; v25 -= 16 )
      {
        if ( *(_DWORD *)v25 != v23 )
          break;
      }
      v74 = *(_DWORD *)(v25 + 20);
    }
    v26 = (int)v71 + *(_DWORD *)(v24 + 8);
    v27 = *(_DWORD *)(*(_DWORD *)(v24 + 12) & 0xFFFFFFFE) - v74;
    if ( (unsigned int)(v7 - 9) <= 2 )
    {
      v28 = *(_DWORD *)(v24 + 8);
      v29 = (int)v71 + *(_DWORD *)(v24 + 4);
      v20 = v69 - v28 == 3;
      v30 = v69 - v28 - 3;
      v69 = v28 + 1;
      if ( !v20 )
        memcpy_0((void *)(v29 + 5), (const void *)(v26 + 3), v30);
      *(_BYTE *)(v29 + 1) = BYTE3(v27);
      *(_BYTE *)(v29 + 2) = v27 >> 16;
      *(_BYTE *)(v29 + 3) = BYTE1(v27);
      *(_BYTE *)(v29 + 4) = v27;
      v23 = k;
    }
    else
    {
      *(_BYTE *)(v26 + 1) = BYTE1(v27);
      *(_BYTE *)(v26 + 2) = v27;
    }
  }
  if ( v67 )
  {
    v68 = 0;
    v70 = 0;
    v31 = a2;
    v32 = *(char **)(a2 + 92);
    v33 = (unsigned int)&v32[*(_DWORD *)(a2 + 96)];
    v75 = v72;
    if ( (unsigned int)v32 < v33 )
    {
      do
      {
        v34 = *v32;
        if ( (*v32 & 0xF8u) < 0xC0 )
          v35 = v34 & 7;
        else
          v35 = v34 & 0x3F;
        v70 += v35;
        v36 = v75;
        if ( v75 < v78 )
        {
          do
          {
            if ( *(_DWORD *)(v36 + 8) >= v70 )
              break;
            v37 = v36 + 16;
            v38 = (int *)v37;
            v85 = v37;
            if ( v37 == v78 )
              v38 = &v88;
            v39 = v38[1] - v38[2] - v68;
            if ( v39 > 0 )
            {
              v32 = (char *)sub_10041260(a1, a2, v32, v38[1] - v38[2] - v68);
              if ( !v32 )
                return 0;
              v33 = *(_DWORD *)(a2 + 96) + *(_DWORD *)(a2 + 92);
              v68 += v39;
              v37 = v85;
            }
            v36 = v37;
            v75 = v37;
          }
          while ( v37 < v78 );
        }
        if ( (*v32 & 0xF8u) < 0xC0 )
          v40 = (unsigned int)(unsigned __int8)*v32 >> 3;
        else
          v40 = 24;
        v86 = &byte_10162B5E[8 * v40];
        if ( byte_10162B5E[8 * v40] )
        {
          v41 = v70 + (unsigned __int8)byte_10162B5D[8 * v40];
          v42 = 0;
          v81 = (unsigned __int8)byte_10162B5C[8 * v40];
          v77 = 0;
          if ( byte_10162B5C[8 * v40] )
          {
            do
            {
              v43 = sub_10041370((int)v32, v42);
              if ( v43 )
              {
                v44 = *v86;
                v45 = v41 + v43 * v44;
                if ( v45 < v41 )
                  v46 = 0;
                else
                  v46 = (signed int)(v75 - v72) >> 4;
                v47 = sub_10040390(a2, v46, v45, (int)&v88);
                v48 = (int)&v32[-*(_DWORD *)(a2 + 92)];
                if ( !sub_100413C0(
                        a1,
                        a2,
                        v48,
                        v77,
                        v44 * (v45 + *(_DWORD *)(v47 + 4) - *(_DWORD *)(v47 + 8) - v41 - v68)) )
                  return 0;
                v49 = *(_DWORD *)(a2 + 92);
                v42 = v77;
                v32 = (char *)(v49 + v48);
                v33 = v49 + *(_DWORD *)(a2 + 96);
              }
              v77 = ++v42;
            }
            while ( v42 < v81 );
          }
        }
        if ( (*v32 & 0xF8u) < 0xC0 )
          v50 = (unsigned int)(unsigned __int8)*v32 >> 3;
        else
          v50 = 24;
        if ( byte_10162B5C[8 * v50] )
          v51 = sub_10041320(v32);
        else
          v51 = 1;
        v32 += v51;
      }
      while ( (unsigned int)v32 < v33 );
      v31 = a2;
    }
    v52 = *(_DWORD *)(v31 + 148);
    for ( l = *(_DWORD *)(v31 + 152); v52 < l; v52 += 12 )
    {
      v53 = *(_DWORD *)v52;
      v54 = sub_10040390(a2, 0, *(_DWORD *)v52, (int)&v88);
      v55 = v54;
      v56 = *(_DWORD *)(v54 + 4) - *(_DWORD *)(v54 + 8);
      *(_DWORD *)v52 = v53 + v56;
      v57 = sub_10040390(a2, (signed int)(v54 - v72) >> 4, v53 + *(_DWORD *)(v52 + 4), (int)&v88);
      if ( v57 != v55 )
        *(_DWORD *)(v52 + 4) += *(_DWORD *)(v57 + 4) - *(_DWORD *)(v57 + 8) - v56;
      v58 = *(_DWORD *)(v52 + 8);
      if ( v58 )
      {
        v59 = sub_10040390(a2, (signed int)(v57 - v72) >> 4, v58, (int)&v88);
        *(_DWORD *)(v52 + 8) = v58 + *(_DWORD *)(v59 + 4) - *(_DWORD *)(v59 + 8);
      }
    }
  }
  v60 = 16 * (1 << sub_10052D80(*(_DWORD *)(a2 + 172)));
  if ( v60 <= 0x1000 )
    v60 = 4096;
  sub_1003E630(a1 + 60, *(_DWORD *)(a2 + 160), v60);
  v61 = *(_DWORD *)(a2 + 164);
  *(_DWORD *)(a2 + 160) = 0;
  sub_10040400(a2, v61);
  *(_DWORD *)(a2 + 164) = v62;
  *(_DWORD *)(a2 + 176) = v62;
  *(_DWORD *)(a2 + 172) = v62;
  return v62 + 1;
}
// 100D1E4C: using guessed type int dword_100D1E4C[];

//----- (10041D80) --------------------------------------------------------
signed int __usercall sub_10041D80@<eax>(_DWORD *a1@<eax>, int a2@<edi>, int a3, int a4)
{
  _DWORD *v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // ebx@6
  int v9; // eax@12
  signed int v10; // esi@12
  int v11; // eax@15
  int v12; // [sp+Ch] [bp-4h]@6

  v4 = a1;
  v5 = a4;
  if ( !a1 )
    goto LABEL_6;
  v6 = *(_DWORD *)(a2 + 8);
  if ( v6 != a4 )
  {
    while ( *(_DWORD *)v6 != 8 )
    {
      v6 = *(_DWORD *)(v6 + 28);
      if ( v6 == a4 )
        goto LABEL_5;
    }
    if ( sub_1003FBB0(a3, a2, -104) < 0 )
      return 0;
    *v4 = 153;
    goto LABEL_6;
  }
LABEL_5:
  if ( *v4 != 5 )
  {
LABEL_6:
    v7 = *(_DWORD *)(a2 + 8);
    v12 = *(_DWORD *)(a2 + 140);
    if ( v7 != a4 )
    {
      while ( 1 )
      {
        switch ( *(_DWORD *)v7 )
        {
          case 8:
            if ( sub_10041100(a3, a2, 11) < 0 )
              return 0;
            v9 = *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8) - **(_DWORD **)(a2 + 112);
            v10 = v9 - *(_DWORD *)(v7 + 16);
            *(_DWORD *)(v7 + 16) = v9;
            if ( sub_10040440(a2, v10, a3, -105) < 0 )
              return 0;
            v5 = a4;
            goto LABEL_20;
          case 5:
          case 7:
            if ( sub_10041100(a3, a2, 11) < 0 )
              return 0;
            v11 = sub_1003FBB0(a3, a2, 4);
            goto LABEL_19;
          case 0xC:
            v11 = sub_1003FBB0(a3, a2, 107);
            goto LABEL_19;
          case 9:
            if ( sub_10041100(a3, a2, 11) < 0 )
              return 0;
            v11 = sub_1003FBB0(a3, a2, 81);
LABEL_19:
            if ( v11 >= 0 )
              goto LABEL_20;
            return 0;
          default:
LABEL_20:
            v7 = *(_DWORD *)(v7 + 28);
            if ( v7 == v5 )
              goto LABEL_21;
            break;
        }
      }
    }
LABEL_21:
    *(_DWORD *)(a2 + 140) = v12;
  }
  return 1;
}

//----- (10041EC0) --------------------------------------------------------
signed int __usercall sub_10041EC0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, _DWORD *a4, int a5)
{
  int v5; // esi@1
  int v6; // eax@3
  signed int v8; // esi@8
  int v9; // [sp+0h] [bp-14h]@0
  int v10; // [sp+4h] [bp-10h]@0

  v5 = a1;
  if ( !sub_10041D80(0, a3, v9, v10) )
    return -1;
  if ( a5 )
  {
    v6 = sub_10041100(a2, a3, v5);
    if ( v6 < 0 || !sub_100413C0(a2, a3, v6, 0, *(_DWORD *)(a5 + 12)) )
      return -1;
  }
  else if ( v5 && sub_10041100(a2, a3, v5) < 0 )
  {
    return -1;
  }
  v8 = *(_DWORD *)(*(_DWORD *)(a3 + 112) + 8) - **(_DWORD **)(a3 + 112) - *a4;
  *a4 = *(_DWORD *)(*(_DWORD *)(a3 + 112) + 8) - **(_DWORD **)(a3 + 112);
  return sub_10040440(a3, v8, a2, -107);
}

//----- (10041F50) --------------------------------------------------------
signed int __cdecl sub_10041F50(int a1, _BYTE *a2, int a3, int a4)
{
  signed int result; // eax@1
  int v5; // ebx@2
  int v6; // ecx@2
  signed int v7; // eax@2
  unsigned int v8; // eax@3
  char v9; // [sp+8h] [bp-58h]@2
  int v10; // [sp+10h] [bp-50h]@2
  int v11; // [sp+18h] [bp-48h]@2
  int v12; // [sp+34h] [bp-2Ch]@2
  int v13; // [sp+3Ch] [bp-24h]@2
  int v14; // [sp+54h] [bp-Ch]@2

  result = sub_100414A0(a1, (int)a2);
  if ( result )
  {
    v5 = *(_DWORD *)(a1 + 56);
    memset(&v9, 0, 0x58u);
    v6 = *(_DWORD *)(a1 + 300) & 0x10 | 8;
    v13 = *(_DWORD *)(a4 + 4);
    v10 = v13;
    v11 = a4;
    v12 = v5;
    v14 = 8 * v6;
    *(_DWORD *)(a1 + 56) = &v9;
    v7 = sub_10042FB0(a4, a1, (int)a2, a3);
    *(_DWORD *)(a1 + 56) = v5;
    if ( v7 && (v8 = sub_10021E70(a1, (int)a2, a4), (*(_DWORD *)(a4 + 12) = v8) != 0) )
    {
      if ( *a2 & 0x80 )
        *(_BYTE *)(a4 + 22) |= 0x80u;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10042010) --------------------------------------------------------
signed int __cdecl sub_10042010(int a1, int a2, int a3, signed int a4)
{
  int v4; // eax@1
  signed int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10041100(a1, a2, a3);
  v5 = v4;
  if ( v4 < 0 || sub_100413C0(a1, a2, v4, 0, a4) )
    result = v5;
  else
    result = -1;
  return result;
}

//----- (10042060) --------------------------------------------------------
signed int __cdecl sub_10042060(int a1, int a2, int a3, signed int a4, signed int a5)
{
  int v5; // eax@1
  int v6; // esi@1
  signed int result; // eax@3

  v5 = sub_10041100(a1, a2, a3);
  v6 = v5;
  if ( v5 < 0 || sub_100413C0(a1, a2, v5, 0, a4) && sub_100413C0(a1, a2, v6, 1, a5) )
    result = v6;
  else
    result = -1;
  return result;
}

//----- (100420C0) --------------------------------------------------------
int __cdecl sub_100420C0(int a1, int a2, void *a3)
{
  int v3; // esi@1
  size_t v4; // eax@1
  signed int v5; // ST0C_4@3
  size_t v6; // edx@4
  int v7; // ebx@5
  void *v8; // ebp@6
  char v9; // al@6
  int v10; // eax@7
  signed int v11; // edi@7
  int v12; // edi@9
  size_t v14; // edi@18
  int v15; // ebp@18
  int v16; // [sp+18h] [bp+8h]@1

  v3 = a2;
  v16 = *(_DWORD *)(a2 + 64);
  v4 = v16;
  if ( !v16 || *(_DWORD *)(v3 + 76) == *(_DWORD *)(v3 + 120) )
  {
    v7 = *(_DWORD *)(v3 + 56) - *(_DWORD *)(v3 + 72) - *(_DWORD *)(v3 + 48);
    if ( v7 <= 0 )
      goto LABEL_18;
    v8 = *(void **)(v3 + 92);
    v9 = *(_BYTE *)v8;
    if ( (*(_BYTE *)v8 & 0xF8u) < 0xC0 )
    {
      v10 = v9 & 7;
      v11 = 7;
    }
    else
    {
      v10 = v9 & 0x3F;
      v11 = 63;
    }
    v12 = v11 - v10;
    if ( v7 < v12 )
      v12 = *(_DWORD *)(v3 + 56) - *(_DWORD *)(v3 + 72) - *(_DWORD *)(v3 + 48);
    if ( sub_10041260(a1, v3, v8, v12) )
    {
      while ( 1 )
      {
        v7 -= v12;
        if ( !v7 )
          break;
        v12 = v7;
        if ( v7 >= 63 )
          v12 = 63;
        if ( !sub_10041260(a1, v3, *(void **)(v3 + 92), v12) )
          return 0;
      }
      v4 = v16;
      goto LABEL_18;
    }
    return 0;
  }
  v5 = *(_DWORD *)(v3 + 120);
  *(_DWORD *)(v3 + 112) = v3 + 48;
  if ( sub_10042010(a1, v3, 23, v5) < 0 )
    return 0;
  v6 = *(_DWORD *)(v3 + 64);
  *(_DWORD *)(v3 + 112) = v3 + 80;
  v16 = v6;
  v4 = v6;
LABEL_18:
  v14 = *(_DWORD *)(v3 + 96);
  v15 = v14 + v4;
  if ( v4 )
  {
    memcpy(a3, *(const void **)(v3 + 60), v4);
    v4 = v16;
  }
  memcpy((char *)a3 + v4, *(const void **)(v3 + 92), v14);
  *((_BYTE *)a3 + v15) = 0;
  return 1;
}

//----- (100421D0) --------------------------------------------------------
int __cdecl sub_100421D0(int a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@4
  int result; // eax@4
  int v7; // eax@10
  int v8; // esi@10
  int v9; // ebx@10
  int *v10; // ecx@11
  int v11; // edx@11
  int v12; // edi@12
  int v13; // eax@14
  int v14; // edx@15
  int v15; // eax@16
  int v16; // eax@22
  int v17; // eax@25
  int v18; // eax@26
  int v19; // [sp+Ch] [bp-4h]@1

  v4 = *(_DWORD *)(a2 + 28);
  v19 = *(_DWORD *)(a2 + 28);
  if ( a3 != 53 || *(_DWORD *)a2 != 22 || *(_DWORD *)v4 != 29 )
  {
    v5 = a1;
  }
  else
  {
    v5 = a1;
    result = sub_100409A0(v4, a1, (_BYTE *)a4);
    if ( !result )
      return result;
    if ( *(_DWORD *)(v4 + 12) == 9 && *(_DWORD *)(a2 + 24) == *(_DWORD *)(*(_DWORD *)(a1 + 24) + 264) )
      return sub_1003FBB0(a1, a4, -119) >= 0;
  }
  if ( *(_DWORD *)v4 == 22 )
  {
    v7 = *(_DWORD *)(*(_DWORD *)(a4 + 112) + 8) - **(_DWORD **)(a4 + 112);
    v8 = *(_DWORD *)(v4 + 28);
    v9 = v4;
    *(_DWORD *)(v4 + 16) = v7;
    for ( *(_DWORD *)(v4 + 28) = 0; *(_DWORD *)v8 == 22; *v10 = v11 )
    {
      v10 = (int *)(v8 + 28);
      v11 = v9;
      *(_DWORD *)(v8 + 16) = v7;
      v9 = v8;
      v8 = *(_DWORD *)(v8 + 28);
    }
    v12 = a1;
    if ( sub_10042FB0(a1, a1, a4, v8) )
    {
      while ( sub_10042010(
                v12,
                a4,
                12,
                *(_DWORD *)(*(_DWORD *)(a4 + 112) + 8) - *(_DWORD *)(v8 + 16) - **(_DWORD **)(a4 + 112)) >= 0 )
      {
        v13 = sub_10038C10(v12, *(_DWORD *)(v9 + 24), a4 + 128);
        if ( !v13 )
          break;
        v14 = *(_DWORD *)(v13 + 12);
        if ( sub_1003FC00(v12, a4, *(_DWORD *)(v9 + 12), SBYTE1(v14), *(_BYTE *)(v13 + 12)) < 0 )
          break;
        v15 = *(_DWORD *)(v9 + 28);
        *(_DWORD *)(v9 + 28) = v8;
        v8 = v9;
        v9 = v15;
        if ( !v15 )
        {
          v5 = a1;
          v4 = v19;
          goto LABEL_21;
        }
        v12 = a1;
      }
    }
    return 0;
  }
  if ( !sub_10042FB0(v4, v5, a4, v4) )
    return 0;
LABEL_21:
  if ( sub_10042010(v5, a4, 12, *(_DWORD *)(*(_DWORD *)(a4 + 112) + 8) - *(_DWORD *)(v4 + 16) - **(_DWORD **)(a4 + 112)) < 0 )
    return 0;
  v16 = *(_DWORD *)(a2 + 24);
  if ( v16 )
  {
    v17 = sub_10038C10(v5, v16, a4 + 128);
    if ( !v17 )
      return 0;
    v18 = *(_DWORD *)(v17 + 12);
    if ( sub_1003FC00(v5, a4, a3, SBYTE1(v18), v18) < 0 )
      return 0;
  }
  else if ( sub_1003FBB0(v5, a4, a3) < 0 )
  {
    return 0;
  }
  return 1;
}

//----- (100423C0) --------------------------------------------------------
int __usercall sub_100423C0@<eax>(int a1@<ebx>, int a2@<esi>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // ebp@2
  unsigned int v8; // ecx@10
  int v9; // ebp@23
  unsigned int v10; // ecx@31
  int v11; // [sp+8h] [bp-Ch]@2
  int v12; // [sp+Ch] [bp-8h]@1

  v4 = a3;
  v5 = *(_DWORD *)(a3 + 24);
  v12 = *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8) - **(_DWORD **)(a2 + 112);
  if ( *(_DWORD *)(a3 + 20) == -2 )
  {
    v6 = *(_DWORD *)(v5 + 40);
    v11 = *(_DWORD *)(a3 + 28) - 40;
    if ( *(_DWORD *)v5 == 29 && *(_DWORD *)v6 == 30 )
    {
      if ( !sub_100409A0(v5, a1, (_BYTE *)a2) )
        return 0;
      if ( *(_DWORD *)(v5 + 12) == 9
        && (*(_DWORD *)(v6 + 28) & 0x7FF00000) != 2146435072
        && (*(_DWORD *)(v6 + 28) != 0x80000000 || *(_DWORD *)(v6 + 24)) )
      {
        v8 = (signed int)*(double *)(v6 + 24);
        if ( (double)(signed int)v8 == *(double *)(v6 + 24) && v8 < 0x10000 )
        {
          *(_DWORD *)(v6 + 16) = v12;
          *(_DWORD *)(v5 + 16) = v12;
          if ( sub_1003FC00(a1, a2, -120, SBYTE1(v8), v8) < 0 )
            return 0;
          v5 = v6;
          v6 = *(_DWORD *)(v6 + 40);
        }
      }
      v4 = a3;
    }
    if ( v5 == *(_DWORD *)(v4 + 24) && !sub_10042FB0(v5, a1, a2, v5) )
      return 0;
    if ( v6 != v11 )
    {
      while ( sub_10042FB0(v5, a1, a2, v6)
           && sub_10042010(a1, a2, 12, *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8) - **(_DWORD **)(a2 + 112) - v12) >= 0
           && sub_1003FBB0(a1, a2, 55) >= 0 )
      {
        v6 = *(_DWORD *)(v6 + 40);
        if ( v6 == v11 )
          goto LABEL_35;
      }
      return 0;
    }
  }
  else
  {
    v9 = *(_DWORD *)(a3 + 28);
    v11 = *(_DWORD *)(a3 + 28);
    if ( a4 == 55 && *(_DWORD *)v5 == 29 && *(_DWORD *)v9 == 30 )
    {
      if ( !sub_100409A0(v5, a1, (_BYTE *)a2) )
        return 0;
      if ( *(_DWORD *)(v5 + 12) == 9
        && (*(_DWORD *)(v9 + 28) & 0x7FF00000) != 2146435072
        && (*(_DWORD *)(v9 + 28) != 0x80000000 || *(_DWORD *)(v9 + 24)) )
      {
        v10 = (signed int)*(double *)(v9 + 24);
        if ( (double)(signed int)v10 == *(double *)(v9 + 24) && v10 < 0x10000 )
        {
          *(_DWORD *)(v9 + 16) = v12;
          *(_DWORD *)(v5 + 16) = v12;
          return sub_1003FC00(a1, a2, -120, SBYTE1(v10), v10) >= 0;
        }
      }
    }
    if ( !sub_10042FB0(v5, a1, a2, v5) )
      return 0;
  }
LABEL_35:
  if ( !sub_10042FB0(v5, a1, a2, v11)
    || sub_10042010(a1, a2, 12, *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8) - **(_DWORD **)(a2 + 112) - v12) < 0 )
  {
    return 0;
  }
  return sub_1003FBB0(a1, a2, a4) >= 0;
}

//----- (10042620) --------------------------------------------------------
signed int __usercall sub_10042620@<eax>(int a1@<eax>, __int64 a2, int a3)
{
  int v3; // esi@1
  int v4; // esi@2
  int v5; // eax@2
  int v6; // edi@5
  char *v7; // ebx@5
  int v8; // esi@9
  double v9; // st7@10
  signed int v10; // ecx@13
  int v11; // eax@16
  int v12; // esi@23
  signed int v13; // eax@28
  signed int v14; // esi@30
  signed int v15; // esi@36
  signed int v16; // eax@42
  char *v17; // esi@42
  unsigned int v18; // eax@52
  size_t v20; // eax@61
  signed int v21; // edi@66
  int v22; // ebx@67
  signed int v23; // eax@74
  int v24; // ecx@80
  _BYTE *v25; // eax@81
  int v26; // ebx@81
  void *v27; // eax@82
  int i; // eax@83
  int v29; // eax@90
  int v30; // esi@91
  int v31; // eax@92
  int v32; // eax@93
  int v33; // eax@95
  int j; // esi@99
  int v35; // eax@100
  int v36; // eax@102
  int v37; // esi@106
  int v38; // ebx@110
  bool v39; // zf@111
  int v40; // eax@111
  int v41; // eax@116
  int v42; // esi@119
  int v43; // esi@121
  int v44; // ebx@125
  int k; // esi@125
  int v46; // eax@126
  int v47; // eax@127
  int v48; // ebx@133
  int l; // esi@133
  int v50; // eax@135
  int v51; // eax@136
  int v52; // esi@137
  signed int v53; // [sp+1Ch] [bp-440h]@1
  int v54; // [sp+20h] [bp-43Ch]@2
  int v55; // [sp+24h] [bp-438h]@2
  unsigned int v56; // [sp+28h] [bp-434h]@2
  signed int v57; // [sp+2Ch] [bp-430h]@1
  int v58; // [sp+2Ch] [bp-430h]@66
  signed int v59; // [sp+30h] [bp-42Ch]@5
  int v60; // [sp+30h] [bp-42Ch]@67
  signed int v61; // [sp+34h] [bp-428h]@5
  int v62; // [sp+38h] [bp-424h]@2
  int v63; // [sp+3Ch] [bp-420h]@2
  signed int v64; // [sp+40h] [bp-41Ch]@5
  signed int v65; // [sp+44h] [bp-418h]@1
  int v66; // [sp+44h] [bp-418h]@90
  double v67; // [sp+48h] [bp-414h]@10
  int v68; // [sp+48h] [bp-414h]@59
  signed int v69; // [sp+50h] [bp-40Ch]@1
  signed int v70; // [sp+54h] [bp-408h]@1
  int v71; // [sp+58h] [bp-404h]@20
  char v72; // [sp+5Ch] [bp-400h]@39

  v3 = a1;
  v53 = 70;
  v57 = 1;
  v65 = 0;
  v69 = 0;
  v70 = -1;
  if ( !sub_10042FB0(0, a2, SHIDWORD(a2), *(_DWORD *)(a1 + 24)) )
    return 0;
  v54 = *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 112) + 8) - **(_DWORD **)(HIDWORD(a2) + 112);
  sub_100405E0(SHIDWORD(a2), a3, 4, v54);
  v4 = *(_DWORD *)(v3 + 28);
  v5 = *(_DWORD *)(v4 + 32);
  v63 = v4;
  v62 = v5;
  v55 = 0;
  v56 = 0;
  if ( !v5 || v5 == 1 && (v69 = **(_DWORD **)(v4 + 24) == 41) != 0 )
  {
    v62 = 0;
    v61 = 0;
    LOWORD(v64) = -1;
    goto LABEL_59;
  }
  v6 = *(_DWORD *)(v4 + 24);
  v7 = 0;
  v59 = 0;
  v61 = 0x3FFFFFFF;
  v64 = -1073741823;
  if ( !v6 )
    goto LABEL_52;
  do
  {
    if ( *(_DWORD *)v6 == 41 )
    {
      --v62;
      v69 = 1;
    }
    else if ( v53 != 118 )
    {
      v8 = *(_DWORD *)(v6 + 24);
      switch ( *(_DWORD *)v8 )
      {
        case 0x1E:
          v9 = *(double *)(v8 + 24);
          v67 = v9;
          if ( (HIDWORD(v67) & 0x7FF00000) != 2146435072 && (HIDWORD(v67) != 0x80000000 || LODWORD(v67)) )
          {
            v10 = (signed int)v9;
            if ( (double)(signed int)v9 == v9 && (unsigned int)(v10 + 0x3FFFFFFF) <= 0x7FFFFFFE )
            {
              *(_DWORD *)(v6 + 32) = 2 * v10 | 1;
              goto LABEL_27;
            }
          }
          v11 = sub_100387D0(a2, v9, 0);
          if ( v11 )
          {
            *(_DWORD *)(v6 + 32) = *(_DWORD *)(v11 + 8);
            goto LABEL_27;
          }
          v57 = 0;
          goto LABEL_47;
        case 0x1F:
          *(_DWORD *)(v6 + 32) = *(_DWORD *)(*(_DWORD *)(v8 + 24) + 8);
          goto LABEL_27;
        case 0x1D:
          if ( *(_DWORD *)(v8 + 28) )
            goto LABEL_23;
          v57 = sub_100407C0(a2, SHIDWORD(a2), *(_DWORD *)(v8 + 24), &v71);
          if ( !v57 )
            goto LABEL_47;
          if ( v71 == -2147483647 )
            goto LABEL_23;
          *(_DWORD *)(v6 + 32) = v71;
          v65 = 1;
          goto LABEL_27;
        case 0x21:
LABEL_23:
          v12 = *(_DWORD *)(v8 + 12);
          if ( v12 == 67 )
          {
            *(_DWORD *)(v6 + 32) = 14;
          }
          else
          {
            if ( v12 != 66 )
            {
LABEL_45:
              v53 = 118;
              break;
            }
            *(_DWORD *)(v6 + 32) = 6;
          }
LABEL_27:
          if ( v53 == 70 )
          {
            v13 = *(_DWORD *)(v6 + 32);
            if ( v13 & 1 && v13 != -2147483647 && (v14 = v13 >> 1, (unsigned int)((v13 >> 1) + 0x8000) < 0x10000) )
            {
              if ( v14 < v61 )
                v61 = v13 >> 1;
              if ( v64 < v14 )
                v64 = v13 >> 1;
              v15 = v14 + ((char)-(v14 < 0) & 0x10000);
              if ( v15 >= v59 )
              {
                if ( v7 || v15 >= 0x2000 )
                {
                  v59 = 0x10000;
                  v7 = (char *)sub_10011830(a2, 0x2000u);
                  if ( !v7 )
                  {
                    sub_10011170(a2);
                    return 0;
                  }
                }
                else
                {
                  v7 = &v72;
                  v59 = 0x2000;
                }
                memset(v7, 0, v59 >> 3);
              }
              v16 = 1 << (v15 & 0x1F);
              v17 = &v7[4 * (v15 >> 5)];
              if ( v16 & *(_DWORD *)v17 )
                v53 = 71;
              else
                *(_DWORD *)v17 |= v16;
            }
            else
            {
              v53 = 71;
            }
          }
          break;
        default:
          goto LABEL_45;
      }
    }
    v6 = *(_DWORD *)(v6 + 40);
  }
  while ( v6 );
LABEL_47:
  if ( v7 && v7 != &v72 )
    sub_10010340(a2, (unsigned int)v7);
  if ( !v57 )
    return 0;
  if ( v53 == 70 )
  {
LABEL_52:
    v18 = v64 - v61 + 1;
    v55 = v64 - v61 + 1;
    if ( v18 >= 0x10000 || v18 > 2 * v62 )
      v53 = 71;
  }
LABEL_59:
  v68 = sub_10042060(a2, SHIDWORD(a2), 18, 0, 0);
  if ( v68 < 0 )
    return 0;
  if ( v53 == 118 )
    v20 = 0;
  else
    v20 = v53 == 70 ? 2 * v55 + 6 : 4 * v62 + 4;
  if ( sub_1003FC60(a2, SHIDWORD(a2), v53, v20) < 0 )
    return 0;
  v21 = -1;
  v58 = -1;
  if ( v53 == 118 )
  {
    v22 = *(_DWORD *)(v63 + 24);
    v60 = -1;
    if ( v22 )
    {
      while ( !*(_DWORD *)(v22 + 24) || sub_10042FB0(v21, a2, SHIDWORD(a2), *(_DWORD *)(v22 + 24)) )
      {
        if ( v60 >= 0
          && !sub_100413C0(
                a2,
                SHIDWORD(a2),
                v60,
                0,
                *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 112) + 8) - **(_DWORD **)(HIDWORD(a2) + 112) - v21) )
        {
          break;
        }
        if ( *(_DWORD *)v22 != 41 )
        {
          v60 = sub_10042010(a2, SHIDWORD(a2), 7, 0);
          if ( v60 < 0 )
            break;
          v23 = sub_10040440(SHIDWORD(a2), 0, a2, 119);
          v21 = v23;
          v58 = v23;
          if ( v23 < 0 )
            break;
          *(_DWORD *)(v22 + 16) = v23;
          if ( v22 == *(_DWORD *)(v63 + 24) && !sub_100413C0(a2, SHIDWORD(a2), v68, 1, v23 - v54) )
            break;
        }
        v22 = *(_DWORD *)(v22 + 40);
        if ( !v22 )
          goto LABEL_78;
      }
      return 0;
    }
LABEL_78:
    v70 = sub_10040440(SHIDWORD(a2), 0, a2, 120);
    if ( v70 < 0 )
      return 0;
    goto LABEL_106;
  }
  v24 = **(_DWORD **)(HIDWORD(a2) + 112);
  if ( v53 == 70 )
  {
    *(_BYTE *)(v24 + v54 + 4) = v61;
    *(_BYTE *)(v24 + v54 + 3) = BYTE1(v61);
    v25 = (_BYTE *)(v24 + v54 + 6);
    *(v25 - 1) = BYTE1(v64);
    *v25 = v64;
    v26 = v24 + v54 + 6;
    if ( v55 )
    {
      v27 = (void *)sub_10011830(a2, 4 * v55);
      v56 = (unsigned int)v27;
      if ( !v27 )
        return 0;
      memset(v27, 0, 4 * v55);
      for ( i = *(_DWORD *)(v63 + 24); i; i = *(_DWORD *)(i + 40) )
      {
        if ( *(_DWORD *)i != 41 )
          *(_DWORD *)(v56 + 4 * ((*(_DWORD *)(i + 32) >> 1) - v61)) = i;
      }
    }
  }
  else
  {
    *(_BYTE *)(v24 + v54 + 3) = BYTE1(v62);
    *(_BYTE *)(v24 + v54 + 4) = v62;
    v26 = v24 + v54 + 4;
  }
  if ( !v65 )
    goto LABEL_106;
  v29 = *(_DWORD *)(HIDWORD(a2) + 112);
  v66 = *(_DWORD *)(v29 + 8);
  *(_DWORD *)(v29 + 8) = v26 + 1;
  if ( v53 == 70 )
  {
    v30 = 0;
    if ( v55 > 0 )
    {
      while ( 1 )
      {
        v31 = *(_DWORD *)(v56 + 4 * v30);
        if ( v31 )
        {
          v32 = *(_DWORD *)(v31 + 24);
          if ( v32 )
          {
            if ( *(_DWORD *)v32 == 29 )
            {
              v33 = sub_10038C10(a2, *(_DWORD *)(v32 + 24), HIDWORD(a2) + 128);
              if ( !v33 )
                break;
              *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 112) + 8) = v26;
              if ( sub_10042010(a2, SHIDWORD(a2), 13, *(_DWORD *)(v33 + 12)) < 0 )
                break;
            }
          }
        }
        ++v30;
        v26 += 2;
        if ( v30 >= v55 )
          goto LABEL_105;
      }
LABEL_141:
      v21 = 0;
      goto LABEL_142;
    }
  }
  else
  {
    for ( j = *(_DWORD *)(v63 + 24); j; v26 += 4 )
    {
      v35 = *(_DWORD *)(j + 24);
      if ( v35 )
      {
        if ( *(_DWORD *)v35 == 29 )
        {
          v36 = sub_10038C10(a2, *(_DWORD *)(v35 + 24), HIDWORD(a2) + 128);
          if ( !v36 )
            goto LABEL_141;
          *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 112) + 8) = v26;
          if ( sub_10042010(a2, SHIDWORD(a2), 13, *(_DWORD *)(v36 + 12)) < 0 )
            goto LABEL_141;
        }
      }
      j = *(_DWORD *)(j + 40);
    }
  }
LABEL_105:
  *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 112) + 8) = v66;
LABEL_106:
  v37 = *(_DWORD *)(v63 + 24);
  if ( v37 )
  {
    while ( v53 != 118
         || *(_DWORD *)v37 == 41
         || sub_10040510(
              a2,
              SHIDWORD(a2),
              *(_DWORD *)(v37 + 16) + **(_DWORD **)(HIDWORD(a2) + 112),
              *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 112) + 8) - *(_DWORD *)(v37 + 16) - **(_DWORD **)(HIDWORD(a2) + 112)) )
    {
      v38 = *(_DWORD *)(v37 + 28);
      v21 = sub_10042FB0(v21, a2, SHIDWORD(a2), *(_DWORD *)(v37 + 28));
      if ( !v21 )
        goto LABEL_142;
      v39 = *(_DWORD *)v37 == 41;
      v40 = *(_DWORD *)(v38 + 16);
      *(_DWORD *)(v37 + 16) = v40;
      if ( v39 )
        v58 = v40 - v54;
      v37 = *(_DWORD *)(v37 + 40);
      if ( !v37 )
      {
        v21 = v58;
        goto LABEL_115;
      }
    }
    return 0;
  }
LABEL_115:
  if ( v69 )
  {
    v41 = v54;
  }
  else
  {
    v41 = v54;
    v21 = *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 112) + 8) - **(_DWORD **)(HIDWORD(a2) + 112) - v54;
  }
  if ( v53 == 118 )
  {
    v42 = 0;
    v21 = sub_10040510(a2, SHIDWORD(a2), v70 + **(_DWORD **)(HIDWORD(a2) + 112), v41 + v21 - v70);
    if ( !v21 )
      goto LABEL_142;
  }
  else
  {
    v43 = v41 + **(_DWORD **)(HIDWORD(a2) + 112);
    v21 = sub_10040510(a2, SHIDWORD(a2), v43, v21);
    if ( !v21 )
      goto LABEL_142;
    v42 = v43 + 2;
  }
  v21 = sub_100413C0(
          a2,
          SHIDWORD(a2),
          v68,
          0,
          *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 112) + 8) - **(_DWORD **)(HIDWORD(a2) + 112) - v54);
  if ( v21 )
  {
    if ( v53 == 70 )
    {
      v44 = 0;
      for ( k = v42 + 4; v44 < v55; k += 2 )
      {
        v46 = *(_DWORD *)(v56 + 4 * v44);
        if ( v46 )
          v47 = *(_DWORD *)(v46 + 16) - v54;
        else
          v47 = 0;
        v21 = sub_10040510(a2, SHIDWORD(a2), k, v47);
        if ( !v21 )
          break;
        ++v44;
      }
    }
    else if ( v53 == 71 )
    {
      v48 = *(_DWORD *)(v63 + 24);
      for ( l = v42 + 2; v48; v48 = *(_DWORD *)(v48 + 40) )
      {
        if ( *(_DWORD *)v48 != 41 )
        {
          v50 = sub_10038A60(a2, *(_DWORD *)(v48 + 32), 0);
          if ( !v50 )
            goto LABEL_141;
          v51 = sub_10038C10(a2, v50, HIDWORD(a2) + 128);
          if ( !v51 )
            goto LABEL_141;
          *(_BYTE *)(l + 1) = *(_WORD *)(v51 + 12) >> 8;
          *(_BYTE *)(l + 2) = *(_BYTE *)(v51 + 12);
          v52 = l + 2;
          v21 = sub_10040510(a2, SHIDWORD(a2), v52, *(_DWORD *)(v48 + 16) - v54);
          if ( !v21 )
            break;
          l = v52 + 2;
        }
      }
    }
  }
LABEL_142:
  if ( v56 )
    sub_10010340(a2, v56);
  if ( !v21 || !sub_10040690(a2, SHIDWORD(a2)) )
    return 0;
  return 1;
}

//----- (10042F50) --------------------------------------------------------
signed int __usercall sub_10042F50@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>)
{
  unsigned int v3; // eax@1
  int v4; // ecx@1
  unsigned int v5; // esi@1

  v3 = *(_WORD *)(a1 + 6);
  v4 = *(_DWORD *)(a3 + 112);
  v5 = v3 - *(_DWORD *)(v4 + 28);
  if ( v3 != *(_DWORD *)(v4 + 28) )
  {
    *(_DWORD *)(v4 + 28) = v3;
    if ( v5 < 2 * (unsigned int)(v3 > 0x7F) + 2 )
    {
      while ( sub_10041100(a2, a3, 22) >= 0 )
      {
        if ( !--v5 )
          return 1;
      }
      return 0;
    }
    if ( sub_10042010(a2, a3, 23, v3) < 0 )
      return 0;
  }
  return 1;
}

//----- (10042FB0) --------------------------------------------------------
signed int __usercall sub_10042FB0@<eax>(char a1@<dil>, signed int a2, int a3, int a4)
{
  int v4; // ebx@1
  signed int result; // eax@2
  int v6; // ebp@3
  int v7; // esi@3
  int v8; // edi@3
  unsigned int v9; // eax@3
  int v10; // edx@3
  bool v11; // zf@3
  unsigned int v12; // ecx@3
  int v13; // eax@10
  int v14; // ecx@10
  int v15; // esi@10
  unsigned int v16; // ecx@10
  int v17; // eax@19
  int v18; // eax@23
  signed int v19; // eax@24
  int v20; // edi@24
  void (__cdecl *v21)(int, int, signed int); // eax@30
  int v22; // eax@32
  int v23; // ecx@33
  char v24; // dh@33
  int v25; // ST18_4@36
  signed int v26; // esi@36
  int v27; // edi@40
  int v28; // ST18_4@47
  signed int v29; // eax@52
  signed int v30; // esi@63
  int *v31; // eax@71
  int v32; // edi@77
  int v33; // esi@78
  int v34; // eax@88
  int v35; // ecx@88
  int v36; // ST18_4@93
  char v37; // si@106
  int v38; // esi@111
  int v39; // eax@111
  int v40; // edi@119
  int v41; // edx@121
  int *v42; // eax@122
  int v43; // esi@127
  signed int v44; // esi@131
  int v45; // edi@139
  int v46; // esi@139
  int i; // eax@140
  int v48; // ecx@144
  int v49; // ecx@145
  int v50; // edi@150
  signed int v51; // esi@150
  int j; // eax@151
  int v53; // ecx@157
  int v54; // edx@167
  int v55; // ST18_4@168
  signed int v56; // esi@171
  signed int v57; // esi@173
  int v58; // eax@174
  int v59; // ecx@174
  signed int v60; // edi@174
  int v61; // eax@185
  int v62; // edi@190
  int v63; // eax@190
  int v64; // eax@191
  int v65; // esi@195
  signed int v66; // esi@202
  signed int v67; // esi@204
  int v68; // eax@205
  signed int v69; // esi@217
  unsigned int v70; // eax@225
  int v71; // esi@227
  int v72; // eax@227
  int v73; // esi@234
  int v74; // esi@239
  int v75; // edi@239
  int v76; // edi@240
  int v77; // eax@243
  int v78; // eax@244
  int v79; // edi@252
  int v80; // eax@259
  int v81; // edi@262
  int v82; // edi@271
  int v83; // edi@277
  int v84; // edi@281
  int v85; // ecx@282
  int v86; // eax@282
  int v87; // esi@285
  int v88; // esi@294
  int v89; // eax@294
  _DWORD *v90; // edi@295
  int v91; // ST18_4@302
  int v92; // esi@302
  int v93; // edi@303
  int v94; // esi@310
  int v95; // eax@319
  int v96; // eax@323
  int v97; // eax@330
  signed int v98; // eax@331
  int v99; // eax@347
  int v100; // edx@347
  signed int v101; // esi@353
  int v102; // ST18_4@359
  int v103; // eax@360
  int v104; // edi@361
  signed int v105; // eax@365
  _BYTE *v106; // esi@370
  int v107; // eax@371
  int v108; // edi@371
  int v109; // eax@371
  int v110; // esi@374
  int v111; // esi@375
  int v112; // edi@375
  int v113; // eax@348
  int v114; // esi@387
  int v115; // edi@387
  int v116; // eax@389
  int v117; // ecx@389
  int v118; // edi@402
  int v119; // esi@420
  int v120; // esi@422
  signed int v121; // eax@25
  int v122; // eax@430
  int v123; // esi@434
  int v124; // eax@438
  int v125; // eax@440
  int v126; // eax@454
  int v127; // edi@458
  int v128; // edi@465
  int v129; // eax@465
  int v130; // eax@466
  int v131; // eax@468
  int v132; // esi@470
  int v133; // eax@471
  int v134; // eax@476
  int v135; // [sp-4h] [bp-80h]@50
  signed int v136; // [sp+4h] [bp-78h]@50
  char v137; // [sp+8h] [bp-74h]@3
  char v138; // [sp+14h] [bp-68h]@0
  __int64 v139; // [sp+18h] [bp-64h]@24
  int v140; // [sp+20h] [bp-5Ch]@36
  int v141; // [sp+24h] [bp-58h]@3
  int v142; // [sp+28h] [bp-54h]@3
  int v143; // [sp+2Ch] [bp-50h]@30
  int v144; // [sp+30h] [bp-4Ch]@16
  int v145; // [sp+34h] [bp-48h]@287
  int v146; // [sp+38h] [bp-44h]@1
  int v147; // [sp+3Ch] [bp-40h]@36
  int v148; // [sp+40h] [bp-3Ch]@85
  int v149; // [sp+44h] [bp-38h]@44
  int v150; // [sp+48h] [bp-34h]@85
  int v151; // [sp+4Ch] [bp-30h]@85
  int v152; // [sp+50h] [bp-2Ch]@85
  int v153; // [sp+54h] [bp-28h]@297
  char v154; // [sp+5Ch] [bp-20h]@198
  int v155; // [sp+74h] [bp-8h]@198

  v4 = a2;
  if ( (unsigned int)&v146 <= *(_DWORD *)(a2 + 12) )
  {
    sub_100110F0(a2, (int)sub_1003ED50, 0, 26, v138);
    return 0;
  }
  v6 = a3;
  ++*(_DWORD *)(v6 + 180);
  v141 = 1;
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
  v137 = a1;
  v8 = a4;
  v9 = *(_WORD *)(a4 + 6);
  *(_DWORD *)(a4 + 16) = v7;
  v10 = *(_DWORD *)(v6 + 112);
  v12 = v9 - *(_DWORD *)(v10 + 28);
  v11 = v9 == *(_DWORD *)(v10 + 28);
  v142 = v7;
  a2 = v12;
  if ( !v11 )
  {
    *(_DWORD *)(v10 + 28) = v9;
    if ( v12 < 2 * (unsigned int)(v9 > 0x7F) + 2 )
    {
      while ( sub_10041100(v4, v6, 22) >= 0 )
      {
        if ( !--a2 )
          goto LABEL_9;
      }
      return 0;
    }
    if ( sub_10042010(v4, v6, 23, v9) < 0 )
      return 0;
  }
LABEL_9:
  switch ( *(_DWORD *)v8 )
  {
    case 0x22:
      v13 = *(_DWORD *)(v4 + 76);
      v14 = *(_DWORD *)(v13 + 12);
      v15 = v14;
      a2 = *(_DWORD *)(v13 + 12);
      v16 = v14 + 200;
      if ( v16 <= *(_DWORD *)(v13 + 8) )
        *(_DWORD *)(v13 + 12) = v16;
      else
        v15 = sub_1003E2D0(v4 + 60, 0xC8u);
      if ( !v15 )
      {
        sub_10011170(v4);
        return 0;
      }
      if ( !sub_1003F880(
              v4,
              (void *)v15,
              *(_DWORD *)(v6 + 28),
              *(_DWORD *)(v6 + 32),
              *(_DWORD *)(v6 + 116),
              *(_WORD *)(v8 + 6),
              *(_DWORD *)(v6 + 124)) )
        return 0;
      *(_DWORD *)v15 = *(_DWORD *)(v8 + 32) | 2;
      *(_DWORD *)(v15 + 4) = *(_DWORD *)(v8 + 36);
      *(_DWORD *)(v15 + 196) = v6;
      v144 = sub_10010550(v4, *(_DWORD *)(*(_DWORD *)(v8 + 24) + 8) & 0xFFFFFFF8);
      if ( !sub_10041F50(v4, (_BYTE *)v15, *(_DWORD *)(v8 + 28), v144) )
        return 0;
      if ( *(_BYTE *)v15 & 0xC0 )
        *(_DWORD *)v6 |= 0x80u;
      sub_1003F940(v4, v15);
      v17 = *(_DWORD *)(v4 + 76);
      if ( v17 == v4 + 60 || a2 - *(_DWORD *)(v17 + 4) > (unsigned int)(*(_DWORD *)(v17 + 12) - *(_DWORD *)(v17 + 4)) )
        sub_1003E5E0(v4 + 60, a2);
      else
        *(_DWORD *)(v17 + 12) = (a2 + 3) & 0xFFFFFFFC;
      v18 = sub_10038C10(v4, *(_DWORD *)(v8 + 24), v6 + 128);
      if ( !v18 )
        return 0;
      v19 = *(_DWORD *)(v18 + 12);
      v20 = *(_DWORD *)(v8 + 12);
      LOWORD(v139) = v19;
      if ( v20 )
      {
        v121 = sub_1003FC00(v4, v6, v20, SBYTE1(v19), v19);
        goto LABEL_428;
      }
      if ( sub_10042010(v4, v6, 19, v19) < 0 || sub_1003FBB0(v4, v6, 0) < 0 )
        return 0;
      v11 = (*(_BYTE *)v6 & 2) == 0;
      *(_DWORD *)(v6 + 112) = v6 + 48;
      if ( !v11 )
      {
        if ( sub_10015D00(
               v4,
               *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v144 + 4) + 4) + 4) & 0xFFFFFFF8,
               *(_DWORD *)(v144 + 24),
               &v144,
               (unsigned int *)&a2) )
        {
          v143 = *(_WORD *)(a2 + 18);
          v21 = *(void (__cdecl **)(int, int, signed int))(*(_DWORD *)(*(_DWORD *)v144 + 4) + 52);
          if ( v21 )
            v21(v4, v144, a2);
          v22 = sub_1003FC60(v4, v6, -118, 4u);
          if ( v22 >= 0 )
          {
            v23 = v22 + **(_DWORD **)(v6 + 112);
            v24 = BYTE1(v143);
            *(_BYTE *)(v23 + 2) = v143;
            *(_BYTE *)(v23 + 1) = v24;
            *(_BYTE *)(v23 + 4) = v139;
            *(_BYTE *)(v23 + 3) = BYTE1(v139);
            *(_DWORD *)(v6 + 112) = v6 + 80;
            goto LABEL_54;
          }
        }
        return 0;
      }
      if ( sub_1003FC00(v4, v6, 125, SBYTE1(v139), v139) < 0 )
        return 0;
      *(_DWORD *)(v6 + 112) = v6 + 80;
      goto LABEL_54;
    case 0x25:
      v147 = 2;
      v25 = *(_DWORD *)(v8 + 24);
      v26 = -1;
      v140 = -1;
      a2 = -1;
      if ( !sub_10042FB0(v8, v4, v6, v25) )
        return 0;
      while ( 2 )
      {
        if ( v147 == 2 )
        {
          sub_100405E0(v6, (int)&v147, 2, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112));
        }
        else
        {
          v147 = 2;
          if ( !sub_100413C0(v4, v6, a2, 0, v26 - v140) )
            return 0;
        }
        v27 = *(_DWORD *)(a4 + 32);
        a2 = sub_10041100(v4, v6, (v27 != 0) + 1);
        if ( a2 < 0 )
          return 0;
        v140 = sub_10040440(v6, 0, v4, 7);
        if ( v140 < 0 || !sub_10042FB0(v27, v4, v6, *(_DWORD *)(a4 + 28)) )
          return 0;
        if ( !v27 )
        {
          if ( !sub_10040510(
                  v4,
                  v6,
                  v140 + **(_DWORD **)(v6 + 112),
                  *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v140) )
            return 0;
          goto LABEL_52;
        }
        v147 = 3;
        v26 = sub_10041EC0(0, v4, v6, &v149, 0);
        if ( v26 < 0
          || !sub_10040510(
                v4,
                v6,
                v140 + **(_DWORD **)(v6 + 112),
                *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v140) )
        {
          return 0;
        }
        if ( *(_DWORD *)v27 == 37 )
        {
          v28 = *(_DWORD *)(v27 + 24);
          a4 = v27;
          result = sub_10042FB0(v27, v4, v6, v28);
          if ( !result )
            return result;
          continue;
        }
        break;
      }
      if ( !sub_10042FB0(v27, v4, v6, v27) )
        return 0;
      v136 = v26 - v140;
      v135 = a2;
LABEL_66:
      result = sub_100413C0(v4, v6, v135, 0, v136);
      if ( result )
        goto LABEL_52;
      return result;
    default:
      goto LABEL_54;
    case 0x27:
      v29 = sub_10042620(v8, __PAIR__(v6, v4), (int)&v147);
      goto LABEL_53;
    case 0x2A:
      sub_100405E0(v6, (int)&v147, 13, v7);
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      a2 = sub_10041100(v4, v6, 3);
      if ( a2 < 0 )
        return 0;
      v140 = sub_10040440(v6, 0, v4, 7);
      if ( v140 < 0 )
        return 0;
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 28)) )
        return 0;
      v30 = sub_10040440(v6, v142 + **(_DWORD **)(v6 + 112) - *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8), v4, 6);
      if ( v30 < 0
        || !sub_10040510(
              v4,
              v6,
              v140 + **(_DWORD **)(v6 + 112),
              *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v140) )
      {
        return 0;
      }
      v136 = v30 - v140;
      v135 = a2;
      goto LABEL_66;
    case 0x2B:
      if ( sub_10041100(v4, v6, 3) < 0 )
        return 0;
      if ( sub_1003FBB0(v4, v6, 0) < 0 )
        return 0;
      v142 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
      sub_100405E0(v6, (int)&v147, 10, v142);
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      v31 = &v147;
      do
      {
        v31[1] = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
        v31 = (int *)v31[7];
      }
      while ( v31 && *v31 == 1 );
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 28)) )
        return 0;
      if ( sub_10040440(v6, v142 + **(_DWORD **)(v6 + 112) - *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8), v4, 8) >= 0 )
        goto LABEL_52;
      return 0;
    case 0x2C:
      v32 = *(_DWORD *)(v8 + 24);
      v140 = 0;
      LODWORD(v139) = v32;
      sub_100405E0(v6, (int)&v147, 11, v7);
      if ( *(_DWORD *)v32 == 47 )
      {
        v147 = 12;
        v33 = *(_DWORD *)(v32 + 24);
        v11 = *(_DWORD *)v33 == 48;
        a2 = -1;
        HIDWORD(v139) = v33;
        if ( v11 && *(_DWORD *)(*(_DWORD *)(v33 + 24) + 28) )
        {
          if ( !sub_10042FB0(v32, v4, v6, v33) )
            return 0;
          v33 = *(_DWORD *)(v33 + 24);
          HIDWORD(v139) = v33;
        }
        if ( sub_1003FBB0(v4, v6, 1) >= 0
          && sub_10042FB0(v32, v4, v6, *(_DWORD *)(v32 + 28))
          && sub_1003FBB0(v4, v6, 103) >= 0 )
        {
          v142 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
          v148 = v142;
          v151 = -1;
          v152 = -1;
          v150 = -1;
          v149 = -1;
          switch ( *(_DWORD *)v33 )
          {
            case 0x30:
              HIDWORD(v139) = *(_DWORD *)(HIDWORD(v139) + 24);
              if ( sub_10041100(v4, v6, 6) < 0 )
                return 0;
              goto LABEL_87;
            case 0x1D:
LABEL_87:
              v32 = HIDWORD(v139);
              *(_DWORD *)(HIDWORD(v139) + 12) = 104;
              if ( !sub_100409A0(v32, v4, (_BYTE *)v6) )
                return 0;
              v34 = *(_DWORD *)(v32 + 32);
              v35 = *(_DWORD *)(v32 + 12);
              if ( v34 < 0 )
              {
                v36 = *(_DWORD *)(v32 + 12);
                LOBYTE(v32) = v4;
                result = sub_10040960(SHIDWORD(v139), v4, v6, v36);
                if ( !result )
                  return result;
              }
              else
              {
                if ( *(_BYTE *)(v32 + 36) & 2 )
                  LOBYTE(v35) = 86;
                if ( sub_1003FC00(v4, v6, v35, SBYTE1(v34), *(_DWORD *)(v32 + 32)) < 0 )
                  return 0;
              }
LABEL_101:
              if ( *(_DWORD *)HIDWORD(v139) == 23 )
                goto LABEL_118;
              a2 = sub_10041100(v4, v6, 3);
              if ( a2 < 0 )
                return 0;
              v140 = sub_10040440(v6, 0, v4, 7);
              if ( v140 >= 0 )
                goto LABEL_118;
              result = 0;
              break;
            case 0x16:
              result = sub_100421D0(v4, SHIDWORD(v139), 105, v6);
              if ( !result )
                return result;
              goto LABEL_101;
            case 0x17:
              if ( !sub_1003FBB0(v4, v6, 106) )
                return 0;
              a2 = sub_10041100(v4, v6, 3);
              if ( a2 < 0 )
                return 0;
              v140 = sub_10040440(v6, 0, v4, 7);
              if ( v140 < 0 || !sub_100423C0(v4, v6, SHIDWORD(v139), 122) )
                return 0;
              goto LABEL_101;
            default:
              goto LABEL_101;
          }
          return result;
        }
        return 0;
      }
      if ( *(_DWORD *)(v32 + 24) )
      {
        if ( !sub_10042FB0(v32, v4, v6, *(_DWORD *)(v32 + 24)) )
          return 0;
        v37 = 81;
      }
      else
      {
        v37 = 0;
      }
      a2 = sub_10041100(v4, v6, 4);
      if ( a2 < 0 || sub_1003FBB0(v4, v6, v37) < 0 )
        return 0;
      v38 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
      v148 = v38;
      v151 = -1;
      v152 = -1;
      v150 = -1;
      v149 = -1;
      v39 = *(_DWORD *)(v32 + 28);
      v142 = v38;
      if ( v39 )
      {
        if ( !sub_10042FB0(v32, v4, v6, v39) )
          return 0;
        if ( !sub_100413C0(v4, v6, a2, 0, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v38) )
          return 0;
        v140 = sub_10040440(v6, 0, v4, 7);
        if ( v140 < 0 )
          return 0;
      }
      else
      {
        result = sub_100413C0(v4, v6, a2, 0, 0);
        if ( !result )
          return result;
      }
      HIDWORD(v139) = *(_DWORD *)(v32 + 32);
LABEL_118:
      if ( !sub_10042FB0(v32, v4, v6, *(_DWORD *)(a4 + 28)) )
        return 0;
      v40 = v142;
      if ( *(_DWORD *)v139 != 47 )
      {
        if ( !sub_100413C0(v4, v6, a2, 1, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v142) )
          return 0;
        v41 = HIDWORD(v139);
        if ( HIDWORD(v139) )
        {
          v42 = &v147;
          do
          {
            v42[1] = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
            v42 = (int *)v42[7];
          }
          while ( v42 && *v42 == 1 );
          if ( !sub_10042FB0(v40, v4, v6, v41) || sub_1003FBB0(v4, v6, 81) < 0 )
            return 0;
          v43 = *(_WORD *)(a4 + 10);
          if ( *(_DWORD *)(*(_DWORD *)(v6 + 112) + 28) != v43 )
          {
            if ( sub_10042010(v4, v6, 23, *(_WORD *)(a4 + 10)) < 0 )
              return 0;
            *(_DWORD *)(*(_DWORD *)(v6 + 112) + 28) = v43;
          }
        }
        if ( !sub_100413C0(v4, v6, a2, 2, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v40) )
          return 0;
      }
      v44 = sub_10040440(v6, v40 + **(_DWORD **)(v6 + 112) - *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8), v4, 6);
      if ( v44 < 0
        || v140 > 0
        && !sub_10040510(
              v4,
              v6,
              v140 + **(_DWORD **)(v6 + 112),
              *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v140)
        || *(_DWORD *)v139 == 47 && !sub_100413C0(v4, v6, a2, 0, v44 - v140)
        || !sub_10040690(v4, v6) )
      {
        return 0;
      }
      if ( *(_DWORD *)v139 != 47 )
        goto LABEL_54;
      v121 = sub_1003FBB0(v4, v6, 107);
      goto LABEL_428;
    case 0x2D:
      v45 = *(_DWORD *)(v8 + 24);
      v46 = *(_DWORD *)(v6 + 8);
      if ( v45 )
      {
        i = sub_10038C10(v4, v45, v6 + 128);
        if ( !i )
          return 0;
        while ( *(_DWORD *)v46 != 1 || *(_DWORD *)(v46 + 24) != v45 )
          v46 = *(_DWORD *)(v46 + 28);
        v48 = 16;
      }
      else
      {
        v49 = *(_DWORD *)v46;
        for ( i = 0; *(_DWORD *)v46 < 10; v49 = *(_DWORD *)v46 )
        {
          if ( v49 == 4 )
            break;
          v46 = *(_DWORD *)(v46 + 28);
        }
        v48 = 0;
      }
      v121 = sub_10041EC0(v48, v4, v6, (_DWORD *)(v46 + 8), i);
      goto LABEL_428;
    case 0x2E:
      v50 = *(_DWORD *)(v8 + 24);
      v51 = *(_DWORD *)(v6 + 8);
      if ( v50 )
      {
        a2 = 0;
        j = sub_10038C10(v4, v50, v6 + 128);
        if ( !j )
          return 0;
        while ( *(_DWORD *)v51 != 1 || *(_DWORD *)(v51 + 24) != v50 )
        {
          if ( *(_DWORD *)v51 >= 10 )
            a2 = v51;
          v51 = *(_DWORD *)(v51 + 28);
        }
        v51 = a2;
        v53 = 17;
      }
      else
      {
        for ( j = 0; *(_DWORD *)v51 < 10; v51 = *(_DWORD *)(v51 + 28) )
          ;
        v53 = 5;
      }
      v121 = sub_10041EC0(v53, v4, v6, (_DWORD *)(v51 + 12), j);
      goto LABEL_428;
    case 0x31:
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      sub_100405E0(v6, (int)&v147, 5, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112));
      if ( sub_1003FBB0(v4, v6, 3) < 0 || !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 28)) )
        return 0;
      if ( sub_1003FBB0(v4, v6, 4) >= 0 )
        goto LABEL_52;
      return 0;
    case 0x37:
      v54 = *(_DWORD *)(v8 + 32);
      v142 = -1;
      v143 = -1;
      HIDWORD(v139) = -1;
      sub_100405E0(v6, (int)&v147, v54 != 0 ? 8 : 0, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112));
      v140 = *(_DWORD *)(v6 + 140);
      if ( sub_1003FBB0(v4, v6, -123) < 0 )
        return 0;
      v55 = *(_DWORD *)(v8 + 24);
      v144 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
      if ( !sub_10042FB0(v8, v4, v6, v55) )
        return 0;
      if ( *(_DWORD *)(v8 + 32) )
      {
        if ( sub_10041100(v4, v6, 11) < 0 )
          return 0;
        v56 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v151;
        v151 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
        if ( sub_10040440(v6, v56, v4, -105) < 0 )
          return 0;
      }
      if ( sub_10041100(v4, v6, 11) < 0 )
        return 0;
      v57 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v152;
      v152 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
      if ( sub_10040440(v6, v57, v4, -107) < 0 )
        return 0;
      v58 = *(_DWORD *)(v6 + 112);
      v59 = *(_DWORD *)(v58 + 8) - *(_DWORD *)v58;
      v60 = *(_DWORD *)(v8 + 28);
      LODWORD(v139) = *(_DWORD *)(v58 + 8) - *(_DWORD *)v58;
      a2 = v60;
      if ( !v60 )
        goto LABEL_209;
      HIDWORD(v139) = v59;
      if ( !sub_10042F50(v60, v4, v6) )
        return 0;
      while ( 2 )
      {
        if ( v142 == -1 )
        {
          if ( sub_1003FC00(v4, v6, 117, SBYTE1(v140), v140) < 0 )
            return 0;
          *(_DWORD *)(v6 + 140) = v140;
        }
        else
        {
          if ( !sub_10040510(
                  v4,
                  v6,
                  v142 + **(_DWORD **)(v6 + 112),
                  *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v142) )
            return 0;
          ++*(_DWORD *)(v6 + 140);
          if ( sub_10041100(v4, v6, 11) < 0 || sub_1003FBB0(v4, v6, 4) < 0 )
            return 0;
        }
        v146 = sub_10042010(v4, v6, 20, 0);
        if ( v146 < 0 )
          return 0;
        if ( sub_1003FBB0(v4, v6, 0) < 0 )
          return 0;
        v61 = sub_10038C10(v4, *(_DWORD *)(*(_DWORD *)(v4 + 24) + 196), v6 + 128);
        if ( !v61 )
          return 0;
        if ( sub_1003FC00(v4, v6, 59, *(_WORD *)(v61 + 12) >> 8, *(_BYTE *)(v61 + 12)) < 0 )
          return 0;
        if ( sub_1003FBB0(v4, v6, 57) < 0 )
          return 0;
        if ( sub_1003FBB0(v4, v6, 89) < 0 )
          return 0;
        if ( sub_1003FBB0(v4, v6, 116) < 0 )
          return 0;
        v62 = *(_DWORD *)(a2 + 24);
        v63 = sub_10038C10(v4, *(_DWORD *)(v62 + 24), v6 + 128);
        if ( !v63 )
          return 0;
        v64 = *(_DWORD *)(v63 + 12);
        if ( sub_1003FC00(v4, v6, -126, SBYTE1(v64), v64) < 0 )
          return 0;
        if ( sub_10041100(v4, v6, 11) < 0 )
          return 0;
        if ( sub_1003FBB0(v4, v6, 3) < 0 )
          return 0;
        if ( *(_DWORD *)(v62 + 28) )
        {
          v65 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
          if ( !sub_10042FB0(v62, v4, v6, *(_DWORD *)(v62 + 28)) )
            return 0;
          if ( !sub_100413C0(v4, v6, v146, 0, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - v65 - **(_DWORD **)(v6 + 112)) )
            return 0;
          v142 = sub_10040440(v6, 0, v4, 7);
          if ( v142 < 0 )
            return 0;
        }
        sub_100405E0(v6, (int)&v154, 7, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112));
        v155 = *(_DWORD *)(v62 + 24);
        if ( !sub_10042FB0(v62, v4, v6, *(_DWORD *)(a2 + 32)) )
          return 0;
        sub_10040690(v4, v6);
        if ( sub_10041100(v4, v6, 11) < 0 )
          return 0;
        if ( sub_1003FBB0(v4, v6, 4) < 0 )
          return 0;
        if ( *(_DWORD *)(a4 + 32) )
        {
          v66 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v151;
          v151 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
          if ( sub_10040440(v6, v66, v4, -105) < 0 )
            return 0;
        }
        if ( sub_10041100(v4, v6, 11) < 0 )
          return 0;
        v67 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v152;
        v152 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
        if ( sub_10040440(v6, v67, v4, -107) < 0 )
          return 0;
        v68 = *(_DWORD *)(a2 + 28);
        if ( v68 )
        {
          a2 = *(_DWORD *)(a2 + 28);
          result = sub_10042F50(v68, v4, v6);
          if ( !result )
            return result;
          continue;
        }
        break;
      }
      v60 = a2;
LABEL_209:
      if ( *(_DWORD *)(a4 + 32) )
        goto LABEL_504;
      if ( v142 != -1 && *(_DWORD *)(*(_DWORD *)(v60 + 24) + 28) )
      {
LABEL_504:
        v143 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
        if ( sub_1003FC00(v4, v6, 117, SBYTE1(v140), v140) < 0 )
          return 0;
        v11 = v142 == -1;
        *(_DWORD *)(v6 + 140) = v140;
        if ( !v11
          && *(_DWORD *)(*(_DWORD *)(v60 + 24) + 28)
          && !sub_10040510(
                v4,
                v6,
                v142 + **(_DWORD **)(v6 + 112),
                *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v142) )
        {
          return 0;
        }
        if ( *(_DWORD *)(a4 + 32) )
        {
          v69 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v151;
          v151 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
          if ( sub_10040440(v6, v69, v4, -105) < 0 )
            return 0;
          *(_DWORD *)(v6 + 140) = v140;
        }
        if ( sub_10041100(v4, v6, 11) < 0
          || sub_1003FBB0(v4, v6, 116) < 0
          || sub_10041100(v4, v6, 11) < 0
          || sub_1003FBB0(v4, v6, 110) < 0 )
        {
          return 0;
        }
      }
      if ( *(_DWORD *)(a4 + 32) )
      {
        if ( !sub_10040620(v151, v6, v4, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8), 114) )
          return 0;
        v70 = ++*(_DWORD *)(v6 + 140);
        if ( v70 > *(_DWORD *)(v6 + 144) )
          *(_DWORD *)(v6 + 144) = v70;
        v71 = a4;
        v72 = *(_DWORD *)(a4 + 32);
        v147 = 9;
        if ( !sub_10042F50(v72, v4, v6)
          || sub_1003FBB0(v4, v6, -122) < 0
          || !sub_10042FB0(v6, v4, v6, *(_DWORD *)(v71 + 32))
          || sub_1003FBB0(v4, v6, 115) < 0 )
        {
          return 0;
        }
      }
      sub_10040690(v4, v6);
      if ( sub_10041100(v4, v6, 15) < 0 )
        return 0;
      if ( sub_1003FBB0(v4, v6, 0) < 0 )
        return 0;
      if ( !sub_10040620(v152, v6, v4, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8), 6) )
        return 0;
      v73 = a4;
      if ( *(_DWORD *)(a4 + 28) )
      {
        if ( !sub_100415D0(v4, v6, v144, v139, SHIDWORD(v139)) )
          return 0;
      }
      if ( !*(_DWORD *)(v73 + 32) )
        goto LABEL_54;
      result = sub_100415D0(v4, v6, v144, v143, v143);
      if ( result )
        goto LABEL_54;
      return result;
    case 0x30:
      v74 = *(_DWORD *)(v8 + 24);
      v75 = *(_DWORD *)(v8 + 24);
      a2 = -1;
      v140 = -1;
      if ( !sub_100409A0(v75, v4, (_BYTE *)v6) )
        return 0;
      while ( 2 )
      {
        LOWORD(v76) = v139;
        HIDWORD(v139) = *(_DWORD *)(v74 + 12);
        if ( HIDWORD(v139) == 9 )
          goto LABEL_256;
        v76 = *(_DWORD *)(v74 + 32);
        if ( v76 < 0 )
        {
          v77 = sub_10038C10(v4, *(_DWORD *)(v74 + 24), v6 + 128);
          if ( !v77 )
            return 0;
          v76 = *(_DWORD *)(v77 + 12);
          v78 = *(_DWORD *)v6;
          LOWORD(v139) = v76;
          if ( !(*(_DWORD *)v6 & 2) || (char)v78 < 0 )
          {
            *(_DWORD *)(v6 + 112) = v6 + 48;
            if ( !sub_10042F50(v74, v4, v6) || sub_1003FC00(v4, v6, *(_DWORD *)(a4 + 12), SBYTE1(v76), v76) < 0 )
              return 0;
            *(_DWORD *)(v6 + 112) = v6 + 80;
          }
        }
        else
        {
          LODWORD(v139) = *(_DWORD *)(v74 + 32);
        }
        if ( !*(_DWORD *)(v74 + 28) )
          goto LABEL_256;
        if ( HIDWORD(v139) == 109 && sub_1003FC00(v4, v6, 108, SBYTE1(v76), v76) < 0 )
          return 0;
        v79 = *(_DWORD *)(v74 + 28);
        if ( *(_DWORD *)(a4 + 12) == 126 && !sub_100406F0(v4, v6, *(_DWORD *)(v74 + 24), *(_DWORD *)(v74 + 28)) )
          return 0;
        if ( !sub_10042FB0(v79, v4, v6, v79) )
          return 0;
        LOWORD(v76) = v139;
LABEL_256:
        if ( v74 == *(_DWORD *)(a4 + 24) && sub_10041100(v4, v6, *(_DWORD *)(a4 + 12) != 126 ? 6 : 21) < 0 )
          return 0;
        v80 = HIDWORD(v139) == 9 ? sub_1003FBB0(v4, v6, 9) : sub_1003FC00(v4, v6, SBYTE4(v139), SBYTE1(v76), v76);
        if ( v80 < 0 )
          return 0;
        v81 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
        if ( a2 >= 0 && !sub_100413C0(v4, v6, a2, 0, v81 - v140) )
          return 0;
        if ( *(_DWORD *)(v74 + 40) )
        {
          v140 = v81;
          a2 = sub_10042010(v4, v6, 7, 0);
          if ( a2 >= 0 && sub_1003FBB0(v4, v6, 81) >= 0 )
          {
            v74 = *(_DWORD *)(v74 + 40);
            result = sub_100409A0(v74, v4, (_BYTE *)v6);
            if ( !result )
              return result;
            continue;
          }
          return 0;
        }
        break;
      }
      if ( !*(_DWORD *)(a4 + 36) )
        goto LABEL_54;
      v121 = sub_1003FBB0(v4, v6, 81);
      goto LABEL_428;
    case 0x32:
      v82 = *(_DWORD *)(v8 + 24);
      if ( v82 )
      {
        result = sub_10042FB0(v82, v4, v6, v82);
        if ( !result )
          return result;
      }
      else if ( sub_1003FBB0(v4, v6, 1) < 0 )
      {
        return 0;
      }
      HIDWORD(v139) = 5;
      if ( !sub_10041D80((_DWORD *)&v139 + 1, v6, v4, 0) )
        return 0;
      v121 = sub_1003FBB0(v4, v6, SBYTE4(v139));
      goto LABEL_428;
    case 0x19:
      sub_100405E0(v6, (int)&v147, 0, v7);
      v83 = *(_DWORD *)(v8 + 24);
      if ( !v83 )
        goto LABEL_52;
      while ( sub_10042FB0(v83, v4, v6, v83) )
      {
        v83 = *(_DWORD *)(v83 + 40);
        if ( !v83 )
        {
LABEL_52:
          v29 = sub_10040690(v4, v6);
LABEL_53:
          v141 = v29;
          if ( !v29 )
            goto LABEL_57;
          goto LABEL_54;
        }
      }
      return 0;
    case 2:
      v84 = *(_DWORD *)(v8 + 24);
      if ( !v84 )
        goto LABEL_54;
      v85 = *(_DWORD *)(v4 + 56);
      v86 = *(_DWORD *)(v85 + 16);
      v87 = !v86 || *(_DWORD *)(v86 + 8) || *(_BYTE *)(v85 + 76) & 0x30;
      v145 = v87;
      if ( v87 )
        goto LABEL_292;
      if ( !sub_10040C90(v4, (_BYTE *)v6, v84, &v145) )
        return 0;
      if ( !v145 )
      {
        *(_DWORD *)(*(_DWORD *)(v6 + 112) + 28) = *(_WORD *)(v84 + 6);
        result = sub_10045A60(v4, 0, v6, 5, 163, v137);
        if ( result )
          goto LABEL_54;
        return result;
      }
LABEL_292:
      if ( !sub_10042FB0(v84, v4, v6, v84) )
        return 0;
      v121 = sub_1003FBB0(v4, v6, v87 != 0 ? 2 : 81);
      goto LABEL_428;
    case 6:
      v88 = *(_DWORD *)(v8 + 24);
      v89 = sub_10038C10(v4, *(_DWORD *)(v8 + 24), v6 + 128);
      if ( !v89 )
        return 0;
      v90 = *(_DWORD **)(v8 + 28);
      if ( sub_10042010(v4, v6, (*v90 == 25) + 13, *(_DWORD *)(v89 + 12)) < 0 )
        return 0;
      if ( sub_1003FBB0(v4, v6, 0) < 0 )
        return 0;
      sub_100405E0(v6, (int)&v147, 1, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112));
      v153 = v88;
      if ( !sub_10042FB0((char)v90, v4, v6, (int)v90) || !sub_10040690(v4, v6) )
        return 0;
      if ( *v90 != 25 )
        goto LABEL_54;
      if ( sub_10041100(v4, v6, 15) < 0 )
        return 0;
      v121 = sub_1003FBB0(v4, v6, 0);
      goto LABEL_428;
    case 3:
      v91 = *(_DWORD *)(v8 + 24);
      v92 = -1;
      v140 = -1;
      LODWORD(v139) = v91;
      if ( !sub_10042FB0(v91, v4, v6, v91) )
        return 0;
      while ( 1 )
      {
        v93 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
        if ( v92 >= 0 && !sub_100413C0(v4, v6, v92, 0, v93 - v140) )
          return 0;
        if ( !*(_DWORD *)(v139 + 40) )
          goto LABEL_54;
        v140 = v93;
        v92 = sub_10042010(v4, v6, 7, 0);
        if ( v92 < 0 || sub_1003FBB0(v4, v6, 81) < 0 )
          return 0;
        LODWORD(v139) = *(_DWORD *)(v139 + 40);
        result = sub_10042FB0(v93, v4, v6, v139);
        if ( !result )
          return result;
      }
    case 4:
      v94 = *(_DWORD *)(v8 + 24);
      LOWORD(v139) = -1;
      switch ( *(_DWORD *)v94 )
      {
        case 0x1D:
          if ( !sub_100409A0(v94, v4, (_BYTE *)v6) )
            return 0;
          if ( *(_DWORD *)(v94 + 32) >= 0 )
          {
            LODWORD(v139) = *(_DWORD *)(v94 + 32);
LABEL_314:
            v8 = a4;
            goto LABEL_315;
          }
          v95 = sub_10038C10(v4, *(_DWORD *)(v94 + 24), v6 + 128);
          if ( !v95 )
            return 0;
          LODWORD(v139) = *(_DWORD *)(v95 + 12);
          if ( sub_1003FC00(v4, v6, 108, SBYTE1(v139), v139) >= 0 )
            goto LABEL_314;
          result = 0;
          break;
        default:
          goto LABEL_315;
        case 0x16:
          if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v94 + 28)) )
            return 0;
          v96 = sub_10038C10(v4, *(_DWORD *)(v94 + 24), v6 + 128);
          if ( !v96 )
            return 0;
          LODWORD(v139) = *(_DWORD *)(v96 + 12);
          goto LABEL_315;
        case 0x17:
          if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v94 + 24)) )
            return 0;
          result = sub_10042FB0(v8, v4, v6, *(_DWORD *)(v94 + 28));
          goto LABEL_328;
        case 0x1B:
          result = sub_10042FB0(v8, v4, v6, v94);
LABEL_328:
          if ( !result )
            return result;
LABEL_315:
          HIDWORD(v139) = *(_DWORD *)(v8 + 12);
          if ( HIDWORD(v139) != 123 && HIDWORD(v139) != 124 && HIDWORD(v139) )
          {
            switch ( *(_DWORD *)v94 )
            {
              case 0x1D:
                v97 = *(_DWORD *)(v94 + 12);
                if ( v97 == 109 )
                  goto LABEL_332;
                v98 = sub_1003FC00(v4, v6, 2 * (v97 != 85) + 84, SBYTE1(v139), v139);
                goto LABEL_334;
              case 0x16:
LABEL_332:
                if ( sub_1003FBB0(v4, v6, 12) < 0 )
                  return 0;
                v98 = sub_1003FC00(v4, v6, 53, SBYTE1(v139), v139);
LABEL_334:
                if ( v98 >= 0 )
                  break;
                return 0;
              case 0x17:
              case 0x1B:
                if ( sub_1003FBB0(v4, v6, 13) >= 0 && sub_1003FBB0(v4, v6, 55) >= 0 )
                  break;
                return 0;
              default:
                break;
            }
          }
          if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 28))
            || HIDWORD(v139) && (sub_10041100(v4, v6, 8) < 0 || sub_1003FBB0(v4, v6, SBYTE4(v139)) < 0)
            || *(_DWORD *)v94 != 29
            && sub_10042010(v4, v6, 12, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v142) < 0 )
          {
            return 0;
          }
          switch ( *(_DWORD *)v94 )
          {
            default:
              goto LABEL_54;
            case 0x1D:
              if ( *(_DWORD *)(v94 + 32) < 0 || !(*(_BYTE *)(v94 + 36) & 2) )
                goto LABEL_347;
              goto LABEL_54;
            case 0x16:
LABEL_347:
              LOWORD(v99) = v139;
              v100 = *(_DWORD *)(v94 + 12);
              goto LABEL_427;
            case 0x17:
            case 0x1B:
              v113 = sub_1003FBB0(v4, v6, 56);
              break;
          }
          goto LABEL_385;
      }
      break;
    case 5:
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      a2 = sub_10041100(v4, v6, 9);
      if ( a2 < 0 )
        return 0;
      v140 = sub_10040440(v6, 0, v4, 7);
      if ( v140 < 0 )
        return 0;
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 28)) )
        return 0;
      v101 = sub_10040440(v6, 0, v4, 6);
      if ( v101 < 0
        || !sub_10040510(
              v4,
              v6,
              v140 + **(_DWORD **)(v6 + 112),
              *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v140)
        || !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 32))
        || !sub_10040510(
              v4,
              v6,
              v101 + **(_DWORD **)(v6 + 112),
              *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v101)
        || !sub_100413C0(v4, v6, a2, 0, v101 - v140) )
      {
        return 0;
      }
      --*(_DWORD *)(v6 + 140);
      goto LABEL_54;
    case 7:
    case 8:
      v102 = *(_DWORD *)(v8 + 24);
      HIDWORD(v139) = v8;
      if ( !sub_10042FB0(v8, v4, v6, v102) )
        return 0;
      v103 = sub_10040440(v6, 0, v4, -106);
      v142 = v103;
      if ( v103 < 0 )
        return 0;
      v104 = *(_DWORD *)(v8 + 28);
      while ( 2 )
      {
        a2 = v103;
        LODWORD(v139) = v104;
        if ( *(_DWORD *)v104 == 7 || *(_DWORD *)v104 == 8 )
        {
          if ( sub_10042FB0(v104, v4, v6, *(_DWORD *)(v104 + 24)) )
          {
            v105 = sub_10040440(v6, 0, v4, -106);
            v140 = v105;
            if ( v105 >= 0 )
            {
              if ( sub_100402E0(v105 - a2, v4, a2 + **(_DWORD **)(v6 + 112), v6) )
              {
                v103 = v140;
                v104 = *(_DWORD *)(v104 + 28);
                continue;
              }
            }
          }
          return 0;
        }
        break;
      }
      if ( !sub_10042FB0(v104, v4, v6, v104) )
        return 0;
      v140 = *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112);
      do
      {
        v106 = (_BYTE *)(v142 + **(_DWORD **)(v6 + 112));
        a2 = sub_100404C0(v142 + **(_DWORD **)(v6 + 112), v6);
        if ( !sub_10040510(v4, v6, (int)v106, v140 - v142) )
          return 0;
        v107 = HIDWORD(v139);
        v108 = a2 + v142;
        *v106 = *(_BYTE *)(HIDWORD(v139) + 12);
        v109 = *(_DWORD *)(v107 + 28);
        v142 = v108;
        HIDWORD(v139) = v109;
      }
      while ( v109 != (_DWORD)v139 );
      goto LABEL_54;
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x2F:
    case 0x3B:
      if ( *(_DWORD *)(v8 + 20) != -2 )
      {
        if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) || !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 28)) )
          return 0;
        v113 = sub_1003FBB0(v4, v6, *(_DWORD *)(v8 + 12));
LABEL_385:
        if ( v113 < 0 )
          return 0;
        goto LABEL_54;
      }
      v110 = *(_DWORD *)(v8 + 24);
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      v111 = *(_DWORD *)(v110 + 40);
      v112 = *(_DWORD *)(v8 + 12);
      if ( !v111 )
        goto LABEL_54;
      while ( sub_10042FB0(v112, v4, v6, v111) && sub_1003FBB0(v4, v6, v112) >= 0 )
      {
        v111 = *(_DWORD *)(v111 + 40);
        if ( !v111 )
          goto LABEL_54;
      }
      return 0;
    case 0x13:
    case 0x3A:
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      v113 = sub_1003FBB0(v4, v6, *(_DWORD *)(v8 + 12));
      goto LABEL_385;
    case 0x14:
    case 0x15:
      v114 = *(_DWORD *)(v8 + 24);
      v115 = *(_DWORD *)(v8 + 12);
      switch ( *(_DWORD *)v114 )
      {
        default:
          goto LABEL_54;
        case 0x1D:
          *(_DWORD *)(v114 + 12) = v115;
          if ( !sub_100409A0(v114, v4, (_BYTE *)v6) )
            return 0;
          v116 = *(_DWORD *)(v114 + 32);
          v117 = *(_DWORD *)(v114 + 12);
          if ( v116 < 0 )
          {
            result = sub_10040960(v114, v4, v6, *(_DWORD *)(v114 + 12));
            goto LABEL_416;
          }
          if ( *(_BYTE *)(v114 + 36) & 2 )
            LOBYTE(v117) = 86;
          break;
        case 0x16:
          result = sub_100421D0(v4, v114, v115, v6);
          goto LABEL_416;
        case 0x17:
          result = sub_100423C0(v4, v6, v114, v115);
          if ( !result )
            return result;
          goto LABEL_54;
        case 0x1B:
          if ( !sub_10042FB0(v115, v4, v6, v114)
            || sub_10042010(
                 v4,
                 v6,
                 12,
                 *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - *(_DWORD *)(v114 + 16) - **(_DWORD **)(v6 + 112)) < 0 )
          {
            return 0;
          }
          if ( sub_1003FBB0(v4, v6, v115) >= 0 )
            goto LABEL_54;
          return 0;
      }
      goto LABEL_392;
    case 0x34:
      v118 = *(_DWORD *)(v8 + 24);
      switch ( *(_DWORD *)v118 )
      {
        case 0x16:
          result = sub_100421D0(v4, v118, 37, v6);
LABEL_416:
          if ( result )
            goto LABEL_54;
          break;
        case 0x17:
          result = sub_100423C0(v4, v6, v118, 38);
          if ( result )
            goto LABEL_54;
          break;
        case 0x1D:
          *(_DWORD *)(v118 + 12) = 36;
          if ( !sub_100409A0(v118, v4, (_BYTE *)v6) )
            return 0;
          if ( *(_DWORD *)(v118 + 12) == 66 )
          {
            if ( sub_1003FBB0(v4, v6, 66) >= 0 )
              goto LABEL_54;
            result = 0;
          }
          else
          {
            result = sub_10040960(v118, v4, v6, *(_DWORD *)(v118 + 12));
            if ( result )
              goto LABEL_54;
          }
          break;
        default:
          if ( sub_1003FBB0(v4, v6, 67) >= 0 )
            goto LABEL_54;
          result = 0;
          break;
      }
      return result;
    case 0x16:
      v29 = sub_100421D0(v4, v8, *(_DWORD *)(v8 + 12), v6);
      goto LABEL_53;
    case 0x17:
      v29 = sub_100423C0(v4, v6, v8, *(_DWORD *)(v8 + 12));
      goto LABEL_53;
    case 0x1B:
    case 0x33:
      v119 = *(_DWORD *)(v8 + 24);
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      v140 = *(_DWORD *)(v119 + 16);
      if ( sub_1003FBB0(v4, v6, 57) < 0 )
        return 0;
      v120 = *(_DWORD *)(v119 + 40);
      if ( !v120 )
        goto LABEL_425;
      while ( sub_10042FB0(v8, v4, v6, v120) )
      {
        v120 = *(_DWORD *)(v120 + 40);
        if ( !v120 )
        {
LABEL_425:
          if ( sub_10042010(v4, v6, 12, *(_DWORD *)(*(_DWORD *)(v6 + 112) + 8) - **(_DWORD **)(v6 + 112) - v140) < 0 )
            return 0;
          v100 = *(_DWORD *)(v8 + 12);
          v99 = *(_DWORD *)(v8 + 32) - 1;
LABEL_427:
          v121 = sub_1003FC00(v4, v6, v100, SBYTE1(v99), v99);
LABEL_428:
          if ( v121 < 0 )
            return 0;
          goto LABEL_54;
        }
      }
      return 0;
    case 0x18:
      v122 = sub_10038C10(v4, *(_DWORD *)(*(_DWORD *)(v4 + 24) + 164), v6 + 128);
      if ( !v122
        || sub_1003FC00(v4, v6, 59, *(_WORD *)(v122 + 12) >> 8, *(_BYTE *)(v122 + 12)) < 0
        || sub_1003FBB0(v4, v6, 57) < 0
        || sub_1003FBB0(v4, v6, 89) < 0 )
      {
        return 0;
      }
      v123 = *(_DWORD *)(v8 + 24);
      if ( !v123 || *(_DWORD *)v123 != 53 )
        goto LABEL_438;
      if ( sub_1003FC00(v4, v6, 93, *(_WORD *)(v123 + 28) >> 8, *(_BYTE *)(v123 + 28)) < 0 )
        return 0;
      v123 = *(_DWORD *)(v123 + 40);
LABEL_438:
      v124 = 0;
      LODWORD(v139) = 0;
      if ( !v123 )
        goto LABEL_451;
      while ( 1 )
      {
        if ( v124 )
          v125 = v124 == 1 ? sub_1003FBB0(v4, v6, 63) : sub_1003FC00(v4, v6, 88, SBYTE1(v139), v139);
        else
          v125 = sub_1003FBB0(v4, v6, 62);
        if ( v125 < 0 )
          break;
        if ( *(_DWORD *)v123 == 3 )
        {
          if ( sub_1003FBB0(v4, v6, 1) < 0 )
            return 0;
        }
        else if ( !sub_10042FB0(v8, v4, v6, v123) )
        {
          return 0;
        }
        if ( sub_1003FBB0(v4, v6, 92) < 0 )
          break;
        v123 = *(_DWORD *)(v123 + 40);
        v124 = v139 + 1;
        LODWORD(v139) = v139 + 1;
        if ( !v123 )
        {
LABEL_451:
          if ( *(_DWORD *)(v8 + 36) && sub_10041100(v4, v6, 5) < 0 )
          {
            result = 0;
          }
          else
          {
LABEL_481:
            if ( sub_1003FBB0(v4, v6, 90) >= 0 )
            {
LABEL_54:
              v11 = (*(_DWORD *)(v6 + 180))-- == 1;
              if ( v11 )
              {
                if ( *(_DWORD *)(v6 + 160) )
                  v141 = sub_10041660(v4, v6);
              }
LABEL_57:
              result = v141;
            }
            else
            {
              result = 0;
            }
          }
          return result;
        }
      }
      return 0;
    case 0x1A:
      v126 = sub_10038C10(v4, *(_DWORD *)(*(_DWORD *)(v4 + 24) + 196), v6 + 128);
      a2 = v126;
      if ( !v126
        || sub_1003FC00(v4, v6, 59, *(_WORD *)(v126 + 12) >> 8, *(_BYTE *)(v126 + 12)) < 0
        || sub_1003FBB0(v4, v6, 57) < 0
        || sub_1003FBB0(v4, v6, 89) < 0 )
      {
        return 0;
      }
      v127 = *(_DWORD *)(v8 + 24);
      LODWORD(v139) = v127;
      if ( !v127 )
        goto LABEL_481;
      if ( *(_DWORD *)v127 != 53 )
        goto LABEL_462;
      if ( sub_1003FC00(v4, v6, 93, *(_WORD *)(v127 + 28) >> 8, *(_BYTE *)(v127 + 28)) < 0 )
        return 0;
      v127 = *(_DWORD *)(v127 + 40);
      LODWORD(v139) = v127;
LABEL_462:
      if ( !v127 )
        goto LABEL_481;
      while ( 2 )
      {
        v128 = *(_DWORD *)(v127 + 24);
        v129 = *(_DWORD *)v128 - 29;
        v11 = *(_DWORD *)v128 == 29;
        HIDWORD(v139) = v128;
        if ( v11 )
          goto LABEL_468;
        v130 = v129 - 1;
        if ( v130 )
        {
          if ( v130 != 1 )
            goto LABEL_470;
LABEL_468:
          v131 = sub_10038C10(v4, *(_DWORD *)(v128 + 24), v6 + 128);
          a2 = v131;
        }
        else
        {
          LOBYTE(v128) = v6;
          v131 = sub_10040F00(v6, v4, *(double *)(HIDWORD(v139) + 24));
        }
        if ( !v131 )
          return 0;
LABEL_470:
        v132 = v139;
        if ( !sub_10042FB0(v128, v4, v6, *(_DWORD *)(v139 + 28)) )
          return 0;
        v133 = *(_DWORD *)(v139 + 12);
        if ( (v133 == 123 || v133 == 124) && sub_1003FBB0(v4, v6, *(_DWORD *)(v139 + 12)) < 0 )
          return 0;
        if ( *(_DWORD *)HIDWORD(v139) == 30 )
        {
          if ( sub_10041100(v4, v6, 13) < 0 )
            return 0;
          v134 = sub_1003FBB0(v4, v6, 92);
        }
        else
        {
          v134 = sub_1003FC00(v4, v6, 91, *(_WORD *)(a2 + 12) >> 8, *(_BYTE *)(a2 + 12));
        }
        if ( v134 < 0 )
          return 0;
        LODWORD(v139) = *(_DWORD *)(v139 + 40);
        if ( *(_DWORD *)(v132 + 40) )
        {
          v127 = v139;
          continue;
        }
        goto LABEL_481;
      }
    case 0x35:
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      if ( sub_1003FC00(v4, v6, 93, *(_WORD *)(v8 + 28) >> 8, *(_BYTE *)(v8 + 28)) >= 0 )
        goto LABEL_54;
      return 0;
    case 0x36:
      if ( sub_1003FC00(v4, v6, 94, *(_WORD *)(v8 + 28) >> 8, *(_BYTE *)(v8 + 28)) >= 0 )
        goto LABEL_54;
      return 0;
    case 0x1C:
      if ( !sub_10042FB0(v8, v4, v6, *(_DWORD *)(v8 + 24)) )
        return 0;
      if ( sub_1003FBB0(v4, v6, -125) >= 0 )
        goto LABEL_54;
      return 0;
    case 0x1D:
      if ( !sub_100409A0(v8, v4, (_BYTE *)v6) )
        return 0;
      v117 = *(_DWORD *)(v8 + 12);
      if ( v117 == 9 )
      {
        if ( sub_1003FBB0(v4, v6, 9) >= 0 )
          goto LABEL_54;
        result = 0;
      }
      else
      {
        v116 = *(_DWORD *)(v8 + 32);
        if ( v116 < 0 )
        {
LABEL_496:
          v29 = sub_10040960(a4, v4, v6, *(_DWORD *)(a4 + 12));
          goto LABEL_53;
        }
LABEL_392:
        if ( sub_1003FC00(v4, v6, v117, SBYTE1(v116), v116) >= 0 )
          goto LABEL_54;
        result = 0;
      }
      return result;
    case 0x1F:
    case 0x20:
      goto LABEL_496;
    case 0x1E:
      v29 = sub_10040F00(v6, v4, *(double *)(v8 + 24));
      goto LABEL_53;
    case 0x21:
      if ( sub_1003FBB0(v4, v6, *(_DWORD *)(v8 + 12)) >= 0 )
        goto LABEL_54;
      return 0;
    case 0x3C:
      if ( sub_1003FBB0(v4, v6, 113) < 0 )
        return 0;
      goto LABEL_54;
  }
  return result;
}
// 10042FB0: could not find valid save-restore pair for edi

//----- (100455A0) --------------------------------------------------------
signed int __cdecl sub_100455A0(int a1)
{
  int *v1; // esi@1
  char *v2; // eax@2
  char v3; // dl@3
  char *v4; // eax@4
  signed int result; // eax@6

  v1 = (int *)&off_10162C20;
  if ( off_10162C20 )
  {
    while ( 1 )
    {
      v2 = (char *)*v1;
      do
        v3 = *v2++;
      while ( v3 );
      v4 = sub_10038950(a1, *v1, (unsigned int)&v2[-*v1 - 1], 1);
      if ( !v4 )
        break;
      *((_DWORD *)v4 + 3) = v1;
      v1 += 4;
      if ( !*v1 )
        goto LABEL_6;
    }
    result = 0;
  }
  else
  {
LABEL_6:
    result = 1;
  }
  return result;
}
// 10162C20: using guessed type char *off_10162C20;

//----- (10045600) --------------------------------------------------------
int __cdecl sub_10045600(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int result; // eax@5

  v3 = *(_DWORD *)(a1 + 76);
  v4 = *(_DWORD *)(v3 + 12);
  if ( (unsigned int)(v4 + 712) <= *(_DWORD *)(v3 + 8) )
    *(_DWORD *)(v3 + 12) = v4 + 712;
  else
    v4 = sub_1003E2D0(a1 + 60, 0x2C8u);
  if ( v4 )
  {
    memset((void *)v4, 0, 0x2C8u);
    *(_DWORD *)(v4 + 144) = v4 + 200;
    *(_DWORD *)(v4 + 140) = v4 + 200;
    *(_DWORD *)(v4 + 136) = v4 + 200;
    *(_DWORD *)(v4 + 148) = a2;
    *(_DWORD *)(v4 + 156) = a2;
    *(_DWORD *)(v4 + 104) = 1;
    *(_DWORD *)(v4 + 152) = a2 + 2 * a3;
    *(_DWORD *)(v4 + 184) = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 524);
    *(_DWORD *)(v4 + 188) = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 528);
    result = v4;
  }
  else
  {
    sub_10011170(a1);
    result = 0;
  }
  return result;
}

//----- (100456B0) --------------------------------------------------------
BOOL __cdecl sub_100456B0(int a1, int a2)
{
  int v2; // eax@2

  if ( *(_DWORD *)(a2 + 180) )
  {
    --*(_DWORD *)(*(_DWORD *)(a2 + 180) + 12);
    v2 = *(_DWORD *)(a2 + 180);
    if ( !*(_DWORD *)(v2 + 12) )
      (*(void (__cdecl **)(int, _DWORD))(v2 + 16))(a1, *(_DWORD *)(a2 + 180));
  }
  return *(_DWORD *)(a2 + 176) == 0;
}

//----- (100456F0) --------------------------------------------------------
signed int __usercall sub_100456F0@<eax>(int a1@<esi>)
{
  int v1; // eax@3
  int v2; // edi@3
  void (__cdecl *v3)(_DWORD, _DWORD, int, int, int, _DWORD); // ecx@4
  unsigned int v4; // ebx@6
  unsigned int i; // ecx@7
  __int16 v6; // ax@8
  int v7; // ebp@23
  unsigned int v8; // ecx@23
  __int16 v9; // ax@24
  int v10; // eax@25
  bool v11; // zf@25
  _WORD *v12; // ebp@25
  signed int result; // eax@30
  int v14; // eax@38
  int v15; // eax@43
  int v16; // edi@43
  int v17; // eax@43
  unsigned int v18; // eax@47
  _WORD *v19; // ecx@50
  int v20; // [sp+Ch] [bp-4h]@23

  if ( !*(_DWORD *)(a1 + 108) )
  {
    while ( 1 )
    {
      while ( *(_DWORD *)(a1 + 144) != *(_DWORD *)(a1 + 140) )
      {
LABEL_50:
        v19 = *(_WORD **)(a1 + 144);
        result = *v19;
        *(_DWORD *)(a1 + 144) = v19 + 1;
        if ( !((0x10000 >> (dword_100CED28[4
                                         * (unsigned __int8)byte_100CCEA8[result & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)result >> 6] << 6)]] & 0x1F)) & 1) )
          goto LABEL_31;
      }
      v1 = *(_DWORD *)(a1 + 156);
      v2 = (*(_DWORD *)(a1 + 152) - v1) >> 1;
      if ( v2 <= 0 )
      {
        if ( *(_DWORD *)(a1 + 176) )
        {
          while ( 1 )
            ;
        }
        *(_DWORD *)(a1 + 124) |= 2u;
        return -1;
      }
      v3 = *(void (__cdecl **)(_DWORD, _DWORD, int, int, int, _DWORD))(a1 + 184);
      if ( v3 )
        v3(*(_DWORD *)(a1 + 172), *(_DWORD *)(a1 + 104), v1, v2, a1 + 192, *(_DWORD *)(a1 + 188));
      v4 = *(_DWORD *)(a1 + 196);
      if ( !v4 )
      {
        v4 = *(_DWORD *)(a1 + 156);
        for ( i = *(_DWORD *)(a1 + 152); v4 < i; v4 += 2 )
        {
          v6 = *(_WORD *)v4;
          if ( !(*(_WORD *)v4 & 0xDFD0) )
          {
            if ( v6 == 10 )
              break;
            if ( v6 == 13 )
            {
              if ( v4 + 2 < i && *(_WORD *)(v4 + 2) == 10 )
                v4 += 2;
              break;
            }
            if ( v6 == 8232 || v6 == 8233 )
              break;
          }
        }
      }
      if ( v4 < *(_DWORD *)(a1 + 152) )
        v2 = ((signed int)(v4 - *(_DWORD *)(a1 + 156)) >> 1) + 1;
      if ( v2 < 256 )
      {
        *(_DWORD *)(a1 + 196) = 0;
      }
      else
      {
        v2 = 255;
        *(_DWORD *)(a1 + 196) = v4;
      }
      v7 = 2 * v2;
      memcpy(*(void **)(a1 + 136), *(const void **)(a1 + 156), 2 * v2);
      v8 = *(_DWORD *)(a1 + 152);
      *(_DWORD *)(a1 + 156) += 2 * v2;
      v20 = v2;
      if ( v4 >= v8 )
        goto LABEL_43;
      v9 = *(_WORD *)v4;
      if ( *(_WORD *)v4 != 13 )
        break;
      v10 = *(_DWORD *)(a1 + 136);
      v11 = *(_WORD *)(v10 + v7 - 2) == 13;
      v12 = (_WORD *)(v10 + v7 - 2);
      if ( !v11 )
        goto LABEL_43;
      if ( v4 + 2 != v8 || !*(_DWORD *)(a1 + 176) )
      {
        *v12 = 10;
LABEL_43:
        v15 = *(_DWORD *)(a1 + 136);
        v16 = v15 + 2 * v2;
        *(_DWORD *)(a1 + 144) = v15;
        v17 = *(_DWORD *)(a1 + 124);
        *(_DWORD *)(a1 + 140) = v16;
        if ( v17 & 0x20 )
          *(_DWORD *)(a1 + 132) = 0;
        else
          *(_DWORD *)(a1 + 132) += *(_DWORD *)(a1 + 128);
        if ( *(_WORD *)(v16 - 2) == 10 )
          v18 = v17 | 0x20;
        else
          v18 = v17 & 0xFFFFFFDF;
        *(_DWORD *)(a1 + 124) = v18;
        *(_DWORD *)(a1 + 128) = v20;
        goto LABEL_50;
      }
      *(_DWORD *)(a1 + 124) |= 0x40u;
      if ( --v2 )
        goto LABEL_43;
      if ( *(_DWORD *)(a1 + 108) )
        goto LABEL_30;
    }
    if ( v9 == 10 )
    {
      if ( v4 > *(_DWORD *)(a1 + 148) && *(_WORD *)(v4 - 2) == 13 )
      {
        v14 = *(_DWORD *)(a1 + 136);
        if ( *(_WORD *)(v14 + 2 * v2 - 4) == 13 )
          *(_WORD *)(v14 + 2 * --v2 - 2) = 10;
      }
    }
    else if ( v9 == 8232 || v9 == 8233 )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 136) + v7 - 2) = 10;
    }
    goto LABEL_43;
  }
LABEL_30:
  result = *(_WORD *)(a1 + 2 * --*(_DWORD *)(a1 + 108) + 112);
LABEL_31:
  if ( result == 10 )
    ++*(_DWORD *)(a1 + 104);
  return result;
}

//----- (10045980) --------------------------------------------------------
int __usercall sub_10045980@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( a2 != -1 )
  {
    if ( a2 == 10 )
      --*(_DWORD *)(result + 104);
    *(_WORD *)(result + 2 * (*(_DWORD *)(result + 108))++ + 112) = a2;
  }
  return result;
}

//----- (100459A0) --------------------------------------------------------
int __usercall sub_100459A0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // ecx@1

  v1 = a1;
  v2 = sub_100456F0(a1);
  sub_10045980(v1, v2);
  return v3;
}

//----- (100459C0) --------------------------------------------------------
BOOL __usercall sub_100459C0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // edi@1
  int i; // esi@1
  signed int v5; // eax@2
  int j; // ebx@4

  v3 = 0;
  for ( i = a1; v3 < a2; *(_WORD *)(a3 + 2 * v3++) = v5 )
  {
    v5 = sub_100456F0(i);
    if ( v5 == -1 )
      break;
  }
  for ( j = v3 - 1; j >= 0; --j )
    sub_10045980(i, *(_WORD *)(a3 + 2 * j));
  return v3 == a2;
}

//----- (10045A10) --------------------------------------------------------
signed int __usercall sub_10045A10@<eax>(signed int result@<eax>, int a2@<ecx>)
{
  int v2; // edi@1
  int i; // esi@1

  v2 = result - 1;
  for ( i = a2; v2 >= 0; --v2 )
    result = sub_100456F0(i);
  return result;
}

//----- (10045A30) --------------------------------------------------------
signed int __usercall sub_10045A30@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  signed int result; // eax@2

  v2 = a1;
  v3 = sub_100456F0(a1);
  if ( v3 == a2 )
  {
    result = 1;
  }
  else
  {
    sub_10045980(v2, v3);
    result = 0;
  }
  return result;
}

//----- (10045A60) --------------------------------------------------------
signed int __cdecl sub_10045A60(int a1, int a2, int a3, int a4, int a5, char a6)
{
  int v6; // edi@1
  signed int result; // eax@3
  void (__cdecl *v8)(int, const char *, int *); // ebx@5
  void *v9; // eax@7
  int v10; // edx@7
  int v11; // ST14_4@7
  char *v12; // eax@7
  char *v13; // edx@8
  int v14; // ecx@10
  int v15; // edi@10
  char *v16; // eax@11
  int v17; // eax@18
  int (__cdecl *v18)(int, const char *, int *, _DWORD); // ecx@18
  unsigned int v19; // ecx@25
  unsigned int *v20; // eax@27
  int v21; // edx@39
  const char *v22; // [sp+8h] [bp-34h]@4
  char *v23; // [sp+Ch] [bp-30h]@1
  int v24; // [sp+10h] [bp-2Ch]@4
  int v25; // [sp+14h] [bp-28h]@4
  int v26; // [sp+18h] [bp-24h]@4
  char *v27; // [sp+1Ch] [bp-20h]@4
  char *v28; // [sp+20h] [bp-1Ch]@4
  char *v29; // [sp+24h] [bp-18h]@4
  char *v30; // [sp+28h] [bp-14h]@4
  int v31; // [sp+2Ch] [bp-10h]@4
  int v32; // [sp+30h] [bp-Ch]@4
  unsigned int v33; // [sp+34h] [bp-8h]@4
  unsigned int *v34; // [sp+38h] [bp-4h]@4

  v6 = 0;
  v23 = 0;
  if ( a4 & 4 && !(*(_BYTE *)(a1 + 300) & 1) )
    return 1;
  v31 = a4;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v33 = 0;
  v34 = 0;
  v32 = a5;
  v22 = 0;
  result = sub_1003E9B0(
             a1,
             (int (__cdecl *)(int, _DWORD, int))sub_1003ED50,
             0,
             a5,
             (unsigned int *)&v22,
             (int)&v25,
             &v24,
             1,
             (int)&a6);
  if ( result )
  {
    sub_1003AB10(a1, (int)&v23, (unsigned int)"error line buffer");
    v8 = *(void (__cdecl **)(int, const char *, int *))(a1 + 276);
    if ( !v8 )
    {
LABEL_23:
      if ( v22 )
        sub_10010340(a1, (unsigned int)v22);
      v19 = (unsigned int)v34;
      if ( v34 )
      {
        if ( *v34 )
        {
          v20 = v34;
          do
          {
            sub_10010340(a1, *v20);
            v19 = (unsigned int)v34;
            v20 = &v34[++v6];
          }
          while ( *v20 );
        }
        sub_10010340(a1, v19);
      }
      if ( v33 )
        sub_10010340(a1, v33);
      sub_1003A860(*(_DWORD *)(a1 + 24), (int)&v23);
      if ( a2 )
      {
        if ( !(a4 & 1) )
          *(_DWORD *)(a2 + 124) |= 1u;
      }
      return v24;
    }
    if ( a2 )
    {
      v9 = *(void **)(a2 + 136);
      v10 = *(_DWORD *)(a2 + 104);
      v25 = *(_DWORD *)(a2 + 172);
      v11 = (*(_DWORD *)(a2 + 140) - (signed int)v9) >> 1;
      v26 = v10;
      v12 = sub_1001AB60(a1, v9, v11, 0);
      v23 = v12;
      if ( v12 )
      {
        v13 = (char *)sub_10010FF0((unsigned int)v12);
        v12 = v23;
      }
      else
      {
        v13 = 0;
      }
      v14 = *(_DWORD *)(a2 + 96) + *(_DWORD *)(a2 + 100);
      v27 = v13;
      v15 = *(_DWORD *)(a2 + 24 * (v14 & 3) + 12);
      if ( v12 )
      {
        v28 = &v13[(v15 - *(_DWORD *)(a2 + 136)) >> 1];
        v16 = (char *)sub_10011010((unsigned int)v12);
        v29 = v16;
        if ( v23 )
          v30 = &v16[2 * ((v15 - *(_DWORD *)(a2 + 136)) >> 1)];
        else
          v30 = 0;
      }
      else
      {
        v28 = 0;
        v29 = 0;
        v30 = 0;
      }
      if ( *(_BYTE *)(a2 + 124) & 1 )
      {
LABEL_16:
        v6 = 0;
        if ( *(_DWORD *)(a1 + 8) )
          v8 = 0;
        v17 = *(_DWORD *)(a1 + 24);
        v18 = *(int (__cdecl **)(int, const char *, int *, _DWORD))(v17 + 564);
        if ( (!v18 || v8 && v18(a1, v22, &v25, *(_DWORD *)(v17 + 568))) && v8 )
          v8(a1, v22, &v25);
        goto LABEL_23;
      }
    }
    else if ( a3 )
    {
      v21 = *(_DWORD *)(a3 + 112);
      v25 = *(_DWORD *)(a3 + 116);
      v26 = *(_DWORD *)(v21 + 28);
    }
    if ( sub_10019EA0(a1, v22, (int)&v25) )
      v8 = 0;
    goto LABEL_16;
  }
  return result;
}

//----- (10045D00) --------------------------------------------------------
signed int __cdecl sub_10045D00(int a1, int a2)
{
  int v2; // ebp@1
  int *v3; // eax@1
  int v4; // ebx@1
  bool v5; // zf@1
  int v6; // ecx@2
  int v7; // esi@2
  int v8; // ebx@5
  int v9; // esi@5
  int v10; // ecx@5
  unsigned int v11; // edx@5
  unsigned int v12; // edx@6
  signed int result; // eax@14
  int v14; // [sp-10h] [bp-20h]@8
  int *v15; // [sp-Ch] [bp-1Ch]@8
  size_t v16; // [sp-8h] [bp-18h]@8
  int v17; // [sp-4h] [bp-14h]@8
  int v18; // [sp+18h] [bp+8h]@1

  v2 = a2;
  v3 = *(int **)a2;
  v4 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2) >> 1;
  v5 = *(_DWORD *)a2 == 0;
  v18 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2) >> 1;
  if ( v5 )
  {
    v6 = *(_DWORD *)(a1 + 76);
    v7 = (int)(v3 + 16);
    v3 = *(int **)(v6 + 12);
    if ( (unsigned int)(v3 + 32) <= *(_DWORD *)(v6 + 8) )
      *(_DWORD *)(v6 + 12) = v3 + 32;
    else
      v3 = (int *)sub_1003E2D0(a1 + 60, 0x80u);
    goto LABEL_13;
  }
  v8 = *(_DWORD *)(a1 + 76);
  v9 = (*(_DWORD *)(v2 + 4) - (signed int)v3) >> 1;
  v10 = 2 * v9;
  v11 = (unsigned int)v3 + ((2 * v9 + 3) & 0xFFFFFFFC);
  v7 = 2 * v9;
  if ( *(_DWORD *)(v8 + 12) != v11 )
  {
    v17 = v10;
    v16 = v10;
    v15 = v3;
    v14 = a1 + 60;
    goto LABEL_11;
  }
  v12 = (unsigned int)v3 + ((2 * v10 + 3) & 0xFFFFFFFC);
  if ( v12 > *(_DWORD *)(v8 + 8) )
  {
    v17 = v10;
    v16 = v10;
    v15 = v3;
    v14 = a1 + 60;
    if ( v3 == *(int **)(v8 + 4) )
    {
      v3 = sub_1003E400(v14, (int)v3, v10, v10);
      goto LABEL_12;
    }
LABEL_11:
    v3 = sub_1003E510(v14, v15, v16, v17);
    goto LABEL_12;
  }
  *(_DWORD *)(v8 + 12) = v12;
LABEL_12:
  v4 = v18;
LABEL_13:
  if ( v3 )
  {
    *(_DWORD *)v2 = v3;
    *(_DWORD *)(v2 + 4) = (char *)v3 + 2 * v7;
    *(_DWORD *)(v2 + 8) = (char *)v3 + 2 * v4;
    result = 1;
  }
  else
  {
    sub_10011170(a1);
    result = 0;
  }
  return result;
}

//----- (10045DD0) --------------------------------------------------------
signed int __usercall sub_10045DD0@<eax>(int a1@<ecx>, int a2@<esi>, __int16 a3)
{
  signed int result; // eax@2

  if ( *(_DWORD *)(a2 + 8) != *(_DWORD *)(a2 + 4) || (result = sub_10045D00(a1, a2)) != 0 )
  {
    **(_WORD **)(a2 + 8) = a3;
    *(_DWORD *)(a2 + 8) += 2;
    result = 1;
  }
  return result;
}

//----- (10045E00) --------------------------------------------------------
int __cdecl sub_10045E00(int a1)
{
  int v1; // ebp@4
  int v2; // ebx@6
  int v3; // edi@8
  int v4; // esi@10
  int v5; // ebp@12
  int v6; // ebx@15
  int v7; // edi@18
  int v8; // esi@21
  int result; // eax@23
  __int16 v10; // [sp+14h] [bp-10h]@1
  unsigned __int16 v11; // [sp+16h] [bp-Eh]@3
  unsigned __int16 v12; // [sp+18h] [bp-Ch]@5
  unsigned __int16 v13; // [sp+1Ah] [bp-Ah]@7
  unsigned __int16 v14; // [sp+1Ch] [bp-8h]@9

  if ( sub_100459C0(a1, 5, (int)&v10)
    && v10 == 117
    && v11 < 0x80u
    && (v1 = v11, isxdigit(v11))
    && v12 < 0x80u
    && (v2 = v12, isxdigit(v12))
    && v13 < 0x80u
    && (v3 = v13, isxdigit(v13))
    && v14 < 0x80u
    && (v4 = v14, isxdigit(v14)) )
  {
    if ( isdigit(v1) )
      v5 = v1 - 48;
    else
      v5 = tolower(v1) - 87;
    if ( isdigit(v2) )
      v6 = v2 - 48;
    else
      v6 = tolower(v2) - 87;
    if ( isdigit(v3) )
      v7 = v3 - 48;
    else
      v7 = tolower(v3) - 87;
    if ( isdigit(v4) )
      v8 = v4 - 48;
    else
      v8 = tolower(v4) - 87;
    sub_10045A10(5, a1);
    result = v8 + 16 * (v7 + 16 * (v6 + 16 * v5));
  }
  else
  {
    result = 92;
  }
  return result;
}

//----- (10045FA0) --------------------------------------------------------
signed int __usercall sub_10045FA0@<eax>(char a1@<sil>, int a2, int a3)
{
  int v3; // edx@1
  signed int result; // eax@2
  int v5; // eax@4
  int v6; // eax@4
  signed int v7; // eax@8
  signed int v8; // esi@8
  int v9; // eax@11
  int v10; // ebp@11
  int v11; // eax@11
  int v12; // eax@26
  _WORD **v13; // ebx@27
  signed int v14; // eax@29
  signed int v15; // eax@29
  __int16 v16; // ax@30
  signed int v17; // eax@43
  int v18; // eax@51
  signed int v19; // eax@56
  __int16 v20; // cx@61
  const char *v21; // eax@76
  int v22; // eax@84
  __int16 v23; // ax@85
  int v24; // eax@93
  int v25; // eax@95
  __int16 v26; // ax@96
  signed int v27; // eax@100
  int v28; // eax@107
  signed int v29; // ecx@113
  __int16 v30; // dx@116
  signed int v31; // eax@159
  int i; // esi@168
  signed int v33; // eax@176
  char *v34; // eax@179
  int v35; // eax@180
  __int16 v36; // dx@181
  int v37; // eax@198
  int v38; // esi@198
  unsigned int v39; // ebx@200
  int j; // esi@200
  __int16 v41; // dx@209
  __int16 v42; // ax@212
  int v43; // eax@215
  signed int v44; // ebx@215
  signed int v45; // esi@215
  int v46; // ebx@227
  int v47; // eax@227
  int v48; // eax@228
  __int16 v49; // cx@229
  int v50; // ebx@229
  int v51; // ebx@236
  int v52; // esi@244
  int v53; // ebx@250
  int v54; // eax@253
  int v55; // ebx@259
  int v56; // esi@263
  int v57; // eax@266
  signed int v58; // eax@270
  int v59; // eax@275
  __int16 v60; // cx@276
  __int16 v61; // dx@276
  signed int v62; // edx@278
  int v63; // eax@285
  __int16 v64; // ax@287
  int v65; // ecx@289
  signed int v66; // edx@290
  int v67; // [sp-20h] [bp-5Ch]@111
  int v68; // [sp-1Ch] [bp-58h]@111
  int v69; // [sp-10h] [bp-4Ch]@110
  char v70; // [sp-Ch] [bp-48h]@7
  int v71; // [sp+8h] [bp-34h]@27
  int v72; // [sp+8h] [bp-34h]@240
  int v73; // [sp+Ch] [bp-30h]@15
  int v74; // [sp+Ch] [bp-30h]@242
  int v75; // [sp+10h] [bp-2Ch]@238
  int v76; // [sp+10h] [bp-2Ch]@247
  int v77; // [sp+10h] [bp-2Ch]@261
  int v78; // [sp+14h] [bp-28h]@90
  unsigned int v79; // [sp+18h] [bp-24h]@204
  double v80; // [sp+1Ch] [bp-20h]@90
  char v81; // [sp+24h] [bp-18h]@207

  v3 = *(_DWORD *)(a3 + 124);
  if ( v3 & 1 )
    return -1;
  while ( *(_DWORD *)(a3 + 100) )
  {
    v5 = *(_DWORD *)(a3 + 96);
    --*(_DWORD *)(a3 + 100);
    v6 = ((_BYTE)v5 + 1) & 3;
    *(_DWORD *)(a3 + 96) = v6;
    result = *(_DWORD *)(a3 + 24 * v6);
    if ( result != 1 || v3 & 4 )
      return result;
  }
  v70 = a1;
  do
  {
LABEL_8:
    v7 = sub_100456F0(a3);
    v8 = v7;
    if ( v7 == 10 )
    {
      *(_DWORD *)(a3 + 124) &= 0xFFFFFF7F;
      if ( *(_BYTE *)(a3 + 124) & 4 )
        break;
    }
  }
  while ( (*(_DWORD *)&dword_100CED28[4
                                    * (unsigned __int8)byte_100CCEA8[v7 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v7 >> 6] << 6)]] & 0x70000) == 0x40000 );
  v9 = ((unsigned __int8)*(_DWORD *)(a3 + 96) + 1) & 3;
  *(_DWORD *)(a3 + 96) = v9;
  v10 = a3 + 24 * v9;
  v11 = *(_DWORD *)(a3 + 144) - 2;
  *(_DWORD *)(v10 + 12) = v11;
  *(_WORD *)(v10 + 4) = *(_WORD *)(a3 + 132) + ((v11 - *(_DWORD *)(a3 + 136)) >> 1);
  LOWORD(v11) = *(_WORD *)(a3 + 104);
  *(_WORD *)(v10 + 10) = v11;
  *(_WORD *)(v10 + 6) = v11;
  if ( v8 == -1 )
  {
    v20 = *(_WORD *)(a3 + 132) + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1) - *(_WORD *)(a3 + 108);
    *(_DWORD *)v10 = 0;
    result = 0;
    goto LABEL_297;
  }
  if ( v8 != 45 && v8 != 10 )
    *(_DWORD *)(a3 + 124) |= 0x80u;
  v73 = 0;
  if ( (1086 >> (dword_100CED28[4
                              * (unsigned __int8)byte_100CCEA8[v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v8 >> 6] << 6)]] & 0x1F)) & 1
    || v8 == 95
    || v8 == 36 )
  {
    goto LABEL_55;
  }
  if ( v8 != 92
    || (v8 = sub_10045E00(a3),
        !((1086 >> (dword_100CED28[4
                                 * (unsigned __int8)byte_100CCEA8[v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v8 >> 6] << 6)]] & 0x1F)) & 1))
    && v8 != 95
    && v8 != 36 )
  {
    if ( v8 >= 128 || !isdigit(v8) )
    {
      if ( v8 == 46 )
      {
        if ( sub_100459A0(a3) < 128 )
        {
          v12 = sub_100459A0(a3);
          if ( isdigit(v12) )
            goto LABEL_27;
        }
LABEL_33:
        switch ( v8 )
        {
          case 60:
            if ( sub_10045A30(a3, 33) )
            {
              if ( sub_10045A30(a3, 45) )
              {
                if ( sub_10045A30(a3, 45) )
                  goto LABEL_51;
                sub_10045980(a3, 45);
              }
              sub_10045980(a3, 33);
            }
            if ( sub_10045A30(a3, v8) )
            {
              *(_DWORD *)(v10 + 16) = 24;
              result = sub_10045A30(a3, 61) != 0 ? 4 : 14;
              goto LABEL_195;
            }
            *(_DWORD *)(v10 + 16) = (sub_10045A30(a3, 61) != 0) + 20;
            result = 13;
            goto LABEL_197;
          case 47:
            if ( sub_10045A30(a3, 47) )
              goto LABEL_51;
            if ( sub_10045A30(a3, 42) )
            {
              while ( 1 )
              {
                v17 = sub_100456F0(a3);
                if ( v17 == -1 )
                  break;
                if ( v17 == 42 && sub_10045A30(a3, 47) )
                  goto LABEL_8;
              }
              sub_10045A60(a2, a3, 0, 0, 140, v70);
              *(_DWORD *)(a3 + 124) |= 1u;
              goto LABEL_287;
            }
            if ( !(*(_BYTE *)(a3 + 124) & 8) )
            {
              *(_DWORD *)(v10 + 16) = 30;
LABEL_183:
              result = sub_10045A30(a3, 61) != 0 ? 4 : 18;
              goto LABEL_195;
            }
            *(_DWORD *)(a3 + 168) = *(_DWORD *)(a3 + 160);
            v31 = sub_100456F0(a3);
            if ( v31 == 47 )
              goto LABEL_167;
            while ( 1 )
            {
              if ( v31 == 10 || v31 == -1 )
              {
                sub_10045980(a3, v31);
                v69 = 141;
                v68 = a3;
                v67 = a2;
                goto LABEL_112;
              }
              if ( v31 == 92 )
              {
                if ( !sub_10045DD0(a2, a3 + 160, 92) )
                  goto LABEL_278;
                LOWORD(v31) = sub_100456F0(a3);
              }
              if ( !sub_10045DD0(a2, a3 + 160, v31) )
                goto LABEL_283;
              v31 = sub_100456F0(a3);
              if ( v31 == 47 )
              {
LABEL_167:
                if ( !sub_10045DD0(a2, a3 + 160, 0) )
                  goto LABEL_278;
                for ( i = 0; ; i |= 4u )
                {
                  while ( 1 )
                  {
                    while ( sub_10045A30(a3, 103) )
                      i |= 2u;
                    if ( !sub_10045A30(a3, 105) )
                      break;
                    i |= 1u;
                  }
                  if ( !sub_10045A30(a3, 109) )
                    break;
                }
                v33 = sub_100459A0(a3);
                if ( v33 < 128 && isalpha(v33) )
                {
                  *(_DWORD *)(v10 + 12) = *(_DWORD *)(a3 + 144) - 2;
                  sub_10045A60(a2, a3, 0, 0, 142, v70);
                  sub_100456F0(a3);
                  goto LABEL_113;
                }
                v34 = sub_10026D70(
                        a2,
                        a3,
                        *(void **)(a3 + 160),
                        ((*(_DWORD *)(a3 + 168) - *(_DWORD *)(a3 + 160)) >> 1) - 1,
                        i);
                if ( !v34 )
                  goto LABEL_283;
                v35 = sub_10038750(a2, (unsigned int)v34, 0);
                if ( !v35 )
                  goto LABEL_113;
                *(_DWORD *)(v10 + 20) = v35;
                *(_DWORD *)(v10 + 16) = 80;
                result = 32;
                v36 = *(_WORD *)(a3 + 132)
                    + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1)
                    - *(_WORD *)(a3 + 108);
                *(_DWORD *)v10 = 32;
                *(_WORD *)(v10 + 8) = v36;
                return result;
              }
            }
          case 45:
            if ( sub_10045A30(a3, 61) )
            {
              *(_DWORD *)(v10 + 16) = 28;
              result = 4;
              goto LABEL_194;
            }
            if ( !sub_10045A30(a3, v8) )
            {
              *(_DWORD *)(v10 + 16) = 34;
              result = 16;
LABEL_194:
              *(_DWORD *)(a3 + 124) |= 0x80u;
LABEL_195:
              if ( result == -1 )
                *(_DWORD *)(a3 + 124) |= 1u;
LABEL_197:
              v20 = *(_WORD *)(a3 + 132) + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1) - *(_WORD *)(a3 + 108);
              *(_DWORD *)v10 = result;
              goto LABEL_297;
            }
            if ( sub_100459A0(a3) != 62 || *(_BYTE *)(a3 + 124) & 0x80 )
            {
              result = 21;
              goto LABEL_194;
            }
            do
LABEL_51:
              v18 = sub_100456F0(a3);
            while ( v18 != -1 && v18 != 10 );
            sub_10045980(a3, v18);
            goto LABEL_8;
          case 10:
            result = 1;
            goto LABEL_197;
          case 59:
            result = 2;
            goto LABEL_197;
          case 46:
            result = 22;
            goto LABEL_197;
          case 91:
            result = 23;
            goto LABEL_197;
          case 93:
            result = 24;
            goto LABEL_197;
          case 123:
            result = 25;
            goto LABEL_197;
          case 125:
            result = 26;
            goto LABEL_197;
          case 40:
            result = 27;
            goto LABEL_197;
          case 41:
            result = 28;
            goto LABEL_197;
          case 44:
            result = 3;
            goto LABEL_197;
          case 63:
            result = 5;
            goto LABEL_197;
          case 58:
            *(_DWORD *)(v10 + 16) = 0;
            result = 6;
            goto LABEL_197;
          case 124:
            if ( sub_10045A30(a3, v8) )
            {
              result = 7;
            }
            else if ( sub_10045A30(a3, 61) )
            {
              *(_DWORD *)(v10 + 16) = 15;
              result = 4;
            }
            else
            {
              result = 9;
            }
            goto LABEL_197;
          case 94:
            if ( sub_10045A30(a3, 61) )
            {
              *(_DWORD *)(v10 + 16) = 16;
              result = 4;
            }
            else
            {
              result = 10;
            }
            goto LABEL_197;
          case 38:
            if ( sub_10045A30(a3, v8) )
            {
              result = 8;
            }
            else if ( sub_10045A30(a3, 61) )
            {
              *(_DWORD *)(v10 + 16) = 17;
              result = 4;
            }
            else
            {
              result = 11;
            }
            goto LABEL_197;
          case 61:
            if ( sub_10045A30(a3, v8) )
            {
              if ( sub_10045A30(a3, v8) )
              {
                *(_DWORD *)(v10 + 16) = 72;
                result = 12;
              }
              else
              {
                *(_DWORD *)(v10 + 16) = *(_BYTE *)(a2 + 20);
                result = 12;
              }
            }
            else
            {
              *(_DWORD *)(v10 + 16) = 0;
              result = 4;
            }
            goto LABEL_197;
          case 33:
            if ( sub_10045A30(a3, 61) )
            {
              if ( sub_10045A30(a3, 61) )
              {
                *(_DWORD *)(v10 + 16) = 73;
                result = 12;
              }
              else
              {
                *(_DWORD *)(v10 + 16) = *(_BYTE *)(a2 + 21);
                result = 12;
              }
            }
            else
            {
              *(_DWORD *)(v10 + 16) = 32;
              result = 19;
            }
            goto LABEL_197;
          case 62:
            if ( sub_10045A30(a3, v8) )
            {
              *(_DWORD *)(v10 + 16) = (sub_10045A30(a3, v8) != 0) + 25;
              result = sub_10045A30(a3, 61) != 0 ? 4 : 14;
              goto LABEL_195;
            }
            *(_DWORD *)(v10 + 16) = (sub_10045A30(a3, 61) != 0) + 22;
            result = 13;
            goto LABEL_197;
          case 42:
            *(_DWORD *)(v10 + 16) = 29;
            result = sub_10045A30(a3, 61) != 0 ? 4 : 17;
            goto LABEL_195;
          case 37:
            *(_DWORD *)(v10 + 16) = 31;
            goto LABEL_183;
          case 126:
            *(_DWORD *)(v10 + 16) = 33;
            result = 19;
            goto LABEL_197;
          case 43:
            if ( sub_10045A30(a3, 61) )
            {
              *(_DWORD *)(v10 + 16) = 27;
              result = 4;
            }
            else if ( sub_10045A30(a3, v8) )
            {
              result = 20;
            }
            else
            {
              *(_DWORD *)(v10 + 16) = 82;
              result = 15;
            }
            goto LABEL_197;
          case 35:
            v37 = sub_100456F0(a3);
            v38 = v37;
            if ( v37 >= 128 || !isdigit(v37) )
            {
              sub_10045980(a3, v38);
LABEL_214:
              sub_10045A60(a2, a3, 0, 0, 144, v70);
              goto LABEL_278;
            }
            v39 = v38 - 48;
            for ( j = sub_100456F0(a3); j < 128; j = sub_100456F0(a3) )
            {
              if ( !isdigit(j) )
                break;
              v39 = j + 10 * v39 - 48;
              if ( v39 >= 0x10000 )
              {
                v69 = 143;
                goto LABEL_111;
              }
            }
            v79 = v39;
            *(double *)(v10 + 16) = (double)v39;
            if ( !(*(_BYTE *)(a2 + 300) & 1)
              || j != 61 && j != 35
              || (sub_10050B00((int)&v81, 20, "#%u%c", v39), sub_10045A60(a2, a3, 0, 5, 158, (unsigned int)&v81)) )
            {
              if ( j == 61 )
              {
                result = 53;
                v41 = *(_WORD *)(a3 + 132)
                    + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1)
                    - *(_WORD *)(a3 + 108);
                *(_DWORD *)v10 = 53;
                *(_WORD *)(v10 + 8) = v41;
                return result;
              }
              if ( j == 35 )
              {
                v42 = *(_WORD *)(a3 + 132)
                    + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1)
                    - *(_WORD *)(a3 + 108);
                *(_DWORD *)v10 = 54;
                *(_WORD *)(v10 + 8) = v42;
                return 54;
              }
              goto LABEL_214;
            }
            break;
          default:
            goto LABEL_214;
        }
        goto LABEL_113;
      }
      if ( v8 != 34 && v8 != 39 )
        goto LABEL_33;
      v43 = *(_DWORD *)(a3 + 160);
      v44 = v8;
      v79 = v8;
      *(_DWORD *)(a3 + 168) = v43;
      v45 = sub_100456F0(a3);
      if ( v45 != v44 )
      {
        while ( v45 != 10 && v45 != -1 )
        {
          if ( v45 == 92 )
          {
            v45 = sub_100456F0(a3);
            switch ( v45 )
            {
              case 98:
                LOWORD(v45) = 8;
                break;
              case 102:
                LOWORD(v45) = 12;
                break;
              case 110:
                LOWORD(v45) = 10;
                break;
              case 114:
                LOWORD(v45) = 13;
                break;
              case 116:
                LOWORD(v45) = 9;
                break;
              case 118:
                LOWORD(v45) = 11;
                break;
              default:
                if ( (unsigned int)(v45 - 48) > 7 )
                {
                  switch ( v45 )
                  {
                    case 117:
                      if ( sub_100459C0(a3, 4, (int)&v80) )
                      {
                        if ( LOWORD(v80) < 0x80u )
                        {
                          v51 = LOWORD(v80);
                          if ( isxdigit(LOWORD(v80)) )
                          {
                            if ( WORD1(v80) < 0x80u )
                            {
                              v75 = WORD1(v80);
                              if ( isxdigit(WORD1(v80)) )
                              {
                                if ( WORD2(v80) < 0x80u )
                                {
                                  v72 = WORD2(v80);
                                  if ( isxdigit(WORD2(v80)) )
                                  {
                                    if ( WORD3(v80) < 0x80u )
                                    {
                                      v74 = WORD3(v80);
                                      if ( isxdigit(WORD3(v80)) )
                                      {
                                        if ( isdigit(v51) )
                                          v52 = v51 - 48;
                                        else
                                          v52 = tolower(v51) - 87;
                                        if ( isdigit(v75) )
                                          v76 = v75 - 48;
                                        else
                                          v76 = tolower(v75) - 87;
                                        if ( isdigit(v72) )
                                          v53 = v72 - 48;
                                        else
                                          v53 = tolower(v72) - 87;
                                        if ( isdigit(v74) )
                                          v54 = v74 - 48;
                                        else
                                          v54 = tolower(v74) - 87;
                                        v45 = v54 + 16 * (v53 + 16 * (v76 + 16 * v52));
                                        sub_10045A10(4, a3);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      break;
                    case 120:
                      if ( sub_100459C0(a3, 2, (int)&v78) )
                      {
                        if ( (unsigned __int16)v78 < 0x80u )
                        {
                          v55 = (unsigned __int16)v78;
                          if ( isxdigit((unsigned __int16)v78) )
                          {
                            if ( HIWORD(v78) < 0x80u )
                            {
                              v77 = HIWORD(v78);
                              if ( isxdigit(HIWORD(v78)) )
                              {
                                if ( isdigit(v55) )
                                  v56 = v55 - 48;
                                else
                                  v56 = tolower(v55) - 87;
                                if ( isdigit(v77) )
                                  v57 = v77 - 48;
                                else
                                  v57 = tolower(v77) - 87;
                                v45 = v57 + 16 * v56;
                                sub_10045A10(2, a3);
                              }
                            }
                          }
                        }
                      }
                      break;
                    case 10:
                      v58 = *(_DWORD *)(a2 + 16);
                      if ( !v58 || v58 >= 130 )
                        goto LABEL_273;
                      break;
                  }
                }
                else
                {
                  v46 = v45 - 48;
                  v47 = sub_100459A0(a3);
                  if ( (unsigned int)(v47 - 48) <= 7 )
                  {
                    v46 = v47 + 8 * v46 - 48;
                    sub_100456F0(a3);
                    v48 = sub_100459A0(a3);
                    if ( (unsigned int)(v48 - 48) <= 7 )
                    {
                      v49 = v46;
                      v50 = v48 + 8 * v46 - 48;
                      if ( v50 <= 255 )
                      {
                        sub_100456F0(a3);
                        LOWORD(v45) = v50;
                        break;
                      }
                      LOWORD(v46) = v49;
                    }
                  }
                  LOWORD(v45) = v46;
                }
                break;
            }
          }
          if ( !sub_10045DD0(a2, a3 + 160, v45) )
            goto LABEL_283;
LABEL_273:
          v45 = sub_100456F0(a3);
          if ( v45 == v79 )
            goto LABEL_274;
        }
        sub_10045980(a3, v45);
        sub_10045A60(a2, a3, 0, 0, 138, v70);
        goto LABEL_278;
      }
LABEL_274:
      if ( sub_10045DD0(a2, a3 + 160, 0) )
      {
        v59 = sub_10038A10(a2, *(_DWORD *)(a3 + 160), ((*(_DWORD *)(a3 + 168) - *(_DWORD *)(a3 + 160)) >> 1) - 1, 0);
        if ( v59 )
        {
          v60 = *(_WORD *)(a3 + 104);
          *(_DWORD *)(v10 + 20) = v59;
          *(_WORD *)(v10 + 10) = v60;
          *(_DWORD *)(v10 + 16) = 61;
          result = 31;
          v61 = *(_WORD *)(a3 + 132) + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1) - *(_WORD *)(a3 + 108);
          *(_DWORD *)v10 = 31;
          *(_WORD *)(v10 + 8) = v61;
          return result;
        }
        goto LABEL_278;
      }
LABEL_283:
      *(_DWORD *)(a3 + 124) |= 1u;
      goto LABEL_287;
    }
LABEL_27:
    v13 = (_WORD **)(a3 + 160);
    v71 = 10;
    *(_DWORD *)(a3 + 168) = *(_DWORD *)(a3 + 160);
    if ( v8 == 48 )
    {
      if ( !sub_10045DD0(a2, a3 + 160, 48) )
        goto LABEL_283;
      v14 = sub_100456F0(a3);
      v8 = v14;
      v15 = *(_DWORD *)&dword_100CED28[4
                                     * (unsigned __int8)byte_100CCEA8[v14 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v14 >> 6] << 6)]];
      if ( v15 & 0x200000 )
        v16 = v8 + (v15 >> 22);
      else
        v16 = v8;
      if ( v16 == 120 )
      {
        if ( !sub_10045DD0(a2, a3 + 160, v8) )
          goto LABEL_278;
        v8 = sub_100456F0(a3);
        v71 = 16;
      }
      else
      {
        if ( v8 >= 128 )
        {
LABEL_83:
          if ( v8 == 46 )
          {
            while ( sub_10045DD0(a2, a3 + 160, v8) )
            {
              v24 = sub_100456F0(a3);
              v8 = v24;
              if ( v24 >= 128 || !isdigit(v24) )
                goto LABEL_95;
            }
            goto LABEL_113;
          }
          v22 = *(_DWORD *)&dword_100CED28[4
                                         * (unsigned __int8)byte_100CCEA8[v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v8 >> 6] << 6)]];
          if ( v22 & 0x200000 )
            v23 = v8
                + (*(_DWORD *)&dword_100CED28[4
                                            * (unsigned __int8)byte_100CCEA8[v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v8 >> 6] << 6)]] >> 22);
          else
            v23 = v8;
          if ( v23 != 101 )
          {
LABEL_88:
            sub_10045980(a3, v8);
            if ( sub_10045DD0(a2, a3 + 160, 0) )
            {
              if ( v71 == 10 )
              {
                if ( !sub_1001F970(a2, *v13, (int)&v78, &v80) )
                {
                  sub_10045A60(a2, a3, 0, 0, 137, v70);
                  *(_DWORD *)(a3 + 124) |= 1u;
                  goto LABEL_287;
                }
                goto LABEL_116;
              }
              if ( sub_1001FBC0(a2, *v13, &v78, v71, &v80) )
              {
LABEL_116:
                *(double *)(v10 + 16) = v80;
                result = 30;
                v30 = *(_WORD *)(a3 + 132)
                    + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1)
                    - *(_WORD *)(a3 + 108);
                *(_DWORD *)v10 = 30;
                *(_WORD *)(v10 + 8) = v30;
                return result;
              }
              v69 = 137;
              v68 = a3;
              v67 = a2;
              goto LABEL_112;
            }
            goto LABEL_278;
          }
LABEL_95:
          v25 = *(_DWORD *)&dword_100CED28[4
                                         * (unsigned __int8)byte_100CCEA8[v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v8 >> 6] << 6)]];
          if ( v25 & 0x200000 )
            v26 = v8
                + (*(_DWORD *)&dword_100CED28[4
                                            * (unsigned __int8)byte_100CCEA8[v8 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v8 >> 6] << 6)]] >> 22);
          else
            v26 = v8;
          if ( v26 != 101 )
            goto LABEL_88;
          if ( !sub_10045DD0(a2, a3 + 160, v8) )
            goto LABEL_283;
          v27 = sub_100456F0(a3);
          v8 = v27;
          if ( v27 != 43 && v27 != 45 )
          {
LABEL_104:
            if ( v8 >= 128 || !isdigit(v8) )
            {
              v69 = 136;
LABEL_111:
              v68 = a3;
              v67 = a2;
LABEL_112:
              sub_10045A60(v67, v68, 0, 0, v69, v70);
              goto LABEL_113;
            }
            while ( sub_10045DD0(a2, a3 + 160, v8) )
            {
              v28 = sub_100456F0(a3);
              v8 = v28;
              if ( v28 >= 128 || !isdigit(v28) )
                goto LABEL_88;
            }
LABEL_278:
            v62 = *(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136);
            *(_DWORD *)(a3 + 124) |= 1u;
            LOWORD(v62) = *(_WORD *)(a3 + 132) + (v62 >> 1) - *(_WORD *)(a3 + 108);
            *(_DWORD *)v10 = -1;
            *(_WORD *)(v10 + 8) = v62;
            return -1;
          }
          if ( sub_10045DD0(a2, a3 + 160, v27) )
          {
            v8 = sub_100456F0(a3);
            goto LABEL_104;
          }
LABEL_113:
          v29 = *(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136);
          *(_DWORD *)(a3 + 124) |= 1u;
          v20 = *(_WORD *)(a3 + 132) + (v29 >> 1) - *(_WORD *)(a3 + 108);
          *(_DWORD *)v10 = -1;
          result = -1;
          goto LABEL_297;
        }
        if ( isdigit(v8) )
          v71 = 8;
      }
    }
    for ( ; v8 < 128; v8 = sub_100456F0(a3) )
    {
      if ( !isxdigit(v8) )
        break;
      if ( v71 < 16 )
      {
        if ( v8 < 128 && isalpha(v8) )
          break;
        if ( v71 == 8 && v8 >= 56 )
        {
          v21 = "08";
          if ( v8 != 56 )
            v21 = "09";
          if ( !sub_10045A60(a2, a3, 0, 1, 145, (char)v21) )
            goto LABEL_113;
          v71 = 10;
        }
      }
      if ( !sub_10045DD0(a2, a3 + 160, v8) )
        goto LABEL_278;
    }
    if ( v71 != 10 )
      goto LABEL_88;
    goto LABEL_83;
  }
  v73 = 1;
LABEL_55:
  *(_DWORD *)(a3 + 168) = *(_DWORD *)(a3 + 160);
  if ( !sub_10045DD0(a2, a3 + 160, v8) )
    goto LABEL_283;
  while ( 2 )
  {
    v19 = sub_100456F0(a3);
    if ( v19 == 92 )
    {
      v19 = sub_10045E00(a3);
      if ( !((8390526 >> (dword_100CED28[4
                                       * (unsigned __int8)byte_100CCEA8[v19 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v19 >> 6] << 6)]] & 0x1F)) & 1)
        && v19 != 95
        && v19 != 36 )
      {
        break;
      }
      v73 = 1;
      goto LABEL_282;
    }
    if ( (8390526 >> (dword_100CED28[4
                                   * (unsigned __int8)byte_100CCEA8[v19 & 0x3F | ((unsigned __int8)byte_100CCAA8[(unsigned int)(unsigned __int16)v19 >> 6] << 6)]] & 0x1F)) & 1
      || v19 == 95
      || v19 == 36 )
    {
LABEL_282:
      if ( !sub_10045DD0(a2, a3 + 160, v19) )
        goto LABEL_283;
      continue;
    }
    break;
  }
  sub_10045980(a3, v19);
  if ( !sub_10045DD0(a2, a3 + 160, 0) )
    goto LABEL_113;
  v63 = sub_10038A10(a2, *(_DWORD *)(a3 + 160), ((*(_DWORD *)(a3 + 168) - *(_DWORD *)(a3 + 160)) >> 1) - 1, 0);
  if ( v63 )
  {
    if ( !v73 )
    {
      v65 = *(_DWORD *)(v63 + 12);
      if ( v65 )
      {
        v66 = *(_DWORD *)(a2 + 16);
        if ( !v66 || v66 >= 130 || *(_DWORD *)(v65 + 12) <= v66 )
        {
          *(_DWORD *)(v10 + 16) = *(_DWORD *)(v65 + 8);
          if ( *(_DWORD *)(v65 + 4) == -1 )
            *(_DWORD *)(a3 + 124) |= 1u;
          *(_WORD *)(v10 + 8) = *(_WORD *)(a3 + 132)
                              + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1)
                              - *(_WORD *)(a3 + 108);
          result = *(_DWORD *)(v65 + 4);
          *(_DWORD *)v10 = result;
          return result;
        }
      }
    }
    *(_DWORD *)(v10 + 20) = v63;
    *(_DWORD *)(v10 + 16) = 59;
    result = 29;
    v20 = *(_WORD *)(a3 + 132) + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1) - *(_WORD *)(a3 + 108);
    *(_DWORD *)v10 = 29;
LABEL_297:
    *(_WORD *)(v10 + 8) = v20;
    return result;
  }
  *(_DWORD *)(a3 + 124) |= 1u;
LABEL_287:
  v64 = *(_WORD *)(a3 + 132) + ((*(_DWORD *)(a3 + 144) - *(_DWORD *)(a3 + 136)) >> 1) - *(_WORD *)(a3 + 108);
  *(_DWORD *)v10 = -1;
  *(_WORD *)(v10 + 8) = v64;
  return -1;
}
// 10045FA0: could not find valid save-restore pair for esi

//----- (10047550) --------------------------------------------------------
int __cdecl sub_10047550(int a1)
{
  int result; // eax@1
  int v2; // edx@2

  result = a1;
  if ( !(*(_BYTE *)(a1 + 124) & 1) )
  {
    v2 = *(_DWORD *)(a1 + 96);
    ++*(_DWORD *)(a1 + 100);
    *(_DWORD *)(a1 + 96) = ((_BYTE)v2 - 1) & 3;
  }
  return result;
}

//----- (10047570) --------------------------------------------------------
signed int __cdecl sub_10047570(int a1, int a2, int a3)
{
  signed int result; // eax@2

  if ( sub_10045FA0(a2, a1, a2) == a3 )
  {
    result = 1;
  }
  else
  {
    sub_10047550(a2);
    result = 0;
  }
  return result;
}

//----- (100475A0) --------------------------------------------------------
int __cdecl sub_100475A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@1

  result = sub_10045600(a1, a2, a3);
  if ( result )
  {
    *(_DWORD *)(result + 172) = a4;
    *(_DWORD *)(result + 104) = a5;
    if ( a6 )
      ++*(_DWORD *)(a6 + 12);
    *(_DWORD *)(result + 180) = a6;
  }
  return result;
}

//----- (100475E0) --------------------------------------------------------
signed int __cdecl sub_100475E0(int a1, int a2)
{
  int v2; // ecx@1
  signed int result; // eax@2
  signed int v4; // edi@3

  v2 = *(_DWORD *)(a2 + 100);
  if ( v2 )
  {
    result = *(_DWORD *)(a2 + 24 * (((_BYTE)v2 + (unsigned __int8)*(_DWORD *)(a2 + 96)) & 3));
  }
  else
  {
    v4 = sub_10045FA0(a2, a1, a2);
    sub_10047550(a2);
    result = v4;
  }
  return result;
}

//----- (10047620) --------------------------------------------------------
signed int __cdecl sub_10047620(int a1, int a2)
{
  int v2; // esi@1
  signed int result; // eax@1

  v2 = a2;
  *(_DWORD *)(v2 + 124) |= 4u;
  result = sub_100475E0(a1, a2);
  *(_DWORD *)(v2 + 124) &= 0xFFFFFFFB;
  return result;
}

//----- (10047640) --------------------------------------------------------
int __usercall sub_10047640@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( result )
  {
    *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a2 + 24) = result;
  }
  return result;
}

//----- (10047650) --------------------------------------------------------
int __usercall sub_10047650@<eax>(int a1@<ecx>, int a2@<edi>)
{
  int v2; // esi@1
  int v3; // ecx@2
  int v4; // eax@2
  int result; // eax@6
  int v6; // eax@7
  int v7; // ecx@10
  int v8; // ecx@10

  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    v6 = *(_DWORD *)(v2 + 40);
    *(_DWORD *)(a1 + 24) = v6;
    switch ( *(_DWORD *)(v2 + 20) )
    {
      case 0xFFFFFFFE:
        if ( !*(_DWORD *)(v2 + 24) )
          goto LABEL_13;
        **(_DWORD **)(v2 + 28) = v6;
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(v2 + 24);
        return v2;
      case 3:
        sub_10047640(*(_DWORD *)(v2 + 24), a1);
        sub_10047640(*(_DWORD *)(v2 + 28), v7);
        sub_10047640(*(_DWORD *)(v2 + 32), v8);
        return v2;
      case 2:
        sub_10047640(*(_DWORD *)(v2 + 24), a1);
        goto LABEL_12;
      case 0xFFFFFFFD:
      case 0xFFFFFFFF:
LABEL_12:
        sub_10047640(*(_DWORD *)(v2 + 28), a1);
        goto LABEL_13;
      default:
        goto LABEL_13;
      case 1:
        sub_10047640(*(_DWORD *)(v2 + 24), a1);
        result = v2;
        break;
    }
  }
  else
  {
    v3 = *(_DWORD *)(a2 + 76);
    v4 = *(_DWORD *)(v3 + 12);
    if ( (unsigned int)(v4 + 44) <= *(_DWORD *)(v3 + 8) )
      *(_DWORD *)(v3 + 12) = v4 + 44;
    else
      v4 = sub_1003E2D0(a2 + 60, 0x2Cu);
    v2 = v4;
    if ( v4 )
    {
LABEL_13:
      result = v2;
    }
    else
    {
      sub_10011170(a2);
      result = v2;
    }
  }
  return result;
}

//----- (10047720) --------------------------------------------------------
int __usercall sub_10047720@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int result; // eax@1

  result = sub_10047650(a1, a2);
  if ( result )
  {
    *(_DWORD *)result = *(_DWORD *)a3;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 20) = a4;
    *(_DWORD *)(result + 40) = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047750) --------------------------------------------------------
int __usercall sub_10047750@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>, int a4, int a5, int a6)
{
  int v6; // ebx@1
  int *v7; // eax@7
  int v8; // ecx@7
  int v9; // ecx@8
  int v10; // eax@12
  int v11; // ebx@17
  int result; // eax@19
  int v13; // edx@27

  v6 = a1;
  if ( a3 && a1 )
  {
    if ( *(_DWORD *)a3 == a5 && *(_DWORD *)(a3 + 12) == a6 && dword_100D1E4C[4 * a6] & 0x8000 )
    {
      if ( *(_DWORD *)(a3 + 20) != -2 )
      {
        v7 = *(int **)(a3 + 28);
        v8 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 20) = -2;
        *(_DWORD *)(a3 + 32) = 1;
        *(_DWORD *)(v8 + 40) = v7;
        ++*(_DWORD *)(a3 + 32);
        *(_DWORD *)(a3 + 28) = v7 + 10;
        *(_DWORD *)(a3 + 36) = 0;
        if ( a5 == 15 )
        {
          v9 = *(_DWORD *)v8;
          if ( v9 == 31 )
          {
            *(_DWORD *)(a3 + 36) = 1;
          }
          else if ( v9 != 30 )
          {
            *(_DWORD *)(a3 + 36) = 2;
          }
          v10 = *v7;
          if ( v10 == 31 )
          {
            *(_DWORD *)(a3 + 36) |= 1u;
          }
          else if ( v10 != 30 )
          {
            *(_DWORD *)(a3 + 36) |= 2u;
          }
        }
      }
      **(_DWORD **)(a3 + 28) = v6;
      ++*(_DWORD *)(a3 + 32);
      *(_DWORD *)(a3 + 28) = v6 + 40;
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(v6 + 8);
      if ( a5 != 15 )
        return a3;
      v11 = *(_DWORD *)v6;
      if ( v11 == 31 )
      {
        *(_DWORD *)(a3 + 36) |= 1u;
        return a3;
      }
      if ( v11 == 30 )
        return a3;
      *(_DWORD *)(a3 + 36) |= 2u;
      result = a3;
    }
    else if ( a5 != 15 || *(_DWORD *)a3 != 30 || *(_DWORD *)a1 != 30 )
    {
      result = sub_10047650(a2, a4);
      if ( result )
      {
        *(_DWORD *)result = a5;
        *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
        v13 = *(_DWORD *)(v6 + 8);
        *(_DWORD *)(result + 28) = v6;
        *(_DWORD *)(result + 8) = v13;
        *(_DWORD *)(result + 12) = a6;
        *(_DWORD *)(result + 20) = 2;
        *(_DWORD *)(result + 24) = a3;
        *(_DWORD *)(result + 40) = 0;
      }
    }
    else
    {
      *(double *)(a3 + 24) = *(double *)(a1 + 24) + *(double *)(a3 + 24);
      sub_10047640(a1, a2);
      result = a3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100D1E4C: using guessed type int dword_100D1E4C[];

//----- (100478A0) --------------------------------------------------------
signed int __usercall sub_100478A0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  int v3; // ebx@1
  int v4; // eax@1
  signed int v5; // ebp@2
  signed int *v6; // eax@6
  const char *v7; // eax@7
  int v9; // eax@11

  v3 = *(_DWORD *)(a2 + 24 * *(_DWORD *)(a2 + 96) + 20);
  v4 = *(_DWORD *)(a1 + 24);
  if ( v3 == *(_DWORD *)(v4 + 252) )
  {
    v5 = 123;
  }
  else
  {
    if ( v3 != *(_DWORD *)(v4 + 288) )
      return 29;
    v5 = 124;
  }
  if ( sub_10047620(a1, a2) != a3 )
    return 29;
  sub_10045FA0(a2, a1, a2);
  v6 = (signed int *)(a2 + 24 * *(_DWORD *)(a2 + 96) + 16);
  if ( *v6 )
  {
    v7 = "getter";
    if ( v5 != 123 )
      v7 = "setter";
    sub_10045A60(a1, a2, 0, 0, 151, (char)v7);
    return -1;
  }
  *v6 = v5;
  v9 = sub_10038330(a1, v3);
  if ( !v9 || !sub_10045A60(a1, a2, 0, 5, 158, v9) )
    return -1;
  return a3;
}

//----- (10047960) --------------------------------------------------------
int __cdecl sub_10047960(unsigned int *a1)
{
  unsigned int *v1; // esi@1
  unsigned int v2; // eax@1
  int result; // eax@7
  int v4; // eax@9
  unsigned int *v5; // esi@9
  int v6; // edi@10
  int v7; // esi@13
  signed int v8; // edi@13
  signed int v9; // ebx@13
  int v10; // eax@17
  int v11; // eax@18
  int v12; // eax@28
  unsigned int v13; // esi@28
  int v14; // eax@29

  v1 = a1;
  v2 = *a1;
  while ( 2 )
  {
    switch ( v2 )
    {
      case 0x19u:
        if ( !v1[6] )
          return 0;
        v1 = (unsigned int *)(v1[7] - 40);
        goto LABEL_6;
      case 0x31u:
        v1 = (unsigned int *)v1[7];
LABEL_6:
        v2 = *v1 - 25;
        if ( v2 > 0x21 )
          return 0;
        continue;
      default:
        return 0;
      case 0x25u:
        v4 = sub_10047960((unsigned int *)v1[7]);
        v5 = (unsigned int *)v1[8];
        goto LABEL_10;
      case 0x27u:
        v7 = *(_DWORD *)(v1[7] + 24);
        v8 = 1;
        v9 = 0;
        do
        {
          if ( !v7 )
            break;
          if ( *(_DWORD *)v7 == 41 )
            v9 = 1;
          v10 = *(_DWORD *)(v7 + 28);
          if ( *(_DWORD *)(v10 + 24) )
          {
            v11 = sub_10047960((unsigned int *)(*(_DWORD *)(v10 + 28) - 40));
            if ( v11 || !*(_DWORD *)(v7 + 40) )
              v8 &= v11;
          }
          v7 = *(_DWORD *)(v7 + 40);
        }
        while ( v8 );
        return v8 & v9;
      case 0x2Du:
        return 2;
      case 0x32u:
      case 0x3Au:
        return 1;
      case 0x37u:
        if ( v1[8] )
        {
          result = sub_10047960((unsigned int *)v1[8]);
          if ( result == 1 )
            return result;
        }
        v4 = sub_10047960((unsigned int *)v1[6]);
        v5 = (unsigned int *)v1[7];
LABEL_10:
        v6 = v4;
        if ( v5 )
          v6 = sub_10047960(v5) & v4;
        goto LABEL_12;
      case 0x38u:
        v12 = sub_10047960((unsigned int *)v1[8]);
        v13 = v1[7];
        v6 = v12;
        if ( v13 )
        {
          do
          {
            v14 = sub_10047960(*(unsigned int **)(v13 + 32));
            v13 = *(_DWORD *)(v13 + 28);
            v6 &= v14;
          }
          while ( v13 );
          result = v6;
        }
        else
        {
LABEL_12:
          result = v6;
        }
        return result;
    }
  }
}

//----- (10047AD0) --------------------------------------------------------
#error "10047B06: call analysis failed (funcsize=26)"

//----- (10047B10) --------------------------------------------------------
int __usercall sub_10047B10@<eax>(unsigned int *a1@<eax>)
{
  int result; // eax@2

  if ( sub_10047960(a1) == 1 || (result = sub_10047AD0()) != 0 )
    result = 1;
  return result;
}
// 10047AD0: using guessed type int sub_10047AD0(void);

//----- (10047B30) --------------------------------------------------------
int __usercall sub_10047B30@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4@<bl>)
{
  return sub_1004B250(a4, a2, a3, a1, 0);
}

//----- (10047B40) --------------------------------------------------------
signed int __usercall sub_10047B40@<eax>(int a1@<eax>, int a2@<edi>, int a3)
{
  int v3; // esi@1
  signed int v4; // eax@1
  signed int result; // eax@2

  v3 = a1;
  v4 = sub_10047620(a2, a1);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else if ( v4 == 29 )
  {
    sub_10045FA0(v3, a2, v3);
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 20);
    result = 1;
  }
  else
  {
    *(_DWORD *)(a3 + 24) = 0;
    result = 1;
  }
  return result;
}

//----- (10047B90) --------------------------------------------------------
int __usercall sub_10047B90@<eax>(int a1@<eax>, char a2@<sil>, int a3, int *a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // eax@3
  int result; // eax@4
  int v8; // edx@5
  int v9; // eax@6

  v4 = a1;
  v5 = sub_10049560(a2, a1, a3, a4);
  if ( v5 && sub_10047570(v4, a3, 3) )
  {
    v6 = sub_10047720((int)a4, v4, a3 + 24 * *(_DWORD *)(a3 + 96), -2);
    if ( v6 )
    {
      v8 = *(_DWORD *)(v5 + 4);
      *(_DWORD *)(v6 + 24) = v5;
      *(_DWORD *)(v6 + 28) = v5 + 40;
      *(_DWORD *)(v6 + 4) = v8;
      *(_DWORD *)(v6 + 32) = 1;
      v5 = v6;
      while ( 1 )
      {
        v9 = sub_10049560(1, v4, a3, a4);
        if ( !v9 )
          break;
        **(_DWORD **)(v5 + 28) = v9;
        ++*(_DWORD *)(v5 + 32);
        *(_DWORD *)(v5 + 28) = v9 + 40;
        if ( !sub_10047570(v4, a3, 3) )
        {
          *(_DWORD *)(v5 + 8) = *(_DWORD *)(*(_DWORD *)(v5 + 28) - 32);
          goto LABEL_9;
        }
      }
    }
    result = 0;
  }
  else
  {
LABEL_9:
    result = v5;
  }
  return result;
}

//----- (10047C50) --------------------------------------------------------
int __usercall sub_10047C50@<eax>(int result@<eax>, int a2, int a3, int a4, char a5)
{
  int v5; // ecx@3

  for ( ; *(_DWORD *)result == 28; result = *(_DWORD *)(result + 24) )
    ;
  v5 = *(_DWORD *)result;
  if ( *(_DWORD *)result == 29 || v5 == 22 || v5 == 27 && *(_DWORD *)(result + 12) == 58 || v5 == 23 )
  {
    *(_DWORD *)(a4 + 24) = result;
  }
  else
  {
    sub_10045A60(a2, a3, 0, 0, 130, a5);
    result = 0;
  }
  return result;
}

//----- (10047CB0) --------------------------------------------------------
int __usercall sub_10047CB0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int a4@<edi>, _DWORD *a5, int a6, int a7)
{
  int v7; // esi@1
  int result; // eax@1
  signed int v9; // esi@4

  v7 = a1;
  result = sub_10047C50(a7, a3, a2, a6, (unsigned int)off_10162FE0[a4 == 21]);
  if ( result )
  {
    switch ( *(_DWORD *)result )
    {
      case 0x1D:
        if ( a4 == 20 )
          v9 = v7 != 0 ? 41 : 47;
        else
          v9 = v7 != 0 ? 44 : 50;
        if ( *(_DWORD *)(result + 24) != *(_DWORD *)(*(_DWORD *)(a3 + 24) + 216) )
          goto LABEL_16;
        *a5 |= 0x80u;
        *(_DWORD *)(a6 + 12) = v9;
        result = 1;
        break;
      case 0x16:
        if ( a4 == 20 )
        {
          *(_DWORD *)(a6 + 12) = v7 != 0 ? 42 : 48;
          result = 1;
        }
        else
        {
          *(_DWORD *)(a6 + 12) = v7 != 0 ? 45 : 51;
          result = 1;
        }
        break;
      case 0x1B:
        *(_DWORD *)(result + 12) = 132;
        goto LABEL_12;
      case 0x17:
LABEL_12:
        if ( a4 == 20 )
        {
          *(_DWORD *)(a6 + 12) = v7 != 0 ? 43 : 49;
          result = 1;
        }
        else
        {
          *(_DWORD *)(a6 + 12) = v7 != 0 ? 46 : 52;
          result = 1;
        }
        break;
      default:
        v9 = 0;
LABEL_16:
        *(_DWORD *)(a6 + 12) = v9;
        result = 1;
        break;
    }
  }
  return result;
}
// 10162FE0: using guessed type char *off_10162FE0[2];

//----- (10047DC0) --------------------------------------------------------
signed int __usercall sub_10047DC0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  signed int v4; // eax@1
  int v5; // eax@2
  signed int result; // eax@6
  char v7; // [sp+0h] [bp-4h]@0

  *(_DWORD *)(a3 + 124) |= 8u;
  v4 = sub_10047570(a1, a3, 28);
  *(_DWORD *)(a3 + 124) &= 0xFFFFFFF7;
  if ( v4 )
  {
LABEL_7:
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      v5 = sub_10049560(a3, a1, a3, (int *)a4);
      if ( !v5 )
        break;
      **(_DWORD **)(a2 + 28) = v5;
      ++*(_DWORD *)(a2 + 32);
      *(_DWORD *)(a2 + 28) = v5 + 40;
      if ( !sub_10047570(a1, a3, 3) )
      {
        if ( sub_10045FA0(a3, a1, a3) == 28 )
          goto LABEL_7;
        sub_10045A60(a1, a3, 0, 0, 104, v7);
        break;
      }
    }
    result = 0;
  }
  return result;
}

//----- (10047E40) --------------------------------------------------------
int __usercall sub_10047E40@<eax>(int a1@<esi>, int a2, int a3, int *a4, int a5)
{
  int v5; // edi@1
  int v7; // ebp@3
  signed int v8; // eax@3
  int v9; // ebx@4
  int v10; // eax@5
  int v11; // eax@12
  signed int v12; // eax@14
  int v13; // edi@18
  int v14; // esi@19
  int v15; // esi@22
  int v16; // eax@30
  char v17; // [sp-Ch] [bp-14h]@3
  char v18; // [sp+0h] [bp-8h]@0
  char v19; // [sp+4h] [bp-4h]@1

  v5 = a2;
  if ( (unsigned int)&v19 <= *(_DWORD *)(a2 + 12) )
  {
    sub_10045A60(a2, a3, 0, 0, 26, v18);
    return 0;
  }
  v7 = a3;
  *(_DWORD *)(v7 + 124) |= 8u;
  v17 = a1;
  v8 = sub_100475E0(a2, a3);
  *(_DWORD *)(v7 + 124) &= 0xFFFFFFF7;
  if ( v8 != 51 )
  {
    v11 = sub_1004B7F0(a2, a3, a4);
    if ( v11 )
    {
      v9 = v11;
      goto LABEL_14;
    }
    return 0;
  }
  sub_10045FA0(a1, a2, a3);
  v9 = sub_10047720((int)a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), -2);
  if ( !v9 )
    return 0;
  a1 = a2;
  v10 = sub_10047E40(a2, a2, a3, a4, 0);
  if ( !v10 )
    return 0;
  *(_DWORD *)(v9 + 12) = 35;
  *(_DWORD *)(v9 + 24) = v10;
  *(_DWORD *)(v9 + 28) = v10 + 40;
  *(_DWORD *)(v9 + 32) = 1;
  *(_DWORD *)(v9 + 4) = *(_DWORD *)(v10 + 4);
  if ( sub_10047570(a2, a3, 27) )
  {
    if ( sub_10047DC0(a2, v9, a3, (int)a4) )
    {
      a1 = a2;
      goto LABEL_9;
    }
    return 0;
  }
LABEL_9:
  if ( *(_DWORD *)(v9 + 32) > 0x10000u )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 44, v17);
    return 0;
  }
  v5 = a2;
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(v9 + 28) - 32);
LABEL_14:
  v12 = sub_10045FA0(a1, v5, a3);
  if ( v12 <= 0 )
    return v12 != -1 ? v9 : 0;
  while ( 1 )
  {
    if ( v12 == 22 )
    {
      v13 = sub_10047720((int)a4, v5, a3 + 24 * *(_DWORD *)(a3 + 96), -1);
      if ( !v13 )
        return 0;
      LOBYTE(v14) = a2;
      if ( sub_10045FA0(a2, a2, a3) != 29 )
      {
        sub_10045A60(a2, a3, 0, 0, 77, v17);
        return 0;
      }
      *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(a3 + 24 * *(_DWORD *)(a3 + 96) + 8);
      *(_DWORD *)(v13 + 12) = 53;
      *(_DWORD *)(v13 + 28) = v9;
      *(_DWORD *)(v13 + 24) = *(_DWORD *)(a3 + 24 * *(_DWORD *)(a3 + 96) + 20);
      goto LABEL_37;
    }
    if ( v12 == 23 )
    {
      v15 = a3 + 24 * *(_DWORD *)(a3 + 96);
      v13 = sub_10047720((int)a4, v5, v15, 2);
      if ( !v13 )
        return 0;
      v14 = sub_10047B90(a2, v15, a3, a4);
      if ( !v14 )
        return 0;
      if ( sub_10045FA0(v14, a2, a3) != 24 )
      {
        sub_10045A60(a2, a3, 0, 0, 78, v17);
        return 0;
      }
      *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(a3 + 24 * *(_DWORD *)(a3 + 96) + 8);
      if ( *(_DWORD *)v14 == 31 )
      {
        *(_DWORD *)v13 = 22;
        *(_DWORD *)(v13 + 12) = 53;
        *(_DWORD *)(v13 + 20) = -1;
        *(_DWORD *)(v13 + 28) = v9;
        *(_DWORD *)(v13 + 24) = *(_DWORD *)(v14 + 24);
      }
      else
      {
        *(_DWORD *)(v13 + 12) = 55;
        *(_DWORD *)(v13 + 24) = v9;
        *(_DWORD *)(v13 + 28) = v14;
      }
      goto LABEL_37;
    }
    if ( !a5 || v12 != 27 )
      break;
    v16 = sub_10047720((int)a4, v5, a3 + 24 * *(_DWORD *)(a3 + 96), -2);
    v13 = v16;
    if ( !v16 )
      return 0;
    *(_DWORD *)(v16 + 12) = 58;
    if ( *(_DWORD *)(v9 + 12) == 59 && *(_DWORD *)(v9 + 24) == *(_DWORD *)(*(_DWORD *)(a2 + 24) + 244) )
    {
      *(_DWORD *)(v16 + 12) = 121;
      *a4 |= 0x80u;
    }
    *(_DWORD *)(v16 + 24) = v9;
    *(_DWORD *)(v16 + 28) = v9 + 40;
    *(_DWORD *)(v16 + 32) = 1;
    LOBYTE(v14) = a3;
    *(_DWORD *)(v16 + 4) = *(_DWORD *)(v9 + 4);
    if ( !sub_10047DC0(a2, v16, a3, (int)a4) )
      return 0;
    if ( *(_DWORD *)(v13 + 32) > 0x10000u )
    {
      sub_100110F0(a2, (int)sub_1003ED50, 0, 45, v17);
      return 0;
    }
    *(_DWORD *)(v13 + 8) = *(_DWORD *)(*(_DWORD *)(v13 + 28) - 32);
LABEL_37:
    *(_DWORD *)&v19 = v13;
    v12 = sub_10045FA0(v14, a2, a3);
    v9 = v13;
    if ( v12 <= 0 )
      return v12 != -1 ? v13 : 0;
    v5 = a2;
  }
  sub_10047550(a3);
  return v9;
}

//----- (100481E0) --------------------------------------------------------
signed int __cdecl sub_100481E0(int a1)
{
  int v1; // esi@1
  signed int result; // eax@5
  int v3; // esi@8

  v1 = a1;
  if ( a1 )
  {
    while ( 2 )
    {
      switch ( *(_DWORD *)(v1 + 20) )
      {
        case 1:
          if ( *(_DWORD *)(v1 + 12) )
            goto LABEL_5;
          v1 = *(_DWORD *)(v1 + 24);
          if ( !v1 )
            goto LABEL_5;
          continue;
        default:
          goto LABEL_5;
        case 0xFFFFFFFE:
          if ( *(_DWORD *)v1 == 48 )
            goto LABEL_7;
          v3 = *(_DWORD *)(v1 + 24);
          if ( !v3 )
            goto LABEL_5;
          break;
        case 3:
          if ( sub_100481E0(*(_DWORD *)(v1 + 24)) || sub_100481E0(*(_DWORD *)(v1 + 28)) )
            goto LABEL_7;
          result = sub_100481E0(*(_DWORD *)(v1 + 32));
          goto LABEL_15;
        case 2:
          if ( *(_DWORD *)(v1 + 12) )
            goto LABEL_5;
          if ( !sub_100481E0(*(_DWORD *)(v1 + 24)) )
          {
            result = sub_100481E0(*(_DWORD *)(v1 + 28));
LABEL_15:
            if ( !result )
              return result;
          }
          goto LABEL_7;
      }
      break;
    }
    while ( 1 )
    {
      result = sub_100481E0(v3);
      if ( result )
        break;
      v3 = *(_DWORD *)(v3 + 40);
      if ( !v3 )
        return result;
    }
LABEL_7:
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (100482B0) --------------------------------------------------------
signed int __usercall sub_100482B0@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax@1
  int v4; // ecx@2
  int v5; // eax@5
  int v6; // eax@6
  double v8; // st7@11
  double v9; // [sp+8h] [bp-8h]@9

  v3 = *(_DWORD *)a3;
  if ( *(_DWORD *)a3 != a1 )
  {
    v4 = a1 - 30;
    if ( v4 )
    {
      if ( v4 == 1 && v3 == 30 )
      {
        v5 = sub_1001F6E0(a2, *(double *)(a3 + 24));
        if ( v5 )
        {
          v6 = sub_10038890(a2, v5, 0);
          *(_DWORD *)(a3 + 24) = v6;
          if ( v6 )
          {
            *(_DWORD *)a3 = 31;
            *(_DWORD *)(a3 + 12) = 61;
            return 1;
          }
        }
        return 0;
      }
    }
    else if ( v3 == 31 )
    {
      if ( !sub_10020030(a2, *(_DWORD *)(*(_DWORD *)(a3 + 24) + 8), &v9) )
        return 0;
      v8 = v9;
      *(_DWORD *)a3 = 30;
      *(double *)(a3 + 24) = v8;
      *(_DWORD *)(a3 + 12) = 60;
    }
  }
  return 1;
}

//----- (10048350) --------------------------------------------------------
signed int __usercall sub_10048350@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>, int a4, int a5, int a6)
{
  double v6; // st7@1
  int v7; // esi@1
  long double v8; // st6@1
  signed int result; // eax@3
  char v10; // cl@5
  bool v11; // sf@10
  int v12; // [sp+34h] [bp-18h]@4
  int v13; // [sp+38h] [bp-14h]@2
  double v14; // [sp+3Ch] [bp-10h]@1
  long double v15; // [sp+44h] [bp-8h]@1

  v6 = *(double *)(a2 + 24);
  v7 = a1;
  v14 = v6;
  v8 = *(double *)(a4 + 24);
  v15 = v8;
  switch ( a1 )
  {
    case 24:
    case 25:
      if ( !sub_1001F7A0(a3, v6, &v13) || !sub_1001F7A0(a3, v15, &v12) )
        goto LABEL_3;
      v10 = v12 & 0x1F;
      if ( v7 == 24 )
      {
        v13 <<= v10;
        v6 = (double)v13;
      }
      else
      {
        v13 >>= v10;
        v6 = (double)v13;
      }
      goto LABEL_34;
    case 26:
      if ( sub_1001F840(a3, v6, &v14) && sub_1001F7A0(a3, v15, &v12) )
      {
        v11 = ((LODWORD(v14) >> (v12 & 0x1F)) & 0x80000000) != 0;
        LODWORD(v14) >>= v12 & 0x1F;
        v6 = (double)SLODWORD(v14);
        if ( v11 )
          v6 = v6 + 4294967296.0;
LABEL_34:
        if ( a2 != a5 )
          sub_10047640(a2, a6);
        if ( a4 != a5 )
          sub_10047640(a4, a6);
        *(double *)(a5 + 24) = v6;
        *(_DWORD *)a5 = 30;
        *(_DWORD *)(a5 + 12) = 60;
        *(_DWORD *)(a5 + 20) = 0;
        result = 1;
      }
      else
      {
LABEL_3:
        result = 0;
      }
      return result;
    case 27:
      v6 = v6 + v8;
      goto LABEL_34;
    case 28:
      v6 = v6 - v8;
      goto LABEL_34;
    case 29:
      v6 = v6 * v8;
      goto LABEL_34;
    case 30:
      if ( 0.0 == v8 )
      {
        if ( (HIDWORD(v15) & 0x7FF00000) == 2146435072 && (LODWORD(v15) || HIDWORD(v15) & 0xFFFFF)
          || 0.0 == v6
          || (HIDWORD(v14) & 0x7FF00000) == 2146435072 && (LODWORD(v14) || HIDWORD(v14) & 0xFFFFF) )
        {
          v6 = *(double *)*(_DWORD *)(*(_DWORD *)(a3 + 24) + 468);
        }
        else if ( (HIDWORD(v15) ^ HIDWORD(v14)) >= 0 )
        {
          v6 = *(double *)*(_DWORD *)(*(_DWORD *)(a3 + 24) + 476);
        }
        else
        {
          v6 = *(double *)*(_DWORD *)(*(_DWORD *)(a3 + 24) + 472);
        }
      }
      else
      {
        v6 = v6 / v8;
      }
      goto LABEL_34;
    case 31:
      if ( 0.0 == v8 )
      {
        v6 = *(double *)*(_DWORD *)(*(_DWORD *)(a3 + 24) + 468);
      }
      else if ( (HIDWORD(v14) & 0x7FF00000) == 2146435072 || (HIDWORD(v15) & 0x7FFFFFFF) != 2146435072 || LODWORD(v15) )
      {
        v6 = fmod(v6, v8);
      }
      goto LABEL_34;
    default:
      goto LABEL_34;
  }
}

//----- (100485B0) --------------------------------------------------------
signed int __cdecl sub_100485B0(signed int a1, int a2, int a3)
{
  signed int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@1
  signed int result; // eax@2
  int v7; // ebp@3
  int v8; // ebx@33
  int v9; // ecx@37
  int v10; // eax@37
  int v11; // ebp@44
  int v12; // ecx@46
  int v13; // eax@50
  int i; // esi@52
  int v15; // eax@55
  int v16; // eax@56
  char *v17; // esi@56
  unsigned int v18; // eax@60
  int v19; // edi@60
  int v20; // edi@60
  int v21; // ST04_4@61
  int v22; // eax@61
  void *v23; // eax@69
  int v24; // eax@70
  int v25; // ecx@71
  int v26; // ecx@71
  int v27; // esi@73
  int v28; // ecx@78
  int v29; // edi@78
  int v30; // esi@78
  int v31; // eax@79
  long double v32; // st7@90
  int v33; // ecx@94
  signed int v34; // eax@95
  char v35; // [sp+10h] [bp-18h]@0
  int v36; // [sp+1Ch] [bp-Ch]@1
  int v37; // [sp+20h] [bp-8h]@1
  unsigned int v38; // [sp+20h] [bp-8h]@52
  int v39; // [sp+20h] [bp-8h]@57
  int v40; // [sp+20h] [bp-8h]@78
  char v41; // [sp+24h] [bp-4h]@1

  v3 = a1;
  v4 = 0;
  v5 = 0;
  v36 = 0;
  v37 = 0;
  if ( (unsigned int)&v41 <= *(_DWORD *)(a1 + 12) )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 26, v35);
    return 0;
  }
  v7 = a2;
  switch ( *(_DWORD *)(a2 + 20) )
  {
    case 0xFFFFFFFD:
      result = sub_100485B0(a1, *(_DWORD *)(a2 + 28), a3);
      goto LABEL_20;
    case 0xFFFFFFFE:
      v4 = *(_DWORD *)(a2 + 24);
      v36 = *(_DWORD *)(a2 + 24);
      v5 = v4;
      if ( !v4 )
        goto LABEL_27;
      do
      {
        if ( !sub_100485B0(v3, v4, a3) )
          return 0;
        v4 = *(_DWORD *)(v4 + 40);
      }
      while ( v4 );
      v36 = 0;
      goto LABEL_27;
    case 3:
      v5 = *(_DWORD *)(a2 + 24);
      v4 = *(_DWORD *)(a2 + 28);
      v36 = *(_DWORD *)(a2 + 28);
      v37 = *(_DWORD *)(a2 + 32);
      if ( v5 && !sub_100485B0(a1, v5, a3) || v4 && !sub_100485B0(v3, v4, a3) )
        return 0;
      if ( !v37 )
        goto LABEL_27;
      result = sub_100485B0(v3, v37, a3);
      goto LABEL_20;
    case 2:
      v5 = *(_DWORD *)(a2 + 24);
      v4 = *(_DWORD *)(a2 + 28);
      v36 = *(_DWORD *)(a2 + 28);
      if ( v5 && !sub_100485B0(a1, v5, a3) )
        return 0;
      result = sub_100485B0(v3, v4, a3);
      goto LABEL_20;
    case 1:
      v5 = *(_DWORD *)(a2 + 24);
      if ( v5 )
      {
        result = sub_100485B0(a1, v5, a3);
LABEL_20:
        if ( !result )
          return result;
      }
      goto LABEL_27;
    case 0xFFFFFFFF:
      v5 = *(_DWORD *)(a2 + 28);
      if ( !v5 )
        goto LABEL_27;
      break;
    default:
      goto LABEL_27;
  }
  while ( *(_DWORD *)(v5 + 20) == -1 )
  {
    v5 = *(_DWORD *)(v5 + 28);
    if ( !v5 )
      goto LABEL_27;
  }
  if ( !sub_100485B0(a1, v5, a3) )
    return 0;
LABEL_27:
  switch ( *(_DWORD *)v7 )
  {
    case 0x25:
      if ( sub_100481E0(v4) || sub_100481E0(v37) )
        return 1;
      goto LABEL_30;
    case 5:
LABEL_30:
      if ( *(_DWORD *)v5 == 30 )
      {
        if ( 0.0 != *(double *)(v5 + 24) )
          goto LABEL_43;
        goto LABEL_42;
      }
      if ( *(_DWORD *)v5 == 31 )
      {
        v9 = *(_DWORD *)(v5 + 24);
        v10 = *(_DWORD *)(*(_DWORD *)(v9 + 8) & 0xFFFFFFF8);
        if ( v10 & 0x40000000 )
          v10 = *(_DWORD *)(*(_DWORD *)(v9 + 8) & 0xFFFFFFF8) & ((*(_DWORD *)(*(_DWORD *)(v9 + 8) & 0xFFFFFFF8) & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        if ( !v10 )
        {
LABEL_42:
          v4 = v37;
          goto LABEL_43;
        }
      }
      else
      {
        if ( *(_DWORD *)v5 != 33 )
          return 1;
        v8 = *(_DWORD *)(v5 + 12);
        if ( v8 != 67 )
        {
          if ( v8 != 66 && v8 != 64 )
            return 1;
          goto LABEL_42;
        }
      }
LABEL_43:
      if ( v4 )
      {
        *(_DWORD *)v7 = *(_DWORD *)v4;
        *(_DWORD *)(v7 + 12) = *(_DWORD *)(v4 + 12);
        *(_DWORD *)(v7 + 20) = *(_DWORD *)(v4 + 20);
        *(_DWORD *)(v7 + 24) = *(_DWORD *)(v4 + 24);
        v11 = v7 + 24;
        *(_DWORD *)(v11 + 4) = *(_DWORD *)(v4 + 28);
        *(_DWORD *)(v11 + 8) = *(_DWORD *)(v4 + 32);
        *(_DWORD *)(v11 + 12) = *(_DWORD *)(v4 + 36);
        *(_DWORD *)v4 = 0;
        *(_DWORD *)(v4 + 12) = 0;
        *(_DWORD *)(v4 + 20) = 0;
      }
      else
      {
        *(_DWORD *)v7 = 2;
        *(_DWORD *)(v7 + 20) = 1;
        *(_DWORD *)(v7 + 24) = 0;
      }
      sub_10047640(v4, a3);
      if ( v37 && v37 != v4 )
      {
        sub_10047640(v37, v12);
        return 1;
      }
      return 1;
    case 0xF:
      if ( *(_DWORD *)(v7 + 20) != -2 )
      {
        if ( *(_DWORD *)v5 != 31 )
        {
          if ( *(_DWORD *)v4 != 31 )
            goto LABEL_73;
          v4 = v5;
        }
        if ( !sub_100482B0(31, v3, v4) )
          return 0;
        if ( *(_DWORD *)v5 != 31 || *(_DWORD *)v36 != 31 )
          return 1;
        v23 = sub_1001B450(
                v3,
                *(_DWORD *)(*(_DWORD *)(v5 + 24) + 8) & 0xFFFFFFF8,
                (void *)(*(_DWORD *)(*(_DWORD *)(v36 + 24) + 8) & 0xFFFFFFF8));
        if ( v23 )
        {
          v24 = sub_10038890(v3, (int)v23, 0);
          *(_DWORD *)(v7 + 24) = v24;
          if ( v24 )
          {
            v25 = a3;
            *(_DWORD *)v7 = 31;
            *(_DWORD *)(v7 + 12) = 61;
            *(_DWORD *)(v7 + 20) = 0;
            sub_10047640(v5, v25);
            sub_10047640(v36, v26);
            return 1;
          }
        }
        return 0;
      }
      v13 = *(_DWORD *)(v7 + 36);
      if ( v13 & 2 )
        return 1;
      if ( v13 == 1 )
      {
        v38 = 0;
        for ( i = v5; i; v38 += *(_DWORD *)(*(_DWORD *)(v15 + 8) & 0xFFFFFFF8) )
        {
          v3 = a1;
          if ( !sub_100482B0(31, a1, i) )
            return 0;
          if ( *(_DWORD *)i != 31 )
            return 1;
          v15 = *(_DWORD *)(i + 24);
          i = *(_DWORD *)(i + 40);
        }
        v16 = sub_10011830(v3, 2 * v38 + 2);
        v17 = (char *)v16;
        if ( !v16 )
          return 0;
        v39 = sub_1001AB10(v3, v16, v38, 0);
        if ( !v39 )
        {
          sub_10010340(v3, (unsigned int)v17);
          return 0;
        }
        if ( v5 )
        {
          do
          {
            v18 = *(_DWORD *)(*(_DWORD *)(v5 + 24) + 8) & 0xFFFFFFF8;
            v19 = 2 * *(_DWORD *)v18;
            memcpy(v17, *(const void **)(v18 + 4), 2 * *(_DWORD *)v18);
            v17 += v19;
            v20 = *(_DWORD *)(v5 + 40);
            sub_10047640(v5, a3);
            v5 = v20;
          }
          while ( v20 );
        }
        v21 = a1;
        *(_WORD *)v17 = 0;
        v22 = sub_10038890(v21, v39, 0);
        *(_DWORD *)(v7 + 24) = v22;
        if ( v22 )
        {
          *(_DWORD *)v7 = 31;
          *(_DWORD *)(v7 + 12) = 61;
          *(_DWORD *)(v7 + 20) = 0;
          return 1;
        }
        return 0;
      }
LABEL_73:
      v27 = v5;
      if ( *(_DWORD *)(v7 + 20) != -2 )
      {
        if ( sub_100482B0(30, v3, v5)
          && sub_100482B0(30, v3, v36)
          && (*(_DWORD *)v5 != 30 || *(_DWORD *)v36 != 30 || sub_10048350(*(_DWORD *)(v7 + 12), v5, v3, v36, v7, a3)) )
        {
          return 1;
        }
        return 0;
      }
      if ( v5 )
      {
        do
        {
          if ( !sub_100482B0(30, a1, v27) )
            return 0;
          if ( *(_DWORD *)v27 != 30 )
            return 1;
          v27 = *(_DWORD *)(v27 + 40);
        }
        while ( v27 );
      }
      v28 = *(_DWORD *)(v5 + 40);
      v29 = a1;
      v30 = *(_DWORD *)(v28 + 40);
      v40 = *(_DWORD *)(v7 + 12);
      if ( !sub_10048350(v40, v5, a1, v28, v7, a3) )
        return 0;
      v31 = v30;
      if ( v30 )
      {
        do
        {
          v30 = *(_DWORD *)(v30 + 40);
          if ( !sub_10048350(v40, v7, v29, v31, v7, a3) )
            return 0;
          v31 = v30;
        }
        while ( v30 );
        return 1;
      }
      return 1;
    case 0x11:
      if ( *(_DWORD *)(v7 + 20) )
        goto LABEL_73;
      return 1;
    case 0xE:
    case 0x10:
    case 0x12:
      goto LABEL_73;
    case 0x13:
      if ( *(_DWORD *)v5 != 30 )
        return 1;
      v32 = *(double *)(v5 + 24);
      switch ( *(_DWORD *)(v7 + 12) )
      {
        case 0x21:
          if ( !sub_1001F7A0(v3, v32, &a1) )
            return 0;
          a1 = ~a1;
          v32 = (double)a1;
          goto LABEL_94;
        case 0x22:
          v32 = -v32;
          goto LABEL_94;
        case 0x52:
LABEL_94:
          v33 = a3;
          *(long double *)(v7 + 24) = v32;
          *(_DWORD *)v7 = 30;
          *(_DWORD *)(v7 + 12) = 60;
          *(_DWORD *)(v7 + 20) = 0;
          sub_10047640(v5, v33);
          result = 1;
          break;
        case 0x20:
          *(_DWORD *)v7 = 33;
          v34 = 67;
          if ( 0.0 != v32 )
            v34 = 66;
          *(_DWORD *)(v7 + 12) = v34;
          *(_DWORD *)(v7 + 20) = 0;
          result = 1;
          break;
        default:
          return 1;
      }
      return result;
    default:
      return 1;
  }
}

//----- (10048CA0) --------------------------------------------------------
#error "10048CB7: call analysis failed (funcsize=100)"

//----- (10048DA0) --------------------------------------------------------
int __usercall sub_10048DA0@<eax>(char a1@<sil>, int a2, int a3, int *a4)
{
  int v4; // ebx@1
  signed int v5; // eax@1
  int v6; // esi@2
  int v7; // eax@2
  int v8; // ebp@2
  int result; // eax@3
  int v10; // eax@4
  int v11; // ecx@5
  int v12; // esi@6
  int v13; // ebp@6
  int v14; // eax@7
  int v15; // esi@7
  int v16; // esi@10
  int v17; // ebp@10
  int v18; // eax@11
  int v19; // eax@15
  int v20; // ebp@15
  signed int v21; // eax@17
  int v22; // eax@19
  int v23; // esi@19
  int v24; // [sp+18h] [bp+8h]@1
  int v25; // [sp+18h] [bp+8h]@17

  v4 = a3;
  *(_DWORD *)(v4 + 124) |= 8u;
  v5 = sub_10045FA0(a1, a2, a3);
  *(_DWORD *)(v4 + 124) &= 0xFFFFFFF7;
  v24 = v5;
  switch ( v5 + 1 )
  {
    case 16:
    case 17:
    case 20:
      v6 = v4 + 24 * *(_DWORD *)(v4 + 96);
      v7 = sub_10047720((int)a4, a2, v6, 1);
      v8 = v7;
      if ( !v7 )
        goto LABEL_3;
      *(_DWORD *)v7 = 19;
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96) + 16);
      v10 = sub_10048DA0(v6, a2, v4, a4);
      if ( !v10 )
        goto LABEL_3;
      v11 = *(_DWORD *)(v10 + 8);
      *(_DWORD *)(v8 + 24) = v10;
      *(_DWORD *)(v8 + 8) = v11;
      return v8;
    case 0:
      goto LABEL_3;
    case 21:
    case 22:
      v12 = v4 + 24 * *(_DWORD *)(v4 + 96);
      v13 = sub_10047720((int)a4, a2, v12, 1);
      if ( !v13 )
        goto LABEL_3;
      v14 = sub_10047E40((unsigned __int8)v12, a2, v4, a4, 1);
      v15 = v14;
      if ( !v14 || !sub_10047CB0(1, v4, a2, v24, a4, v13, v14) )
        goto LABEL_3;
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(v15 + 8);
      return v13;
    case 53:
      v16 = v4 + 24 * *(_DWORD *)(v4 + 96);
      v17 = sub_10047720((int)a4, a2, v16, 1);
      if ( !v17 )
        goto LABEL_3;
      v18 = sub_10048DA0(v16, a2, v4, a4);
      if ( !v18 )
        goto LABEL_3;
      for ( *(_DWORD *)(v17 + 8) = *(_DWORD *)(v18 + 8); *(_DWORD *)v18 == 28; v18 = *(_DWORD *)(v18 + 24) )
        ;
      *(_DWORD *)(v17 + 24) = v18;
      return v17;
    default:
      sub_10047550(v4);
      v19 = sub_10047E40(a1, a2, v4, a4, 1);
      v20 = v19;
      if ( !v19 )
        goto LABEL_3;
      if ( *(_WORD *)(v4 + 104) != *(_WORD *)(v19 + 10) )
        goto LABEL_22;
      v21 = sub_10047620(a2, v4);
      v25 = v21;
      if ( v21 != 20 && v21 != 21 )
        goto LABEL_22;
      sub_10045FA0(a1, a2, v4);
      v22 = sub_10047720((int)a4, a2, v4 + 24 * *(_DWORD *)(v4 + 96), 1);
      v23 = v22;
      if ( v22 && sub_10047CB0(0, v4, a2, v25, a4, v22, v20) )
      {
        *(_DWORD *)(v23 + 4) = *(_DWORD *)(v20 + 4);
        v20 = v23;
LABEL_22:
        result = v20;
      }
      else
      {
LABEL_3:
        result = 0;
      }
      return result;
  }
}

//----- (10048FE0) --------------------------------------------------------
int __usercall sub_10048FE0@<eax>(int a1@<ebx>, int a2@<edi>, char a3@<sil>, int *a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // ebp@4
  int v7; // ST20_4@4
  int v8; // eax@4

  result = sub_10048DA0(a3, a1, a2, a4);
  v5 = result;
  if ( result )
  {
    do
    {
      if ( !sub_10047570(a1, a2, 17) && !sub_10047570(a1, a2, 18) )
        break;
      v6 = *(_DWORD *)(a2 + 24 * *(_DWORD *)(a2 + 96));
      v7 = *(_DWORD *)(a2 + 24 * *(_DWORD *)(a2 + 96) + 16);
      v8 = sub_10048DA0(v5, a1, a2, a4);
      v5 = sub_10047750(v8, (int)a4, v5, a1, v6, v7);
    }
    while ( v5 );
    result = v5;
  }
  return result;
}

//----- (10049060) --------------------------------------------------------
int __usercall sub_10049060@<eax>(int a1@<eax>, int a2@<ecx>, char a3@<sil>, int *a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int result; // eax@1
  int v7; // esi@1
  int v8; // ebp@4
  int v9; // eax@4

  v4 = a1;
  v5 = a2;
  result = sub_10048FE0(a2, a1, a3, a4);
  v7 = result;
  if ( result )
  {
    do
    {
      if ( !sub_10047570(v5, v4, 15) && !sub_10047570(v5, v4, 16) )
        break;
      v8 = *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96));
      v9 = sub_10048FE0(v5, v4, v7, a4);
      v7 = sub_10047750(v9, (int)a4, v7, v5, v8, (v8 != 15) + 27);
    }
    while ( v7 );
    result = v7;
  }
  return result;
}

//----- (100490E0) --------------------------------------------------------
int __usercall sub_100490E0@<eax>(int a1@<ebx>, int a2@<edi>, char a3@<sil>, int *a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // ST18_4@3
  int v7; // eax@3

  result = sub_10049060(a2, a1, a3, a4);
  v5 = result;
  if ( result )
  {
    do
    {
      if ( !sub_10047570(a1, a2, 14) )
        break;
      v6 = *(_DWORD *)(a2 + 24 * *(_DWORD *)(a2 + 96) + 16);
      v7 = sub_10049060(a2, a1, v5, a4);
      v5 = sub_10047750(v7, (int)a4, v5, a1, 14, v6);
    }
    while ( v5 );
    result = v5;
  }
  return result;
}

//----- (10049150) --------------------------------------------------------
int __usercall sub_10049150@<eax>(int a1@<eax>, int a2@<ecx>, char a3@<sil>, int *a4)
{
  int *v4; // ebp@1
  int v5; // edi@1
  int v6; // ebx@1
  unsigned int v7; // eax@1
  int *v8; // ST0C_4@1
  int result; // eax@1
  int v10; // esi@1
  int v11; // ST24_4@6
  int v12; // ST20_4@6
  int v13; // eax@6
  int v14; // [sp+1Ch] [bp+4h]@1

  v4 = a4;
  v5 = a1;
  v6 = a2;
  v7 = *a4 & 0xFFFFFFEF;
  v8 = a4;
  v14 = *a4 & 0x10;
  *v8 = v7;
  result = sub_100490E0(a2, v5, a3, v8);
  v10 = result;
  if ( result )
  {
    while ( sub_10047570(v6, v5, 13) || !v14 && sub_10047570(v6, v5, 47) || sub_10047570(v6, v5, 59) )
    {
      v11 = *(_DWORD *)(v5 + 24 * *(_DWORD *)(v5 + 96));
      v12 = *(_DWORD *)(v5 + 24 * *(_DWORD *)(v5 + 96) + 16);
      v13 = sub_100490E0(v6, v5, v10, v4);
      result = sub_10047750(v13, (int)v4, v10, v6, v11, v12);
      v10 = result;
      if ( !result )
      {
        *v4 |= v14;
        return result;
      }
    }
    *v4 |= v14;
    result = v10;
  }
  else
  {
    *v4 |= v14;
  }
  return result;
}

//----- (10049230) --------------------------------------------------------
int __usercall sub_10049230@<eax>(int a1@<ebx>, int a2@<edi>, char a3@<sil>, int *a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // ST18_4@3
  int v7; // eax@3

  result = sub_10049150(a2, a1, a3, a4);
  v5 = result;
  if ( result )
  {
    do
    {
      if ( !sub_10047570(a1, a2, 12) )
        break;
      v6 = *(_DWORD *)(a2 + 24 * *(_DWORD *)(a2 + 96) + 16);
      v7 = sub_10049150(a2, a1, v5, a4);
      v5 = sub_10047750(v7, (int)a4, v5, a1, 12, v6);
    }
    while ( v5 );
    result = v5;
  }
  return result;
}

//----- (100492A0) --------------------------------------------------------
int __usercall sub_100492A0@<eax>(int a1@<eax>, int a2@<ecx>, char a3@<sil>, int *a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int result; // eax@1
  int v7; // esi@1
  int v8; // eax@3

  v4 = a1;
  v5 = a2;
  result = sub_10049230(a2, a1, a3, a4);
  v7 = result;
  if ( result )
  {
    do
    {
      if ( !sub_10047570(v5, v4, 11) )
        break;
      v8 = sub_10049230(v5, v4, v7, a4);
      v7 = sub_10047750(v8, (int)a4, v7, v5, 11, 17);
    }
    while ( v7 );
    result = v7;
  }
  return result;
}

//----- (10049300) --------------------------------------------------------
int __usercall sub_10049300@<eax>(int *a1@<ebx>, int a2@<edi>, char a3@<sil>, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // eax@3
  int *v7; // [sp+0h] [bp-Ch]@0

  result = sub_100492A0(a4, a2, a3, v7);
  v5 = result;
  if ( result )
  {
    do
    {
      if ( !sub_10047570(a2, a4, 10) )
        break;
      v6 = sub_100492A0(a4, a2, v5, a1);
      v5 = sub_10047750(v6, (int)a1, v5, a2, 10, 16);
    }
    while ( v5 );
    result = v5;
  }
  return result;
}

//----- (10049360) --------------------------------------------------------
int __usercall sub_10049360@<eax>(int *a1@<eax>, int a2@<ecx>, char a3@<sil>, int a4)
{
  int *v4; // ebx@1
  int v5; // edi@1
  int result; // eax@1
  int v7; // esi@1
  int v8; // eax@3

  v4 = a1;
  v5 = a2;
  result = sub_10049300(a1, a2, a3, a4);
  v7 = result;
  if ( result )
  {
    do
    {
      if ( !sub_10047570(v5, a4, 9) )
        break;
      v8 = sub_10049300(v4, v5, v7, a4);
      v7 = sub_10047750(v8, (int)v4, v7, v5, 9, 15);
    }
    while ( v7 );
    result = v7;
  }
  return result;
}

//----- (100493C0) --------------------------------------------------------
int __usercall sub_100493C0@<eax>(char a1@<sil>, int a2, int a3, int *a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // eax@3

  result = sub_10049360(a4, a2, a1, a3);
  v5 = result;
  if ( result )
  {
    if ( sub_10047570(a2, a3, 8) )
    {
      v6 = sub_100493C0(v5, a2, a3, a4);
      result = sub_10047750(v6, (int)a4, v5, a2, 8, 69);
    }
    else
    {
      result = v5;
    }
  }
  return result;
}

//----- (10049420) --------------------------------------------------------
int __usercall sub_10049420@<eax>(char a1@<sil>, int a2, int a3, int *a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // eax@3

  result = sub_100493C0(a1, a2, a3, a4);
  v5 = result;
  if ( result )
  {
    if ( sub_10047570(a2, a3, 7) )
    {
      v6 = sub_10049420(v5, a2, a3, a4);
      result = sub_10047750(v6, (int)a4, v5, a2, 7, 68);
    }
    else
    {
      result = v5;
    }
  }
  return result;
}

//----- (10049480) --------------------------------------------------------
int __usercall sub_10049480@<eax>(int a1@<eax>, int *a2@<ebx>, char a3@<sil>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ST20_4@4
  int v8; // eax@8
  int v9; // edx@9
  int *v10; // [sp+0h] [bp-1Ch]@0
  char v11; // [sp+4h] [bp-18h]@0
  int v12; // [sp+14h] [bp-8h]@3
  int v13; // [sp+18h] [bp-4h]@4

  v4 = a1;
  v5 = sub_10049420(a3, a1, a4, v10);
  if ( v5 && sub_10047570(v4, a4, 5) )
  {
    v12 = v5;
    v5 = sub_10047720((int)a2, v4, a4 + 24 * *(_DWORD *)(a4 + 96), 3);
    if ( !v5 )
      return 0;
    v6 = *a2;
    *a2 &= 0xFFFFFFEF;
    v13 = sub_10049560(v5, v4, a4, a2);
    *a2 = v6 | *a2 & 0xE0;
    if ( !v13 )
      return 0;
    if ( sub_10045FA0(v5, v4, a4) != 6 )
    {
      sub_10045A60(v4, a4, 0, 0, 103, v11);
      return 0;
    }
    v8 = sub_10049560(v5, v4, a4, a2);
    if ( !v8 )
      return 0;
    *(_DWORD *)(v5 + 4) = *(_DWORD *)(v12 + 4);
    v9 = *(_DWORD *)(v8 + 8);
    *(_DWORD *)(v5 + 24) = v12;
    *(_DWORD *)(v5 + 8) = v9;
    *(_DWORD *)(v5 + 28) = v13;
    *(_DWORD *)(v5 + 32) = v8;
  }
  return v5;
}

//----- (10049560) --------------------------------------------------------
int __usercall sub_10049560@<eax>(char a1@<sil>, int a2, int a3, int *a4)
{
  int v4; // edi@1
  int result; // eax@2
  int v6; // ebx@3
  signed int v7; // eax@4
  int i; // esi@8
  int v9; // edx@11
  int v10; // eax@16
  char v11; // [sp-Ch] [bp-14h]@4
  char v12; // [sp+0h] [bp-8h]@0
  char v13; // [sp+4h] [bp-4h]@1
  int v14; // [sp+Ch] [bp+4h]@8

  v4 = a2;
  if ( (unsigned int)&v13 > *(_DWORD *)(a2 + 12) )
  {
    result = sub_10049480(a2, a4, a1, a3);
    v6 = result;
    if ( result )
    {
      v11 = a1;
      v7 = sub_10045FA0(a1, a2, a3);
      if ( v7 == 29 && (v7 = sub_100478A0(a2, a3, 4), v7 == -1) )
      {
LABEL_18:
        result = 0;
      }
      else if ( v7 == 4 )
      {
        v14 = *(_DWORD *)(a3 + 24 * *(_DWORD *)(a3 + 96) + 16);
        for ( i = v6; *(_DWORD *)i == 28; i = *(_DWORD *)(i + 24) )
          ;
        switch ( *(_DWORD *)i )
        {
          case 0x1D:
            v9 = *(_DWORD *)(i + 24);
            *(_DWORD *)(i + 12) = 109;
            if ( v9 == *(_DWORD *)(*(_DWORD *)(v4 + 24) + 216) )
              *a4 |= 0x80u;
            break;
          case 0x16:
            *(_DWORD *)(i + 12) = 54;
            break;
          case 0x17:
            *(_DWORD *)(i + 12) = 56;
            break;
          case 0x1B:
            *(_DWORD *)(i + 12) = 132;
            break;
          default:
            sub_10045A60(v4, a3, 0, 0, 129, v11);
            goto LABEL_18;
        }
        v10 = sub_10049560(i, v4, a3, a4);
        result = sub_10047750(v10, (int)a4, i, v4, 4, v14);
      }
      else
      {
        sub_10047550(a3);
        result = v6;
      }
    }
  }
  else
  {
    sub_10045A60(a2, a3, 0, 0, 26, v12);
    result = 0;
  }
  return result;
}

//----- (100496B0) --------------------------------------------------------
int __usercall sub_100496B0@<eax>(int a1@<eax>, char a2@<bl>, int a3, int a4)
{
  int v4; // ebp@1
  int v5; // edi@1
  int v6; // eax@1
  int v7; // esi@1
  int result; // eax@2
  int v9; // edx@3
  int v10; // eax@4
  unsigned int v11; // eax@6
  unsigned int v12; // eax@6
  int v13; // edx@14
  int v14; // ebx@14
  int v15; // eax@14
  int v16; // esi@15
  _DWORD *v17; // ecx@19
  _DWORD *v18; // eax@19
  int v19; // ebp@25
  char *v20; // edx@32
  int v21; // ecx@37
  int (__cdecl **v22)(int, int, int, int, int); // edx@48
  signed int (__cdecl *v23)(int, int, signed int, _DWORD *); // ecx@51
  int v24; // eax@52
  void (__cdecl *v25)(int, int, int); // edx@64
  int v26; // eax@79
  void (__cdecl *v27)(int, int, int); // eax@84
  char v28; // [sp-4h] [bp-40h]@12
  signed int v29; // [sp+Ch] [bp-30h]@12
  int v30; // [sp+10h] [bp-2Ch]@1
  signed int (*v31)(); // [sp+14h] [bp-28h]@13
  unsigned int v32; // [sp+18h] [bp-24h]@6
  signed int (*v33)(); // [sp+1Ch] [bp-20h]@8
  int v34; // [sp+20h] [bp-1Ch]@3
  signed int (*v35)(); // [sp+24h] [bp-18h]@13
  signed int (*v36)(); // [sp+28h] [bp-14h]@8
  int v37; // [sp+2Ch] [bp-10h]@6
  int v38; // [sp+30h] [bp-Ch]@45
  unsigned int v39; // [sp+34h] [bp-8h]@6
  int v40; // [sp+38h] [bp-4h]@45

  v4 = a3;
  v5 = a1;
  v6 = sub_10047720(a4, a1, a3 + 24 * *(_DWORD *)(a3 + 96), -2);
  LOBYTE(v7) = 0;
  v30 = v6;
  if ( !v6 )
    return 0;
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(a3 + 24 * *(_DWORD *)(a3 + 96) + 16);
  *(_DWORD *)(v6 + 36) = 0;
  *(_DWORD *)(v6 + 28) = v6 + 24;
  *(_DWORD *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  v9 = *(_DWORD *)(v5 + 56);
  v34 = *(_DWORD *)(v5 + 56);
  if ( *(_BYTE *)(v9 + 76) & 0x30 )
  {
    do
    {
      v10 = *(_DWORD *)(v9 + 44);
      if ( !v10 )
        break;
      v34 = *(_DWORD *)(v9 + 44);
      v9 = *(_DWORD *)(v9 + 44);
    }
    while ( *(_BYTE *)(v10 + 76) & 0x30 );
  }
  v11 = *(_DWORD *)(v9 + 8);
  v32 = v11;
  v12 = *(_DWORD *)(*(_DWORD *)(v11 + 4) + 8) & 0xFFFFFFFE;
  v37 = *(_DWORD *)(v9 + 16);
  v39 = v12;
  if ( !v37 )
    goto LABEL_11;
  if ( (char **)v12 != &off_101621B8 )
  {
    if ( (char **)v12 == &off_10162110 )
    {
      v33 = (signed int (*)())sub_10027800;
      v36 = (signed int (*)())sub_10027840;
      goto LABEL_12;
    }
LABEL_11:
    v33 = *(signed int (**)())(v12 + 16);
    v36 = *(signed int (**)())(v12 + 20);
    goto LABEL_12;
  }
  v33 = sub_1002FB80;
  v36 = (signed int (*)())sub_1002FB50;
LABEL_12:
  v29 = 1;
  v28 = a2;
  while ( 1 )
  {
    v31 = v33;
    v35 = v36;
    if ( sub_10045FA0(v7, v5, v4) != 29 )
      break;
    v13 = a4;
    v14 = *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96) + 20);
    v15 = *(_DWORD *)(a4 + 16);
    if ( v15 )
    {
      v16 = *sub_10051360(v15, *(_DWORD *)(v14 + 20), *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96) + 20));
      if ( !v16 )
        goto LABEL_16;
    }
    else
    {
      v17 = (_DWORD *)(a4 + 12);
      v18 = (_DWORD *)(a4 + 12);
      v16 = *(_DWORD *)(a4 + 12);
      if ( !v16 )
        goto LABEL_17;
      while ( *(_DWORD *)(v16 + 8) != v14 )
      {
        v18 = (_DWORD *)v16;
        v16 = *(_DWORD *)v16;
        if ( !v16 )
          goto LABEL_17;
      }
      *v18 = *(_DWORD *)v16;
      *(_DWORD *)v16 = *v17;
      *v17 = v16;
    }
    if ( !v16 )
    {
LABEL_16:
      v13 = a4;
LABEL_17:
      v16 = sub_10038C10(v5, v14, v13 + 12);
      if ( !v16 )
        return 0;
      goto LABEL_44;
    }
    v19 = *(_DWORD *)(v16 + 12);
    if ( *(_BYTE *)(v5 + 300) & 1 || *(_DWORD *)(v30 + 12) == 126 || v19 == 126 )
    {
      if ( !sub_10038330(v5, v14) )
        return 0;
      if ( v19 == 125 || v19 == 74 )
        v20 = "function";
      else
        v20 = v19 == 126 ? "const" : "var";
      v21 = *(_DWORD *)(v30 + 12) == 126 || v19 == 126 ? 0 : 5;
      if ( !sub_10045A60(v5, a3, 0, v21, 155, (char)v20) )
        return 0;
    }
    if ( *(_DWORD *)(v30 + 12) == 127 && v19 == 74 )
      *(_DWORD *)a4 |= 0x20u;
    v4 = a3;
LABEL_44:
    *(_DWORD *)(v16 + 12) = *(_DWORD *)(v30 + 12);
    v7 = sub_10047720(a4, v5, v4 + 24 * *(_DWORD *)(v4 + 96), -1);
    if ( !v7 )
      return 0;
    *(_DWORD *)(v7 + 12) = 59;
    *(_DWORD *)(v7 + 24) = v14;
    *(_DWORD *)(v7 + 28) = 0;
    *(_DWORD *)(v7 + 32) = -1;
    *(_DWORD *)(v7 + 36) = 2 * (*(_DWORD *)(v30 + 12) == 126) + 5;
    **(_DWORD **)(v30 + 28) = v7;
    ++*(_DWORD *)(v30 + 32);
    *(_DWORD *)(v30 + 28) = v7 + 40;
    if ( !(*(int (__cdecl **)(int, unsigned int, int, int *, int *))(*(_DWORD *)(*(_DWORD *)v32 + 4) + 8))(
            v5,
            v32,
            v14,
            &v40,
            &v38) )
      return 0;
    if ( v38 )
    {
      if ( v40 == v32 )
      {
        v22 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v40 + 4);
        if ( v22 == &off_101614B0 || v22 && *v22 == off_101614B0 )
        {
          v23 = *(signed int (__cdecl **)(int, int, signed int, _DWORD *))(v38 + 4);
          if ( (char *)v23 == (char *)sub_1002FB00 )
          {
            v24 = sub_10038330(v5, v14);
            if ( v24 )
            {
              if ( *(_DWORD *)(v30 + 12) == 126 )
              {
                sub_10045A60(v5, v4, 0, 0, 164, v24);
                v29 = 0;
              }
              else
              {
                v29 = sub_10045A60(v5, v4, 0, 5, 127, v24);
              }
            }
            else
            {
              v29 = 0;
            }
          }
          else if ( v37 )
          {
            if ( (char **)v39 != &off_101621B8 && (char **)v39 == &off_10162110 && v23 != sub_10027800 )
            {
              v31 = *(signed int (**)())(v38 + 4);
              v35 = *(signed int (**)())(v38 + 8);
            }
            if ( !sub_10015C70(v5, v32, v38, 0, *(_BYTE *)(v38 + 16), v31, v35) )
              v29 = 0;
          }
          goto LABEL_76;
        }
      }
      v25 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v40 + 4) + 52);
      if ( v25 )
        v25(v5, v40, v38);
      v38 = 0;
    }
    if ( (char *)v33 == (char *)sub_10027800 )
    {
      v31 = *(signed int (**)())(v39 + 16);
      v35 = *(signed int (**)())(v39 + 20);
    }
    if ( v31 == sub_1002FB80
      && v14 != *(_DWORD *)(*(_DWORD *)(v5 + 24) + 216)
      && *(_DWORD *)(v34 + 52) == v32
      && !sub_10040580(a4) )
    {
      if ( !sub_10015BB0(v5, v32, v14, v31, v35, -1, *(_DWORD *)(v7 + 36) | 0x40, 8, *(_WORD *)(v37 + 20)) )
        v29 = 0;
      ++*(_WORD *)(v37 + 20);
    }
LABEL_76:
    if ( sub_10047570(v5, v4, 4) )
    {
      if ( *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96) + 16) )
      {
        sub_10045A60(v5, v4, 0, 0, 128, v28);
        v29 = 0;
      }
      else
      {
        v26 = sub_10049560(v7, v5, v4, (int *)a4);
        *(_DWORD *)(v7 + 28) = v26;
        if ( v26 )
        {
          *(_DWORD *)(v7 + 12) = *(_DWORD *)(v30 + 12) != 126 ? 109 : 14;
          if ( v14 == *(_DWORD *)(*(_DWORD *)(v5 + 24) + 216) )
            *(_DWORD *)a4 |= 0x80u;
        }
        else
        {
          v29 = 0;
        }
      }
    }
    if ( v38 )
    {
      v27 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v40 + 4) + 52);
      if ( v27 )
        v27(v5, v40, v38);
    }
    if ( !v29 )
      return 0;
    if ( !sub_10047570(v5, v4, 3) )
    {
      result = v30;
      *(_DWORD *)(v30 + 8) = *(_DWORD *)(*(_DWORD *)(v30 + 28) - 32);
      return result;
    }
  }
  sub_10045A60(v5, v4, 0, 0, 102, v28);
  return 0;
}
// 100496B0: could not find valid save-restore pair for ebx
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);
// 10162110: using guessed type char *off_10162110;
// 101621B8: using guessed type char *off_101621B8;

//----- (10049BF0) --------------------------------------------------------
int __usercall sub_10049BF0@<eax>(char a1@<sil>, int a2, int a3, int a4)
{
  int v4; // ebx@1
  signed int v5; // eax@1
  int result; // eax@4
  int v7; // edi@5
  int v8; // esi@7
  int v9; // eax@9
  int v10; // ebx@9
  int v11; // esi@13
  int v12; // eax@22
  int v13; // esi@23
  _DWORD *v14; // eax@23
  int v15; // esi@29
  int v16; // eax@29
  int v17; // ecx@31
  int v18; // eax@32
  bool v19; // zf@33
  int v20; // eax@35
  int v21; // esi@35
  int *v22; // edi@36
  signed int v23; // eax@36
  int v24; // eax@40
  int *v25; // ecx@41
  int v26; // edi@42
  int v27; // ebx@46
  int v28; // edi@51
  int v29; // eax@52
  int v30; // ebx@53
  int v31; // ecx@54
  int v32; // esi@55
  int v33; // eax@56
  int v34; // esi@59
  int v35; // esi@62
  int v36; // edi@63
  signed int v37; // eax@65
  int v38; // eax@74
  int v39; // eax@78
  int v40; // eax@87
  int v41; // eax@87
  int v42; // esi@88
  signed int v43; // eax@89
  signed int v44; // eax@94
  int v45; // eax@97
  int v46; // eax@101
  int v47; // ebx@101
  int v48; // esi@103
  int v49; // esi@105
  int v50; // eax@105
  int v51; // edi@105
  int v52; // esi@111
  int v53; // edi@116
  int v54; // eax@116
  int v55; // eax@121
  int v56; // eax@134
  int v57; // esi@143
  int v58; // eax@144
  int v59; // eax@148
  int v60; // esi@149
  int v61; // eax@150
  int v62; // ecx@150
  int v63; // eax@162
  int v64; // esi@163
  int v65; // ecx@164
  int v66; // eax@164
  _DWORD *v67; // edx@165
  int v68; // esi@179
  int v69; // edi@179
  int v70; // edx@187
  int v71; // eax@188
  signed int v72; // eax@193
  _DWORD *v73; // esi@198
  int v74; // eax@198
  int v75; // edi@205
  _DWORD *v76; // eax@211
  int v77; // esi@213
  int v78; // eax@217
  int v79; // ebx@221
  int v80; // edx@222
  int v81; // eax@224
  signed int v82; // eax@227
  char v83; // [sp+0h] [bp-44h]@0
  int v84; // [sp+10h] [bp-34h]@22
  int v85; // [sp+10h] [bp-34h]@90
  int v86; // [sp+10h] [bp-34h]@111
  int v87; // [sp+10h] [bp-34h]@182
  int v88; // [sp+10h] [bp-34h]@185
  int v89; // [sp+14h] [bp-30h]@6
  int v90; // [sp+14h] [bp-30h]@17
  int v91; // [sp+14h] [bp-30h]@66
  int v92; // [sp+18h] [bp-2Ch]@29
  int v93; // [sp+18h] [bp-2Ch]@95
  int v94; // [sp+18h] [bp-2Ch]@108
  signed int v95; // [sp+1Ch] [bp-28h]@23
  signed int v96; // [sp+20h] [bp-24h]@13
  int v97; // [sp+24h] [bp-20h]@7
  int v98; // [sp+3Ch] [bp-8h]@121
  int v99; // [sp+4Ch] [bp+8h]@13
  int v100; // [sp+4Ch] [bp+8h]@55
  int v101; // [sp+4Ch] [bp+8h]@62
  int v102; // [sp+4Ch] [bp+8h]@103
  int i; // [sp+4Ch] [bp+8h]@217

  v4 = a3;
  *(_DWORD *)(v4 + 124) |= 8u;
  v5 = sub_10045FA0(a1, a2, a3);
  *(_DWORD *)(v4 + 124) &= 0xFFFFFFF7;
  if ( v5 == 29 )
  {
    a1 = a3;
    v5 = sub_100478A0(a2, a3, 34);
    if ( v5 == -1 )
      return 0;
  }
  switch ( v5 )
  {
    case 34:
      return sub_10047B30(a4, a2, a3, a3);
    case 37:
      v7 = sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), 3);
      if ( !v7 )
        return 0;
      v89 = sub_10048CA0(a4);
      if ( !v89 )
        return 0;
      sub_100405E0(a4, (int)&v97, 2, -1);
      v8 = sub_10049BF0(a4, a2, a3, a4);
      if ( !v8 )
        return 0;
      if ( sub_10047570(a2, a3, 38) )
      {
        v97 = 3;
        v9 = sub_10049BF0(v8, a2, a3, a4);
        v10 = v9;
        if ( !v9 )
          return 0;
        *(_DWORD *)(v7 + 8) = *(_DWORD *)(v9 + 8);
      }
      else
      {
        v10 = 0;
        *(_DWORD *)(v7 + 8) = *(_DWORD *)(v8 + 8);
      }
      sub_10040680(a4);
      *(_DWORD *)(v7 + 28) = v8;
      *(_DWORD *)(v7 + 32) = v10;
      *(_DWORD *)(v7 + 24) = v89;
      return v7;
    case 39:
      v11 = a3 + 24 * *(_DWORD *)(a3 + 96);
      v96 = 0;
      v99 = sub_10047720(a4, a2, v11, 2);
      if ( !v99 )
        return 0;
      if ( sub_10045FA0(v11, a2, v4) != 27 )
      {
        sub_10045A60(a2, v4, 0, 0, 80, v83);
        return 0;
      }
      v90 = sub_10047B90(a2, v11, v4, (int *)a4);
      if ( !v90 )
        return 0;
      if ( sub_10045FA0(v11, a2, v4) != 28 )
      {
        sub_10045A60(a2, v4, 0, 0, 81, v83);
        return 0;
      }
      if ( sub_10045FA0(v11, a2, v4) != 25 )
      {
        sub_10045A60(a2, v4, 0, 0, 82, v83);
        return 0;
      }
      v12 = sub_10047720(a4, a2, v4 + 24 * *(_DWORD *)(v4 + 96), -2);
      v84 = v12;
      if ( !v12 )
        return 0;
      v13 = v12;
      v14 = (_DWORD *)(v12 + 24);
      *v14 = 0;
      *(_DWORD *)(v13 + 28) = v14;
      *(_DWORD *)(v13 + 32) = 0;
      sub_100405E0(a4, (int)&v97, 4, -1);
      v95 = sub_10045FA0(v13, a2, v4);
      if ( v95 == 26 )
        goto LABEL_46;
      while ( v95 != -1 )
      {
        if ( v95 != 40 )
        {
          if ( v95 != 41 )
          {
            sub_10045A60(a2, v4, 0, 0, 116, v83);
            return 0;
          }
          if ( v96 )
          {
            sub_10045A60(a2, v4, 0, 0, 114, v83);
            return 0;
          }
          v96 = 1;
        }
        v15 = v4 + 24 * *(_DWORD *)(v4 + 96);
        v16 = sub_10047720(a4, a2, v15, 2);
        v92 = v16;
        if ( !v16 )
          return 0;
        if ( v95 == 41 )
        {
          v17 = v16;
          *(_DWORD *)(v16 + 24) = 0;
        }
        else
        {
          v18 = sub_10047B90(a2, v15, v4, (int *)a4);
          v17 = v92;
          *(_DWORD *)(v92 + 24) = v18;
          if ( !v18 )
            return 0;
        }
        **(_DWORD **)(v84 + 28) = v17;
        v19 = ++*(_DWORD *)(v84 + 32) == 0x10000;
        *(_DWORD *)(v84 + 28) = v17 + 40;
        if ( v19 )
        {
          sub_10045A60(a2, v4, 0, 0, 115, v83);
          return 0;
        }
        if ( sub_10045FA0(v15, a2, v4) != 6 )
        {
          sub_10045A60(a2, v4, 0, 0, 83, v83);
          return 0;
        }
        v20 = sub_10047720(a4, a2, v4 + 24 * *(_DWORD *)(v4 + 96), -2);
        v21 = v20;
        if ( !v20 )
          return 0;
        v22 = (int *)(v20 + 24);
        *(_DWORD *)v20 = 25;
        *(_DWORD *)(v20 + 24) = 0;
        *(_DWORD *)(v20 + 28) = v20 + 24;
        *(_DWORD *)(v20 + 32) = 0;
        v23 = sub_100475E0(a2, v4);
        if ( v23 != 26 )
        {
          while ( v23 != 40 && v23 != 41 )
          {
            if ( v23 == -1 )
              return 0;
            v24 = sub_10049BF0(v21, a2, v4, a4);
            if ( !v24 )
              return 0;
            v25 = *(int **)(v21 + 28);
            *(_DWORD *)(v21 + 8) = *(_DWORD *)(v24 + 8);
            *v25 = v24;
            ++*(_DWORD *)(v21 + 32);
            *(_DWORD *)(v21 + 28) = v24 + 40;
            v23 = sub_100475E0(a2, v4);
            if ( v23 == 26 )
              break;
          }
        }
        v26 = *v22;
        if ( v26 )
          *(_DWORD *)(v21 + 4) = *(_DWORD *)(v26 + 4);
        *(_DWORD *)(v92 + 8) = *(_DWORD *)(v21 + 8);
        *(_DWORD *)(v92 + 28) = v21;
        v95 = sub_10045FA0(v21, a2, v4);
        if ( v95 == 26 )
        {
          v13 = v84;
LABEL_46:
          sub_10040680(a4);
          v27 = *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96) + 8);
          result = v99;
          *(_DWORD *)(v13 + 8) = v27;
          *(_DWORD *)(v99 + 28) = v13;
          *(_DWORD *)(v99 + 8) = v27;
          *(_DWORD *)(v99 + 24) = v90;
          return result;
        }
      }
      return 0;
    case 4294967295:
      return 0;
    case 42:
      v28 = sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), 2);
      if ( !v28 )
        return 0;
      sub_100405E0(a4, (int)&v97, 13, -1);
      v29 = sub_10048CA0(a4);
      if ( !v29 )
        return 0;
      *(_DWORD *)(v28 + 24) = v29;
      v30 = sub_10049BF0(a4, a2, a3, a4);
      if ( !v30 )
        return 0;
      sub_10040680(a4);
      v31 = *(_DWORD *)(v30 + 8);
      *(_DWORD *)(v28 + 28) = v30;
      *(_DWORD *)(v28 + 8) = v31;
      return v28;
    case 43:
      v32 = a3 + 24 * *(_DWORD *)(a3 + 96);
      v100 = sub_10047720(a4, a2, v32, 2);
      if ( !v100 )
        return 0;
      sub_100405E0(a4, (int)&v97, 10, -1);
      v33 = sub_10049BF0(v32, a2, v4, a4);
      if ( !v33 )
        return 0;
      *(_DWORD *)(v100 + 24) = v33;
      if ( sub_10045FA0(v32, a2, v4) != 42 )
      {
        sub_10045A60(a2, v4, 0, 0, 84, v83);
        return 0;
      }
      v34 = sub_10048CA0(a4);
      if ( !v34 )
        return 0;
      sub_10040680(a4);
      *(_DWORD *)(v100 + 8) = *(_DWORD *)(v34 + 8);
      *(_DWORD *)(v100 + 28) = v34;
      if ( *(_DWORD *)(a2 + 16) == 148 )
        goto LABEL_226;
      sub_10047570(a2, v4, 2);
      return v100;
    case 44:
      v35 = a3 + 24 * *(_DWORD *)(a3 + 96);
      v101 = sub_10047720(a4, a2, v35, 2);
      if ( !v101 )
        return 0;
      v36 = a4;
      sub_100405E0(a4, (int)&v97, 11, -1);
      if ( sub_10045FA0(v35, a2, v4) != 27 )
      {
        sub_10045A60(a2, v4, 0, 0, 85, v83);
        return 0;
      }
      *(_DWORD *)(v4 + 124) |= 8u;
      v37 = sub_100475E0(a2, v4);
      *(_DWORD *)(v4 + 124) &= 0xFFFFFFF7;
      if ( v37 == 2 )
      {
        v91 = 0;
LABEL_67:
        if ( sub_10045FA0(v35, a2, v4) != 2 )
        {
          sub_10045A60(a2, v4, 0, 0, 86, v83);
          return 0;
        }
        *(_DWORD *)(v4 + 124) |= 8u;
        v43 = sub_100475E0(a2, v4);
        *(_DWORD *)(v4 + 124) &= 0xFFFFFFF7;
        if ( v43 == 2 )
        {
          v85 = 0;
        }
        else
        {
          v85 = sub_10047B90(a2, -9, v4, (int *)a4);
          if ( !v85 )
            return 0;
        }
        if ( sub_10045FA0(-9, a2, v4) != 2 )
        {
          sub_10045A60(a2, v4, 0, 0, 87, v83);
          return 0;
        }
        *(_DWORD *)(v4 + 124) |= 8u;
        v44 = sub_100475E0(a2, v4);
        *(_DWORD *)(v4 + 124) &= 0xFFFFFFF7;
        if ( v44 == 28 )
        {
          v93 = 0;
        }
        else
        {
          v93 = sub_10047B90(a2, -9, v4, (int *)a4);
          if ( !v93 )
            return 0;
        }
        v45 = sub_10047720(a4, a2, v4 + 24 * *(_DWORD *)(v4 + 96), 3);
        if ( !v45 )
          return 0;
        v36 = a4;
        *(_DWORD *)(v45 + 24) = v91;
        *(_DWORD *)(v45 + 28) = v85;
        *(_DWORD *)v45 = 61;
        *(_DWORD *)(v45 + 12) = 0;
        *(_DWORD *)(v45 + 32) = v93;
        *(_DWORD *)(v101 + 24) = v45;
        v42 = v101;
        goto LABEL_99;
      }
      *(_DWORD *)a4 |= 0x10u;
      if ( v37 == 48 )
      {
        sub_10045FA0(v35, a2, v4);
        v35 = sub_100496B0(a2, v4, v4, a4);
        v91 = v35;
      }
      else
      {
        v35 = sub_10047B90(a2, v35, v4, (int *)a4);
        v91 = v35;
      }
      *(_DWORD *)a4 &= 0xFFFFFFEF;
      if ( !v35 )
        return 0;
      if ( !sub_10047570(a2, v4, 47) )
        goto LABEL_67;
      v97 = 12;
      v38 = *(_DWORD *)v35;
      if ( *(_DWORD *)v35 == 48 )
      {
        if ( *(_DWORD *)(v35 + 32) <= 1u && *(_DWORD *)(v35 + 12) != 126 )
          goto LABEL_77;
LABEL_82:
        sub_10045A60(a2, v4, 0, 0, 117, v83);
        return 0;
      }
      if ( v38 != 29 && v38 != 22 && v38 != 23 )
        goto LABEL_82;
LABEL_77:
      if ( v38 == 48 )
      {
        v39 = *(_DWORD *)(v35 + 24);
        *(_DWORD *)(v35 + 36) = 1;
      }
      else
      {
        v39 = v35;
      }
      if ( *(_DWORD *)v39 == 29 && *(_DWORD *)(v39 + 24) == *(_DWORD *)(*(_DWORD *)(a2 + 24) + 216) )
        *(_DWORD *)a4 |= 0x80u;
      v40 = sub_10047B90(a2, v35, v4, (int *)a4);
      v41 = sub_10047750(v40, a4, v35, a2, 47, 0);
      if ( !v41 )
        return 0;
      v42 = v101;
      *(_DWORD *)(v101 + 24) = v41;
LABEL_99:
      if ( sub_10045FA0(v42, a2, v4) != 28 )
      {
        sub_10045A60(a2, v4, 0, 0, 88, v83);
        return 0;
      }
      v46 = sub_10049BF0(v42, a2, v4, v36);
      v47 = v46;
      if ( !v46 )
        return 0;
      *(_DWORD *)(v42 + 28) = v46;
      sub_10040680(v36);
      *(_DWORD *)(v42 + 8) = *(_DWORD *)(v47 + 8);
      return v42;
    case 55:
      v48 = a3 + 24 * *(_DWORD *)(a3 + 96);
      v102 = sub_10047720(a4, a2, v48, 3);
      *(_DWORD *)(v102 + 12) = 0;
      if ( sub_10045FA0(v48, a2, v4) != 25 )
      {
        sub_10045A60(a2, v4, 0, 0, 89, v83);
        return 0;
      }
      v49 = a4;
      sub_100405E0(a4, (int)&v97, 6, -1);
      v50 = sub_1004AC90(a2, v4, a4);
      v51 = v102;
      *(_DWORD *)(v102 + 24) = v50;
      if ( !v50 )
        return 0;
      if ( sub_10045FA0(a4, a2, v4) != 26 )
      {
        sub_10045A60(a2, v4, 0, 0, 90, v83);
        return 0;
      }
      sub_10040680(a4);
      v94 = v102;
      if ( sub_100475E0(a2, v4) != 56 )
        goto LABEL_125;
      do
      {
        if ( v94 != v102 && !*(_DWORD *)(*(_DWORD *)(v94 + 24) + 28) )
        {
          sub_10045A60(a2, v4, 0, 0, 118, v83);
          return 0;
        }
        sub_10045FA0(v49, a2, v4);
        v52 = v4 + 24 * *(_DWORD *)(v4 + 96);
        v86 = sub_10047720(a4, a2, v52, 3);
        if ( !v86 )
          return 0;
        if ( sub_10045FA0(v52, a2, v4) != 27 )
        {
          sub_10045A60(a2, v4, 0, 0, 91, v83);
          return 0;
        }
        if ( sub_10045FA0(v52, a2, v4) != 29 )
        {
          sub_10045A60(a2, v4, 0, 0, 92, v83);
          return 0;
        }
        v49 = sub_10047720(a4, a2, v4 + 24 * *(_DWORD *)(v4 + 96), -1);
        if ( !v49 )
          return 0;
        *(_DWORD *)(v49 + 24) = *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96) + 20);
        *(_DWORD *)(v49 + 28) = 0;
        if ( sub_100475E0(a2, v4) == 37 )
        {
          sub_10045FA0(v49, a2, v4);
          v53 = a4;
          v54 = sub_10047B90(a2, v49, v4, (int *)a4);
          *(_DWORD *)(v49 + 28) = v54;
          if ( !v54 )
            return 0;
        }
        else
        {
          v53 = a4;
        }
        *(_DWORD *)(v86 + 24) = v49;
        if ( sub_10045FA0(v49, a2, v4) != 28 )
        {
          sub_10045A60(a2, v4, 0, 0, 93, v83);
          return 0;
        }
        if ( sub_10045FA0(v49, a2, v4) != 25 )
        {
          sub_10045A60(a2, v4, 0, 0, 94, v83);
          return 0;
        }
        sub_100405E0(v53, (int)&v97, 7, -1);
        v98 = *(_DWORD *)(v49 + 24);
        v55 = sub_1004AC90(a2, v4, v53);
        LOBYTE(v49) = v86;
        *(_DWORD *)(v86 + 32) = v55;
        if ( !v55 )
          return 0;
        if ( sub_10045FA0(v86, a2, v4) != 26 )
        {
          sub_10045A60(a2, v4, 0, 0, 95, v83);
          return 0;
        }
        sub_10040680(v53);
        *(_DWORD *)(v94 + 28) = v86;
        v94 = v86;
      }
      while ( sub_100475E0(a2, v4) == 56 );
      v51 = v102;
      v49 = a4;
LABEL_125:
      *(_DWORD *)(v94 + 28) = 0;
      if ( sub_10047570(a2, v4, 57) )
      {
        ++*(_DWORD *)(v49 + 4);
        if ( sub_10045FA0(v49, a2, v4) != 25 )
        {
          sub_10045A60(a2, v4, 0, 0, 96, v83);
          return 0;
        }
        sub_100405E0(v49, (int)&v97, 8, -1);
        v56 = sub_1004AC90(a2, v4, v49);
        *(_DWORD *)(v51 + 32) = v56;
        if ( !v56 )
          return 0;
        if ( sub_10045FA0(v49, a2, v4) != 26 )
        {
          sub_10045A60(a2, v4, 0, 0, 97, v83);
          return 0;
        }
        sub_10040680(v49);
      }
      else
      {
        *(_DWORD *)(v51 + 32) = 0;
      }
      if ( !*(_DWORD *)(v51 + 28) && !*(_DWORD *)(v51 + 32) )
      {
        sub_10045A60(a2, v4, 0, 0, 98, v83);
        return 0;
      }
      ++*(_DWORD *)(v49 + 4);
      return v51;
    case 58:
      v57 = a3 + 24 * *(_DWORD *)(a3 + 96);
      v100 = sub_10047720(a4, a2, v57, 1);
      if ( !v100 )
        return 0;
      v58 = sub_10047B90(a2, v57, v4, (int *)a4);
      if ( !v58 )
        return 0;
      *(_DWORD *)(v100 + 8) = *(_DWORD *)(v58 + 8);
      *(_DWORD *)(v100 + 12) = 110;
      *(_DWORD *)(v100 + 24) = v58;
      goto LABEL_226;
    case 56:
      sub_10045A60(a2, a3, 0, 0, 119, v83);
      return 0;
    case 57:
      sub_10045A60(a2, a3, 0, 0, 120, v83);
      return 0;
    case 45:
      v59 = sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), 0);
      v100 = v59;
      if ( !v59 )
        return 0;
      v60 = v59;
      if ( !sub_10047B40(v4, a2, v59) )
        return 0;
      v61 = *(_DWORD *)(a4 + 8);
      v62 = *(_DWORD *)(v60 + 24);
      if ( v62 )
      {
        if ( !v61 )
        {
LABEL_155:
          sub_10045A60(a2, v4, 0, 0, 121, v83);
          return 0;
        }
        while ( *(_DWORD *)v61 != 1 || *(_DWORD *)(v61 + 24) != v62 )
        {
          v61 = *(_DWORD *)(v61 + 28);
          if ( !v61 )
            goto LABEL_155;
        }
        *(_DWORD *)(v60 + 8) = *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96) + 8);
      }
      else
      {
        if ( !v61 )
        {
LABEL_160:
          sub_10045A60(a2, v4, 0, 0, 122, v83);
          return 0;
        }
        while ( *(_DWORD *)v61 < 10 && *(_DWORD *)v61 != 4 )
        {
          v61 = *(_DWORD *)(v61 + 28);
          if ( !v61 )
            goto LABEL_160;
        }
      }
      goto LABEL_226;
    case 46:
      v63 = sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), 0);
      v100 = v63;
      if ( !v63 )
        return 0;
      v64 = v63;
      if ( !sub_10047B40(v4, a2, v63) )
        return 0;
      v65 = *(_DWORD *)(v64 + 24);
      v66 = *(_DWORD *)(a4 + 8);
      if ( !v65 )
      {
        for ( ; v66; v66 = *(_DWORD *)(v66 + 28) )
        {
          if ( *(_DWORD *)v66 >= 10 )
            goto LABEL_226;
        }
        sub_10045A60(a2, v4, 0, 0, 123, v83);
        return 0;
      }
      v67 = 0;
      if ( !v66 )
      {
LABEL_173:
        sub_10045A60(a2, v4, 0, 0, 121, v83);
        return 0;
      }
      while ( 2 )
      {
        if ( *(_DWORD *)v66 == 1 )
        {
          if ( *(_DWORD *)(v66 + 24) == v65 )
          {
            if ( !v67 || *v67 < 10 )
            {
              sub_10045A60(a2, v4, 0, 0, 123, v83);
              return 0;
            }
            *(_DWORD *)(v64 + 8) = *(_DWORD *)(v4 + 24 * *(_DWORD *)(v4 + 96) + 8);
LABEL_226:
            if ( *(_WORD *)(v4 + 104) == *(_WORD *)(v100 + 10) )
            {
              v82 = sub_10047620(a2, v4);
              if ( v82 == -1 )
                return 0;
              if ( v82 && v82 != 1 && v82 != 2 && v82 != 26 )
              {
                sub_10045A60(a2, v4, 0, 0, 109, v83);
                return 0;
              }
            }
            sub_10047570(a2, v4, 2);
            return v100;
          }
        }
        else
        {
          v67 = (_DWORD *)v66;
        }
        v66 = *(_DWORD *)(v66 + 28);
        if ( !v66 )
          goto LABEL_173;
        continue;
      }
    case 49:
      v68 = a3 + 24 * *(_DWORD *)(a3 + 96);
      v69 = sub_10047720(a4, a2, v68, 2);
      if ( !v69 )
        return 0;
      if ( sub_10045FA0(v68, a2, a3) != 27 )
      {
        sub_10045A60(a2, a3, 0, 0, 99, v83);
        return 0;
      }
      v87 = sub_10047B90(a2, a4, a3, (int *)a4);
      if ( !v87 )
        return 0;
      if ( sub_10045FA0(a4, a2, a3) != 28 )
      {
        sub_10045A60(a2, a3, 0, 0, 100, v83);
        return 0;
      }
      *(_DWORD *)(v69 + 24) = v87;
      sub_100405E0(a4, (int)&v97, 5, -1);
      v88 = sub_10049BF0(a4, a2, a3, a4);
      if ( !v88 )
        return 0;
      sub_10040680(a4);
      if ( !sub_10045A60(a2, a3, 0, 5, 158, (unsigned int)"with statement") )
        return 0;
      v70 = *(_DWORD *)(v88 + 8);
      *(_DWORD *)(v69 + 28) = v88;
      *(_DWORD *)(v69 + 8) = v70;
      *(_DWORD *)a4 |= 0x80u;
      return v69;
    case 48:
      v71 = sub_100496B0(a2, a3, a3, a4);
      v100 = v71;
      if ( !v71 )
        return 0;
      *(_DWORD *)(v71 + 36) = 1;
      goto LABEL_226;
    case 50:
      if ( !(*(_BYTE *)a4 & 2) )
      {
        sub_10045A60(a2, a3, 0, 0, 124, v83);
        return 0;
      }
      v100 = sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), 1);
      if ( !v100 )
        return 0;
      *(_DWORD *)(v4 + 124) |= 8u;
      v72 = sub_10047620(a2, v4);
      *(_DWORD *)(v4 + 124) &= 0xFFFFFFF7;
      if ( v72 == -1 )
        return 0;
      if ( v72 && v72 != 1 && v72 != 2 && v72 != 26 )
      {
        v73 = (_DWORD *)a4;
        v74 = sub_10047B90(a2, a4, v4, (int *)a4);
        if ( !v74 )
          return 0;
        *(_DWORD *)a4 |= 4u;
        *(_DWORD *)(v100 + 8) = *(_DWORD *)(v74 + 8);
        *(_DWORD *)(v100 + 24) = v74;
      }
      else
      {
        v73 = (_DWORD *)a4;
        *v73 |= 8u;
        *(_DWORD *)(v100 + 24) = 0;
      }
      if ( *(_BYTE *)(a2 + 300) & 1 )
      {
        if ( !(~*(_BYTE *)v73 & 0xC) )
        {
          result = sub_10047AD0();
          if ( !result )
            return result;
        }
      }
      goto LABEL_226;
    case 25:
      sub_100405E0(a4, (int)&v97, 0, -1);
      v75 = sub_1004AC90(a2, a3, a4);
      if ( !v75 )
        return 0;
      if ( sub_10045FA0(a4, a2, a3) != 26 )
      {
        sub_10045A60(a2, a3, 0, 0, 101, v83);
        return 0;
      }
      sub_10040680(a4);
      return v75;
    case 1:
    case 2:
      result = sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), 1);
      if ( !result )
        return 0;
      *(_DWORD *)result = 2;
      *(_DWORD *)(result + 24) = 0;
      return result;
    case 60:
      v76 = (_DWORD *)sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), 0);
      v100 = (int)v76;
      if ( !v76 )
        return 0;
      *v76 = 60;
      *(_DWORD *)a4 |= 0x80u;
      goto LABEL_226;
    default:
      sub_10047550(a3);
      v77 = sub_10047B90(a2, a1, a3, (int *)a4);
      if ( !v77 )
        return 0;
      if ( sub_100475E0(a2, a3) == 6 )
      {
        if ( *(_DWORD *)v77 != 29 )
        {
          sub_10045A60(a2, a3, 0, 0, 125, v83);
          return 0;
        }
        v78 = *(_DWORD *)(a4 + 8);
        for ( i = *(_DWORD *)(v77 + 24); v78; v78 = *(_DWORD *)(v78 + 28) )
        {
          if ( *(_DWORD *)v78 == 1 && *(_DWORD *)(v78 + 24) == *(_DWORD *)(v77 + 24) )
          {
            sub_10045A60(a2, v4, 0, 0, 126, v83);
            return 0;
          }
        }
        sub_10045FA0(v77, a2, v4);
        sub_100405E0(a4, (int)&v97, 1, -1);
        v98 = i;
        v79 = sub_10049BF0(v77, a2, v4, a4);
        if ( !v79 )
          return 0;
        sub_10040680(a4);
        *(_DWORD *)v77 = 6;
        v80 = *(_DWORD *)(v79 + 8);
        *(_DWORD *)(v77 + 28) = v79;
        *(_DWORD *)(v77 + 8) = v80;
        return v77;
      }
      v81 = sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), 1);
      v100 = v81;
      if ( !v81 )
        return 0;
      *(_DWORD *)v81 = 2;
      *(_DWORD *)(v81 + 4) = *(_DWORD *)(v77 + 4);
      *(_DWORD *)(v81 + 8) = *(_DWORD *)(v77 + 8);
      *(_DWORD *)(v81 + 24) = v77;
      goto LABEL_226;
  }
}
// 10047AD0: using guessed type int sub_10047AD0(void);
// 10048CA0: using guessed type _DWORD __cdecl sub_10048CA0(_DWORD);

//----- (1004AC90) --------------------------------------------------------
int __cdecl sub_1004AC90(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int result; // eax@2
  int v5; // eax@3
  int v6; // esi@3
  signed int v7; // eax@4
  _DWORD *v8; // esi@6
  unsigned int *v9; // edi@6
  int v10; // eax@8
  signed int v11; // eax@12
  char v12; // [sp+0h] [bp-8h]@0
  unsigned int *v13; // [sp+4h] [bp-4h]@1
  int v14; // [sp+Ch] [bp+4h]@3

  v3 = a1;
  if ( (unsigned int)&v13 > *(_DWORD *)(a1 + 12) )
  {
    v5 = sub_10047720(a3, a1, a2 + 24 * *(_DWORD *)(a2 + 96), -2);
    v6 = v5;
    v14 = v5;
    if ( !v5 )
      goto LABEL_26;
    *(_DWORD *)(v5 + 24) = 0;
    *(_DWORD *)(v5 + 28) = v5 + 24;
    *(_DWORD *)(v5 + 32) = 0;
    *(_DWORD *)(a2 + 124) |= 8u;
    v7 = sub_100475E0(v3, a2);
    if ( v7 > 0 )
    {
      while ( v7 != 26 )
      {
        v8 = (_DWORD *)a3;
        *(_DWORD *)(a2 + 124) &= 0xFFFFFFF7;
        v9 = (unsigned int *)sub_10049BF0(a3, v3, a2, a3);
        v13 = v9;
        if ( !v9 )
          goto LABEL_26;
        *(_DWORD *)(a2 + 124) |= 8u;
        if ( *(_DWORD *)(a3 + 8) || (v10 = *(_DWORD *)a3, !(*(_DWORD *)a3 & 1)) )
        {
          **(_DWORD **)(v14 + 28) = v9;
          ++*(_DWORD *)(v14 + 32);
          *(_DWORD *)(v14 + 28) = v9 + 10;
        }
        else
        {
          if ( *(_DWORD *)(*(_DWORD *)(v3 + 56) + 16) && *(_BYTE *)(v3 + 300) & 1 && v10 & 4 )
          {
            v11 = sub_100475E0(v3, a2);
            if ( !v11 || v11 == 26 )
            {
              if ( !sub_10047B10(v9) )
                goto LABEL_24;
              v8 = (_DWORD *)a3;
              v9 = v13;
            }
            *v8 &= 0xFFFFFFFB;
          }
          if ( !sub_100485B0(v3, (int)v9, (int)v8)
            || !sub_100414A0(v3, (int)v8)
            || !sub_10042FB0((char)v9, v3, (int)v8, (int)v9) )
          {
LABEL_24:
            v6 = v14;
            v7 = -1;
            break;
          }
          sub_10047640((int)v9, (int)v8);
        }
        v7 = sub_100475E0(v3, a2);
        v6 = v14;
        if ( v7 <= 0 )
          break;
      }
    }
    *(_DWORD *)(a2 + 124) &= 0xFFFFFFF7;
    if ( v7 != -1 )
    {
      *(_DWORD *)(v6 + 8) = *(_DWORD *)(a2 + 24 * *(_DWORD *)(a2 + 96) + 8);
      result = v6;
    }
    else
    {
LABEL_26:
      result = 0;
    }
  }
  else
  {
    sub_10045A60(a1, a2, 0, 0, 26, v12);
    result = 0;
  }
  return result;
}

//----- (1004AE20) --------------------------------------------------------
_DWORD *__cdecl sub_1004AE20(int a1, int a2, int a3)
{
  int v3; // ebp@1
  bool v4; // zf@4
  _DWORD *i; // eax@5
  _DWORD *v6; // edi@8
  _DWORD *result; // eax@13
  char v8; // [sp+0h] [bp-88h]@0
  int v9; // [sp+10h] [bp-78h]@1
  int v10; // [sp+14h] [bp-74h]@8
  int v11; // [sp+18h] [bp-70h]@8
  int v12; // [sp+1Ch] [bp-6Ch]@8
  int v13; // [sp+20h] [bp-68h]@8
  int v14; // [sp+24h] [bp-64h]@8
  int v15; // [sp+28h] [bp-60h]@8
  int v16; // [sp+2Ch] [bp-5Ch]@8
  char v17; // [sp+30h] [bp-58h]@4
  _DWORD *v18; // [sp+38h] [bp-50h]@4
  int v19; // [sp+5Ch] [bp-2Ch]@7
  int v20; // [sp+64h] [bp-24h]@4

  v3 = *(_DWORD *)(a1 + 56);
  v9 = *(_DWORD *)(a1 + 56);
  if ( !v3 || !*(_DWORD *)(v3 + 8) || *(_DWORD *)(v3 + 52) != a2 )
  {
    memset(&v17, 0, 0x58u);
    v4 = (*(_BYTE *)(a1 + 300) & 4) == 0;
    v20 = a2;
    v18 = (_DWORD *)a2;
    if ( !v4 )
    {
      for ( i = sub_10010590(a1, a2); i; i = sub_10010590(a1, (int)i) )
        v18 = i;
    }
    v19 = v3;
    *(_DWORD *)(a1 + 56) = &v17;
  }
  ++*(_DWORD *)(*(_DWORD *)(a1 + 24) + 72);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v6 = (_DWORD *)sub_1004AC90(a1, a3, (int)&v10);
  if ( v6 )
  {
    if ( !sub_10047570(a1, a3, 0) )
    {
      sub_10045A60(a1, a3, 0, 0, 133, v8);
LABEL_12:
      v6 = 0;
      goto LABEL_13;
    }
    *v6 = 25;
    if ( !sub_100485B0(a1, (int)v6, (int)&v10) )
      goto LABEL_12;
  }
LABEL_13:
  --*(_DWORD *)(*(_DWORD *)(a1 + 24) + 72);
  result = v6;
  *(_DWORD *)(a1 + 56) = v9;
  return result;
}

//----- (1004AF40) --------------------------------------------------------
signed int __cdecl sub_1004AF40(int a1, int a2, int a3, int a4)
{
  int v4; // ebp@1
  bool v5; // zf@4
  _DWORD *i; // eax@5
  int v7; // eax@8
  int v8; // ebx@8
  signed int result; // eax@11
  char v10; // [sp+0h] [bp-68h]@0
  char v11; // [sp+10h] [bp-58h]@4
  _DWORD *v12; // [sp+18h] [bp-50h]@4
  int v13; // [sp+3Ch] [bp-2Ch]@7
  int v14; // [sp+44h] [bp-24h]@4

  v4 = *(_DWORD *)(a1 + 56);
  if ( !v4 || !*(_DWORD *)(v4 + 8) || *(_DWORD *)(v4 + 52) != a2 )
  {
    memset(&v11, 0, 0x58u);
    v5 = (*(_BYTE *)(a1 + 300) & 4) == 0;
    v14 = a2;
    v12 = (_DWORD *)a2;
    if ( !v5 )
    {
      for ( i = sub_10010590(a1, a2); i; i = sub_10010590(a1, (int)i) )
        v12 = i;
    }
    v13 = v4;
    *(_DWORD *)(a1 + 56) = &v11;
  }
  v7 = *(_DWORD *)(a1 + 56);
  v8 = *(_DWORD *)(v7 + 76);
  *(_DWORD *)(v7 + 76) = v8 | 8 * (*(_DWORD *)(a1 + 300) & 0x10 | 8);
  ++*(_DWORD *)(*(_DWORD *)(a1 + 24) + 72);
  if ( sub_1004AC90(a1, a3, a4) )
  {
    if ( sub_10047570(a1, a3, 0) )
    {
      result = 1;
      goto LABEL_13;
    }
    sub_10045A60(a1, a3, 0, 0, 133, v10);
  }
  result = 0;
LABEL_13:
  --*(_DWORD *)(*(_DWORD *)(a1 + 24) + 72);
  *(_DWORD *)(*(_DWORD *)(a1 + 56) + 76) = v8;
  *(_DWORD *)(a1 + 56) = v4;
  return result;
}

//----- (1004B030) --------------------------------------------------------
unsigned int *__usercall sub_1004B030@<eax>(int a1@<eax>, int a2, int a3, unsigned int *a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // edi@1
  unsigned int *v7; // edi@6
  unsigned int *v8; // eax@6
  unsigned int *v9; // ebp@6
  char v11; // [sp+10h] [bp-58h]@5
  int v12; // [sp+18h] [bp-50h]@5
  int v13; // [sp+20h] [bp-48h]@5
  int v14; // [sp+3Ch] [bp-2Ch]@5
  int v15; // [sp+44h] [bp-24h]@5
  unsigned int v16; // [sp+70h] [bp+8h]@6

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 56);
  v6 = *(_DWORD *)(a3 + 4);
  if ( !v5 || *(_DWORD *)(v5 + 16) != a3 || *(_DWORD *)(v5 + 8) != v6 || *(_DWORD *)(v5 + 52) != v6 )
  {
    memset(&v11, 0, 0x58u);
    v13 = a3;
    v15 = v6;
    v12 = v6;
    v14 = v5;
    *(_DWORD *)(v4 + 56) = &v11;
  }
  v7 = a4;
  v16 = *a4;
  *a4 = *a4 & 0xFFFFFFF3 | 2;
  v8 = (unsigned int *)sub_1004AC90(v4, a2, (int)a4);
  v9 = v8;
  if ( v8 )
  {
    if ( *(_BYTE *)(v4 + 300) & 1 )
    {
      if ( *(_BYTE *)a4 & 4 )
      {
        v7 = a4;
        if ( !sub_10047B10(v8) )
          v9 = 0;
      }
    }
  }
  *(_DWORD *)(v4 + 56) = v5;
  *v7 = v16 | *v7 & 0xE0;
  return v9;
}

//----- (1004B0E0) --------------------------------------------------------
int __cdecl sub_1004B0E0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@2
  int v5; // edx@2
  unsigned int v6; // eax@3
  signed int v7; // edi@4
  int v8; // eax@8
  int v9; // [sp+8h] [bp-158h]@1
  int v10; // [sp+24h] [bp-13Ch]@1
  char v11; // [sp+40h] [bp-120h]@2
  int v12; // [sp+48h] [bp-118h]@2
  int v13; // [sp+50h] [bp-110h]@2
  int v14; // [sp+6Ch] [bp-F4h]@2
  int v15; // [sp+74h] [bp-ECh]@2
  int v16; // [sp+8Ch] [bp-D4h]@2
  unsigned int v17[50]; // [sp+98h] [bp-C8h]@1

  sub_1003E280((int)&v10, (int)"code", 1024, 1u);
  sub_1003E280((int)&v9, (int)"note", 1024, 1u);
  result = sub_1003F880(
             a1,
             v17,
             (int)&v10,
             (int)&v9,
             *(_DWORD *)(a2 + 172),
             *(_DWORD *)(a2 + 104),
             *(_DWORD *)(a2 + 180));
  if ( result )
  {
    ++*(_DWORD *)(*(_DWORD *)(a1 + 24) + 72);
    v4 = *(_DWORD *)(a1 + 56);
    memset(&v11, 0, 0x58u);
    v15 = *(_DWORD *)(a3 + 4);
    v12 = v15;
    v16 = 8 * (*(_DWORD *)(a1 + 300) & 0x10 | 8);
    *(_DWORD *)(a1 + 56) = &v11;
    v5 = 3 * *(_DWORD *)(a2 + 96);
    v13 = a3;
    v14 = v4;
    *(_DWORD *)(a2 + 8 * v5) = 25;
    if ( sub_1004B030(a1, a2, a3, v17) && (v6 = sub_10021E70(a1, (int)v17, a3), (*(_DWORD *)(a3 + 12) = v6) != 0) )
    {
      if ( v17[0] & 0x80 )
        *(_BYTE *)(a3 + 22) |= 0x80u;
      v7 = 1;
    }
    else
    {
      v7 = 0;
    }
    v8 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 56) = v4;
    --*(_DWORD *)(v8 + 72);
    sub_1003F940(a1, (int)v17);
    sub_1003E6D0((_DWORD **)&v10);
    sub_1003E6D0((_DWORD **)&v9);
    result = v7;
  }
  return result;
}

//----- (1004B250) --------------------------------------------------------
int __usercall sub_1004B250@<eax>(char a1@<bl>, int a2, int a3, int a4, int a5)
{
  int v5; // ebp@1
  signed int v6; // esi@1
  int v8; // ebx@6
  int v9; // eax@13
  unsigned int v10; // ST18_4@13
  int v11; // edx@14
  int v12; // ecx@15
  bool v13; // zf@15
  int v14; // eax@17
  signed int v15; // eax@18
  void (__cdecl *v16)(int, int, int); // eax@21
  int v17; // esi@25
  int v18; // ecx@39
  _DWORD *v19; // eax@42
  int v20; // eax@49
  int v21; // eax@50
  int v22; // esi@51
  int *v23; // ecx@52
  int *v24; // eax@52
  int v25; // eax@56
  int v26; // esi@59
  unsigned int v27; // ebp@59
  int v28; // edx@60
  int v29; // ecx@61
  void (__cdecl *v30)(int, int, int); // eax@61
  int v31; // esi@68
  int v32; // ecx@71
  char *v33; // ecx@77
  int v34; // eax@86
  int v35; // ecx@86
  unsigned int *v36; // edx@87
  char v37; // [sp-4h] [bp-40h]@6
  int v38; // [sp+Ch] [bp-30h]@13
  int v39; // [sp+10h] [bp-2Ch]@13
  unsigned int *v40; // [sp+14h] [bp-28h]@15
  int v41; // [sp+18h] [bp-24h]@1
  int v42; // [sp+1Ch] [bp-20h]@3
  int v43; // [sp+20h] [bp-1Ch]@34
  int v44; // [sp+24h] [bp-18h]@34
  int v45; // [sp+28h] [bp-14h]@34
  int v46; // [sp+2Ch] [bp-10h]@34
  int v47; // [sp+30h] [bp-Ch]@34
  int v48; // [sp+34h] [bp-8h]@34
  int v49; // [sp+38h] [bp-4h]@34
  int v50; // [sp+44h] [bp+8h]@4

  v5 = a3;
  v6 = 0;
  v41 = sub_10047720(a4, a2, a3 + 24 * *(_DWORD *)(a3 + 96), -3);
  if ( !v41 )
    return 0;
  v42 = *(_DWORD *)(a3 + 24 * *(_DWORD *)(a3 + 96) + 16);
  if ( sub_10047570(a2, a3, 29) )
    v50 = *(_DWORD *)(a3 + 24 * *(_DWORD *)(a3 + 96) + 20);
  else
    v50 = 0;
  v37 = a1;
  v8 = sub_10028940(a2, 0, 0, 0, a5 != 0 ? 8 : 0, *(_DWORD *)(*(_DWORD *)(a2 + 56) + 8), v50);
  if ( !v8 )
    return 0;
  if ( v42 )
    *(_BYTE *)(v8 + 22) |= v42 != 123 ? 32 : 16;
  if ( sub_10045FA0(0, a2, v5) != 27 )
  {
    sub_10045A60(a2, v5, 0, 0, 69, v37);
    return 0;
  }
  if ( !sub_10047570(a2, v5, 28) )
  {
    while ( 1 )
    {
      if ( sub_10045FA0(v6, a2, v5) != 29 )
      {
        sub_10045A60(a2, v5, 0, 0, 70, v37);
        return 0;
      }
      v9 = *(_DWORD *)(v5 + 24 * *(_DWORD *)(v5 + 96) + 20);
      v38 = 0;
      v10 = *(_DWORD *)(v8 + 4);
      v42 = v9;
      if ( !sub_10015D00(a2, v10, v9, &v38, (unsigned int *)&v39) )
        return 0;
      v11 = v39;
      if ( v39 )
      {
        v12 = v38;
        v13 = v38 == *(_DWORD *)(v8 + 4);
        v40 = (unsigned int *)1;
        if ( v13 && *(signed int (**)())(v39 + 4) == sub_1002FB00 )
        {
          v14 = sub_10038330(a2, v42);
          if ( !v14 || (v15 = sub_10045A60(a2, v5, 0, 5, 111, v14), v40 = (unsigned int *)1, !v15) )
            v40 = 0;
          v12 = v38;
          v11 = v39;
          v6 = 2;
        }
        v16 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v12 + 4) + 52);
        if ( v16 )
          v16(a2, v12, v11);
        if ( !v40 )
          return 0;
        v39 = 0;
      }
      v17 = v6 | 8;
      if ( !sub_10015BB0(
              a2,
              *(_DWORD *)(v8 + 4),
              v42,
              sub_1002FB00,
              (signed int (*)())sub_1002FB20,
              -1,
              69,
              v17,
              *(_WORD *)(v8 + 16)) )
        return 0;
      ++*(_WORD *)(v8 + 16);
      if ( !sub_10047570(a2, v5, 3) )
        break;
      v6 = 0;
    }
    if ( sub_10045FA0(v17, a2, v5) != 28 )
    {
      sub_10045A60(a2, v5, 0, 0, 71, v37);
      return 0;
    }
    LOBYTE(v6) = 0;
  }
  if ( sub_10045FA0(v6, a2, v5) != 25 )
  {
    sub_10045A60(a2, v5, 0, 0, 72, v37);
    return 0;
  }
  *(_DWORD *)(v41 + 4) = *(_DWORD *)(v5 + 24 * *(_DWORD *)(v5 + 96) + 4);
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v40 = sub_1004B030(a2, v5, v8, (unsigned int *)&v43);
  if ( !v40 )
    return 0;
  if ( sub_10045FA0(0, a2, v5) != 26 )
  {
    sub_10045A60(a2, v5, 0, 0, 73, v37);
    return 0;
  }
  *(_DWORD *)(v41 + 8) = *(_DWORD *)(v5 + 24 * *(_DWORD *)(v5 + 96) + 8);
  if ( (char)v43 >= 0 )
  {
    if ( a5 || !v50 || (v19 = (_DWORD *)a4, !*(_DWORD *)(a4 + 8)) )
    {
      if ( !(v43 & 0x40) )
      {
LABEL_46:
        v18 = a4;
        goto LABEL_47;
      }
      v19 = (_DWORD *)a4;
    }
    *v19 |= 0x80u;
    goto LABEL_46;
  }
  v18 = a4;
  *(_BYTE *)(v8 + 22) |= 0x80u;
  *(_DWORD *)v18 |= 0x80u;
LABEL_47:
  if ( a5 || !v50 )
  {
    v31 = (*(_DWORD *)(v8 + 24) != 0) + 128;
    goto LABEL_86;
  }
  v20 = *(_DWORD *)(v18 + 16);
  if ( v20 )
  {
    v21 = *sub_10051360(v20, *(_DWORD *)(v50 + 20), v50);
    if ( v21 )
    {
      v22 = v21;
      goto LABEL_70;
    }
LABEL_55:
    v22 = sub_10038C10(a2, v50, a4 + 12);
    if ( !v22 )
      return 0;
    v25 = a4;
    goto LABEL_57;
  }
  v23 = (int *)(v18 + 12);
  v24 = v23;
  v22 = *v23;
  if ( !*v23 )
    goto LABEL_55;
  while ( *(_DWORD *)(v22 + 8) != v50 )
  {
    v24 = (int *)v22;
    v22 = *(_DWORD *)v22;
    if ( !v22 )
      goto LABEL_55;
  }
  *v24 = *(_DWORD *)v22;
  *(_DWORD *)v22 = *v23;
  *v23 = v22;
LABEL_70:
  if ( !v22 )
    goto LABEL_55;
  v13 = (*(_BYTE *)(a2 + 300) & 1) == 0;
  v32 = *(_DWORD *)(v22 + 12);
  v42 = *(_DWORD *)(v22 + 12);
  if ( !v13 || v32 == 126 )
  {
    if ( !sub_10038330(a2, v50) )
      return 0;
    if ( v42 == 125 || v42 == 74 )
      v33 = "function";
    else
      v33 = v42 == 126 ? "const" : "var";
    if ( !sub_10045A60(a2, v5, 0, v42 != 126 ? 5 : 0, 155, (char)v33) )
      return 0;
    v32 = v42;
  }
  v25 = a4;
  if ( *(_DWORD *)(a4 + 8) && v32 == 127 )
    *(_DWORD *)a4 |= 0x20u;
LABEL_57:
  *(_DWORD *)(v22 + 12) = *(_DWORD *)(v25 + 8) != 0 ? 74 : 125;
  if ( !*(_DWORD *)(v25 + 8) && *(_BYTE *)v25 & 2 )
  {
    v26 = *(_DWORD *)(a2 + 56);
    v27 = *(_DWORD *)(v26 + 8);
    if ( !sub_10015D00(a2, *(_DWORD *)(v26 + 8), v50, &v38, (unsigned int *)&v39) )
      return 0;
    v28 = v39;
    if ( !v39 )
      goto LABEL_90;
    v29 = v38;
    v30 = *(void (__cdecl **)(int, int, int))(*(_DWORD *)(*(_DWORD *)v38 + 4) + 52);
    if ( v30 )
    {
      v30(a2, v38, v39);
      v29 = v38;
      v28 = v39;
    }
    if ( !v28 || v29 != v27 )
    {
LABEL_90:
      if ( !sub_10017EF0(
              a2,
              v27,
              v50,
              *(_DWORD *)(v8 + 4),
              sub_1002FB80,
              (signed int (*)())sub_1002FB50,
              1,
              8,
              *(_WORD *)(*(_DWORD *)(v26 + 16) + 20),
              0) )
        return 0;
      ++*(_WORD *)(*(_DWORD *)(v26 + 16) + 20);
    }
    v25 = a4;
  }
  v31 = *(_DWORD *)(v25 + 8) != 0 ? 0x4A : 0;
LABEL_86:
  v34 = sub_10038750(a2, *(_DWORD *)(v8 + 4), 0);
  v35 = v41;
  *(_DWORD *)(v41 + 24) = v34;
  if ( !v34 )
    return 0;
  v36 = v40;
  *(_DWORD *)(v35 + 12) = v31;
  *(_DWORD *)(v35 + 28) = v36;
  *(_DWORD *)(v35 + 32) = v43 & 0xE0;
  *(_DWORD *)(v35 + 36) = v44;
  return v35;
}
// 1004B250: could not find valid save-restore pair for ebx

//----- (1004B7E0) --------------------------------------------------------
int __usercall sub_1004B7E0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4@<bl>)
{
  return sub_1004B250(a4, a2, a3, a1, 1);
}

//----- (1004B7F0) --------------------------------------------------------
int __cdecl sub_1004B7F0(int a1, int a2, int *a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int *v6; // ebp@2
  signed int v7; // eax@3
  int v8; // eax@8
  int result; // eax@11
  int v10; // esi@11
  int v11; // eax@13
  int v12; // eax@15
  signed int v13; // eax@17
  signed int v14; // eax@19
  int v15; // eax@21
  int v16; // eax@33
  int v17; // esi@34
  int v18; // eax@35
  int v19; // esi@39
  int v20; // ecx@41
  int v21; // esi@41
  int v22; // eax@41
  int v23; // eax@44
  int v24; // esi@44
  int v25; // eax@45
  int v26; // eax@45
  signed int v27; // eax@48
  int v28; // eax@51
  int v29; // ST1C_4@51
  int v30; // ecx@53
  int v31; // eax@71
  int v32; // ecx@73
  int v33; // eax@73
  int v34; // esi@85
  char v35; // [sp+0h] [bp-1Ch]@0
  int v36; // [sp+10h] [bp-Ch]@1
  signed int v37; // [sp+14h] [bp-8h]@3
  signed int v38; // [sp+14h] [bp-8h]@19
  int v39; // [sp+14h] [bp-8h]@66
  signed int v40; // [sp+18h] [bp-4h]@1
  int v41; // [sp+18h] [bp-4h]@18
  int v42; // [sp+18h] [bp-4h]@39
  int v43; // [sp+18h] [bp-4h]@43

  v3 = a2;
  v4 = a1;
  v5 = 0;
  v36 = 0;
  v40 = 0;
  if ( (unsigned int)&a1 <= *(_DWORD *)(a1 + 12) )
  {
LABEL_10:
    sub_10045A60(v4, v3, 0, 0, 26, v35);
    return 0;
  }
  v6 = a3;
  while ( 2 )
  {
    *(_DWORD *)(v3 + 124) |= 8u;
    v7 = sub_10045FA0(v5, v4, v3);
    *(_DWORD *)(v3 + 124) &= 0xFFFFFFF7;
    v37 = v7;
    if ( v7 == 29 )
    {
      v7 = sub_100478A0(v4, v3, 34);
      v37 = v7;
      if ( v7 != -1 )
      {
        v5 = v36;
        goto LABEL_6;
      }
      return 0;
    }
LABEL_6:
    switch ( v7 )
    {
      case 53:
        if ( v5 )
          goto LABEL_83;
        v8 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), 1);
        v36 = v8;
        if ( !v8 )
          return 0;
        v5 = v8;
        *(_DWORD *)(v8 + 24) = 0;
        *(_DWORD *)(v8 + 28) = (signed int)*(double *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 16);
        if ( (unsigned int)&a1 <= *(_DWORD *)(v4 + 12) )
          goto LABEL_10;
        continue;
      case 34:
        result = sub_1004B7E0((int)v6, v4, v3, v3);
        v10 = result;
        if ( !result )
          return result;
        goto LABEL_81;
      case 23:
        v11 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), -2);
        a1 = v11;
        if ( !v11 )
          return 0;
        v10 = v11;
        *(_DWORD *)v11 = 24;
        *(_DWORD *)(v11 + 36) = 0;
        if ( v36 )
        {
          *(_DWORD *)(v11 + 24) = v36;
          v12 = v36 + 40;
          *(_DWORD *)(v10 + 32) = 1;
        }
        else
        {
          v12 = v11 + 24;
          *(_DWORD *)(v10 + 24) = 0;
          *(_DWORD *)(v10 + 32) = 0;
        }
        *(_DWORD *)(v10 + 28) = v12;
        *(_DWORD *)(v3 + 124) |= 8u;
        v13 = sub_10047570(v4, v3, 24);
        *(_DWORD *)(v3 + 124) &= 0xFFFFFFF7;
        if ( v13 )
          goto LABEL_31;
        v41 = 0;
        break;
      case 25:
        v16 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), -2);
        a1 = v16;
        if ( !v16 )
          return 0;
        v17 = v16;
        *(_DWORD *)v16 = 26;
        if ( v36 )
        {
          *(_DWORD *)(v16 + 24) = v36;
          v18 = v36 + 40;
          *(_DWORD *)(v17 + 32) = 1;
        }
        else
        {
          v18 = v16 + 24;
          *(_DWORD *)(v17 + 24) = 0;
          *(_DWORD *)(v17 + 32) = 0;
        }
        *(_DWORD *)(v17 + 28) = v18;
        if ( sub_10047570(v4, v3, 26) )
          goto LABEL_61;
        while ( 2 )
        {
          switch ( sub_10045FA0(v17, v4, v3) )
          {
            case 30:
              v19 = v3 + 24 * *(_DWORD *)(v3 + 96);
              v42 = sub_10047720((int)v6, v4, v19, 0);
              if ( v42 )
                *(double *)(v42 + 24) = *(double *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 16);
              goto LABEL_48;
            case 29:
              v20 = *(_DWORD *)(v4 + 24);
              v21 = *(_DWORD *)(v20 + 248);
              v22 = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 20);
              if ( v22 != v21 && v22 != *(_DWORD *)(v20 + 284) )
                goto LABEL_46;
              v43 = (v22 != v21) + 123;
              if ( !sub_10047570(v4, v3, 29) )
                goto LABEL_46;
              v23 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), -1);
              v24 = v23;
              if ( !v23 )
                return 0;
              *(_DWORD *)(v23 + 24) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 20);
              *(_DWORD *)(v23 + 28) = 0;
              *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 16) = 0;
              *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96)) = 34;
              v25 = sub_1004B7E0((int)v6, v4, v3, v3);
              v26 = sub_10047750(v25, (int)v6, v24, v4, 6, v43);
              goto LABEL_52;
            case 31:
LABEL_46:
              v19 = v3 + 24 * *(_DWORD *)(v3 + 96);
              v42 = sub_10047720((int)v6, v4, v19, 0);
              if ( v42 )
                *(_DWORD *)(v42 + 24) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 20);
LABEL_48:
              v27 = sub_10045FA0(v19, v4, v3);
              if ( v27 == 29 )
              {
                v27 = sub_100478A0(v4, v3, 6);
                if ( v27 == -1 )
                  return 0;
              }
              if ( v27 != 6 )
              {
                sub_10045A60(v4, v3, 0, 0, 106, v35);
                return 0;
              }
              v24 = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 16);
              v28 = sub_10049560(v24, v4, v3, v6);
              v29 = v24;
              LOBYTE(v24) = v42;
              v26 = sub_10047750(v28, (int)v6, v42, v4, 6, v29);
LABEL_52:
              if ( !v26 )
                return 0;
              v30 = a1;
              **(_DWORD **)(a1 + 28) = v26;
              ++*(_DWORD *)(v30 + 32);
              *(_DWORD *)(v30 + 28) = v26 + 40;
              if ( sub_10047570(v4, v3, 3) )
              {
                v17 = a1;
                continue;
              }
              if ( sub_10045FA0(v24, v4, v3) != 26 )
              {
                sub_10045A60(v4, v3, 0, 0, 107, v35);
                return 0;
              }
LABEL_61:
              v17 = a1;
LABEL_62:
              *(_DWORD *)(v17 + 8) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 8);
              result = v17;
              break;
            case 26:
              result = sub_10045A60(v4, v3, 0, 5, 161, v35);
              if ( result )
                goto LABEL_62;
              return result;
            default:
              sub_10045A60(v4, v3, 0, 0, 131, v35);
              return 0;
          }
          return result;
        }
      case 54:
        v10 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), 0);
        if ( !v10 )
          return 0;
        *(_DWORD *)(v10 + 28) = (signed int)*(double *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 16);
        goto LABEL_80;
      case 27:
        v10 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), 1);
        if ( !v10 )
          return 0;
        a1 = *v6;
        *v6 = a1 & 0xFFFFFFEF;
        v39 = sub_10047B90(v4, v10, v3, v6);
        *v6 = a1 | *v6 & 0xE0;
        if ( !v39 )
          return 0;
        if ( sub_10045FA0(v10, v4, v3) != 28 )
        {
          sub_10045A60(v4, v3, 0, 0, 108, v35);
          return 0;
        }
        *(_DWORD *)v10 = 28;
        *(_DWORD *)(v10 + 8) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 8);
        *(_DWORD *)(v10 + 24) = v39;
LABEL_81:
        if ( !v36 )
          return v10;
        if ( v40 )
        {
LABEL_83:
          sub_10045A60(v4, v3, 0, 0, 134, v35);
          return 0;
        }
        result = v36;
        *(_DWORD *)(v36 + 24) = v10;
        return result;
      case 31:
        v40 = 1;
        goto LABEL_71;
      case 29:
      case 32:
LABEL_71:
        v31 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), 0);
        v10 = v31;
        if ( !v31 )
          return 0;
        *(_DWORD *)(v31 + 12) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 16);
        *(_DWORD *)(v31 + 24) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 20);
        if ( v37 == 29 )
        {
          *(_DWORD *)(v31 + 20) = -1;
          *(_DWORD *)(v31 + 32) = -1;
          v32 = *(_DWORD *)(v31 + 24);
          *(_DWORD *)(v31 + 28) = 0;
          *(_DWORD *)(v31 + 36) = 0;
          v33 = *(_DWORD *)(v4 + 24);
          if ( v32 == *(_DWORD *)(v33 + 276) || v32 == *(_DWORD *)(v33 + 280) )
            *v6 |= 0x80u;
        }
        goto LABEL_81;
      case 30:
        v10 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), 0);
        if ( !v10 )
          return 0;
        *(double *)(v10 + 24) = *(double *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 16);
        goto LABEL_80;
      case 33:
        v10 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), 0);
        if ( !v10 )
          return 0;
        *(_DWORD *)(v10 + 12) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 16);
LABEL_80:
        v40 = 1;
        goto LABEL_81;
      case 35:
      case 36:
      case 61:
        v34 = sub_1001B130(
                v4,
                *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 12),
                *(_WORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 8) - *(_WORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 4));
        sub_10045A60(v4, v3, 0, 0, 132, v34);
        sub_10010340(v4, v34);
        return 0;
      default:
        sub_10045A60(v4, v3, 0, 0, 133, v35);
        return 0;
      case 4294967295:
        return 0;
    }
    break;
  }
  while ( 1 )
  {
    *(_DWORD *)(v3 + 124) |= 8u;
    v14 = sub_100475E0(v4, v3);
    *(_DWORD *)(v3 + 124) &= 0xFFFFFFF7;
    v38 = v14;
    if ( v14 == 24 )
      break;
    if ( v14 == 3 )
    {
      sub_10047570(v4, v3, 3);
      v15 = sub_10047720((int)v6, v4, v3 + 24 * *(_DWORD *)(v3 + 96), 0);
      v10 = a1;
    }
    else
    {
      v15 = sub_10049560(v10, v4, v3, v6);
    }
    if ( !v15 )
      return 0;
    **(_DWORD **)(v10 + 28) = v15;
    ++*(_DWORD *)(v10 + 32);
    *(_DWORD *)(v10 + 28) = v15 + 40;
    if ( (v38 == 3 || sub_10047570(v4, v3, 3)) && (unsigned int)++v41 < 0x10000 )
      continue;
    goto LABEL_29;
  }
  *(_DWORD *)(v10 + 36) = 1;
LABEL_29:
  if ( sub_10045FA0(v10, v4, v3) != 24 )
  {
    sub_10045A60(v4, v3, 0, 0, 105, v35);
    return 0;
  }
LABEL_31:
  *(_DWORD *)(v10 + 8) = *(_DWORD *)(v3 + 24 * *(_DWORD *)(v3 + 96) + 8);
  return v10;
}

//----- (1004BF50) --------------------------------------------------------
int __usercall sub_1004BF50@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)
{
  unsigned __int16 v2; // ax@2
  int result; // eax@2
  __int16 v4; // dx@3

  if ( (dword_100D1E4C[4 * *a1] & 0xFu) - 9 > 2 )
  {
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *(_BYTE *)(a2 + 1);
    result = *(_BYTE *)(a2 + 2) | v4;
  }
  else
  {
    HIBYTE(v2) = *(_BYTE *)(a2 + 1);
    LOBYTE(v2) = *(_BYTE *)(a2 + 2);
    result = *(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 3) | (v2 << 8)) << 8);
  }
  return result;
}
// 100D1E4C: using guessed type int dword_100D1E4C[];

//----- (1004BFA0) --------------------------------------------------------
signed int __usercall sub_1004BFA0@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // edi@1
  int v4; // edx@2
  int *v5; // eax@2
  unsigned int v6; // ecx@2
  size_t v7; // edx@5
  int v8; // ebx@5
  unsigned int v9; // ecx@6
  signed int result; // eax@14
  int v11; // [sp-10h] [bp-1Ch]@8
  void *v12; // [sp-Ch] [bp-18h]@8
  size_t v13; // [sp-8h] [bp-14h]@8
  int v14; // [sp-4h] [bp-10h]@8

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 4);
  if ( !v2 )
  {
    v4 = *(_DWORD *)(v3 + 16);
    v5 = *(int **)(v4 + 12);
    v6 = (a2 + 3) & 0xFFFFFFFC;
    if ( (unsigned int)v5 + v6 <= *(_DWORD *)(v4 + 8) )
      *(_DWORD *)(v4 + 12) = (char *)v5 + v6;
    else
      v5 = (int *)sub_1003E2D0(v3, v6);
    goto LABEL_12;
  }
  v7 = *(_DWORD *)(a1 + 12);
  v8 = *(_DWORD *)(v3 + 16);
  if ( *(_DWORD *)(v8 + 12) != v2 + ((v7 + 3) & 0xFFFFFFFC) )
  {
    v14 = a2;
    v13 = *(_DWORD *)(a1 + 12);
    v12 = *(void **)(a1 + 8);
    v11 = *(_DWORD *)(a1 + 4);
LABEL_11:
    v5 = sub_1003E510(v11, v12, v13, v14);
    goto LABEL_12;
  }
  v9 = v2 + ((v7 + a2 + 3) & 0xFFFFFFFC);
  if ( v9 <= *(_DWORD *)(v8 + 8) )
  {
    *(_DWORD *)(v8 + 12) = v9;
    goto LABEL_13;
  }
  v14 = a2;
  v13 = *(_DWORD *)(a1 + 12);
  v12 = *(void **)(a1 + 8);
  v11 = *(_DWORD *)(a1 + 4);
  if ( v2 != *(_DWORD *)(v8 + 4) )
    goto LABEL_11;
  v5 = sub_1003E400(v3, v2, v7, a2);
LABEL_12:
  *(_DWORD *)(a1 + 8) = v5;
LABEL_13:
  if ( *(_DWORD *)(a1 + 8) )
  {
    *(_DWORD *)(a1 + 12) += a2;
    result = 1;
  }
  else
  {
    sub_10011170(*(_DWORD *)a1);
    result = 0;
  }
  return result;
}

//----- (1004C040) --------------------------------------------------------
signed int __usercall sub_1004C040@<eax>(int a1@<eax>, size_t a2@<ebx>, void *a3)
{
  int v3; // esi@1
  int v4; // eax@1
  signed int result; // eax@3
  signed int v6; // edi@4
  void *v7; // esi@4

  v3 = a1;
  v4 = a2 - *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 16) + 1;
  if ( v4 <= 0 || sub_1004BFA0(v3, v4) )
  {
    v6 = *(_DWORD *)(v3 + 16);
    *(_DWORD *)(v3 + 16) = v6 + a2;
    v7 = (void *)(v6 + *(_DWORD *)(v3 + 8));
    memcpy_0(v7, a3, a2);
    result = v6;
    *((_BYTE *)v7 + a2) = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1004C090) --------------------------------------------------------
signed int __usercall sub_1004C090@<eax>(_DWORD *a1@<eax>, char *a2, char a3)
{
  int *v3; // edi@1
  const char *v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@2
  signed int v7; // edi@3

  v3 = a1;
  v4 = (const char *)sub_100509D0(a2, (int)&a3);
  v5 = (unsigned int)v4;
  if ( v4 )
  {
    v7 = sub_1004C040((int)v3, strlen(v4), (void *)v4);
    sub_10053E10(v5, dword_10658DEC);
    result = v7;
  }
  else
  {
    sub_10011170(*v3);
    result = -1;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1004C0F0) --------------------------------------------------------
int __usercall sub_1004C0F0@<eax>(int a1@<eax>, int a2, __int16 a3)
{
  int v3; // ebp@1
  int v4; // edi@1
  int result; // eax@3
  unsigned int v6; // eax@4
  int v7; // ecx@4
  _BYTE *v8; // esi@6
  int v9; // edx@9
  int v10; // eax@9
  int v11; // eax@11
  _BYTE *v12; // ebx@13
  unsigned __int16 v13; // bp@16
  int v14; // edx@23
  int v15; // ecx@23
  int v16; // edi@23
  int v17; // ecx@26
  _BYTE *v18; // eax@26
  int v19; // ecx@26
  int v20; // edi@26
  _WORD *v21; // eax@29
  char *v22; // eax@31
  signed int v23; // eax@30
  int v24; // [sp+8h] [bp-Ch]@6
  unsigned int v25; // [sp+Ch] [bp-8h]@13
  int v26; // [sp+10h] [bp-4h]@1

  v3 = a2;
  v4 = a1;
  v26 = *(_DWORD *)(a2 + 16);
  if ( a3 && sub_1004C090((_DWORD *)a2, "%c", a3) < 0 )
  {
    result = 0;
  }
  else
  {
    v6 = *(_DWORD *)v4;
    v7 = *(_DWORD *)(v4 + 4);
    if ( *(_DWORD *)v4 & 0x40000000 )
    {
      if ( *(_DWORD *)v7 & 0x40000000 )
      {
        v8 = (_BYTE *)sub_1001A200(v4);
        v24 = (int)v8;
      }
      else if ( (v6 & 0x80000000) == 0 )
      {
        v9 = *(_DWORD *)(v7 + 4);
        v10 = (v6 >> 15) & 0x7FFF;
        v24 = v9 + 2 * v10;
        v8 = (_BYTE *)(v9 + 2 * v10);
      }
      else
      {
        v24 = *(_DWORD *)(v7 + 4);
        v8 = *(_BYTE **)(v7 + 4);
      }
    }
    else
    {
      v24 = *(_DWORD *)(v4 + 4);
      v8 = *(_BYTE **)(v4 + 4);
    }
    v11 = *(_DWORD *)v4;
    if ( *(_DWORD *)v4 & 0x40000000 )
      v11 = *(_DWORD *)v4 & ((v11 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    v25 = (unsigned int)&v8[2 * v11];
    v12 = v8;
    if ( (unsigned int)v8 < v25 )
    {
      while ( 1 )
      {
        v13 = *(_WORD *)v12;
        while ( v13 < 0x80u )
        {
          if ( !isprint(v13) )
            break;
          if ( v13 == a3 )
            break;
          if ( v13 == 92 )
            break;
          if ( v13 & 0xFF00 )
            break;
          v13 = *((_WORD *)v12 + 1);
          v12 += 2;
          if ( v12 == (_BYTE *)v25 )
            break;
        }
        v14 = a2;
        v15 = *(_DWORD *)(a2 + 16);
        v16 = (v12 - v8) >> 1;
        if ( v16 - *(_DWORD *)(a2 + 12) + v15 + 1 > 0 )
        {
          if ( !sub_1004BFA0(a2, ((v12 - v8) >> 1) - *(_DWORD *)(a2 + 12) + v15 + 1) )
            goto LABEL_39;
          v8 = (_BYTE *)v24;
          v14 = a2;
        }
        v17 = *(_DWORD *)(v14 + 16);
        v18 = (_BYTE *)(v17 + *(_DWORD *)(v14 + 8));
        v19 = v16 + v17;
        v20 = v16 - 1;
        for ( *(_DWORD *)(v14 + 16) = v19; v20 >= 0; --v20 )
        {
          *v18++ = *v8;
          v8 += 2;
        }
        *v18 = 0;
        if ( v12 == (_BYTE *)v25 )
          break;
        v21 = sub_1001AFE0(&unk_100D27E0, v13);
        if ( v21 )
        {
          v23 = sub_1004C090((_DWORD *)a2, "\\%c", *((_BYTE *)v21 + 2));
        }
        else
        {
          v22 = "\\u%04X";
          if ( !(v13 & 0xFF00) )
            v22 = "\\x%02X";
          v23 = sub_1004C090((_DWORD *)a2, v22, v13);
        }
        if ( v23 < 0 )
          goto LABEL_39;
        v12 += 2;
        v24 = (int)v12;
        if ( (unsigned int)v12 >= v25 )
          break;
        v8 = v12;
      }
      v3 = a2;
    }
    if ( a3 && sub_1004C090((_DWORD *)v3, "%c", a3) < 0 )
LABEL_39:
      result = 0;
    else
      result = v26 + *(_DWORD *)(v3 + 8);
  }
  return result;
}

//----- (1004C310) --------------------------------------------------------
int __cdecl sub_1004C310(int a1, int a2, __int16 a3)
{
  int v3; // ebx@1
  int v4; // ebp@1
  int v5; // edi@1
  const char *v6; // eax@1
  int v7; // esi@3
  int result; // eax@5
  int v9; // [sp+10h] [bp-14h]@1
  int v10; // [sp+14h] [bp-10h]@1
  int v11; // [sp+18h] [bp-Ch]@1
  int v12; // [sp+1Ch] [bp-8h]@1
  int v13; // [sp+20h] [bp-4h]@1

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 76) + 12);
  v4 = 0;
  v5 = a1 + 60;
  v9 = a1;
  v10 = a1 + 60;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v6 = (const char *)sub_1004C0F0(a2, (int)&v9, a3);
  if ( v6 )
    v4 = sub_10010F20(a1, v6);
  v7 = *(_DWORD *)(a1 + 76);
  if ( v7 == v5 || v3 - *(_DWORD *)(v7 + 4) > (unsigned int)(*(_DWORD *)(v7 + 12) - *(_DWORD *)(v7 + 4)) )
  {
    sub_1003E5E0(v5, v3);
    result = v4;
  }
  else
  {
    *(_DWORD *)(v7 + 12) = (v3 + 3) & 0xFFFFFFFC;
    result = v4;
  }
  return result;
}

//----- (1004C3A0) --------------------------------------------------------
int __cdecl sub_1004C3A0(int a1, int a2, unsigned int a3, char a4)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // eax@3
  int v7; // eax@4
  int v8; // eax@5
  int v9; // ecx@6
  int (__cdecl **v10)(int, int, int, int, int); // eax@6

  v4 = sub_10011830(a1, 0x40u);
  if ( v4 )
  {
    *(_DWORD *)v4 = a1;
    *(_DWORD *)(v4 + 4) = v4 + 20;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    sub_1003E280(v4 + 20, a2, 256, 1u);
    *(_DWORD *)(v4 + 48) = a3 & 0xFFFEFFFF;
    *(_BYTE *)(v4 + 52) = a4;
    *(_BYTE *)(v4 + 53) = (a3 >> 16) & 1;
    *(_DWORD *)(v4 + 56) = 0;
    *(_DWORD *)(v4 + 60) = 0;
    v6 = *(_DWORD *)(a1 + 56);
    if ( v6 )
    {
      v7 = *(_DWORD *)(v6 + 16);
      if ( v7 )
      {
        v8 = *(_DWORD *)(v7 + 4);
        if ( v8 )
        {
          v9 = *(_DWORD *)v8;
          v10 = *(int (__cdecl ***)(int, int, int, int, int))(*(_DWORD *)v8 + 4);
          if ( v10 == &off_101614B0 || v10 && *v10 == off_101614B0 )
            *(_DWORD *)(v4 + 60) = v9;
        }
      }
    }
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (1004C450) --------------------------------------------------------
int *__cdecl sub_1004C450(unsigned int a1)
{
  sub_1003E6D0((_DWORD **)(a1 + 20));
  return sub_10010340(*(_DWORD *)a1, a1);
}

//----- (1004C470) --------------------------------------------------------
int __cdecl sub_1004C470(int a1)
{
  const char *v1; // eax@1
  int v2; // ebx@1
  int result; // eax@2
  int v4; // ebp@3

  v1 = *(const char **)(a1 + 8);
  v2 = *(_DWORD *)a1;
  if ( v1 )
  {
    result = sub_10010F20(v2, v1);
    v4 = result;
    if ( result )
    {
      sub_1003E6B0((_DWORD **)(a1 + 20));
      *(_DWORD *)(a1 + 4) = a1 + 20;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      result = v4;
      *(_DWORD *)a1 = v2;
    }
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v2 + 24) + 480);
  }
  return result;
}

//----- (1004C4D0) --------------------------------------------------------
size_t __cdecl sub_1004C4D0(int a1, void *a2, char a3)
{
  const char *v3; // ecx@1
  unsigned int v5; // esi@9
  unsigned int v6; // edi@10
  const char *v7; // eax@11
  const char *v8; // edi@13
  size_t v9; // ebx@18

  v3 = (const char *)a2;
  if ( !*(_BYTE *)a2 )
    return 0;
  if ( *(_BYTE *)a2 == 9 )
  {
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( sub_1004C090((_DWORD *)a1, "%*s", *(_DWORD *)(a1 + 48)) < 0 )
        return -1;
      v3 = (const char *)a2;
    }
    ++v3;
  }
  v5 = 0;
  if ( !*(_BYTE *)(a1 + 52) )
  {
    v6 = strlen(v3);
    if ( v3[v6 - 1] == 10 )
    {
      v7 = (const char *)sub_100118A0(*(_DWORD *)a1, (void *)v3);
      v5 = (unsigned int)v7;
      if ( !v7 )
        return -1;
      v3 = v7;
      v7[v6 - 1] = 0;
    }
  }
  v8 = (const char *)sub_100509D0((char *)v3, (int)&a3);
  if ( v5 )
    sub_10010340(*(_DWORD *)a1, v5);
  if ( !v8 )
  {
    sub_10011170(*(_DWORD *)a1);
    return -1;
  }
  v9 = strlen(v8);
  if ( sub_1004C040(a1, v9, (void *)v8) < 0 )
    v9 = -1;
  sub_10053E10((unsigned int)v8, dword_10658DEC);
  return v9;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (1004C5E0) --------------------------------------------------------
BOOL __cdecl sub_1004C5E0(int a1, const char *a2)
{
  return sub_1004C040(a1, strlen(a2), (void *)a2) >= 0;
}

//----- (1004C620) --------------------------------------------------------
signed int __usercall sub_1004C620@<eax>(int a1@<eax>, int a2@<ebx>, int a3)
{
  int v3; // esi@1
  unsigned int v4; // eax@2
  char v6; // cl@6

  v3 = a1;
  if ( !sub_1004BFA0(a1, 3) )
    return 0;
  v4 = *(_DWORD *)(v3 + 28);
  if ( v4 >= *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 32) + 56) + 32) )
  {
    sub_10011170(*(_DWORD *)v3);
    return 0;
  }
  *(_DWORD *)(*(_DWORD *)(v3 + 20) + 4 * v4) = a3;
  if ( a2 == 254 )
  {
    v6 = 53;
  }
  else
  {
    v6 = 55;
    if ( a2 != 255 )
      v6 = a2;
  }
  *(_BYTE *)(v4 + *(_DWORD *)(v3 + 24)) = v6;
  *(_DWORD *)(v3 + 16) += 3;
  *(_DWORD *)(v3 + 28) = v4 + 1;
  return 1;
}

//----- (1004C690) --------------------------------------------------------
signed int __usercall sub_1004C690@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // edi@1
  int v3; // ecx@1
  signed int result; // eax@2
  int v5; // edx@3
  int v6; // ecx@3
  unsigned __int8 v7; // dl@3
  int v8; // ecx@5
  int v9; // edx@5
  signed int v10; // ecx@6

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 28);
  if ( v3 )
  {
    v5 = *(_DWORD *)(a1 + 24);
    v6 = v3 - 1;
    *(_DWORD *)(a1 + 28) = v6;
    v7 = *((_BYTE *)&off_100D1E40 + 16 * *(_BYTE *)(v5 + v6) + 11);
    if ( v7 && v7 < (unsigned __int8)byte_100D1E4B[16 * v2] )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4 * v6) -= 2;
      v8 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4 * v6);
      v9 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 16) = v8;
      result = sub_1004C090((_DWORD *)a1, "(%s)", v9 + v8 + 2);
    }
    else
    {
      v10 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4 * v6);
      *(_DWORD *)(a1 + 16) = v10;
      result = v10;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100D1E40: using guessed type void *off_100D1E40;

//----- (1004C700) --------------------------------------------------------
int __cdecl sub_1004C700(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if ( v2 == v3 )
    result = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a2 + 12);
  else
    result = v2 - v3;
  return result;
}

//----- (1004C720) --------------------------------------------------------
signed int __usercall sub_1004C720@<eax>(int a1@<ebx>, int a2, unsigned int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  char v8; // al@1
  int v9; // edi@2
  int v11; // edx@6
  unsigned int v12; // eax@6
  int v13; // ecx@7
  int v14; // ebp@9
  int v15; // eax@10
  signed int v16; // edi@12
  signed int v17; // edi@13
  int v18; // ecx@13
  int v19; // edi@13
  int v20; // eax@16
  int v21; // eax@18
  int v22; // eax@20
  char v23; // [sp+0h] [bp-20h]@0
  int v24; // [sp+Ch] [bp-14h]@12
  int v25; // [sp+10h] [bp-10h]@7
  int v26; // [sp+14h] [bp-Ch]@6
  int v27; // [sp+18h] [bp-8h]@1
  unsigned int v28; // [sp+1Ch] [bp-4h]@9

  v7 = *(_DWORD *)(a1 + 32);
  v27 = *(_DWORD *)a1;
  v8 = sub_1004C690(a1, 0);
  sub_1004C4D0(v7, "\tswitch (%s) {\n", *(_BYTE *)(a1 + 8) + v8);
  if ( a3 )
  {
    v9 = *(_DWORD *)(a2 + 4) - a6;
    if ( v9 > 0 )
    {
      *(_DWORD *)(v7 + 48) += 2;
      sub_1004C4D0(v7, "\tdefault:\n", v23);
      *(_DWORD *)(v7 + 48) += 2;
      if ( !sub_1004CCA0(a1, a6 + a4, v9) )
        return 0;
      *(_DWORD *)(v7 + 48) -= 4;
    }
    v11 = a7 != 0;
    v12 = 0;
    v26 = a7 != 0;
    if ( a3 )
    {
      v13 = a2 + 8;
      v25 = a2 + 8;
      while ( 1 )
      {
        v14 = *(_DWORD *)(v13 - 4);
        v28 = v12 + 1;
        if ( v12 + 1 >= a3 )
          v15 = a5;
        else
          v15 = *(_DWORD *)(v13 + 12);
        v16 = *(_DWORD *)(v13 - 8);
        v24 = v15;
        if ( a7 )
        {
          v17 = v16 >> 1;
          v18 = byte_100D1E48[16 * *(_BYTE *)(v17 + a4)];
          *(_DWORD *)(v7 + 48) += 2;
          v19 = v18 + v17;
          if ( !sub_1004CCA0(a1, a4 + v11, v19 - v11) )
            return 0;
          v26 = v19;
        }
        else
        {
          if ( *(_DWORD *)v13 )
          {
            v20 = *(_DWORD *)(*(_DWORD *)v13 + 8) & 0xFFFFFFF8;
            LOBYTE(v16) = 1;
          }
          else
          {
            v20 = sub_1001ACB0(v27, v16);
            if ( !v20 )
              return 0;
          }
          v21 = sub_1004C0F0(v20, a1, (v16 & 7) != 4 ? 0 : 34);
          if ( !v21 )
            return 0;
          *(_DWORD *)(a1 + 16) = v21 - *(_DWORD *)(a1 + 8);
          *(_DWORD *)(v7 + 48) += 2;
          sub_1004C4D0(v7, "\tcase %s:\n", v21);
        }
        *(_DWORD *)(v7 + 48) += 2;
        v22 = v24;
        if ( v14 <= a6 && a6 < v24 )
        {
          if ( a6 != v14 )
          {
            if ( !sub_1004CCA0(a1, a4 + v14, a6 - v14) )
              return 0;
            v14 = a6;
          }
          *(_DWORD *)(v7 + 48) -= 2;
          sub_1004C4D0(v7, "\tdefault:\n", v23);
          v22 = v24;
          *(_DWORD *)(v7 + 48) += 2;
        }
        if ( !sub_1004CCA0(a1, a4 + v14, v22 - v14) )
          return 0;
        v12 = v28;
        *(_DWORD *)(v7 + 48) -= 4;
        v25 += 16;
        if ( v28 >= a3 )
          break;
        v13 = v25;
        v11 = v26;
      }
    }
  }
  if ( a6 == a5 )
  {
    *(_DWORD *)(v7 + 48) += 2;
    sub_1004C4D0(v7, "\tdefault:;\n", v23);
    *(_DWORD *)(v7 + 48) -= 2;
  }
  sub_1004C4D0(v7, "\t}\n", v23);
  return 1;
}

//----- (1004C950) --------------------------------------------------------
int __usercall sub_1004C950@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v3; // ecx@1
  int v4; // eax@2
  int v5; // ecx@6
  int *v6; // eax@7
  int result; // eax@9

  v3 = *(_DWORD *)(a1 + 60);
  if ( v3 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(v3 + 36);
      if ( v4 )
        break;
LABEL_6:
      v5 = *(_DWORD *)(v3 + 16);
      if ( v5 )
      {
        v6 = (int *)(**(_DWORD **)(v5 + 4) & 0xFFFFFFF8);
        if ( v6 )
        {
          v3 = *v6;
          if ( *v6 )
            continue;
        }
      }
      goto LABEL_9;
    }
    while ( *(_DWORD *)(v4 + 4) != a3 || *(_WORD *)(v4 + 18) != a2 )
    {
      v4 = *(_DWORD *)(v4 + 20);
      if ( !v4 )
        goto LABEL_6;
    }
    result = *(_DWORD *)v4;
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (1004C9A0) --------------------------------------------------------
void *__usercall sub_1004C9A0@<eax>(unsigned __int8 *a1@<eax>)
{
  unsigned __int8 v1; // cl@2
  unsigned __int8 v2; // al@2
  const char *v3; // eax@4

  if ( a1 )
  {
    v1 = *a1;
    v2 = *a1 >> 3;
    if ( v2 < 0x18u )
    {
      if ( (unsigned int)v1 >> 3 == 6 )
      {
        v3 = "var";
LABEL_5:
        sub_10050B00((int)&unk_10572714, 8, "%s ", (char)v3);
        return &unk_10572714;
      }
      if ( v2 < 0x18u && (unsigned int)v1 >> 3 == 21 )
      {
        v3 = "const";
        goto LABEL_5;
      }
    }
  }
  return &unk_100C4192;
}

//----- (1004CA00) --------------------------------------------------------
int __cdecl sub_1004CA00(int a1, int a2)
{
  return sub_1004F7C0((int *)a1, a2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
}

//----- (1004CA20) --------------------------------------------------------
int __usercall sub_1004CA20@<eax>(char a1@<bpl>, int a2, int a3)
{
  int v3; // esi@1
  char v4; // ST08_1@2
  int v5; // edi@3
  char v6; // al@4
  int v7; // eax@11
  int result; // eax@12
  int v9; // ecx@15
  unsigned int v10; // ebx@15
  int v11; // ebp@15
  unsigned int v12; // eax@15
  int v13; // eax@20
  int i; // eax@20
  int v15; // edi@24
  int v16; // eax@29
  int v17; // ebx@34
  int v18; // edi@36
  int v19; // eax@36
  char v20; // [sp-8h] [bp-18h]@13
  char v21; // [sp-8h] [bp-18h]@34
  int v22; // [sp+8h] [bp-8h]@15
  int v23; // [sp+Ch] [bp-4h]@0
  int v24; // [sp+14h] [bp+4h]@15

  v3 = a2;
  if ( *(_BYTE *)(a2 + 52) )
  {
    sub_1004C5E0(a2, "\n");
    sub_1004C4D0(a2, "\t", v4);
LABEL_3:
    v5 = a3;
    goto LABEL_4;
  }
  if ( *(_BYTE *)(a2 + 53) )
    goto LABEL_3;
  v5 = a3;
  if ( *(_BYTE *)(a3 + 22) & 8 )
    sub_1004C5E0(a2, "(");
LABEL_4:
  v6 = *(_BYTE *)(v5 + 22);
  if ( v6 & 0x10 )
  {
    sub_1004C4D0(a2, "%s ", (unsigned int)"getter");
  }
  else if ( v6 & 0x20 )
  {
    sub_1004C4D0(a2, "%s ", (unsigned int)"setter");
  }
  sub_1004C4D0(a2, "%s ", (unsigned int)"function");
  v7 = *(_DWORD *)(v5 + 24);
  if ( !v7 || (result = sub_1004C0F0(*(_DWORD *)(v7 + 8) & 0xFFFFFFF8, a2, 0)) != 0 )
  {
    v20 = a1;
    sub_1004C5E0(a2, "(");
    if ( *(_DWORD *)(v5 + 12) && *(_DWORD *)(v5 + 4) )
    {
      v9 = *(_DWORD *)(*(_DWORD *)a2 + 76);
      v10 = *(_WORD *)(v5 + 16);
      v24 = *(_DWORD *)a2;
      v22 = *(_DWORD *)(v9 + 12);
      v11 = v22;
      v12 = (4 * v10 + 3) & 0xFFFFFFFC;
      if ( v12 + v22 <= *(_DWORD *)(v9 + 8) )
        *(_DWORD *)(v9 + 12) = v12 + v22;
      else
        v11 = sub_1003E2D0(v24 + 60, v12);
      if ( !v11 )
      {
        sub_10011170(v24);
        return 0;
      }
      v13 = **(_DWORD **)(v5 + 4);
      v23 = v13;
      for ( i = *(_DWORD *)(v13 + 36); i; i = *(_DWORD *)(i + 20) )
      {
        if ( *(signed int (**)())(i + 4) == sub_1002FB00 )
          *(_DWORD *)(v11 + 4 * *(_WORD *)(i + 18)) = *(_DWORD *)i;
      }
      v15 = 0;
      if ( v10 )
      {
        do
        {
          if ( v15 )
            sub_1004C5E0(v3, ", ");
          if ( !sub_1004C0F0(*(_DWORD *)(*(_DWORD *)(v11 + 4 * v15) + 8) & 0xFFFFFFF8, v3, 0) )
            return 0;
        }
        while ( ++v15 < v10 );
      }
      v16 = *(_DWORD *)(v24 + 76);
      if ( v16 == v24 + 60 || v22 - *(_DWORD *)(v16 + 4) > (unsigned int)(*(_DWORD *)(v16 + 12) - *(_DWORD *)(v16 + 4)) )
        sub_1003E5E0(v24 + 60, v22);
      else
        *(_DWORD *)(v16 + 12) = (v22 + 3) & 0xFFFFFFFC;
      v5 = a3;
    }
    sub_1004C4D0(v3, ") {\n", v20);
    v17 = *(_DWORD *)(v3 + 48);
    *(_DWORD *)(v3 + 48) = v17 + 4;
    if ( *(_DWORD *)(v5 + 12) && *(_DWORD *)(v5 + 4) )
    {
      v18 = *(_DWORD *)(v3 + 60);
      *(_DWORD *)(v3 + 60) = v23;
      v19 = sub_1004CA00(v3, *(_DWORD *)(a3 + 12));
      *(_DWORD *)(v3 + 60) = v18;
      if ( !v19 )
      {
        *(_DWORD *)(v3 + 48) = v17;
        return 0;
      }
      v5 = a3;
    }
    else
    {
      sub_1004C4D0(v3, "\t[native code]\n", v21);
    }
    *(_DWORD *)(v3 + 48) -= 4;
    sub_1004C4D0(v3, "\t}", v21);
    if ( *(_BYTE *)(v3 + 52) )
    {
      sub_1004C5E0(v3, "\n");
    }
    else if ( !*(_BYTE *)(v3 + 53) )
    {
      if ( *(_BYTE *)(v5 + 22) & 8 )
        sub_1004C5E0(v3, ")");
    }
    result = 1;
  }
  return result;
}
// 1004CA20: could not find valid save-restore pair for ebp

//----- (1004CCA0) --------------------------------------------------------
signed int __cdecl sub_1004CCA0(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // ebp@1
  int v4; // esi@1
  int v5; // ecx@1
  signed int v6; // eax@2
  int v7; // ebx@2
  void **v8; // eax@7
  const char *v9; // ecx@7
  int v10; // eax@8
  int v11; // eax@9
  int v12; // ebx@12
  unsigned __int8 *v13; // eax@12
  unsigned __int8 v14; // al@13
  signed int v15; // eax@15
  void *v16; // ST1C_4@16
  int v17; // ST20_4@17
  unsigned __int8 *v18; // eax@22
  unsigned __int8 *v19; // ebx@22
  unsigned __int8 v20; // al@23
  unsigned int v21; // eax@24
  int v22; // eax@30
  int *v23; // eax@30
  int v24; // eax@30
  int v25; // eax@32
  int *v26; // eax@32
  int v27; // eax@32
  int v28; // eax@34
  unsigned __int8 *v29; // eax@34
  const char *v30; // ebp@34
  int v31; // ebx@34
  char v32; // ST1C_1@34
  _BYTE *v33; // ebp@35
  _BYTE *v34; // ebp@36
  _BYTE *v35; // ebp@37
  int v36; // ebp@38
  unsigned __int16 v37; // cx@39
  int *v38; // eax@39
  int v39; // eax@39
  _BYTE *v40; // ebp@40
  int v41; // ebx@41
  char v42; // al@43
  unsigned __int8 v43; // al@43
  int v44; // ebp@43
  int v45; // eax@47
  int v46; // ebx@47
  int *v47; // eax@47
  signed int v48; // eax@48
  char v49; // ST1C_1@53
  unsigned __int16 v50; // ax@56
  unsigned __int8 *v51; // eax@57
  unsigned __int8 v52; // al@58
  unsigned __int8 *v53; // eax@61
  unsigned int v54; // eax@63
  _BYTE *v55; // eax@66
  signed int v56; // eax@70
  unsigned int v57; // ST4C_4@71
  int v58; // ST20_4@72
  char v59; // al@75
  char v60; // al@78
  char v61; // cl@79
  char v62; // al@82
  int v63; // eax@84
  unsigned __int8 *v64; // eax@89
  unsigned __int8 v65; // al@90
  char v66; // al@93
  char v67; // ST18_1@93
  unsigned __int8 *v68; // eax@94
  unsigned __int8 v69; // al@95
  unsigned __int8 *v70; // eax@102
  unsigned __int8 v71; // al@103
  int v72; // ST20_4@105
  unsigned __int8 *v73; // eax@106
  unsigned int v74; // ecx@108
  int v75; // eax@112
  int *v76; // eax@112
  int v77; // eax@112
  int v78; // eax@115
  int *v79; // eax@115
  int v80; // eax@115
  unsigned __int8 *v81; // eax@118
  unsigned __int8 v82; // al@119
  unsigned int v83; // eax@120
  char v84; // al@124
  signed int v85; // eax@126
  int v86; // ebx@127
  unsigned __int8 v87; // al@128
  int v88; // ebx@130
  char v89; // al@134
  int v90; // eax@134
  signed int v91; // eax@135
  signed int v92; // eax@137
  unsigned __int8 v93; // al@138
  const char *v94; // ST40_4@140
  int v95; // ST20_4@141
  int v96; // ST20_4@142
  signed int v97; // eax@143
  int v98; // eax@144
  void *v99; // eax@145
  void *v100; // ebx@147
  signed int v101; // ST44_4@148
  int v102; // ebx@152
  unsigned __int16 v103; // dx@152
  int *v104; // esi@152
  unsigned __int16 v105; // dx@154
  unsigned __int16 v106; // dx@156
  unsigned __int16 v107; // ax@159
  unsigned __int8 v108; // al@164
  unsigned __int8 *v109; // eax@166
  unsigned __int8 v110; // al@167
  char v111; // al@171
  int v112; // eax@172
  const char *v113; // ecx@173
  const char *v114; // ecx@180
  int v115; // eax@180
  int v116; // eax@182
  const char *v117; // ecx@182
  signed int (*v118)(); // esi@183
  unsigned __int16 v119; // dx@184
  int *v120; // eax@184
  unsigned __int16 v121; // cx@187
  const char *v122; // ST40_4@189
  unsigned __int16 v123; // ax@191
  signed int v124; // eax@193
  void *v125; // eax@193
  signed int v126; // edx@193
  signed int v127; // eax@198
  void *v128; // eax@198
  signed int v129; // eax@201
  int v130; // eax@205
  int v131; // ecx@206
  signed int v132; // eax@213
  unsigned int v133; // ecx@214
  unsigned __int16 v134; // cx@221
  int *v135; // eax@221
  int v136; // eax@221
  unsigned __int16 v137; // dx@223
  int *v138; // eax@223
  int *v139; // ebx@223
  __int16 v140; // ax@225
  int v141; // ST1C_4@228
  int v142; // ST20_4@229
  int v143; // ST1C_4@229
  int v144; // ST20_4@230
  signed int (*v145)(); // esi@231
  unsigned __int16 v146; // dx@232
  int *v147; // eax@232
  unsigned __int16 v148; // ax@235
  int v149; // eax@236
  unsigned __int16 v150; // dx@238
  int *v151; // eax@238
  __int16 v152; // ax@240
  int v153; // ST1C_4@243
  int v154; // ST20_4@244
  int v155; // ST1C_4@244
  signed int (*v156)(); // esi@245
  unsigned __int16 v157; // dx@246
  int *v158; // eax@246
  unsigned __int16 v159; // dx@249
  int v160; // eax@250
  unsigned __int16 v161; // dx@252
  int *v162; // eax@252
  __int16 v163; // ax@254
  char v164; // al@257
  int v165; // ST20_4@257
  int v166; // ST48_4@258
  char v167; // al@258
  int v168; // ST20_4@258
  unsigned __int16 v169; // ax@260
  int *v170; // eax@260
  __int16 v171; // ax@262
  char v172; // al@265
  unsigned __int16 v173; // ax@266
  int *v174; // ebx@266
  __int16 v175; // ax@268
  int v176; // ebx@271
  unsigned __int8 *v177; // eax@271
  unsigned __int8 v178; // al@272
  int v179; // eax@274
  bool v180; // zf@278
  _BYTE *v181; // ebx@280
  int v182; // eax@280
  const char *v183; // ST40_4@283
  _BYTE *v184; // ebx@283
  unsigned __int8 *v185; // eax@284
  unsigned __int8 v186; // al@285
  int v187; // ST1C_4@287
  unsigned __int8 *v188; // eax@288
  char v189; // al@288
  unsigned __int8 *v190; // eax@289
  unsigned __int8 v191; // al@290
  int v192; // ST1C_4@292
  char v193; // ah@294
  char v194; // al@294
  signed int (*v195)(); // esi@296
  unsigned __int16 v196; // dx@297
  int *v197; // ebx@297
  unsigned __int16 v198; // ax@300
  unsigned __int8 *v199; // eax@301
  unsigned __int8 *v200; // esi@301
  int v201; // eax@301
  char v202; // ST1C_1@302
  char v203; // ah@304
  unsigned __int16 v204; // ax@305
  signed int v205; // eax@305
  char *v206; // eax@308
  unsigned __int16 v207; // ax@310
  int *v208; // eax@310
  int v209; // eax@310
  unsigned __int16 v210; // ax@312
  int *v211; // eax@312
  char *v212; // eax@313
  unsigned int v213; // ecx@316
  int v214; // ebx@320
  void *v215; // eax@322
  int v216; // ebx@323
  int v217; // eax@323
  __int16 v218; // cx@323
  int v219; // eax@323
  int v220; // ebx@323
  __int16 v221; // dx@323
  int v222; // eax@323
  const char *v223; // eax@326
  int v224; // ebx@327
  unsigned __int8 *v225; // eax@329
  int v226; // eax@330
  signed int v227; // eax@324
  unsigned int v228; // ecx@334
  signed int v229; // ebx@335
  int v231; // ebx@338
  int v232; // eax@338
  unsigned __int16 v233; // cx@338
  _BYTE *v234; // eax@338
  int v235; // ebx@338
  int v236; // eax@338
  unsigned __int8 *v237; // eax@341
  int v238; // eax@342
  unsigned __int16 v239; // cx@344
  int *v240; // ST3C_4@344
  int v241; // ebx@344
  int v242; // eax@344
  unsigned __int8 *v243; // eax@346
  int v244; // ebx@346
  int v245; // eax@346
  _BYTE *v246; // ebx@346
  int v247; // eax@352
  _BYTE *v248; // ebx@353
  int v249; // ebx@359
  int v250; // eax@359
  int v251; // eax@360
  const char *v252; // ST40_4@362
  int v253; // eax@362
  unsigned __int16 v254; // ax@363
  int v255; // eax@364
  char v256; // ST20_1@364
  unsigned int v257; // ST1C_4@364
  const char *v258; // eax@364
  int v259; // ebx@364
  int v260; // eax@366
  char v261; // al@367
  signed int v262; // eax@369
  _BYTE *v263; // eax@373
  char v264; // ch@374
  signed int v265; // ST20_4@374
  char *v266; // eax@375
  _BYTE *v267; // ebx@378
  unsigned __int8 *v268; // eax@378
  signed int v269; // ST20_4@380
  unsigned __int16 v270; // dx@381
  int *v271; // eax@381
  __int16 v272; // ax@383
  const char *v273; // ST40_4@386
  int v274; // ebx@386
  const char *v275; // ST40_4@387
  unsigned __int8 *v276; // eax@387
  unsigned __int8 v277; // al@388
  char v278; // bh@397
  char v279; // bl@397
  int v280; // ST20_4@397
  char v281; // ah@398
  void *v282; // [sp+4h] [bp-78h]@67
  char v283; // [sp+8h] [bp-74h]@0
  char v284; // [sp+8h] [bp-74h]@83
  int v285; // [sp+18h] [bp-64h]@1
  char *v286; // [sp+18h] [bp-64h]@225
  char *v287; // [sp+18h] [bp-64h]@240
  char *v288; // [sp+18h] [bp-64h]@254
  char *v289; // [sp+18h] [bp-64h]@262
  char *v290; // [sp+18h] [bp-64h]@268
  int v291; // [sp+18h] [bp-64h]@328
  int v292; // [sp+1Ch] [bp-60h]@1
  void *v293; // [sp+20h] [bp-5Ch]@70
  _BYTE *v294; // [sp+20h] [bp-5Ch]@75
  void *v295; // [sp+20h] [bp-5Ch]@137
  const char *v296; // [sp+20h] [bp-5Ch]@143
  _BYTE *v297; // [sp+20h] [bp-5Ch]@158
  int v298; // [sp+20h] [bp-5Ch]@188
  signed int v299; // [sp+20h] [bp-5Ch]@191
  int *v300; // [sp+20h] [bp-5Ch]@238
  int *v301; // [sp+20h] [bp-5Ch]@252
  int *v302; // [sp+20h] [bp-5Ch]@260
  int v303; // [sp+20h] [bp-5Ch]@271
  int v304; // [sp+20h] [bp-5Ch]@323
  unsigned int v305; // [sp+20h] [bp-5Ch]@352
  int *v306; // [sp+20h] [bp-5Ch]@381
  const char *v307; // [sp+24h] [bp-58h]@7
  const char *v308; // [sp+24h] [bp-58h]@12
  const char *v309; // [sp+24h] [bp-58h]@29
  const char *v310; // [sp+24h] [bp-58h]@327
  const char *v311; // [sp+24h] [bp-58h]@338
  const char *v312; // [sp+24h] [bp-58h]@354
  void **v313; // [sp+28h] [bp-54h]@7
  int v314; // [sp+28h] [bp-54h]@74
  int v315; // [sp+28h] [bp-54h]@166
  signed int v316; // [sp+28h] [bp-54h]@192
  signed int v317; // [sp+28h] [bp-54h]@205
  signed int i; // [sp+28h] [bp-54h]@213
  int v319; // [sp+28h] [bp-54h]@324
  signed int v320; // [sp+28h] [bp-54h]@340
  int v321; // [sp+28h] [bp-54h]@354
  int v322; // [sp+2Ch] [bp-50h]@74
  void *v323; // [sp+2Ch] [bp-50h]@135
  int v324; // [sp+2Ch] [bp-50h]@158
  _DWORD *v325; // [sp+2Ch] [bp-50h]@191
  int v326; // [sp+2Ch] [bp-50h]@323
  int v327; // [sp+2Ch] [bp-50h]@327
  signed int v328; // [sp+2Ch] [bp-50h]@338
  int v329; // [sp+2Ch] [bp-50h]@353
  _BYTE *v330; // [sp+2Ch] [bp-50h]@387
  int v331; // [sp+30h] [bp-4Ch]@2
  int v332; // [sp+30h] [bp-4Ch]@74
  signed int v333; // [sp+30h] [bp-4Ch]@192
  unsigned int v334; // [sp+30h] [bp-4Ch]@326
  int **v335; // [sp+30h] [bp-4Ch]@340
  signed int j; // [sp+30h] [bp-4Ch]@346
  unsigned __int8 *v337; // [sp+34h] [bp-48h]@1
  int v338; // [sp+38h] [bp-44h]@7
  int v339; // [sp+38h] [bp-44h]@136
  int v340; // [sp+3Ch] [bp-40h]@1
  int v341; // [sp+40h] [bp-3Ch]@2
  int v342; // [sp+44h] [bp-38h]@323
  int v343; // [sp+44h] [bp-38h]@346
  int v344; // [sp+44h] [bp-38h]@364
  int v345; // [sp+48h] [bp-34h]@323
  int v346; // [sp+48h] [bp-34h]@338
  int v347; // [sp+4Ch] [bp-30h]@1
  int v348; // [sp+50h] [bp-2Ch]@1
  unsigned int v349; // [sp+54h] [bp-28h]@1
  int v350; // [sp+58h] [bp-24h]@305
  int v351; // [sp+5Ch] [bp-20h]@308

  v3 = a2;
  v4 = *(_DWORD *)(a1 + 32);
  v292 = *(_DWORD *)a1;
  v5 = 0;
  v340 = *(_DWORD *)(a1 + 32);
  v349 = a3 + a2;
  v347 = 0;
  v348 = 0;
  v285 = -2;
  v337 = 0;
  if ( a2 >= a3 + a2 )
    return 1;
  while ( 2 )
  {
    v6 = *(_BYTE *)v3;
    v7 = *(_BYTE *)v3;
    v331 = v5;
    v341 = *(_BYTE *)v3;
    if ( v6 >= 154 )
    {
      if ( v6 == 254 )
      {
        v6 = 53;
      }
      else if ( v6 == 255 )
      {
        v6 = 55;
      }
    }
    v8 = &off_100D1E40 + 4 * v6;
    v307 = (const char *)*((_BYTE *)v8 + 8);
    v338 = *((_BYTE *)v8 + 8);
    v9 = (const char *)v8[1];
    v313 = v8;
    if ( v9 )
    {
      v10 = *((_BYTE *)v8 + 9);
      if ( v10 )
      {
        v11 = v10 - 1;
        if ( v11 )
        {
          if ( v11 != 1 )
            goto LABEL_11;
          v308 = (const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7));
          v12 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
          v13 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
          v337 = v13;
          if ( v13 && (v14 = *v13, (v14 & 0xF8u) < 0xC0) && (unsigned int)v14 >> 3 == 8 )
          {
            v15 = sub_1004C040(a1, strlen(v308), (void *)v308);
          }
          else
          {
            v16 = v313[1];
            v15 = sub_1004C090((_DWORD *)a1, "%s %s %s", v12);
          }
        }
        else
        {
          v17 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
          v15 = sub_1004C090((_DWORD *)a1, "%s%s", (unsigned int)v313[1]);
        }
      }
      else
      {
        if ( v7 == 123 || v7 == 124 )
        {
LABEL_11:
          v285 = -2;
          goto LABEL_403;
        }
        v15 = sub_1004C040(a1, strlen(v9), (void *)v9);
      }
LABEL_276:
      v285 = v15;
      goto LABEL_277;
    }
    switch ( v7 )
    {
      case 0:
        v18 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v19 = v18;
        v337 = v18;
        v285 = -2;
        if ( v18 )
        {
          v20 = *v18;
          if ( (*v19 & 0xF8u) < 0xC0 )
            v21 = (unsigned int)v20 >> 3;
          else
            v21 = 24;
        }
        else
        {
          v21 = 0;
        }
        switch ( v21 )
        {
          case 3u:
            sub_1004C4D0(v4, "\tdo {\n", v283);
            *(_DWORD *)(v4 + 48) += 4;
            goto LABEL_403;
          case 4u:
            v309 = (const char *)&unk_100C4192;
            goto LABEL_74;
          case 0xDu:
            v22 = sub_10041370((int)v19, 0);
            v23 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v22);
            *(_DWORD *)(v4 + 48) -= 4;
            v24 = sub_1004C0F0(v23[2] & 0xFFFFFFF8, a1, 0);
            if ( !v24 )
              return 0;
            *(_DWORD *)(a1 + 16) = v24 - *(_DWORD *)(a1 + 8);
            sub_1004C4D0(v4, "\t%s:\n", v24);
            *(_DWORD *)(v4 + 48) += 4;
            goto LABEL_403;
          case 0xEu:
            v25 = sub_10041370((int)v19, 0);
            v26 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v25);
            v27 = sub_1004C0F0(v26[2] & 0xFFFFFFF8, a1, 0);
            if ( !v27 )
              return 0;
            *(_DWORD *)(a1 + 16) = v27 - *(_DWORD *)(a1 + 8);
            sub_1004C4D0(v4, "\t%s: {\n", v27);
            *(_DWORD *)(v4 + 48) += 4;
            goto LABEL_403;
          case 0x14u:
            v28 = *(_DWORD *)(v4 + 56);
            *(_DWORD *)(v4 + 48) -= 4;
            v29 = sub_10021400(v28, v3);
            v30 = &v307[v3];
            v31 = (int)v29;
            v337 = v29;
            sub_1004C4D0(v4, "\t} catch (", v32);
            if ( *v30 != 59 )
              return 0;
            v33 = v30 + 3;
            if ( *v33 != 57 )
              return 0;
            v34 = v33 + 1;
            if ( *v34 != 89 )
              return 0;
            v35 = v34 + 1;
            if ( *v35 != 116 )
              return 0;
            v36 = (int)(v35 + 1);
            if ( *(_BYTE *)v36 != -126 )
              return 0;
            HIBYTE(v37) = *(_BYTE *)(v36 + 1);
            LOBYTE(v37) = *(_BYTE *)(v36 + 2);
            v38 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v37);
            v39 = sub_1004C0F0(v38[2] & 0xFFFFFFF8, a1, 0);
            if ( !v39 )
              return 0;
            *(_DWORD *)(a1 + 16) = v39 - *(_DWORD *)(a1 + 8);
            sub_1004C4D0(v4, "%s", v39);
            v40 = (_BYTE *)(v36 + 3);
            if ( *v40 != 3 )
              return 0;
            v3 = (unsigned int)(v40 + 1);
            v41 = sub_10041370(v31, 0);
            if ( !v41 )
              goto LABEL_46;
            sub_1004C4D0(v4, " if ", v283);
            if ( !sub_1004CCA0(a1, v3, v41) )
              return 0;
            v42 = sub_1004C690(a1, 0);
            sub_1004C4D0(v4, "%s", *(_BYTE *)(a1 + 8) + v42);
            v43 = *(_BYTE *)(v3 + v41);
            v44 = v41 + v3;
            if ( v43 != 7 && v43 != -116 )
              return 0;
            v3 = byte_100D1E48[16 * v43] + v44;
LABEL_46:
            sub_1004C4D0(v4, ") {\n", v283);
            *(_DWORD *)(v4 + 48) += 4;
            v338 = 0;
            goto LABEL_403;
          case 0x13u:
            v45 = sub_10041370((int)v19, 0);
            v46 = v292;
            v47 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v45);
            goto LABEL_364;
          case 0xFu:
            goto LABEL_98;
          default:
            goto LABEL_403;
        }
        goto LABEL_403;
      case 131:
        v48 = sub_1004C690(a1, v331);
        v285 = v48;
        if ( (unsigned __int8)byte_100D1E4B[16 * *(_BYTE *)(*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 24))] < (unsigned __int8)byte_100D1E4B[16 * v331] )
          goto LABEL_277;
        v15 = sub_1004C090((_DWORD *)a1, "(%s)", v48 + *(_BYTE *)(a1 + 8));
        goto LABEL_276;
      case 1:
      case 57:
      case 108:
        v15 = sub_1004C090((_DWORD *)a1, (char *)&unk_100C4192, v283);
        goto LABEL_276;
      case 133:
        sub_1004C4D0(v4, "\ttry {\n", v283);
        *(_DWORD *)(v4 + 48) += 4;
        goto LABEL_52;
      case 114:
      case 135:
      case 144:
        goto LABEL_52;
      case 134:
        *(_DWORD *)(v4 + 48) -= 4;
        sub_1004C4D0(v4, "\t} finally {\n", v283);
        *(_DWORD *)(v4 + 48) += 4;
        v15 = sub_1004C090((_DWORD *)a1, "finally-cookie", v49);
        goto LABEL_276;
      case 115:
        if ( strcmp((const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 115)), "finally-cookie") )
          return 0;
        v285 = -2;
        goto LABEL_403;
      case 117:
        HIBYTE(v50) = *(_BYTE *)(v3 + 1);
        LOBYTE(v50) = *(_BYTE *)(v3 + 2);
        *(_DWORD *)(a1 + 28) = v50;
        goto LABEL_277;
      case 116:
        v51 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v337 = v51;
        if ( !v51 )
          return 0;
        v52 = *v51;
        if ( (v52 & 0xF8u) >= 0xC0 || (unsigned int)v52 >> 3 != 11 )
          return 0;
        v285 = -2;
        goto LABEL_403;
      case 2:
      case 81:
        v53 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v19 = v53;
        v337 = v53;
        if ( !v53 || (*v53 & 0xF8u) >= 0xC0 )
          goto LABEL_66;
        v54 = (unsigned int)*v53 >> 3;
        if ( v54 == 4 )
        {
          v285 = -2;
          v309 = (const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, v341));
LABEL_74:
          ++v3;
          v332 = sub_10041370((int)v19, 0);
          v322 = sub_10041370((int)v19, 1);
          v314 = sub_10041370((int)v19, 2);
          if ( v314 + sub_1004BF50((_BYTE *)(v314 + v3), v314 + v3) )
            return 0;
          sub_1004C4D0(v4, "\tfor (%s;", (char)v309);
          v294 = (_BYTE *)(v332 + v3);
          v59 = *(_BYTE *)(v332 + v3);
          if ( v59 == 7 || v59 == -116 )
          {
            if ( !sub_1004CCA0(a1, v3, v332) )
              return 0;
            v60 = sub_1004C690(a1, v341);
            sub_1004C4D0(v4, " %s", *(_BYTE *)(a1 + 8) + v60);
          }
          sub_1004C5E0(v4, ";");
          v61 = *(_BYTE *)(v322 + v3);
          if ( v61 != 6 && v61 != -117 )
          {
            if ( !sub_1004CCA0(a1, v322 + v3, v314 - v322 - 1) )
              return 0;
            v62 = sub_1004C690(a1, v341);
            sub_1004C4D0(v4, " %s", *(_BYTE *)(a1 + 8) + v62);
          }
          sub_1004C4D0(v4, ") {\n", v283);
          *(_DWORD *)(v4 + 48) += 4;
          v63 = v332 ? byte_100D1E48[16 * *v294] : 0;
          if ( !sub_1004CCA0(a1, (unsigned int)&v294[v63], v322 - v332 - v63) )
            return 0;
          *(_DWORD *)(v4 + 48) -= 4;
          sub_1004C4D0(v4, "\t}\n", v284);
          v338 = v314 + byte_100D1E48[16 * *(_BYTE *)(v314 + v3)];
LABEL_403:
          v3 += v338;
          if ( v3 >= v349 )
            return 1;
          v5 = v341;
          continue;
        }
        if ( v54 != 7 )
        {
          if ( v54 == 11 )
          {
LABEL_52:
            v285 = -2;
          }
          else
          {
LABEL_66:
            v55 = (_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, v341));
            if ( *v55 )
            {
              LOBYTE(v282) = (_BYTE)v55;
LABEL_68:
              sub_1004C4D0(v4, "\t%s;\n", (char)v282);
            }
LABEL_69:
            v285 = -2;
          }
          goto LABEL_403;
        }
        v56 = sub_1004C690(a1, v341);
        v293 = sub_100118A0(v292, (void *)(*(_DWORD *)(a1 + 8) + v56));
        if ( !v293 )
          return 0;
        v57 = (unsigned int)&v307[v3];
        v3 += sub_10041370((int)v19, 0);
        v338 = 0;
        if ( sub_1004CCA0(a1, v57, v3 - v57) )
        {
          v58 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v341);
          v285 = sub_1004C090((_DWORD *)a1, "%s, %s", (char)v293);
          sub_10010340(v292, (unsigned int)v293);
LABEL_277:
          if ( v285 >= 0 )
            v180 = sub_1004C620(a1, v341, v285) == 0;
          else
            v180 = v285 == -1;
          if ( v180 )
            return 0;
          goto LABEL_403;
        }
        sub_10010340(v292, (unsigned int)v293);
        return 0;
      case 107:
        sub_1004C690(a1, 107);
        sub_1004C690(a1, 107);
        v285 = -2;
        goto LABEL_403;
      case 3:
        v64 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v337 = v64;
        if ( v64 )
        {
          v65 = *v64;
          if ( (v65 & 0xF8u) < 0xC0 && (unsigned int)v65 >> 3 == 11 )
          {
            v285 = -2;
            goto LABEL_403;
          }
        }
        v66 = sub_1004C690(a1, 3);
        sub_1004C4D0(v4, "\twith (%s) {\n", *(_BYTE *)(a1 + 8) + v66);
        *(_DWORD *)(v4 + 48) += 4;
        v15 = sub_1004C090((_DWORD *)a1, "with-cookie", v67);
        goto LABEL_276;
      case 4:
        v68 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v337 = v68;
        v285 = -2;
        if ( v68 )
        {
          v69 = *v68;
          if ( (v69 & 0xF8u) < 0xC0 && (unsigned int)v69 >> 3 == 11 )
            goto LABEL_403;
        }
        if ( strcmp((const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 4)), "with-cookie") )
          return 0;
LABEL_98:
        *(_DWORD *)(v4 + 48) -= 4;
        sub_1004C4D0(v4, "\t}\n", v283);
        goto LABEL_403;
      case 5:
      case 152:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7)) )
        {
          sub_1004C4D0(v4, "\t%s %s;\n", (unsigned int)*v313);
          v285 = -2;
          goto LABEL_403;
        }
        v282 = *v313;
        goto LABEL_68;
      case 110:
        v70 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v337 = v70;
        v285 = -2;
        if ( !v70 || (v71 = *v70, (v71 & 0xF8u) >= 0xC0) || (unsigned int)v71 >> 3 != 11 )
        {
          v72 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 110);
          sub_1004C4D0(v4, "\t%s %s;\n", (unsigned int)*v313);
        }
        goto LABEL_403;
      case 6:
      case 139:
        v73 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v337 = v73;
        if ( v73 )
        {
          if ( (*v73 & 0xF8u) < 0xC0 )
            v74 = (unsigned int)*v73 >> 3;
          else
            v74 = 24;
        }
        else
        {
          v74 = 0;
        }
        switch ( v74 )
        {
          case 0xBu:
            goto LABEL_69;
          case 0x11u:
            v75 = sub_10041370((int)v73, 0);
            v76 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v75);
            v77 = sub_1004C0F0(v76[2] & 0xFFFFFFF8, a1, 0);
            if ( !v77 )
              return 0;
            *(_DWORD *)(a1 + 16) = v77 - *(_DWORD *)(a1 + 8);
            sub_1004C4D0(v4, "\tcontinue %s;\n", v77);
            goto LABEL_69;
          case 5u:
            sub_1004C4D0(v4, "\tcontinue;\n", v283);
            v285 = -2;
            goto LABEL_403;
          case 0x10u:
            v78 = sub_10041370((int)v73, 0);
            v79 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v78);
            v80 = sub_1004C0F0(v79[2] & 0xFFFFFFF8, a1, 0);
            if ( !v80 )
              return 0;
            *(_DWORD *)(a1 + 16) = v80 - *(_DWORD *)(a1 + 8);
            sub_1004C4D0(v4, "\tbreak %s;\n", v80);
            goto LABEL_69;
          default:
            sub_1004C4D0(v4, "\tbreak;\n", v283);
            v285 = -2;
            break;
        }
        goto LABEL_403;
      case 7:
      case 140:
        v338 = sub_1004BF50((_BYTE *)v3, v3);
        v81 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v337 = v81;
        if ( v81 )
        {
          v82 = *v81;
          if ( (v82 & 0xF8u) < 0xC0 )
            v83 = (unsigned int)v82 >> 3;
          else
            v83 = 24;
        }
        else
        {
          v83 = 0;
        }
        switch ( v83 )
        {
          case 1u:
          case 2u:
            v84 = sub_1004C690(a1, v7);
            sub_1004C4D0(v4, "\tif (%s) {\n", *(_BYTE *)(a1 + 8) + v84);
            *(_DWORD *)(v4 + 48) += 4;
            if ( (*v337 & 0xF8u) >= 0xC0 || (unsigned int)*v337 >> 3 != 1 )
            {
              v86 = sub_10041370((int)v337, 0);
              if ( !sub_1004CCA0(a1, (unsigned int)&v307[v3], v86 - (_DWORD)v307) )
                return 0;
              *(_DWORD *)(v4 + 48) -= 4;
              v87 = *(_BYTE *)(v3 + v86);
              v3 += v86;
              if ( v87 != 6 && v87 != -117 )
                return 0;
              v88 = byte_100D1E48[16 * v87];
              v338 = sub_1004BF50((_BYTE *)v3, v3);
              sub_1004C4D0(v4, "\t} else {\n", v283);
              *(_DWORD *)(v4 + 48) += 4;
              v85 = sub_1004CCA0(a1, v88 + v3, v338 - v88);
            }
            else
            {
              v85 = sub_1004CCA0(a1, (unsigned int)&v307[v3], v338 - (_DWORD)v307);
            }
LABEL_131:
            if ( !v85 )
              return 0;
            *(_DWORD *)(v4 + 48) -= 4;
            sub_1004C4D0(v4, "\t}\n", v283);
LABEL_133:
            v285 = -2;
            goto LABEL_403;
          case 3u:
            v89 = sub_1004C690(a1, v7);
            sub_1004C4D0(v4, "\twhile (%s) {\n", *(_BYTE *)(a1 + 8) + v89);
            *(_DWORD *)(v4 + 48) += 4;
            v90 = sub_10041370((int)v337, 0);
            v85 = sub_1004CCA0(a1, (unsigned int)&v307[v3], v90 - (_DWORD)v307);
            goto LABEL_131;
          case 9u:
            v91 = sub_1004C690(a1, v7);
            v323 = sub_100118A0(v292, (void *)(*(_DWORD *)(a1 + 8) + v91));
            if ( !v323 )
              return 0;
            v339 = sub_10041370((int)v337, 0);
            if ( !sub_1004CCA0(a1, (unsigned int)&v307[v3], v339 - (_DWORD)v307) )
              return 0;
            v92 = sub_1004C690(a1, v7);
            v295 = sub_100118A0(v292, (void *)(*(_DWORD *)(a1 + 8) + v92));
            if ( !v295 )
            {
              sub_10010340(v292, (unsigned int)v323);
              return 0;
            }
            v3 += v339;
            v93 = *(_BYTE *)v3;
            if ( *(_BYTE *)v3 != 6 && v93 != -117 )
              return 0;
            v94 = (const char *)byte_100D1E48[16 * v93];
            v338 = sub_1004BF50((_BYTE *)v3, v3);
            if ( !sub_1004CCA0(a1, (unsigned int)&v94[v3], v338 - (_DWORD)v94) )
              return 0;
            v95 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
            v285 = sub_1004C090((_DWORD *)a1, "%s ? %s : %s", (char)v323);
            sub_10010340(v292, (unsigned int)v323);
            sub_10010340(v292, (unsigned int)v295);
            break;
          default:
            goto LABEL_277;
        }
        goto LABEL_277;
      case 8:
      case 141:
        *(_DWORD *)(v4 + 48) -= 4;
        v96 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        sub_1004C4D0(v4, "\t} while (%s);\n", v96);
        goto LABEL_69;
      case 68:
      case 142:
      case 69:
      case 143:
        v97 = sub_1004C690(a1, v7);
        v296 = (const char *)sub_100118A0(v292, (void *)(*(_DWORD *)(a1 + 8) + v97));
        if ( !v296 )
          return 0;
        v98 = v3 + sub_1004BF50((_BYTE *)v3, v3);
        v3 += (unsigned int)v307;
        v338 = v98 - v3;
        if ( !sub_1004CCA0(a1, v3, v98 - v3) )
          return 0;
        v99 = (void *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7));
        if ( *(_BYTE *)(v4 + 52) && strlen((const char *)v99) + *(_DWORD *)(v4 + 48) + strlen(v296) + 8 > 0x4B )
        {
          v100 = sub_100118A0(v292, v99);
          if ( !v100
            || (v285 = sub_1004C090((_DWORD *)a1, "%s %s\n", (char)v296),
                v101 = sub_1004C090((_DWORD *)a1, "%*s%s", *(_DWORD *)(v4 + 48) + 4),
                sub_10010340(v292, (unsigned int)v100),
                v101 < 0) )
          {
            v285 = -1;
          }
        }
        else
        {
          v285 = sub_1004C090((_DWORD *)a1, "%s %s %s", (char)v296);
        }
        sub_10010340(v292, (unsigned int)v296);
        goto LABEL_277;
      case 10:
        v102 = v340;
        HIBYTE(v103) = *(_BYTE *)(v3 + 1);
        LOBYTE(v103) = *(_BYTE *)(v3 + 2);
        v104 = (int *)sub_1004C950(v340, v103, (int)sub_1002FB00);
        if ( v104 )
          goto LABEL_158;
        return 0;
      case 11:
        HIBYTE(v105) = *(_BYTE *)(v3 + 1);
        LOBYTE(v105) = *(_BYTE *)(v3 + 2);
        v104 = (int *)sub_1004C950(v340, v105, (int)sub_1002FB80);
        if ( v104 )
          goto LABEL_157;
        return 0;
      case 104:
        HIBYTE(v106) = *(_BYTE *)(v3 + 1);
        LOBYTE(v106) = *(_BYTE *)(v3 + 2);
        v104 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v106);
LABEL_157:
        v102 = v340;
LABEL_158:
        v337 = sub_10021400(*(_DWORD *)(v102 + 56), v3);
        v324 = 0;
        v297 = &unk_100C4192;
        goto LABEL_164;
      case 105:
        HIBYTE(v107) = *(_BYTE *)(v3 + 1);
        v324 = 0;
        LOBYTE(v107) = *(_BYTE *)(v3 + 2);
        v104 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v107);
        if ( !v104[3] && sub_10028320(v104[2] & 0xFFFFFFF8) )
          goto LABEL_163;
        v324 = sub_1004C0F0(v104[2] & 0xFFFFFFF8, a1, 39);
        if ( !v324 )
          return 0;
        v104 = 0;
LABEL_163:
        v102 = v340;
        v297 = (_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 105));
        v337 = 0;
LABEL_164:
        v3 += (unsigned int)v307;
        v108 = *(_BYTE *)v3;
        if ( *(_BYTE *)v3 != 7 && v108 != -116 )
          return 0;
        v307 = (const char *)byte_100D1E48[16 * v108];
        v338 = sub_1004BF50((_BYTE *)v3, v3);
        v109 = sub_10021400(*(_DWORD *)(v102 + 56), v3);
        v315 = sub_10041370((int)v109, 0);
        goto LABEL_171;
      case 106:
        v110 = *(_BYTE *)(v3++ + 1);
        if ( v110 != 7 && v110 != -116 )
          return 0;
        v338 = byte_100D1E48[16 * v110];
        v337 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v348 = v3 + sub_10041370((int)v337, 0);
        v347 = v3 + sub_1004BF50((_BYTE *)v3, v3);
        goto LABEL_277;
      case 122:
        v104 = 0;
        v324 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 122);
        v102 = v340;
        v297 = (_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 122));
        v315 = v348 - v3;
        v348 = 0;
        v338 = v347 - v3;
        v347 = 0;
LABEL_171:
        v111 = (unsigned int)sub_1004C9A0(v337);
        sub_1004C4D0(v102, "\tfor (%s%s", v111);
        if ( v104 )
        {
          v112 = sub_1004C0F0(v104[2] & 0xFFFFFFF8, a1, 0);
          if ( !v112 )
            return 0;
          *(_DWORD *)(a1 + 16) = v112 - *(_DWORD *)(a1 + 8);
          v113 = ".%s";
          if ( !*v297 )
            v113 = "%s";
          sub_1004C4D0(v102, (void *)v113, v112);
        }
        else if ( v324 )
        {
          sub_1004C4D0(v102, "[%s]", v324);
        }
        sub_1004C4D0(
          v102,
          " in %s) {\n",
          *(_BYTE *)(a1 + 8) + *(_BYTE *)(*(_DWORD *)(a1 + 20) + 4 * *(_DWORD *)(a1 + 28) - 4));
        *(_DWORD *)(v102 + 48) += 4;
        if ( !sub_1004CCA0(a1, (unsigned int)&v307[v3], v315 - (_DWORD)v307) )
          return 0;
        *(_DWORD *)(v102 + 48) -= 4;
        sub_1004C4D0(v102, "\t}\n", v283);
        v4 = v340;
        v285 = -2;
        goto LABEL_403;
      case 13:
        v114 = (const char *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4 * *(_DWORD *)(a1 + 28) - 8));
        v115 = sub_1004C040(a1, strlen(v114), (void *)v114);
        if ( v115 >= 0 && sub_1004C620(a1, *(_BYTE *)(*(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 28) - 2), v115) )
          goto LABEL_182;
        return 0;
      case 12:
LABEL_182:
        v116 = *(_DWORD *)(a1 + 28);
        v341 = *(_BYTE *)(*(_DWORD *)(a1 + 24) + v116 - 1);
        v117 = (const char *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4 * v116 - 4));
        v15 = sub_1004C040(a1, strlen(v117), (void *)v117);
        goto LABEL_276;
      case 85:
        v118 = sub_1002FB00;
        goto LABEL_184;
      case 87:
        v118 = sub_1002FB80;
LABEL_184:
        HIBYTE(v119) = *(_BYTE *)(v3 + 1);
        LOBYTE(v119) = *(_BYTE *)(v3 + 2);
        v120 = (int *)sub_1004C950(v340, v119, (int)v118);
        if ( v120 )
          goto LABEL_188;
        return 0;
      case 14:
      case 109:
        HIBYTE(v121) = *(_BYTE *)(v3 + 1);
        LOBYTE(v121) = *(_BYTE *)(v3 + 2);
        v120 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v121);
LABEL_188:
        v298 = sub_1004C0F0(v120[2] & 0xFFFFFFF8, a1, 0);
        if ( !v298 )
          return 0;
        v122 = (const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7));
        if ( v7 == 109 )
          sub_1004C690(a1, 109);
        goto LABEL_284;
      case 35:
      case 58:
      case 121:
      case 132:
        HIBYTE(v123) = *(_BYTE *)(v3 + 1);
        LOBYTE(v123) = *(_BYTE *)(v3 + 2);
        v299 = v123;
        v325 = (_DWORD *)sub_10011830(v292, 4 * v123 + 4);
        if ( !v325 )
          return 0;
        v333 = 1;
        v316 = v299;
        if ( v299 <= 0 )
          goto LABEL_197;
        while ( 1 )
        {
          v124 = sub_1004C690(a1, 0);
          v125 = sub_100118A0(v292, (void *)(*(_DWORD *)(a1 + 8) + v124));
          v126 = v316;
          v325[v316] = v125;
          if ( !v125 )
            break;
          --v316;
          if ( v126 - 1 <= 0 )
            goto LABEL_197;
        }
        v333 = 0;
LABEL_197:
        if ( *(_DWORD *)(a1 + 28) < 2u )
          return 0;
        sub_1004C690(a1, 0);
        v127 = sub_1004C690(a1, 0);
        v128 = sub_100118A0(v292, (void *)(*(_DWORD *)(a1 + 8) + v127));
        *v325 = v128;
        if ( !v325[v316] )
          v333 = 0;
        if ( v7 == 35 )
          v129 = sub_1004C090((_DWORD *)a1, "%s %s%s", (unsigned int)"new");
        else
          v129 = sub_1004C090((_DWORD *)a1, "%s%s", (char)v128);
        v285 = v129;
        if ( v129 < 0 )
          v333 = 0;
        v130 = 1;
        v317 = 1;
        if ( v299 >= 1 )
        {
          while ( 1 )
          {
            v131 = v325[v130];
            if ( !v131 || sub_1004C090((_DWORD *)a1, "%s%s", v131) < 0 )
              break;
            v130 = v317++ + 1;
            if ( v317 > v299 )
              goto LABEL_211;
          }
          v333 = 0;
        }
LABEL_211:
        if ( sub_1004C090((_DWORD *)a1, ")", v283) < 0 )
          v333 = 0;
        v132 = 0;
        for ( i = 0; v132 <= v299; i = v132 )
        {
          v133 = v325[v132];
          if ( v133 )
          {
            sub_10010340(v292, v133);
            v132 = i;
          }
          ++v132;
        }
        sub_10010340(v292, (unsigned int)v325);
        if ( !v333 )
          return 0;
        if ( v7 != 132 )
          goto LABEL_277;
        if ( !sub_1004C620(a1, 132, v285) )
          return 0;
        v15 = sub_1004C090((_DWORD *)a1, (char *)&unk_100C4192, v283);
        goto LABEL_276;
      case 36:
        HIBYTE(v134) = *(_BYTE *)(v3 + 1);
        LOBYTE(v134) = *(_BYTE *)(v3 + 2);
        v135 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v134);
        v136 = sub_1004C0F0(v135[2] & 0xFFFFFFF8, a1, 0);
        if ( !v136 )
          return 0;
        *(_DWORD *)(a1 + 16) = v136 - *(_DWORD *)(a1 + 8);
        v15 = sub_1004C090((_DWORD *)a1, "%s %s", (unsigned int)"delete");
        goto LABEL_276;
      case 37:
        HIBYTE(v137) = *(_BYTE *)(v3 + 1);
        LOBYTE(v137) = *(_BYTE *)(v3 + 2);
        v138 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v137);
        v139 = v138;
        if ( v138[3] || !sub_10028320(v138[2] & 0xFFFFFFF8) )
        {
          v140 = 39;
          v286 = "%s %s[%s]";
        }
        else
        {
          v140 = 0;
          v286 = "%s %s.%s";
        }
        if ( !sub_1004C0F0(v139[2] & 0xFFFFFFF8, a1, v140) )
          return 0;
        v141 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 37);
        v15 = sub_1004C090((_DWORD *)a1, v286, (unsigned int)"delete");
        goto LABEL_276;
      case 38:
        v142 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 38);
        v143 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 38);
        v15 = sub_1004C090((_DWORD *)a1, "%s %s[%s]", (unsigned int)"delete");
        goto LABEL_276;
      case 39:
      case 40:
        v144 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        v15 = sub_1004C090((_DWORD *)a1, "%s %s", (unsigned int)*v313);
        goto LABEL_276;
      case 95:
      case 97:
        v145 = sub_1002FB00;
        goto LABEL_232;
      case 96:
      case 98:
        v145 = sub_1002FB80;
LABEL_232:
        HIBYTE(v146) = *(_BYTE *)(v3 + 1);
        LOBYTE(v146) = *(_BYTE *)(v3 + 2);
        v147 = (int *)sub_1004C950(v340, v146, (int)v145);
        if ( v147 )
          goto LABEL_236;
        return 0;
      case 41:
      case 44:
        HIBYTE(v148) = *(_BYTE *)(v3 + 1);
        LOBYTE(v148) = *(_BYTE *)(v3 + 2);
        v147 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v148);
LABEL_236:
        v149 = sub_1004C0F0(v147[2] & 0xFFFFFFF8, a1, 0);
        if ( !v149 )
          return 0;
        *(_DWORD *)(a1 + 16) = v149 - *(_DWORD *)(a1 + 8);
        v15 = sub_1004C090(
                (_DWORD *)a1,
                "%s%s",
                (unsigned int)*(&off_10162FE8 + (~(unsigned __int8)((unsigned int)v313[3] >> 9) & 1)));
        goto LABEL_303;
      case 42:
      case 45:
        HIBYTE(v150) = *(_BYTE *)(v3 + 1);
        LOBYTE(v150) = *(_BYTE *)(v3 + 2);
        v151 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v150);
        v300 = v151;
        if ( v151[3] || !sub_10028320(v151[2] & 0xFFFFFFF8) )
        {
          v152 = 39;
          v287 = "%s%s[%s]";
        }
        else
        {
          v152 = 0;
          v287 = "%s%s.%s";
        }
        if ( !sub_1004C0F0(v300[2] & 0xFFFFFFF8, a1, v152) )
          return 0;
        v153 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        v15 = sub_1004C090(
                (_DWORD *)a1,
                v287,
                (unsigned int)*(&off_10162FE8 + (~(unsigned __int8)((unsigned int)v313[3] >> 9) & 1)));
        goto LABEL_276;
      case 43:
      case 46:
        v154 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        v155 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        v15 = sub_1004C090(
                (_DWORD *)a1,
                "%s%s[%s]",
                (unsigned int)*(&off_10162FE8 + (~(unsigned __int8)((unsigned int)v313[3] >> 9) & 1)));
        goto LABEL_276;
      case 99:
      case 101:
        v156 = sub_1002FB00;
        goto LABEL_246;
      case 100:
      case 102:
        v156 = sub_1002FB80;
LABEL_246:
        HIBYTE(v157) = *(_BYTE *)(v3 + 1);
        LOBYTE(v157) = *(_BYTE *)(v3 + 2);
        v158 = (int *)sub_1004C950(v340, v157, (int)v156);
        if ( v158 )
          goto LABEL_250;
        return 0;
      case 47:
      case 50:
        HIBYTE(v159) = *(_BYTE *)(v3 + 1);
        LOBYTE(v159) = *(_BYTE *)(v3 + 2);
        v158 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v159);
LABEL_250:
        v160 = sub_1004C0F0(v158[2] & 0xFFFFFFF8, a1, 0);
        if ( !v160 )
          return 0;
        v285 = v160 - *(_DWORD *)(a1 + 8);
        sub_1004C040(a1, 2u, *(&off_10162FE8 + (~(unsigned __int8)((unsigned int)v313[3] >> 9) & 1)));
        v4 = v340;
        goto LABEL_277;
      case 48:
      case 51:
        HIBYTE(v161) = *(_BYTE *)(v3 + 1);
        LOBYTE(v161) = *(_BYTE *)(v3 + 2);
        v162 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v161);
        v301 = v162;
        if ( v162[3] || !sub_10028320(v162[2] & 0xFFFFFFF8) )
        {
          v163 = 39;
          v288 = "%s[%s]%s";
        }
        else
        {
          v163 = 0;
          v288 = "%s.%s%s";
        }
        if ( !sub_1004C0F0(v301[2] & 0xFFFFFFF8, a1, v163) )
          return 0;
        v164 = sub_1004C690(a1, v7);
        v165 = (int)*(&off_10162FE8 + (~(unsigned __int8)((unsigned int)v313[3] >> 9) & 1));
        v15 = sub_1004C090((_DWORD *)a1, v288, *(_BYTE *)(a1 + 8) + v164);
        goto LABEL_276;
      case 49:
      case 52:
        v166 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        v167 = sub_1004C690(a1, v7);
        v168 = (int)*(&off_10162FE8 + (~(unsigned __int8)((unsigned int)v313[3] >> 9) & 1));
        v15 = sub_1004C090((_DWORD *)a1, "%s[%s]%s", *(_BYTE *)(a1 + 8) + v167);
        goto LABEL_276;
      case 254:
        v341 = 53;
        sub_1004C690(a1, v331);
        v7 = 53;
        goto LABEL_260;
      case 53:
LABEL_260:
        HIBYTE(v169) = *(_BYTE *)(v3 + 1);
        LOBYTE(v169) = *(_BYTE *)(v3 + 2);
        v170 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v169);
        v302 = v170;
        if ( v170[3] || !sub_10028320(v170[2] & 0xFFFFFFF8) )
        {
          v171 = 39;
          v289 = "%s[%s]";
        }
        else
        {
          v171 = 0;
          v289 = "%s.%s";
        }
        if ( !sub_1004C0F0(v302[2] & 0xFFFFFFF8, a1, v171) )
          return 0;
        v172 = sub_1004C690(a1, v7);
        v15 = sub_1004C090((_DWORD *)a1, v289, *(_BYTE *)(a1 + 8) + v172);
        goto LABEL_276;
      case 54:
        HIBYTE(v173) = *(_BYTE *)(v3 + 1);
        LOBYTE(v173) = *(_BYTE *)(v3 + 2);
        v174 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v173);
        if ( v174[3] || !sub_10028320(v174[2] & 0xFFFFFFF8) )
        {
          v175 = 39;
          v290 = "%s[%s] %s= %s";
        }
        else
        {
          v175 = 0;
          v290 = "%s.%s %s= %s";
        }
        if ( !sub_1004C0F0(v174[2] & 0xFFFFFFF8, a1, v175) )
          return 0;
        v176 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 54);
        v303 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 54);
        v177 = sub_10021400(*(_DWORD *)(v4 + 56), v3 - 1);
        v337 = v177;
        if ( v177 )
        {
          v178 = *v177;
          if ( (v178 & 0xF8u) < 0xC0 && (unsigned int)v178 >> 3 == 8 )
            v179 = dword_100D1E44[4 * v331];
        }
        v15 = sub_1004C090((_DWORD *)a1, v290, v303);
        goto LABEL_276;
      case 153:
        goto LABEL_277;
      case 255:
        sub_1004C690(a1, v331);
        goto LABEL_280;
      case 55:
LABEL_280:
        v181 = (_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 0));
        v341 = 55;
        v182 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 55);
        if ( *v181 )
          v15 = sub_1004C090((_DWORD *)a1, "%s[%s]", v182);
        else
          v15 = sub_1004C090((_DWORD *)a1, "%s", v182);
        goto LABEL_276;
      case 56:
        v183 = (const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 0));
        v184 = (_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 0));
        v341 = 56;
        v298 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 56);
        if ( *v184 )
        {
          v190 = sub_10021400(*(_DWORD *)(v4 + 56), v3 - 1);
          v337 = v190;
          if ( v190 && (v191 = *v190, (v191 & 0xF8u) < 0xC0) && (unsigned int)v191 >> 3 == 8 )
          {
            v192 = dword_100D1E44[4 * v331];
            v15 = sub_1004C090((_DWORD *)a1, "%s[%s] %s= %s", v298);
          }
          else
          {
            v15 = sub_1004C090((_DWORD *)a1, "%s[%s] %s= %s", v298);
          }
        }
        else
        {
LABEL_284:
          v4 = v340;
          v185 = sub_10021400(*(_DWORD *)(v340 + 56), v3 - 1);
          v337 = v185;
          if ( v185 && (v186 = *v185, (v186 & 0xF8u) < 0xC0) && (unsigned int)v186 >> 3 == 8 )
          {
            v187 = dword_100D1E44[4 * v331];
            v15 = sub_1004C090((_DWORD *)a1, "%s %s= %s", v298);
          }
          else
          {
            v188 = sub_10021400(*(_DWORD *)(v340 + 56), v3);
            v337 = v188;
            v189 = (unsigned int)sub_1004C9A0(v188);
            v15 = sub_1004C090((_DWORD *)a1, "%s%s = %s", v189);
          }
        }
        goto LABEL_276;
      case 136:
        v193 = *(_BYTE *)(v3 + 1);
        v194 = *(_BYTE *)(v3 + 2);
        v15 = sub_1004C090((_DWORD *)a1, "%s[%d]", (unsigned int)"arguments");
        goto LABEL_276;
      case 137:
        v15 = sub_1004C090((_DWORD *)a1, "%s.%s", (unsigned int)"arguments");
        goto LABEL_276;
      case 84:
        v195 = sub_1002FB00;
        goto LABEL_297;
      case 86:
        v195 = sub_1002FB80;
LABEL_297:
        HIBYTE(v196) = *(_BYTE *)(v3 + 1);
        LOBYTE(v196) = *(_BYTE *)(v3 + 2);
        v197 = (int *)sub_1004C950(v340, v196, (int)v195);
        if ( v197 )
          goto LABEL_301;
        return 0;
      case 59:
        HIBYTE(v198) = *(_BYTE *)(v3 + 1);
        LOBYTE(v198) = *(_BYTE *)(v3 + 2);
        v197 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v198);
LABEL_301:
        v199 = sub_10021400(*(_DWORD *)(v340 + 56), v3);
        v200 = v199;
        v337 = v199;
        v201 = sub_1004C0F0(v197[2] & 0xFFFFFFF8, a1, 0);
        if ( !v201 )
          return 0;
        *(_DWORD *)(a1 + 16) = v201 - *(_DWORD *)(a1 + 8);
        v202 = (unsigned int)sub_1004C9A0(v200);
        v15 = sub_1004C090((_DWORD *)a1, "%s%s", v202);
LABEL_303:
        v4 = v340;
        goto LABEL_276;
      case 88:
        v203 = *(_BYTE *)(v3 + 1);
        v15 = sub_1004C090((_DWORD *)a1, "%u", *(_BYTE *)(v3 + 2));
        goto LABEL_276;
      case 60:
        HIBYTE(v204) = *(_BYTE *)(v3 + 1);
        LOBYTE(v204) = *(_BYTE *)(v3 + 2);
        v205 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v204)[2];
        v350 = v205;
        if ( v205 & 1 && v205 != -2147483647 )
        {
          v15 = sub_1004C090((_DWORD *)a1, (char *)&unk_100CC178, v205 >> 1);
        }
        else
        {
          v206 = (char *)sub_1003DB50((int)&v351, 26, 0, 0, *(double *)(v205 & 0xFFFFFFF8));
          if ( !v206 )
          {
            sub_10011170(v292);
            return 0;
          }
          v15 = sub_1004C090((_DWORD *)a1, v206, v283);
        }
        goto LABEL_276;
      case 61:
        HIBYTE(v207) = *(_BYTE *)(v3 + 1);
        LOBYTE(v207) = *(_BYTE *)(v3 + 2);
        v208 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v207);
        v209 = sub_1004C0F0(v208[2] & 0xFFFFFFF8, a1, 34);
        if ( !v209 )
          return 0;
        v15 = v209 - *(_DWORD *)(a1 + 8);
        goto LABEL_276;
      case 80:
      case 128:
      case 129:
        HIBYTE(v210) = *(_BYTE *)(v3 + 1);
        LOBYTE(v210) = *(_BYTE *)(v3 + 2);
        v211 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v210);
        if ( v7 == 80 )
        {
          v212 = sub_1001AD70(v292, v211[2]);
          if ( !v212 )
            return 0;
        }
        else
        {
          if ( (unsigned int)&v307[v3] >= v349 || (v213 = 98304, v307[v3] != -125) )
            v213 = 0x8000;
          if ( !sub_10027E60(v3, v292, v211[2] & 0xFFFFFFF8, v213, 0, 0, &v350) )
            return 0;
          v212 = (char *)(v350 & 0xFFFFFFF8);
        }
        v214 = *(_DWORD *)v212;
        if ( *(_DWORD *)v212 & 0x40000000 )
          v214 = *(_DWORD *)v212 & ((v214 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
        v215 = sub_10010FF0((unsigned int)v212);
        v15 = sub_1004C040(a1, v214, v215);
        goto LABEL_276;
      case 70:
      case 147:
        v337 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v338 = sub_10041370((int)v337, 0);
        v216 = 2 * (v7 != 70) + 2;
        v345 = v216;
        v217 = sub_1004BF50((_BYTE *)v3, v3);
        LOBYTE(v218) = 0;
        HIBYTE(v218) = *(_BYTE *)(v216 + v3 + 1);
        v342 = v217;
        v219 = v216 + v3 + 2;
        v220 = *(_BYTE *)v219 | v218;
        LOBYTE(v221) = 0;
        HIBYTE(v221) = *(_BYTE *)(v219 + 1);
        v304 = v219 + 2;
        v222 = (*(_BYTE *)(v219 + 2) | v221) - v220;
        v326 = v222 + 1;
        if ( v222 == -1 )
        {
          v319 = 0;
          v227 = sub_1004C720(a1, 0, 0, v3, v338, v342, 0);
        }
        else
        {
          v319 = sub_10011830(v292, 16 * v326);
          if ( !v319 )
            return 0;
          v223 = (const char *)v326;
          v334 = 0;
          if ( v326 > 0 )
          {
            v327 = 2 * v220;
            v224 = v319 + 8;
            v310 = v223;
            do
            {
              *(_DWORD *)v224 = 0;
              v291 = sub_1004BF50((_BYTE *)v3, v304);
              if ( v291 )
              {
                v225 = sub_10021400(*(_DWORD *)(v4 + 56), v304);
                v337 = v225;
                if ( v225 )
                {
                  v226 = sub_10041370((int)v225, 0);
                  *(_DWORD *)v224 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v226);
                }
                *(_DWORD *)(v224 + 4) = v334;
                *(_DWORD *)(v224 - 8) = v327 | 1;
                *(_DWORD *)(v224 - 4) = v291;
                ++v334;
                v224 += 16;
              }
              v304 += v345;
              v327 += 2;
              --v310;
            }
            while ( v310 );
          }
          sub_1002EB00(v319, v334, 0x10u, (signed int (__cdecl *)(signed int *, signed int *, int))sub_1004C700, 0);
          v227 = sub_1004C720(a1, v319, v334, v3, v338, v342, 0);
        }
        v228 = v319;
LABEL_335:
        v229 = v227;
        sub_10010340(v292, v228);
LABEL_336:
        if ( v229 )
          goto LABEL_69;
        return 0;
      case 71:
      case 148:
        v337 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v338 = sub_10041370((int)v337, 0);
        v231 = 2 * (v341 != 71) + 2;
        v232 = sub_1004BF50((_BYTE *)v3, v3);
        HIBYTE(v233) = *(_BYTE *)(v231 + v3 + 1);
        v346 = v232;
        v234 = (_BYTE *)(v231 + v3 + 2);
        v235 = (int)v234;
        LOBYTE(v233) = *v234;
        v328 = v233;
        v236 = sub_10011830(v292, 16 * v233);
        v311 = (const char *)v236;
        if ( !v236 )
          return 0;
        if ( v328 > 0 )
        {
          v335 = (int **)(v236 + 8);
          v320 = v328;
          do
          {
            v237 = sub_10021400(*(_DWORD *)(v4 + 56), v235);
            v337 = v237;
            if ( v237 )
            {
              v238 = sub_10041370((int)v237, 0);
              *v335 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v238);
            }
            else
            {
              *v335 = 0;
            }
            HIBYTE(v239) = *(_BYTE *)(v235 + 1);
            LOBYTE(v239) = *(_BYTE *)(v235 + 2);
            v240 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v239);
            v241 = v235 + 2;
            v242 = sub_1004BF50((_BYTE *)v3, v241);
            v235 = 2 * (v341 != 71) + 2 + v241;
            *(v335 - 2) = (int *)v240[2];
            *(v335 - 1) = (int *)v242;
            v180 = v320-- == 1;
            v335 += 4;
          }
          while ( !v180 );
        }
        v227 = sub_1004C720(a1, (int)v311, v328, v3, v338, v346, 0);
        v228 = (unsigned int)v311;
        goto LABEL_335;
      case 118:
        v243 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v244 = (int)v243;
        v337 = v243;
        v338 = sub_10041370((int)v243, 0);
        v245 = sub_10041370(v244, 1);
        v343 = v245;
        v246 = (_BYTE *)v3;
        for ( j = 0; v245; ++j )
        {
          v246 += v245;
          if ( *v246 == 120 || *v246 == -110 )
          {
            v245 = 0;
          }
          else
          {
            v337 = sub_10021400(*(_DWORD *)(v4 + 56), (int)v246);
            v245 = sub_10041370((int)v337, 0);
          }
        }
        v247 = sub_10011830(v292, 16 * j);
        v305 = v247;
        if ( !v247 )
          return 0;
        v329 = v343;
        v248 = (_BYTE *)v3;
        if ( j > 0 )
        {
          v321 = v247;
          v312 = (const char *)j;
          do
          {
            v248 += v329;
            *(_DWORD *)v321 = 2 * (_DWORD)&v248[-v3] | 1;
            *(_DWORD *)(v321 + 4) = &v248[sub_1004BF50(v248, (int)v248)] - v3;
            if ( *v248 == 119 || *v248 == -111 )
            {
              v337 = sub_10021400(*(_DWORD *)(v4 + 56), (int)v248);
              v329 = sub_10041370((int)v337, 0);
            }
            v321 += 16;
            --v312;
          }
          while ( v312 );
        }
        v249 = *(_DWORD *)(16 * j + v305 - 16) >> 1;
        v250 = sub_1004BF50((_BYTE *)(v249 + v3), v249 + v3);
        v229 = sub_1004C720(a1, v305, j, v3, v338, v250 + v249, 1);
        sub_10010340(v292, v305);
        goto LABEL_336;
      case 119:
      case 145:
        v251 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        if ( !v251 )
          return 0;
        sub_1004C4D0(v4, "\tcase %s:\n", v251);
        goto LABEL_69;
      case 72:
      case 73:
        v252 = (const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7));
        v253 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        *(_DWORD *)(v292 + 16);
        v15 = sub_1004C090((_DWORD *)a1, "%s %c%s %s", v253);
        goto LABEL_276;
      case 74:
        v46 = v292;
        HIBYTE(v254) = *(_BYTE *)(v3 + 1);
        LOBYTE(v254) = *(_BYTE *)(v3 + 2);
        v47 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v254);
LABEL_364:
        v255 = sub_10010550(v46, v47[2] & 0xFFFFFFF8);
        v256 = *(_BYTE *)(v4 + 52);
        v257 = *(_DWORD *)(v4 + 48);
        v344 = v255;
        v258 = sub_10011BC0(v255);
        v259 = sub_1004C3A0(v46, (int)v258, v257, v256);
        if ( !v259 )
          return 0;
        *(_DWORD *)(v259 + 60) = *(_DWORD *)(v4 + 60);
        if ( sub_1004CA20(v3, v259, v344) )
        {
          v260 = sub_1004C470(v259);
          if ( v260 )
          {
            v261 = (unsigned int)sub_10010FF0(v260);
            sub_1004C4D0(v4, "%s\n", v261);
          }
        }
        sub_1004C450(v259);
        goto LABEL_277;
      case 83:
        v262 = sub_10051700(v292, *(_DWORD *)(v4 + 56), v3);
        v341 = v262;
        if ( v262 == 154 )
          return 0;
        *(_BYTE *)v3 = v262;
        v338 = byte_100D1E48[16 * v262];
        if ( !sub_1004CCA0(a1, v3, v338) )
          return 0;
        *(_BYTE *)v3 = 83;
        v285 = -2;
        goto LABEL_403;
      case 89:
        if ( *(_DWORD *)(a1 + 28) < 2u )
          return 0;
        sub_1004C690(a1, 89);
        v263 = (_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 89));
        v341 = v307[v3];
        if ( v341 == 93 )
        {
          v3 += (unsigned int)v307;
          v264 = *(_BYTE *)(v3 + 1);
          v338 = 3;
          v265 = *v263 != 79 ? 91 : 123;
          v15 = sub_1004C090((_DWORD *)a1, "#%u=%c", *(_BYTE *)(v3 + 2));
        }
        else
        {
          v180 = *v263 == 79;
          v266 = "{";
          if ( !v180 )
            v266 = "[";
          v15 = sub_1004C090((_DWORD *)a1, v266, v283);
        }
        goto LABEL_276;
      case 90:
        v267 = (_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 90));
        v268 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v337 = v268;
        if ( v268 )
          *v268;
        v269 = *v267 != 123 ? 93 : 125;
        v15 = sub_1004C090((_DWORD *)a1, "%s%s%c", (char)v267);
        goto LABEL_276;
      case 91:
      case 130:
        HIBYTE(v270) = *(_BYTE *)(v3 + 1);
        LOBYTE(v270) = *(_BYTE *)(v3 + 2);
        v271 = sub_10038D40(v292, *(_DWORD *)(v4 + 56) + 16, v270);
        v306 = v271;
        if ( v271[3] || !sub_10028320(v271[2] & 0xFFFFFFF8) )
          v272 = 39;
        else
          v272 = 0;
        if ( !sub_1004C0F0(v306[2] & 0xFFFFFFF8, a1, v272) )
          return 0;
        v273 = (const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7));
        v274 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, v7);
        goto LABEL_390;
      case 92:
        v275 = (const char *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 92));
        v330 = (_BYTE *)(*(_DWORD *)(a1 + 8) + sub_1004C690(a1, 92));
        v274 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 92);
        v276 = sub_10021400(*(_DWORD *)(v4 + 56), v3);
        v337 = v276;
        if ( v276 && (v277 = *v276, (v277 & 0xF8u) < 0xC0) && (unsigned int)v277 >> 3 == 13 )
        {
LABEL_390:
          if ( v331 == 123 || v331 == 124 )
          {
            *(_BYTE *)(v274 + 1);
            v15 = sub_1004C090((_DWORD *)a1, "%s%s%s %s%s", v274);
          }
          else
          {
            *(_BYTE *)(v274 + 1);
            v15 = sub_1004C090((_DWORD *)a1, "%s%s%s:%s", v274);
          }
        }
        else
        {
          if ( !*(_BYTE *)(v274 + 1) )
            *v330;
          v15 = sub_1004C090((_DWORD *)a1, "%s%s%s", v274);
        }
        goto LABEL_276;
      case 93:
        v278 = *(_BYTE *)(v3 + 1);
        v279 = *(_BYTE *)(v3 + 2);
        v280 = *(_DWORD *)(a1 + 8) + sub_1004C690(a1, 93);
        v15 = sub_1004C090((_DWORD *)a1, "#%u=%s", v279);
        goto LABEL_276;
      case 94:
        v281 = *(_BYTE *)(v3 + 1);
        v15 = sub_1004C090((_DWORD *)a1, "#%u#", *(_BYTE *)(v3 + 2));
        goto LABEL_276;
      case 113:
        sub_1004C4D0(v4, "\tdebugger;\n", v283);
        goto LABEL_133;
      default:
        v285 = -2;
        goto LABEL_403;
    }
  }
}
// 100D1E40: using guessed type void *off_100D1E40;
// 100D1E44: using guessed type int dword_100D1E44[];
// 10162FE8: using guessed type void *off_10162FE8;

//----- (1004F7C0) --------------------------------------------------------
signed int __cdecl sub_1004F7C0(int *a1, int a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  int *v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // eax@1
  unsigned int v10; // ebp@1
  signed int v11; // ebp@4
  int v12; // ecx@5
  int v13; // ebx@5
  signed int v14; // eax@5
  bool v15; // zf@5
  char v16; // al@6
  char v17; // al@6
  int v18; // esi@8
  signed int result; // eax@10
  int v20; // [sp+10h] [bp-28h]@1
  int v21; // [sp+14h] [bp-24h]@1
  int v22; // [sp+18h] [bp-20h]@1
  int v23; // [sp+1Ch] [bp-1Ch]@1
  int v24; // [sp+20h] [bp-18h]@1
  int v25; // [sp+24h] [bp-14h]@1
  int v26; // [sp+28h] [bp-10h]@5
  int v27; // [sp+2Ch] [bp-Ch]@5
  int v28; // [sp+30h] [bp-8h]@5
  int *v29; // [sp+34h] [bp-4h]@1
  int v30; // [sp+3Ch] [bp+4h]@1

  v4 = *(_DWORD *)(a2 + 32);
  v5 = a1;
  v6 = *a1;
  v29 = a1;
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 76) + 12);
  v22 = v6 + 60;
  v30 = v6 + 60;
  v21 = v6;
  v23 = 0;
  v24 = 0;
  v25 = 3;
  v8 = *(_DWORD *)(v6 + 76);
  v9 = *(_DWORD *)(v8 + 12);
  v20 = v7;
  v10 = v9 + ((5 * v4 + 3) & 0xFFFFFFFC);
  if ( v10 <= *(_DWORD *)(v8 + 8) )
    *(_DWORD *)(v8 + 12) = v10;
  else
    v9 = sub_1003E2D0(v30, (5 * v4 + 3) & 0xFFFFFFFC);
  v11 = 0;
  if ( v9 )
  {
    v12 = v9 + 4 * v4;
    v13 = v5[14];
    v26 = v9;
    v27 = v12;
    v5[14] = a2;
    v28 = 0;
    v14 = sub_1004CCA0((int)&v21, a3, a4);
    v15 = v28 == 0;
    v11 = v14;
    v5[14] = v13;
    if ( !v15 )
    {
      do
      {
        v16 = sub_1004C690((int)&v21, 0);
        v17 = v23 + v16;
      }
      while ( v28 );
      sub_1004C4D0((int)v5, "%s", v17);
    }
  }
  v18 = *(_DWORD *)(v6 + 76);
  if ( v18 == v30 || v20 - *(_DWORD *)(v18 + 4) > (unsigned int)(*(_DWORD *)(v18 + 12) - *(_DWORD *)(v18 + 4)) )
  {
    sub_1003E5E0(v30, v20);
    result = v11;
  }
  else
  {
    *(_DWORD *)(v18 + 12) = (v20 + 3) & 0xFFFFFFFC;
    result = v11;
  }
  return result;
}

//----- (1004F8E0) --------------------------------------------------------
_BYTE *__cdecl sub_1004F8E0(int a1, int a2, signed int a3, _BYTE *a4)
{
  int v4; // eax@1
  _BYTE *v5; // ebp@2
  _BYTE *v6; // ebx@2
  int v7; // ecx@4
  int v8; // edi@5
  _DWORD *v9; // ecx@5
  unsigned int v10; // eax@5
  _BYTE **v11; // eax@18
  signed int v12; // esi@23
  _BYTE *result; // eax@26
  void **v14; // esi@27
  _BYTE *v15; // edi@28
  unsigned __int8 *v16; // eax@29
  int v17; // ebp@33
  _BYTE *v18; // ebx@34
  int v19; // eax@37
  int *v20; // eax@47
  unsigned int v21; // esi@47
  int v22; // edi@49
  int v23; // [sp+10h] [bp-10h]@5
  void *v24; // [sp+14h] [bp-Ch]@27
  signed int v25; // [sp+18h] [bp-8h]@23
  int v26; // [sp+1Ch] [bp-4h]@27

  v4 = *(_DWORD *)(a1 + 56);
  if ( !v4 )
    goto LABEL_54;
  v5 = *(_BYTE **)(v4 + 56);
  v6 = *(_BYTE **)(v4 + 56);
  if ( a2 != 1 )
  {
    if ( !v6 )
      goto LABEL_54;
    v23 = *(_DWORD *)(v4 + 12);
    if ( !*(_DWORD *)(v4 + 12) )
      goto LABEL_54;
    if ( a2
      && (v8 = *(_DWORD *)(v4 + 12),
          v11 = (_BYTE **)(*(_DWORD *)(v4 + 60) + 4 * (a2 - *(_DWORD *)(v23 + 32))),
          (unsigned int)v11 - *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4) < *(_DWORD *)(*(_DWORD *)(a1 + 44) + 12)
                                                                    - *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4)) )
    {
      v6 = *v11;
    }
    else
    {
      v8 = v23;
    }
    goto LABEL_21;
  }
  if ( v6 )
  {
    v23 = *(_DWORD *)(v4 + 12);
    v9 = *(_DWORD **)(v4 + 64);
    v10 = *(_DWORD *)(v4 + 60);
    v8 = v23;
  }
  else
  {
    v7 = *(_DWORD *)(v4 + 44);
    if ( !v7 )
      goto LABEL_54;
    v8 = *(_DWORD *)(v7 + 12);
    v9 = *(_DWORD **)(v4 + 28);
    v23 = v8;
    v10 = (unsigned int)&v9[*(_DWORD *)(v4 + 24)];
  }
  if ( v8 && v9 && v10 )
  {
    if ( (unsigned int)v9 < v10 )
    {
      while ( *v9 != a3 )
      {
        ++v9;
        if ( (unsigned int)v9 >= v10 )
          goto LABEL_21;
      }
      v6 = (_BYTE *)v9[-*(_DWORD *)(v8 + 32)];
    }
LABEL_21:
    if ( (unsigned int)&v6[-*(_DWORD *)v8] < *(_DWORD *)(v8 + 4) || (v6 = v5) != 0 )
    {
      v12 = *v6;
      v25 = *v6;
      if ( v12 == 83 )
      {
        v25 = sub_10051700(a1, v8, (int)v6);
        v12 = v25;
      }
      if ( v12 == 64 )
        return (_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 156) + 8) & 0xFFFFFFF8);
      v14 = &off_100D1E40 + 4 * v12;
      v24 = v14[3];
      v26 = (unsigned int)v14[3] & 0x30;
      if ( v26 == 16 )
      {
        v15 = v6;
        goto LABEL_33;
      }
      v16 = sub_10021400(v8, (int)v6);
      if ( v16 && (*v16 & 0xF8u) < 0xC0 && (unsigned int)*v16 >> 3 == 12 )
      {
        v15 = &v6[-sub_10041370((int)v16, 0)];
LABEL_33:
        v17 = (int)&v6[*((_BYTE *)v14 + 8) - (_DWORD)v15];
        if ( (unsigned __int16)v24 & 0x1BC0 )
        {
          result = (_BYTE *)sub_10011830(a1, (unsigned int)&v6[*((_BYTE *)v14 + 8) - (_DWORD)v15]);
          v18 = result;
          if ( !result )
            return result;
          memcpy(result, v15, v17);
          if ( v26 == 16 )
          {
            *v18 = 59;
            v15 = v18;
            goto LABEL_47;
          }
          v19 = v17 - *((_BYTE *)v14 + 8);
          if ( v26 == 32 )
          {
            v18[v19] = ((unsigned __int8)v24 & 0x40) != 0 ? -2 : 53;
            v15 = v18;
            goto LABEL_47;
          }
          if ( v26 == 48 )
          {
            v18[v19] = ((unsigned __int8)v24 & 0x40) != 0 ? -1 : 55;
            v15 = v18;
            goto LABEL_47;
          }
          if ( v25 == 122 )
          {
            v18[v19] = 55;
          }
          else if ( v25 == 132 )
          {
            v18[v19] = 58;
            v15 = v18;
            goto LABEL_47;
          }
          v15 = v18;
        }
        else
        {
          v18 = 0;
        }
LABEL_47:
        v20 = (int *)sub_1004C3A0(a1, (int)"js_DecompileValueGenerator", 0, 0);
        v21 = (unsigned int)v20;
        if ( v20 && sub_1004F7C0(v20, v23, (unsigned int)v15, v17) )
          v22 = sub_1004C470(v21);
        else
          v22 = 0;
        sub_1004C450(v21);
        if ( v18 )
          sub_10010340(a1, (unsigned int)v18);
        return (_BYTE *)v22;
      }
    }
  }
LABEL_54:
  result = a4;
  if ( !a4 )
    result = (_BYTE *)sub_1001ACB0(a1, a3);
  return result;
}
// 100D1E40: using guessed type void *off_100D1E40;

//----- (1004FBA0) --------------------------------------------------------
int __usercall sub_1004FBA0@<eax>(int a1@<eax>, int (__cdecl **a2)(_DWORD, _DWORD, _DWORD)@<esi>, int a3, int a4, char a5)
{
  char v5; // bl@1
  int v6; // ebp@1
  int v7; // edi@1
  bool v8; // zf@1
  bool v9; // sf@1
  int result; // eax@6
  int v11; // edi@11

  v5 = a5;
  v6 = a4;
  v7 = a1 - a4;
  v8 = a1 == a4;
  v9 = a1 - a4 < 0;
  LOBYTE(a4) = 32;
  if ( v9 || v8 || a5 & 1 )
    goto LABEL_8;
  if ( a5 & 8 )
    LOBYTE(a4) = 48;
  if ( --v7 < 0 )
  {
LABEL_8:
    result = (*a2)(a2, a3, v6);
    if ( result >= 0 )
    {
      if ( v7 > 0 && v5 & 1 && (v11 = v7 - 1, v11 >= 0) )
      {
        while ( 1 )
        {
          result = (*a2)(a2, &a4, 1);
          if ( result < 0 )
            break;
          if ( --v11 < 0 )
            goto LABEL_14;
        }
      }
      else
      {
LABEL_14:
        result = 0;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      result = (*a2)(a2, &a4, 1);
      if ( result < 0 )
        break;
      if ( --v7 < 0 )
        goto LABEL_8;
    }
  }
  return result;
}

//----- (1004FC30) --------------------------------------------------------
int __usercall sub_1004FC30@<eax>(int a1@<edx>, int a2@<ecx>, int (__cdecl **a3)(_DWORD, _DWORD, _DWORD)@<esi>, int a4, int a5, char a6, char a7)
{
  int v7; // ebx@1
  signed int v8; // ebp@1
  int v9; // eax@9
  int v10; // edi@19
  int v11; // edi@20
  int result; // eax@21
  int v13; // ebx@25
  int v14; // edi@28
  int v15; // edi@32
  int v16; // [sp+10h] [bp-8h]@1
  int v17; // [sp+14h] [bp-4h]@1

  v7 = 0;
  v8 = 0;
  v16 = 0;
  v17 = 0;
  if ( !(a6 & 1) )
  {
    if ( a7 & 0x10 )
    {
      a6 = 45;
LABEL_8:
      v8 = 1;
      goto LABEL_9;
    }
    if ( a7 & 2 )
    {
      a6 = 43;
      goto LABEL_8;
    }
    if ( a7 & 4 )
    {
      a6 = 32;
      goto LABEL_8;
    }
  }
LABEL_9:
  v9 = v8 + a5;
  if ( a1 > 0 && a1 > a5 )
  {
    v7 = a1 - a5;
    v9 += a1 - a5;
  }
  if ( a7 & 8 && a1 < 0 && a2 > v9 )
  {
    v16 = a2 - v9;
    v9 = a2;
  }
  if ( a7 & 1 )
  {
    if ( a2 > v9 )
      v17 = a2 - v9;
    goto LABEL_19;
  }
  if ( a2 <= v9 )
  {
LABEL_19:
    v10 = 0;
    goto LABEL_20;
  }
  v10 = a2 - v9;
LABEL_20:
  v11 = v10 - 1;
  if ( v11 < 0 )
  {
LABEL_23:
    if ( !v8 || (result = (*a3)(a3, &a6, 1), result >= 0) )
    {
      v13 = v7 - 1;
      if ( v13 < 0 )
      {
LABEL_28:
        v14 = v16 - 1;
        if ( v16 - 1 < 0 )
        {
LABEL_31:
          result = (*a3)(a3, a4, a5);
          if ( result >= 0 )
          {
            v15 = v17 - 1;
            if ( v17 - 1 < 0 )
            {
LABEL_35:
              result = 0;
            }
            else
            {
              while ( 1 )
              {
                result = (*a3)(a3, word_100D2B44, 1);
                if ( result < 0 )
                  break;
                if ( --v15 < 0 )
                  goto LABEL_35;
              }
            }
          }
        }
        else
        {
          while ( 1 )
          {
            result = (*a3)(a3, &word_100D1C0C, 1);
            if ( result < 0 )
              break;
            if ( --v14 < 0 )
              goto LABEL_31;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          result = (*a3)(a3, &word_100D1C0C, 1);
          if ( result < 0 )
            break;
          if ( --v13 < 0 )
            goto LABEL_28;
        }
      }
    }
  }
  else
  {
    while ( 1 )
    {
      result = (*a3)(a3, word_100D2B44, 1);
      if ( result < 0 )
        break;
      if ( --v11 < 0 )
        goto LABEL_23;
    }
  }
  return result;
}
// 100D1C0C: using guessed type __int16 word_100D1C0C;

//----- (1004FDA0) --------------------------------------------------------
unsigned int __usercall sub_1004FDA0@<eax>(unsigned int a1@<edx>, int (__cdecl **a2)(_DWORD, _DWORD, _DWORD)@<ecx>, int a3@<ebx>, unsigned int a4, int a5, char a6, char a7, int a8)
{
  unsigned int result; // eax@1
  int v9; // edi@3
  int *v10; // ecx@3
  unsigned __int64 v11; // rtt@4
  int (__cdecl **v12)(_DWORD, _DWORD, _DWORD); // [sp+8h] [bp-6Ch]@1
  int v13; // [sp+70h] [bp-4h]@3

  result = a4;
  v12 = a2;
  if ( a3 || a4 )
  {
    v9 = 0;
    v10 = &v13;
    if ( !a4 )
      goto LABEL_10;
    do
    {
      v11 = result;
      result /= a1;
      v10 = (int *)((char *)v10 - 1);
      ++v9;
      *(_BYTE *)v10 = *(_BYTE *)((v11 % a1 & 0xF) + a8);
    }
    while ( result );
    if ( !v9 )
    {
LABEL_10:
      v10 = (int *)((char *)v10 - 1);
      *(_BYTE *)v10 = 48;
      v9 = 1;
    }
    result = sub_1004FC30(a3, a5, v12, (int)v10, v9, a6, a7);
  }
  return result;
}

//----- (1004FE50) --------------------------------------------------------
int __cdecl sub_1004FE50(int (__cdecl **a1)(_DWORD, _DWORD, _DWORD), __int64 a2, int a3, int a4, unsigned int a5, char a6, char a7, int a8)
{
  unsigned int v8; // ecx@1
  unsigned int v9; // edi@1
  int result; // eax@3
  int v11; // esi@4
  int *v12; // ebp@4
  unsigned __int64 v13; // kr08_8@5
  int v14; // [sp+7Ch] [bp-4h]@4

  v9 = HIDWORD(a2);
  v8 = a2;
  if ( a4 || a2 )
  {
    v11 = 0;
    v12 = &v14;
    if ( !a2 )
      goto LABEL_11;
    do
    {
      v12 = (int *)((char *)v12 - 1);
      *(_BYTE *)v12 = *(_BYTE *)((__PAIR__(v9, v8) % (signed int)a5 & 0xF) + a8);
      v13 = __PAIR__(v9, v8) / (signed int)a5;
      v9 = __PAIR__(v9, v8) / (signed int)a5 >> 32;
      v8 = v13;
      ++v11;
    }
    while ( __PAIR__(v9, (unsigned int)v13) );
    if ( !v11 )
    {
LABEL_11:
      v12 = (int *)((char *)v12 - 1);
      *(_BYTE *)v12 = 48;
      v11 = 1;
    }
    result = sub_1004FC30(a4, a3, a1, (int)v12, v11, a6, a7);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004FF50) --------------------------------------------------------
int __usercall sub_1004FF50@<eax>(void *a1@<ecx>, int (__cdecl **a2)(_DWORD, _DWORD, _DWORD)@<edi>, double a3, int a4)
{
  int v4; // esi@1
  int result; // eax@2
  char v6[20]; // [sp+Ch] [bp-144h]@3
  char v7; // [sp+20h] [bp-130h]@3

  v4 = a4 - (_DWORD)a1;
  if ( a4 - (signed int)a1 < 20 )
  {
    memcpy(v6, a1, a4 - (_DWORD)a1);
    v6[v4] = 0;
    sprintf(&v7, v6, a3);
    result = (*a2)(a2, &v7, strlen(&v7));
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004FF50: using guessed type char var_144[20];

//----- (10050000) --------------------------------------------------------
int __usercall sub_10050000@<eax>(int a1@<edx>, const char *a2@<edi>, int (__cdecl **a3)(_DWORD, _DWORD, _DWORD), int a4, char a5)
{
  int result; // eax@2
  signed int v6; // eax@4
  const char *v7; // ecx@9

  if ( a1 )
  {
    if ( a2 )
      v6 = strlen(a2);
    else
      v6 = 6;
    if ( a1 > 0 && a1 < v6 )
      v6 = a1;
    v7 = a2;
    if ( !a2 )
      v7 = "(null)";
    result = sub_1004FBA0(a4, a3, (int)v7, v6, a5);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10050060) --------------------------------------------------------
int __usercall sub_10050060@<eax>(int a1@<eax>, char *a2@<edi>, _DWORD *a3, int a4)
{
  int v4; // ebx@1
  signed int v5; // ebp@1
  char v6; // al@1
  signed int v7; // esi@1
  char *v8; // ecx@1
  char v9; // al@3
  int result; // eax@16
  signed int i; // ecx@19
  char v12; // cl@21
  char *v13; // edx@21
  unsigned __int8 v14; // cl@23
  int v15; // esi@24
  int v16; // esi@30
  char v17; // cl@31
  int v18; // edx@59
  int v19; // ecx@60

  v4 = a1;
  v5 = 0;
  *a3 = 0;
  v6 = *a2;
  v7 = 0;
  v8 = a2;
  if ( !*a2 )
    return 0;
  do
  {
    ++v8;
    if ( v6 == 37 )
    {
      v9 = *v8++;
      if ( v9 != 37 )
      {
        if ( v9 )
        {
          while ( (unsigned __int8)(v9 - 48) <= 9u )
          {
            v9 = *v8++;
            if ( !v9 )
              goto LABEL_13;
          }
          if ( v9 == 36 )
          {
            if ( v7 > 0 )
              goto LABEL_68;
            ++v5;
          }
          else
          {
            if ( v5 > 0 )
              goto LABEL_17;
            v7 = 1;
          }
        }
      }
    }
LABEL_13:
    v6 = *v8;
  }
  while ( *v8 );
  if ( !v5 )
    return 0;
  if ( v5 <= 20 )
  {
    result = a4;
  }
  else
  {
    result = sub_10053CF0(8 * v5, dword_10658DEC);
    if ( !result )
    {
LABEL_17:
      *a3 = -1;
      return 0;
    }
  }
  for ( i = 0; i < v5; ++i )
    *(_DWORD *)(result + 8 * i) = 20;
  v12 = *a2;
  v13 = a2;
  if ( !*a2 )
  {
LABEL_55:
    if ( *a3 < 0 )
      goto LABEL_56;
    v18 = 0;
    if ( v5 <= 0 )
      return result;
    while ( 1 )
    {
      v19 = *(_DWORD *)(result + 8 * v18);
      if ( v19 != 20 )
        break;
LABEL_64:
      if ( ++v18 >= v5 )
        return result;
    }
    *(_DWORD *)(result + 8 * v18 + 4) = v4;
    switch ( v19 )
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 8:
      case 10:
        v4 += 4;
        goto LABEL_64;
      case 6:
      case 7:
      case 9:
        v4 += 8;
        goto LABEL_64;
      default:
        if ( result != a4 )
          sub_10053E10(result, dword_10658DEC);
        break;
    }
LABEL_68:
    *a3 = -1;
    return 0;
  }
  while ( 1 )
  {
    ++v13;
    if ( v12 == 37 )
    {
      v14 = *v13++;
      if ( v14 != 37 )
      {
        v15 = 0;
        if ( !v14 )
          goto LABEL_27;
        while ( v14 != 36 )
        {
          v15 = v14 + 10 * v15 - 48;
          v14 = *v13++;
          if ( !v14 )
            goto LABEL_27;
        }
        if ( v15 < 1 || v15 > v5 )
        {
LABEL_27:
          *a3 = -1;
          goto LABEL_56;
        }
        v16 = v15 - 1;
        if ( *(_DWORD *)(result + 8 * v16) == 20 )
          break;
      }
    }
LABEL_54:
    v12 = *v13;
    if ( !*v13 )
      goto LABEL_55;
  }
  v17 = *v13++;
  if ( v17 == 42 )
    goto LABEL_58;
  for ( ; (unsigned __int8)v17 >= 0x30u; v17 = *v13++ )
  {
    if ( (unsigned __int8)v17 > 0x39u )
      break;
  }
  if ( v17 == 46 )
  {
    v17 = *v13++;
    if ( v17 == 42 )
      goto LABEL_27;
    for ( ; (unsigned __int8)v17 >= 0x30u; v17 = *v13++ )
    {
      if ( (unsigned __int8)v17 > 0x39u )
        break;
    }
  }
  *(_DWORD *)(result + 8 * v16) = 2;
  if ( v17 == 104 )
  {
    *(_DWORD *)(result + 8 * v16) = 0;
LABEL_46:
    v17 = *v13++;
    goto LABEL_47;
  }
  if ( v17 == 76 || v17 == 108 && (*(_DWORD *)(result + 8 * v16) = 4, v17 = *v13, ++v13, v17 == 108) )
  {
    *(_DWORD *)(result + 8 * v16) = 6;
    goto LABEL_46;
  }
LABEL_47:
  switch ( v17 )
  {
    case 0x65:
    case 0x66:
    case 0x67:
      *(_DWORD *)(result + 8 * v16) = 9;
      break;
    case 0x70:
      *(_DWORD *)(result + 8 * v16) = 5;
      break;
    case 0x73:
      *(_DWORD *)(result + 8 * v16) = 8;
      break;
    case 0x6E:
      *(_DWORD *)(result + 8 * v16) = 10;
      break;
    default:
      *(_DWORD *)(result + 8 * v16) = 20;
      break;
    case 0x58:
    case 0x63:
    case 0x64:
    case 0x69:
    case 0x6F:
    case 0x75:
    case 0x78:
      break;
  }
  if ( *(_DWORD *)(result + 8 * v16) != 20 )
    goto LABEL_54;
LABEL_58:
  *a3 = -1;
LABEL_56:
  if ( result != a4 )
  {
    sub_10053E10(result, dword_10658DEC);
    return 0;
  }
  return 0;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10050380) --------------------------------------------------------
int __usercall sub_10050380@<eax>(int a1@<edx>, char *a2@<ecx>, int a3)
{
  int (__cdecl **v3)(_DWORD, _DWORD, _DWORD); // ebp@1
  void *v4; // ebx@1
  unsigned __int64 v5; // rdi@1
  int result; // eax@1
  char v7; // al@2
  unsigned __int8 v8; // dl@5
  int v9; // ecx@5
  int i; // ebp@27
  int v11; // ecx@30
  int v12; // ecx@31
  int v13; // eax@36
  int v14; // ecx@36
  unsigned int v15; // edx@46
  double v16; // st7@53
  char v17; // cl@58
  signed int v18; // eax@70
  void *v19; // ebx@72
  int v20; // ecx@78
  _DWORD *v21; // ebx@78
  int v22; // eax@78
  _DWORD *v23; // ebx@80
  const char *v24; // edi@84
  _DWORD *v25; // eax@85
  int v26; // esi@93
  char v27; // [sp+1Ch] [bp-E0h]@22
  int v28; // [sp+24h] [bp-D8h]@1
  void *v29; // [sp+28h] [bp-D4h]@5
  double v30; // [sp+2Ch] [bp-D0h]@53
  int v31; // [sp+34h] [bp-C8h]@31
  void *v32; // [sp+38h] [bp-C4h]@1
  char *v33; // [sp+3Ch] [bp-C0h]@45
  char *v34; // [sp+40h] [bp-BCh]@1
  char v35; // [sp+44h] [bp-B8h]@1
  char v36; // [sp+E4h] [bp-18h]@55
  int v37; // [sp+E5h] [bp-17h]@55

  v3 = (int (__cdecl **)(_DWORD, _DWORD, _DWORD))a3;
  v4 = (void *)a1;
  v32 = 0;
  v5 = __PAIR__((unsigned int)a2, sub_10050060(a1, a2, &v28, (int)&v35));
  result = v28;
  v34 = (char *)v5;
  if ( v28 < 0 )
    return result;
  v7 = *(_BYTE *)HIDWORD(v5);
  if ( !*(_BYTE *)HIDWORD(v5) )
  {
LABEL_93:
    HIDWORD(v5) = (*v3)(v3, &unk_100D2B50, 1);
    if ( (_DWORD)v5 )
    {
      if ( (char *)v5 != &v35 )
        sub_10053E10(v5, dword_10658DEC);
    }
    return v26;
  }
  while ( 1 )
  {
    ++HIDWORD(v5);
    if ( v7 != 37 )
    {
      result = (*(int (__cdecl **)(int, int, signed int))a3)(a3, HIDWORD(v5) - 1, 1);
      goto LABEL_89;
    }
    v8 = *(_BYTE *)HIDWORD(v5);
    v29 = (void *)(HIDWORD(v5) - 1);
    v9 = 0;
    ++HIDWORD(v5);
    if ( v8 != 37 )
      break;
    result = (*(int (__cdecl **)(int, int, signed int))a3)(a3, HIDWORD(v5) - 1, 1);
LABEL_89:
    v28 = result;
LABEL_90:
    if ( result < 0 )
      return result;
LABEL_91:
    v7 = *(_BYTE *)HIDWORD(v5);
    if ( !*(_BYTE *)HIDWORD(v5) )
    {
      v3 = (int (__cdecl **)(_DWORD, _DWORD, _DWORD))a3;
      LODWORD(v5) = v34;
      goto LABEL_93;
    }
  }
  if ( !v34 )
    goto LABEL_14;
  for ( LODWORD(v5) = 0; v8; ++HIDWORD(v5) )
  {
    if ( v8 == 36 )
      break;
    LODWORD(v5) = v8 + 10 * v5 - 48;
    v8 = *(_BYTE *)HIDWORD(v5);
  }
  if ( *(_DWORD *)&v34[8 * v5 - 8] == 20 )
  {
    if ( v34 != &v35 )
      sub_10053E10((unsigned int)v34, dword_10658DEC);
    result = -1;
  }
  else
  {
    v4 = *(void **)&v34[8 * v5 - 4];
    v32 = (void *)HIDWORD(v5);
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v8 = *(_BYTE *)HIDWORD(v5);
            ++HIDWORD(v5);
LABEL_14:
            if ( v8 != 45 )
              break;
            v9 |= 1u;
          }
          if ( v8 != 43 )
            break;
          v9 |= 2u;
        }
        if ( v8 != 32 )
          break;
        v9 |= 4u;
      }
      if ( v8 != 48 )
        break;
      v9 |= 8u;
    }
    v27 = v9;
    if ( v9 & 2 )
    {
      LOBYTE(v9) = v9 & 0xFB;
      v27 = v9;
    }
    if ( v9 & 1 )
      v27 = v9 & 0xF7;
    if ( v8 == 42 )
    {
      v8 = *(_BYTE *)HIDWORD(v5);
      i = *(_DWORD *)v4;
      ++HIDWORD(v5);
      v4 = (char *)v4 + 4;
    }
    else
    {
      for ( i = 0; v8 >= 0x30u; i = v11 + 10 * i - 48 )
      {
        if ( v8 > 0x39u )
          break;
        v11 = v8;
        v8 = *(_BYTE *)HIDWORD(v5);
        ++HIDWORD(v5);
      }
    }
    v12 = -1;
    v31 = -1;
    if ( v8 == 46 )
    {
      v8 = *(_BYTE *)HIDWORD(v5);
      ++HIDWORD(v5);
      if ( v8 == 42 )
      {
        v8 = *(_BYTE *)HIDWORD(v5);
        v12 = *(_DWORD *)v4;
        ++HIDWORD(v5);
        v4 = (char *)v4 + 4;
        goto LABEL_37;
      }
      v12 = 0;
      v31 = 0;
      if ( v8 >= 0x30u )
      {
        do
        {
          if ( v8 > 0x39u )
            break;
          v13 = 5 * v12;
          v14 = v8;
          v8 = *(_BYTE *)HIDWORD(v5);
          ++HIDWORD(v5);
          v12 = v14 + 2 * v13 - 48;
        }
        while ( v8 >= 0x30u );
LABEL_37:
        v31 = v12;
      }
    }
    LODWORD(v5) = 2;
    if ( v8 == 104 )
    {
      LODWORD(v5) = 0;
      goto LABEL_44;
    }
    if ( v8 == 76 || v8 == 108 && (v8 = *(_BYTE *)HIDWORD(v5), ++HIDWORD(v5), LODWORD(v5) = 4, v8 == 108) )
    {
      LODWORD(v5) = 6;
LABEL_44:
      v8 = *(_BYTE *)HIDWORD(v5);
      ++HIDWORD(v5);
    }
    v33 = off_10162FF4[0];
    switch ( v8 )
    {
      case 0x64u:
      case 0x69u:
        v15 = 10;
        goto LABEL_49;
      case 0x6Fu:
        v15 = 8;
        goto LABEL_48;
      case 0x75u:
        v15 = 10;
        goto LABEL_48;
      case 0x78u:
        v15 = 16;
        goto LABEL_48;
      case 0x58u:
        v15 = 16;
        v33 = off_10162FF8;
LABEL_48:
        LODWORD(v5) = v5 | 1;
        goto LABEL_49;
      case 0x45u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
        v16 = *(double *)v4;
        v4 = (char *)v4 + 8;
        v30 = v16;
        if ( !v34 )
        {
          result = sub_1004FF50(v29, (int (__cdecl **)(_DWORD, _DWORD, _DWORD))a3, v16, SHIDWORD(v5));
          goto LABEL_89;
        }
        LODWORD(v5) = HIDWORD(v5) - (_DWORD)v32;
        if ( HIDWORD(v5) - (signed int)v32 < 20 )
        {
          v36 = 37;
          memcpy(&v37, v32, HIDWORD(v5) - (_DWORD)v32);
          result = sub_1004FF50(&v36, (int (__cdecl **)(_DWORD, _DWORD, _DWORD))a3, v30, (int)&v37 + v5);
          goto LABEL_89;
        }
        result = v28;
        goto LABEL_90;
      case 0x63u:
        v17 = *(_BYTE *)v4;
        v4 = (char *)v4 + 4;
        LOBYTE(v30) = v17;
        if ( v27 & 1 )
          goto LABEL_63;
        if ( i <= 1 )
          goto LABEL_62;
        break;
      case 0x70u:
        LODWORD(v5) = 5;
        v15 = 16;
LABEL_49:
        switch ( (_DWORD)v5 )
        {
          case 0:
          case 2:
          case 4:
            v18 = *(_DWORD *)v4;
            v29 = (char *)v4 + 4;
            LODWORD(v30) = v18;
            if ( v18 >= 0 )
              goto LABEL_76;
            v18 = -v18;
            v27 |= 0x10u;
            goto LABEL_75;
          case 1:
            v18 = *(_DWORD *)v4;
            v19 = (char *)v4 + 4;
            v18 = (unsigned __int16)v18;
            goto LABEL_74;
          case 3:
          case 5:
            v18 = *(_DWORD *)v4;
            v19 = (char *)v4 + 4;
LABEL_74:
            v29 = v19;
LABEL_75:
            LODWORD(v30) = v18;
LABEL_76:
            result = sub_1004FDA0(v15, (int (__cdecl **)(_DWORD, _DWORD, _DWORD))a3, v12, v18, i, v5, v27, (int)v33);
            v28 = result;
            if ( result < 0 )
              return result;
            v4 = v29;
            goto LABEL_91;
          case 6:
            v20 = *(_DWORD *)v4;
            v21 = (char *)v4 + 8;
            LODWORD(v30) = v20;
            v22 = *(v21 - 1);
            v29 = v21;
            HIDWORD(v30) = v22;
            if ( v22 >= 0 )
              goto LABEL_82;
            v20 = -v20;
            v22 = (unsigned __int64)-__PAIR__(v22, v20) >> 32;
            v27 |= 0x10u;
            LODWORD(v30) = v20;
            break;
          case 7:
            v20 = *(_DWORD *)v4;
            v23 = (char *)v4 + 8;
            LODWORD(v30) = v20;
            v22 = *(v23 - 1);
            v29 = v23;
            break;
          default:
            goto LABEL_91;
        }
        HIDWORD(v30) = v22;
LABEL_82:
        result = sub_1004FE50(
                   (int (__cdecl **)(_DWORD, _DWORD, _DWORD))a3,
                   __PAIR__(v22, v20),
                   i,
                   v31,
                   v15,
                   v5,
                   v27,
                   (int)v33);
        v28 = result;
        if ( result < 0 )
          return result;
        v4 = v29;
        goto LABEL_91;
      case 0x73u:
        v24 = *(const char **)v4;
        v4 = (char *)v4 + 4;
        LODWORD(v30) = v24;
        result = sub_10050000(v12, v24, (int (__cdecl **)(_DWORD, _DWORD, _DWORD))a3, i, v27);
        goto LABEL_89;
      case 0x6Eu:
        v25 = *(_DWORD **)v4;
        v4 = (char *)v4 + 4;
        LODWORD(v30) = v25;
        if ( v25 )
          *v25 = *(_DWORD *)(a3 + 8) - *(_DWORD *)(a3 + 4);
        goto LABEL_91;
      default:
        LODWORD(v5) = a3;
        result = (*(int (**)(int, const char *, ...))a3)(a3, "%", 1);
        if ( result < 0 )
          return result;
        result = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))a3)(a3, (v5 - 0x100000000i64) >> 32, 1);
        goto LABEL_89;
    }
    while ( 1 )
    {
      --i;
      result = (*(int (__cdecl **)(int, char *, signed int))a3)(a3, word_100D2B44, 1);
      if ( result < 0 )
        break;
      if ( i <= 1 )
      {
LABEL_62:
        --i;
LABEL_63:
        result = (*(int (__cdecl **)(int, double *, signed int))a3)(a3, &v30, 1);
        v28 = result;
        if ( result >= 0 )
        {
          if ( !(v27 & 1) || i <= 1 )
            goto LABEL_91;
          while ( 1 )
          {
            --i;
            result = (*(int (__cdecl **)(_DWORD, char *, _DWORD))a3)(a3, word_100D2B44, 1);
            v28 = result;
            if ( result < 0 )
              break;
            if ( i <= 1 )
              goto LABEL_91;
          }
        }
        return result;
      }
    }
  }
  return result;
}
// 10162FF4: using guessed type char *off_10162FF4[2];
// 10162FF8: using guessed type char *off_10162FF8;
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10050930) --------------------------------------------------------
signed int __cdecl sub_10050930(int a1, _BYTE *a2, unsigned int a3)
{
  void *v3; // eax@1
  unsigned int v4; // ecx@1
  unsigned int v5; // edi@1
  int v6; // ebx@1
  unsigned int v7; // edx@2
  unsigned int v8; // ebp@4
  char *v9; // eax@5
  _BYTE *v11; // eax@11

  v3 = *(void **)(a1 + 4);
  v4 = *(_DWORD *)(a1 + 12);
  v5 = a3;
  v6 = *(_DWORD *)(a1 + 8) - (_DWORD)v3;
  if ( v6 + a3 >= v4 )
  {
    v7 = a3;
    if ( a3 <= 0x20 )
      v7 = 32;
    v8 = v4 + v7;
    if ( v3 )
      v9 = (char *)sub_10053FC0(v3, v8, dword_10658DEC);
    else
      v9 = (char *)sub_10053CF0(v8, dword_10658DEC);
    if ( !v9 )
      return -1;
    *(_DWORD *)(a1 + 4) = v9;
    *(_DWORD *)(a1 + 12) = v8;
    *(_DWORD *)(a1 + 8) = &v9[v6];
  }
  if ( a3 )
  {
    v11 = a2;
    do
    {
      --v5;
      *(_BYTE *)(*(_DWORD *)(a1 + 8))++ = *v11++;
    }
    while ( v5 );
  }
  return 0;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100509D0) --------------------------------------------------------
unsigned int __cdecl sub_100509D0(char *a1, int a2)
{
  bool v2; // sf@1
  unsigned int result; // eax@1
  signed int (__cdecl *v4)(int, _BYTE *, unsigned int); // [sp+0h] [bp-18h]@1
  unsigned int v5; // [sp+4h] [bp-14h]@1
  int v6; // [sp+8h] [bp-10h]@1
  int v7; // [sp+Ch] [bp-Ch]@1

  v4 = sub_10050930;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v2 = sub_10050380(a2, a1, (int)&v4) < 0;
  result = v5;
  if ( v2 )
  {
    if ( v5 )
      sub_10053E10(v5, dword_10658DEC);
    result = 0;
  }
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10050A30) --------------------------------------------------------
int __cdecl sub_10050A30(int a1, _BYTE *a2, unsigned int a3)
{
  int v3; // ecx@1
  _BYTE *v4; // esi@4

  v3 = a3;
  if ( a3 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8) )
    v3 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8);
  if ( v3 )
  {
    v4 = a2;
    do
    {
      --v3;
      *(_BYTE *)(*(_DWORD *)(a1 + 8))++ = *v4++;
    }
    while ( v3 );
  }
  return 0;
}

//----- (10050A70) --------------------------------------------------------
int __cdecl sub_10050A70(int a1, int a2, char *a3, int a4)
{
  int v4; // eax@2
  int v5; // eax@5
  int result; // eax@6
  int (__cdecl *v7)(int, _BYTE *, unsigned int); // [sp+0h] [bp-18h]@2
  int v8; // [sp+4h] [bp-14h]@2
  int v9; // [sp+8h] [bp-10h]@2
  int v10; // [sp+Ch] [bp-Ch]@2

  if ( a2 <= 0 )
    goto LABEL_10;
  v8 = a1;
  v9 = a1;
  v10 = a2;
  v7 = sub_10050A30;
  sub_10050380(a4, a3, (int)&v7);
  v4 = v9;
  if ( v9 != v8 )
  {
    if ( *(_BYTE *)(v9 - 1) )
    {
      --v9;
      *(_BYTE *)(v4 - 1) = 0;
      v4 = v9;
    }
  }
  v5 = v4 - v8;
  if ( v5 )
    result = v5 - 1;
  else
LABEL_10:
    result = 0;
  return result;
}

//----- (10050AE0) --------------------------------------------------------
unsigned int __cdecl sub_10050AE0(char *a1, char a2)
{
  return sub_100509D0(a1, (int)&a2);
}

//----- (10050B00) --------------------------------------------------------
int __cdecl sub_10050B00(int a1, int a2, char *a3, char a4)
{
  int result; // eax@2

  if ( a2 > 0 )
    result = sub_10050A70(a1, a2, a3, (int)&a4);
  else
    result = 0;
  return result;
}

//----- (10050B30) --------------------------------------------------------
int __cdecl sub_10050B30(int a1, int a2, int a3)
{
  int result; // eax@1
  unsigned int v4; // esi@1

  result = sub_100105B0(**(_DWORD **)(a1 + 20), &off_10163020, a2, 0);
  v4 = result;
  if ( result )
  {
    sub_100A3B10(a3);
    sub_10010570(**(_DWORD **)(a1 + 20), v4, a3);
    if ( sub_10010800(**(_DWORD **)(a1 + 20), v4, (int *)&off_10163000)
      && sub_10011BE0(**(_DWORD **)(a1 + 20), v4, (const char **)&off_10163068) )
    {
      result = v4;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 10163000: using guessed type char *off_10163000;
// 10163020: using guessed type char *off_10163020;
// 10163068: using guessed type char *off_10163068;

//----- (10050BB0) --------------------------------------------------------
signed int __usercall sub_10050BB0@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5)
{
  int v5; // esi@1
  int v6; // ebx@4
  int v7; // ebp@4
  int v8; // eax@4
  signed int result; // eax@8

  v5 = *a5 & 0xFFFFFFF8;
  if ( a4 != 1 || *a5 & 7 || !v5 )
  {
    sub_100110D0(a2, "invalid args %i to appendChild\n", a4);
    result = 0;
  }
  else
  {
    v6 = sub_100102E0(a2);
    v7 = sub_10010550(a2, a3);
    v8 = sub_10010550(a2, v5);
    if ( v6 && v8 && v7 )
    {
      if ( *(_DWORD *)(v8 + 32) == v6 )
      {
        sub_100A3D40(v7, v8);
        result = 1;
      }
      else
      {
        sub_100110D0(a2, "invalid node\n", a1);
        result = 0;
      }
    }
    else
    {
      sub_100110D0(a2, "unable to find priv pointer\n", a1);
      result = 0;
    }
  }
  return result;
}
// 10050BB0: could not find valid save-restore pair for edi

//----- (10050C60) --------------------------------------------------------
void __cdecl sub_10050C60(int a1, int a2)
{
  void *v2; // eax@1
  char v3; // [sp+0h] [bp-4h]@0

  v2 = (void *)sub_10010550(a1, a2);
  if ( v2 )
    sub_100A4240(v2);
  else
    sub_100110D0(a1, "unable to find priv pointer\n", v3);
}

//----- (10050CA0) --------------------------------------------------------
signed int __cdecl sub_10050CA0(int a1, int a2, signed int a3, int *a4)
{
  unsigned int v4; // eax@1
  char v6; // [sp+0h] [bp-4h]@0

  v4 = sub_10010550(a1, a2);
  if ( !v4 )
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v6);
    return 0;
  }
  if ( a3 & 1 )
  {
    if ( a3 >> 1 != 99 )
    {
      sub_100110D0(a1, "unknown id %i\n", a3 >> 1);
      return 0;
    }
    if ( *(_DWORD *)(v4 + 28) )
    {
      *a4 = sub_10012FC0(*(_DWORD *)(v4 + 32), *(_DWORD *)(v4 + 28));
      return 1;
    }
    *a4 = 0;
  }
  return 1;
}

//----- (10050D30) --------------------------------------------------------
signed int __cdecl sub_10050D30(int a1, int a2)
{
  signed int result; // eax@2
  char v3; // [sp+0h] [bp-4h]@0

  if ( sub_10010550(a1, a2) )
  {
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v3);
    result = 0;
  }
  return result;
}

//----- (10050D60) --------------------------------------------------------
signed int __usercall sub_10050D60@<eax>(char a1@<dil>, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  int v6; // esi@1
  int v7; // ebx@4
  unsigned int v8; // ebp@4
  int v9; // eax@4
  int v10; // esi@4
  signed int result; // eax@8

  v6 = *a5 & 0xFFFFFFF8;
  if ( a4 != 1 || *a5 & 7 || !v6 )
  {
    sub_100110D0(a2, "invalid args %i to removeChild\n", a4);
    result = 0;
  }
  else
  {
    v7 = sub_100102E0(a2);
    v8 = sub_10010550(a2, a3);
    v9 = sub_10010550(a2, v6);
    v10 = v9;
    if ( v7 && v9 && v8 )
    {
      if ( sub_100A4670(*(_DWORD *)(v8 + 28), v9) )
      {
        sub_100A3E10(v10);
        *a6 = *a5;
        result = 1;
      }
      else
      {
        sub_100110D0(a2, "node not a child\n", a1);
        result = 0;
      }
    }
    else
    {
      sub_100110D0(a2, "unable to find priv pointer\n", a1);
      result = 0;
    }
  }
  return result;
}
// 10050D60: could not find valid save-restore pair for edi

//----- (10050E30) --------------------------------------------------------
char *__cdecl sub_10050E30(int a1, int a2, int a3)
{
  int v3; // esi@1
  char *result; // eax@3

  v3 = sub_100105B0(**(_DWORD **)(a1 + 20), &off_10163090, a2, 0);
  if ( v3 )
    sub_10010570(**(_DWORD **)(a1 + 20), v3, a3);
  result = sub_10010800(**(_DWORD **)(a1 + 20), v3, (int *)&off_101630D8);
  if ( result )
    result = (char *)v3;
  return result;
}
// 10163090: using guessed type char *off_10163090;
// 101630D8: using guessed type char *off_101630D8;

//----- (10050E90) --------------------------------------------------------
signed int __cdecl sub_10050E90(int a1, int a2, int a3, __int32 *a4)
{
  unsigned int v4; // eax@1
  signed int result; // eax@2
  int v6; // eax@5
  __int32 v7; // ecx@5
  const char *v8; // eax@6
  char v9; // [sp+0h] [bp-4h]@0

  v4 = sub_10010550(a1, a2);
  if ( v4 )
  {
    if ( a3 & 1 && !(a3 & 0xFFFFFFFE) )
    {
      v6 = sub_100A46E0(11, 0, *(_DWORD *)(v4 + 40));
      v7 = 1;
      if ( v6 )
      {
        v8 = *(const char **)(v6 + 8);
        if ( v8 )
          v7 = j__atol(v8);
      }
      *a4 = 2 * v7 | 1;
    }
    result = 1;
  }
  else
  {
    sub_100110D0(a1, "unable to find priv pointer\n", v9);
    result = 0;
  }
  return result;
}

//----- (10050F10) --------------------------------------------------------
signed int __usercall sub_10050F10@<eax>(char a1@<bl>, int a2, int a3, int a4, _DWORD *a5)
{
  int v5; // esi@1
  signed int v7; // ebx@3
  unsigned int v8; // eax@6
  void *v9; // eax@6
  int v10; // esi@7
  char v11; // [sp-4h] [bp-Ch]@3
  char v12; // [sp+0h] [bp-8h]@0

  v5 = sub_10010550(a2, a3);
  if ( !v5 )
  {
    sub_100110D0(a2, "unable to find priv pointer\n", v12);
    return 0;
  }
  v11 = a1;
  v7 = 1;
  if ( a4 & 1 && !(a4 & 0xFFFFFFFE) )
  {
    if ( *a5 & 1 )
    {
      v8 = sub_100101C0(a2, *a5);
      v9 = sub_10010FF0(v8);
      if ( !v9 )
      {
        sub_100110D0(a2, "invalid colspan value\n", v11);
        _wassert(L"FALSE", L"..\\lib\\adl\\SCR\\SCR_obj_HTMLTableCellElement.c", 0x15Du);
      }
      sub_100A4370(v5, 11, v9);
      *(_BYTE *)(v5 + 1) |= 1u;
      v10 = *(_DWORD *)(v5 + 32);
      if ( v10 )
      {
        *(_DWORD *)(v10 + 12) |= 2u;
        return 1;
      }
    }
    else
    {
      v7 = 0;
      sub_100110D0(a2, "expected integer for selectedIndex\n", v11);
    }
  }
  return v7;
}
// 10050F10: could not find valid save-restore pair for ebx
// 100101C0: using guessed type _DWORD __cdecl sub_100101C0(_DWORD, _DWORD);

//----- (10050FD0) --------------------------------------------------------
signed int __cdecl sub_10050FD0(int a1, int a2, int a3)
{
  int v3; // esi@1
  signed int result; // eax@3

  v3 = sub_100105B0(**(_DWORD **)(a1 + 20), &off_101630F8, a2, 0);
  if ( v3 )
    sub_10010570(**(_DWORD **)(a1 + 20), v3, a3);
  result = sub_10011BE0(**(_DWORD **)(a1 + 20), v3, (const char **)&off_10163140);
  if ( result )
    result = v3;
  return result;
}
// 101630F8: using guessed type char *off_101630F8;
// 10163140: using guessed type char *off_10163140;

//----- (10051030) --------------------------------------------------------
int __usercall sub_10051030@<eax>(char a1@<sil>, int a2, int a3, int a4, signed int *a5, int *a6)
{
  int v6; // ebp@4
  unsigned int v7; // eax@4
  int v8; // esi@4
  signed int v9; // edi@7
  int result; // eax@8
  int v11; // ebx@9
  int v12; // eax@9
  int v13; // edx@11
  _DWORD *v14; // edi@11
  int v15; // ecx@11
  int v16; // edi@11
  int v17; // ebx@12
  int v18; // esi@14
  char v19; // [sp-Ch] [bp-10h]@4

  if ( a4 == 1 && *a5 & 1 && *a5 != -2147483647 )
  {
    v19 = a1;
    v6 = sub_100102E0(a2);
    v7 = sub_10010550(a2, a3);
    v8 = v7;
    if ( v6 && v7 && *(_DWORD *)(v7 + 32) == v6 )
    {
      v9 = *a5 >> 1;
      if ( v9 >= 0 )
      {
        v11 = sub_100A45C0(63, *(_DWORD *)(v7 + 28), v9);
        v12 = sub_100A4120(v6, v8, 1, 63, 0);
        if ( v12 )
        {
          if ( v11 )
          {
            v13 = *(_DWORD *)(v12 + 16);
            v14 = *(_DWORD **)(v12 + 20);
            v15 = v12 + 16;
            *(_DWORD *)(v13 + 4) = v14;
            *v14 = v13;
            *(_DWORD *)v15 = v15;
            *(_DWORD *)(v15 + 4) = v15;
            v16 = *(_DWORD *)(v11 + 16);
            *(_DWORD *)(v16 + 4) = v12 + 16;
            *(_DWORD *)v15 = v16;
            *(_DWORD *)(v15 + 4) = v11 + 16;
            *(_DWORD *)(v11 + 16) = v12 + 16;
          }
          v17 = sub_10012FC0(v6, v12);
          *a6 = v17;
        }
        else
        {
          v17 = 0;
          sub_100110D0(a2, "could not new table row at idx %i\n", v9);
        }
        *(_BYTE *)(v8 + 1) |= 1u;
        v18 = *(_DWORD *)(v8 + 32);
        if ( v18 )
          *(_DWORD *)(v18 + 12) |= 2u;
        result = v17 != 0;
      }
      else
      {
        sub_100110D0(a2, "invalid insertRow index\n", v19);
        result = 0;
      }
    }
    else
    {
      sub_100110D0(a2, "unable to find priv pointer\n", v19);
      result = 0;
    }
  }
  else
  {
    sub_100110D0(a2, "invalid args %i to insertRow\n", a4);
    result = 0;
  }
  return result;
}
// 10051030: could not find valid save-restore pair for esi

//----- (10051170) --------------------------------------------------------
int __cdecl sub_10051170(int a1, unsigned int a2)
{
  return sub_10053CF0(a2, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (10051190) --------------------------------------------------------
int *__cdecl sub_10051190(int a1, unsigned int a2)
{
  return sub_10053E10(a2, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100511B0) --------------------------------------------------------
int sub_100511B0()
{
  return sub_10053CF0(0x10u, dword_10658DEC);
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100511D0) --------------------------------------------------------
int *__cdecl sub_100511D0(int a1, unsigned int a2, int a3)
{
  int *result; // eax@2

  if ( a3 == 1 )
    result = sub_10053E10(a2, dword_10658DEC);
  return result;
}
// 10658DEC: using guessed type int dword_10658DEC;

//----- (100511F0) --------------------------------------------------------
int __cdecl sub_100511F0(unsigned int a1, int a2, int a3, int a4, int (__cdecl **a5)(int, int), int a6)
{
  int (__cdecl **v6)(int, int); // ebx@3
  int v7; // esi@5
  int result; // eax@5
  void *v9; // eax@6
  signed int v10; // [sp+4h] [bp+4h]@2

  if ( a1 > 0x10 )
  {
    v10 = sub_10052D80(a1);
    if ( v10 < 0 )
      return 0;
  }
  else
  {
    v10 = 4;
  }
  v6 = a5;
  if ( !a5 )
    v6 = off_10163158;
  v7 = (*v6)(a6, 32);
  result = 0;
  if ( v7 )
  {
    *(_DWORD *)v7 = 0;
    *(_DWORD *)(v7 + 4) = 0;
    *(_DWORD *)(v7 + 12) = 0;
    *(_DWORD *)(v7 + 16) = 0;
    *(_DWORD *)(v7 + 20) = 0;
    *(_DWORD *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 28) = 0;
    *(_DWORD *)(v7 + 8) = 32 - v10;
    v9 = (void *)(*v6)(a6, 4 * (1 << v10));
    *(_DWORD *)v7 = v9;
    if ( v9 )
    {
      memset(v9, 0, 4 * (1 << v10));
      *(_DWORD *)(v7 + 20) = a4;
      *(_DWORD *)(v7 + 12) = a2;
      *(_DWORD *)(v7 + 16) = a3;
      *(_DWORD *)(v7 + 24) = v6;
      *(_DWORD *)(v7 + 28) = a6;
      result = v7;
    }
    else
    {
      v6[1](a6, v7);
      result = 0;
    }
  }
  return result;
}
// 10163158: using guessed type int (__cdecl *off_10163158[3])(int, int);

//----- (100512D0) --------------------------------------------------------
int __cdecl sub_100512D0(int a1)
{
  _DWORD *v1; // ebp@1
  int v2; // ebx@1
  unsigned int v3; // edx@1
  unsigned int v4; // ecx@1
  int v5; // edi@1
  _DWORD **v6; // esi@2
  _DWORD *v7; // eax@2
  signed int v9; // [sp+Ch] [bp-4h]@1
  unsigned int v10; // [sp+14h] [bp+4h]@1

  v1 = (_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 28);
  v3 = 1 << (32 - *(_BYTE *)(a1 + 8));
  v4 = 0;
  v5 = *(_DWORD *)(a1 + 24);
  v9 = 1 << (32 - *(_BYTE *)(a1 + 8));
  v10 = 0;
  if ( v3 )
  {
    do
    {
      v6 = (_DWORD **)(*v1 + 4 * v4);
      v7 = *v6;
      if ( *v6 )
      {
        do
        {
          *v6 = (_DWORD *)*v7;
          (*(void (__cdecl **)(int, _DWORD *, signed int))(v5 + 12))(v2, v7, 1);
          v7 = *v6;
        }
        while ( *v6 );
        v3 = v9;
        v4 = v10;
      }
      v10 = ++v4;
    }
    while ( v4 < v3 );
  }
  (*(void (__cdecl **)(int, _DWORD))(v5 + 4))(v2, *v1);
  return (*(int (__cdecl **)(int, _DWORD *))(v5 + 4))(v2, v1);
}

//----- (10051360) --------------------------------------------------------
_DWORD *__cdecl sub_10051360(int a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  int v4; // esi@1
  _DWORD *v5; // edi@1
  _DWORD *v6; // ebx@1
  _DWORD *result; // eax@5

  v3 = (unsigned int)(-1640531527 * a2) >> *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 4 * v3);
  v5 = (_DWORD *)(*(_DWORD *)a1 + 4 * v3);
  v6 = (_DWORD *)(*(_DWORD *)a1 + 4 * v3);
  if ( v4 )
  {
    while ( *(_DWORD *)(v4 + 4) != a2 || !(*(int (__cdecl **)(int, _DWORD))(a1 + 16))(a3, *(_DWORD *)(v4 + 8)) )
    {
      v6 = (_DWORD *)v4;
      v4 = *(_DWORD *)v4;
      if ( !v4 )
        goto LABEL_5;
    }
    if ( v6 != v5 )
    {
      *v6 = *(_DWORD *)v4;
      *(_DWORD *)v4 = *v5;
      *v5 = v4;
    }
    result = v5;
  }
  else
  {
LABEL_5:
    result = v6;
  }
  return result;
}

//----- (100513D0) --------------------------------------------------------
int __cdecl sub_100513D0(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  int v5; // edi@1
  unsigned int v6; // ebp@1
  int v7; // ebx@2
  void *v8; // eax@2
  int result; // eax@4
  unsigned int v10; // eax@5
  int v11; // esi@6
  int v12; // ebx@7
  _DWORD *v13; // eax@7
  int v14; // ebx@10
  _DWORD *v15; // esi@10
  int v16; // [sp+10h] [bp-4h]@2
  unsigned int v17; // [sp+18h] [bp+4h]@5

  v5 = a1;
  v6 = 1 << (32 - *(_BYTE *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 4) < (1 << (32 - *(_BYTE *)(a1 + 8))) - ((unsigned int)(1 << (32 - *(_BYTE *)(a1 + 8))) >> 3) )
  {
    v15 = a2;
    v14 = a4;
  }
  else
  {
    v7 = *(_DWORD *)a1;
    v16 = *(_DWORD *)a1;
    v8 = (void *)(**(int (__cdecl ***)(_DWORD, _DWORD))(a1 + 24))(*(_DWORD *)(a1 + 28), 8 * v6);
    *(_DWORD *)a1 = v8;
    if ( !v8 )
    {
      *(_DWORD *)a1 = v7;
      return 0;
    }
    memset(v8, 0, 8 * v6);
    --*(_DWORD *)(a1 + 8);
    v10 = 0;
    v17 = 0;
    if ( v6 )
    {
      do
      {
        v11 = *(_DWORD *)(v7 + 4 * v10);
        if ( v11 )
        {
          do
          {
            v12 = *(_DWORD *)v11;
            v13 = sub_10051360(v5, *(_DWORD *)(v11 + 4), *(_DWORD *)(v11 + 8));
            *(_DWORD *)v11 = 0;
            *v13 = v11;
            v11 = v12;
          }
          while ( v12 );
          v7 = v16;
          v10 = v17;
        }
        v17 = ++v10;
      }
      while ( v10 < v6 );
    }
    (*(void (__cdecl **)(_DWORD, int))(*(_DWORD *)(v5 + 24) + 4))(*(_DWORD *)(v5 + 28), v7);
    v14 = a4;
    v15 = sub_10051360(v5, a3, a4);
  }
  result = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)(v5 + 24) + 8))(*(_DWORD *)(v5 + 28), v14);
  if ( !result )
    return 0;
  *(_DWORD *)(result + 8) = v14;
  *(_DWORD *)(result + 4) = a3;
  *(_DWORD *)(result + 12) = a5;
  *(_DWORD *)result = *v15;
  *v15 = result;
  ++*(_DWORD *)(v5 + 4);
  return result;
}

//----- (100514E0) --------------------------------------------------------
void *__cdecl sub_100514E0(int a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // ebp@1
  void *result; // eax@2
  int v5; // ebx@5
  unsigned int v6; // eax@7
  int v7; // esi@8
  int v8; // ebx@9
  _DWORD *v9; // eax@9
  int v10; // [sp+10h] [bp+8h]@5
  unsigned int v11; // [sp+14h] [bp+Ch]@7

  *a2 = *a3;
  (*(void (__cdecl **)(_DWORD, _DWORD *, signed int))(*(_DWORD *)(a1 + 24) + 12))(*(_DWORD *)(a1 + 28), a3, 1);
  v3 = 1 << (32 - *(_BYTE *)(a1 + 8));
  if ( v3 <= 0x10 )
    result = 0;
  else
    result = (void *)(v3 >> 2);
  if ( --*(_DWORD *)(a1 + 4) < (unsigned int)result )
  {
    v5 = *(_DWORD *)a1;
    v10 = *(_DWORD *)a1;
    result = (void *)(**(int (__cdecl ***)(_DWORD, _DWORD))(a1 + 24))(*(_DWORD *)(a1 + 28), 4 * v3 >> 1);
    *(_DWORD *)a1 = result;
    if ( result )
    {
      memset(result, 0, 4 * v3 >> 1);
      ++*(_DWORD *)(a1 + 8);
      v6 = 0;
      v11 = 0;
      if ( v3 )
      {
        do
        {
          v7 = *(_DWORD *)(v5 + 4 * v6);
          if ( v7 )
          {
            do
            {
              v8 = *(_DWORD *)v7;
              v9 = sub_10051360(a1, *(_DWORD *)(v7 + 4), *(_DWORD *)(v7 + 8));
              *(_DWORD *)v7 = 0;
              *v9 = v7;
              v7 = v8;
            }
            while ( v8 );
            v6 = v11;
            v5 = v10;
          }
          v11 = ++v6;
        }
        while ( v6 < v3 );
      }
      result = (void *)(*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)(a1 + 24) + 4))(*(_DWORD *)(a1 + 28), v5);
    }
    else
    {
      *(_DWORD *)a1 = v5;
    }
  }
  return result;
}

//----- (100515D0) --------------------------------------------------------
int __cdecl sub_100515D0(int a1, int (__cdecl *a2)(_DWORD *, int, int), int a3)
{
  int v3; // ecx@1
  unsigned int v4; // edx@1
  unsigned int v5; // eax@1
  int v6; // ebx@1
  _DWORD *v7; // esi@2
  _DWORD *v8; // edi@2
  char v9; // al@3
  _DWORD *v11; // [sp+4h] [bp-Ch]@1
  unsigned int v12; // [sp+8h] [bp-8h]@1
  unsigned int v13; // [sp+Ch] [bp-4h]@1

  v3 = 32 - *(_DWORD *)(a1 + 8);
  v4 = 1 << v3;
  v5 = 0;
  v6 = 0;
  v11 = 0;
  v13 = 1 << v3;
  v12 = 0;
  if ( 1 << v3 )
  {
    while ( 1 )
    {
      v7 = *(_DWORD **)(*(_DWORD *)a1 + 4 * v5);
      v8 = (_DWORD *)(*(_DWORD *)a1 + 4 * v5);
      if ( v7 )
        break;
LABEL_10:
      v12 = ++v5;
      if ( v5 >= v4 )
        goto LABEL_11;
    }
    while ( 1 )
    {
      v9 = a2(v7, v6++, a3);
      if ( v9 & 6 )
      {
        *v8 = *v7;
        if ( v9 & 2 )
        {
          *v7 = v11;
          v11 = v7;
        }
      }
      else
      {
        v8 = v7;
      }
      if ( v9 & 1 )
        break;
      v7 = (_DWORD *)*v8;
      if ( !*v8 )
      {
        v4 = v13;
        v5 = v12;
        goto LABEL_10;
      }
    }
  }
LABEL_11:
  while ( v11 )
    sub_100514E0(a1, &v11, v11);
  return v6;
}

//----- (10051690) --------------------------------------------------------
unsigned int __cdecl sub_10051690(_BYTE *a1)
{
  _BYTE *v1; // edx@1
  unsigned __int8 v2; // cl@1
  unsigned int result; // eax@1
  unsigned int v4; // esi@2
  int v5; // eax@2

  v1 = a1;
  v2 = *a1;
  for ( result = 0; v2; result = v4 ^ v5 )
  {
    v4 = 16 * result ^ (result >> 28);
    v5 = v2;
    v2 = (v1++)[1];
  }
  return result;
}

//----- (100516C0) --------------------------------------------------------
BOOL __cdecl sub_100516C0(int a1, int a2)
{
  return a1 == a2;
}

//----- (100516D0) --------------------------------------------------------
int __usercall sub_100516D0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int result; // eax@1
  int v4; // ecx@1

  result = *(_DWORD *)(a2 + 572);
  v4 = a2 + 572;
  if ( result == v4 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( *(_DWORD *)(result + 8) != a3 || *(_DWORD *)(result + 12) != a1 )
    {
      result = *(_DWORD *)result;
      if ( result == v4 )
        goto LABEL_5;
    }
  }
  return result;
}

//----- (10051700) --------------------------------------------------------
signed int __cdecl sub_10051700(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int result; // eax@2

  v3 = sub_100516D0(a3, *(_DWORD *)(a1 + 24), a2);
  if ( v3 )
    result = *(_DWORD *)(v3 + 16);
  else
    result = 154;
  return result;
}

//----- (10051730) --------------------------------------------------------
int *__usercall sub_10051730@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  **(_DWORD **)(a2 + 4) = *(_DWORD *)a2;
  *(_DWORD *)(*(_DWORD *)a2 + 4) = *(_DWORD *)(a2 + 4);
  **(_BYTE **)(a2 + 12) = *(_BYTE *)(a2 + 16);
  sub_1003A860(*(_DWORD *)(a1 + 24), a2 + 24);
  return sub_10010340(a1, a2);
}

//----- (10051760) --------------------------------------------------------
int *__cdecl sub_10051760(int a1, int *a2)
{
  int *result; // eax@1
  unsigned int v3; // esi@1
  int *v4; // ebp@1
  int v5; // ebx@2

  result = *(int **)(a1 + 24);
  v3 = result[143];
  v4 = result + 143;
  if ( (int *)v3 != result + 143 )
  {
    do
    {
      result = a2;
      v5 = *(_DWORD *)v3;
      if ( *(int **)(v3 + 8) == a2 )
        result = sub_10051730(a1, v3);
      v3 = v5;
    }
    while ( (int *)v5 != v4 );
  }
  return result;
}

//----- (100517A0) --------------------------------------------------------
int *__cdecl sub_100517A0(int a1)
{
  int *result; // eax@1
  int *v2; // esi@1
  int *v3; // ebp@1
  int v4; // ebx@2

  result = *(int **)(a1 + 24);
  v2 = (int *)result[143];
  v3 = result + 143;
  if ( v2 != result + 143 )
  {
    do
    {
      v4 = *v2;
      result = sub_10051730(a1, (unsigned int)v2);
      v2 = (int *)v4;
    }
    while ( (int *)v4 != v3 );
  }
  return result;
}

//----- (100517E0) --------------------------------------------------------
int __cdecl sub_100517E0(int a1, int a2, int a3, int *a4)
{
  int result; // eax@1
  int v5; // edx@1
  int v6; // ebx@2

  result = sub_100516D0(a3, *(_DWORD *)(a1 + 24), a2);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 16);
    result = (*(int (__cdecl **)(int, int, int, int *, _DWORD))(result + 20))(a1, a2, v5, a4, *(_DWORD *)(result + 24));
    if ( result == 1 )
      *a4 = 2 * v6 | 1;
  }
  return result;
}

//----- (10051830) --------------------------------------------------------
int __cdecl sub_10051830(int a1)
{
  int result; // eax@1

  for ( result = *(_DWORD *)(a1 + 580); result != a1 + 580; result = *(_DWORD *)result )
    *(_BYTE *)(*(_DWORD *)(result + 12) + 17) |= 1u;
  return result;
}

//----- (10051860) --------------------------------------------------------
int __usercall sub_10051860@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // edx@2

  result = *(_DWORD *)(a2 + 580);
  v4 = a2 + 580;
  if ( result == v4 )
  {
LABEL_6:
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 16);
    while ( *(_DWORD *)(result + 8) != v5 || **(_DWORD **)(result + 12) != a3 )
    {
      result = *(_DWORD *)result;
      if ( result == v4 )
        goto LABEL_6;
    }
  }
  return result;
}

//----- (10051890) --------------------------------------------------------
int __cdecl sub_10051890(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10051860(a2, a1, a3);
  if ( result )
    result = *(_DWORD *)(result + 12);
  return result;
}

//----- (100518B0) --------------------------------------------------------
int __cdecl sub_100518B0(int a1, int a2, int a3)
{
  int v3; // eax@1
  int result; // eax@6

  v3 = *(_DWORD *)(a1 + 580);
  if ( v3 == a1 + 580 )
  {
LABEL_6:
    result = 0;
  }
  else
  {
    while ( a2 && *(_DWORD *)(v3 + 8) != *(_DWORD *)(a2 + 16) || *(_DWORD *)(v3 + 12) != a3 )
    {
      v3 = *(_DWORD *)v3;
      if ( v3 == a1 + 580 )
        goto LABEL_6;
    }
    result = *(_DWORD *)(v3 + 16);
  }
  return result;
}

//----- (10051900) --------------------------------------------------------
int __cdecl sub_10051900(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@3

  v2 = a2;
  if ( !a2 )
    v2 = *(_DWORD *)(a1 + 56);
  result = *(_DWORD *)(v2 + 44);
  if ( result )
  {
    while ( !*(_DWORD *)(result + 12) )
    {
      result = *(_DWORD *)(result + 44);
      if ( !result )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (10051930) --------------------------------------------------------
int __cdecl sub_10051930(int a1, int a2)
{
  int v2; // esi@1
  int (__cdecl *v3)(int, unsigned int); // ecx@2
  int result; // eax@4
  int v5; // edx@5

  v2 = *(_DWORD *)(a2 + 16);
  if ( v2
    && (v3 = *(int (__cdecl **)(int, unsigned int))(a1 + 316)) != 0
    && *(_DWORD *)(v2 + 4) != (*(_DWORD *)(*(_DWORD *)(a2 + 28) - 8) & 0xFFFFFFF8) )
  {
    result = v3(a1, *(_DWORD *)(*(_DWORD *)(a2 + 28) - 8) & 0xFFFFFFF8);
  }
  else
  {
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 )
      result = *(_DWORD *)(v5 + 40);
    else
      result = 0;
  }
  return result;
}

//----- (10051980) --------------------------------------------------------
int __cdecl sub_10051980(int a1, int a2, int a3)
{
  int (__cdecl *v3)(int, unsigned int); // eax@1
  int result; // eax@2

  v3 = *(int (__cdecl **)(int, unsigned int))(a1 + 316);
  if ( v3 )
  {
    result = v3(a1, *(_DWORD *)(*(_DWORD *)(a2 + 28) - 8) & 0xFFFFFFF8);
  }
  else
  {
    result = a3;
    if ( a3 )
      result = sub_10051930(a1, a3);
  }
  return result;
}

//----- (100519C0) --------------------------------------------------------
_DWORD *__usercall sub_100519C0@<eax>(int a1@<ebx>, unsigned int a2@<esi>)
{
  bool v2; // zf@1
  _DWORD *result; // eax@2
  int v4; // edi@3

  v2 = (*(_DWORD *)(a2 + 28))-- == 1;
  if ( v2 )
  {
    **(_DWORD **)(a2 + 4) = *(_DWORD *)a2;
    *(_DWORD *)(*(_DWORD *)a2 + 4) = *(_DWORD *)(a2 + 4);
    v4 = *(_DWORD *)(a2 + 12);
    if ( sub_100518B0(*(_DWORD *)(a1 + 24), 0, *(_DWORD *)(a2 + 12))
      || (result = sub_10015C70(
                     a1,
                     *(_DWORD *)(a2 + 8),
                     v4,
                     0,
                     *(_BYTE *)(v4 + 16),
                     *(signed int (**)())(v4 + 4),
                     *(signed int (**)())(a2 + 16))) != 0 )
    {
      sub_1003A860(*(_DWORD *)(a1 + 24), a2 + 24);
      sub_10010340(a1, a2);
      result = (_DWORD *)1;
    }
  }
  else
  {
    result = (_DWORD *)1;
  }
  return result;
}

//----- (10051A40) --------------------------------------------------------
_DWORD *__cdecl sub_10051A40(int a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // eax@1
  unsigned int v6; // esi@1
  int v7; // ecx@1
  int v8; // ebp@2
  int v9; // eax@4
  int v11; // eax@11
  int v12; // ecx@15
  signed int v13; // ecx@16
  unsigned int v14; // edi@19
  int v15; // ecx@19
  int v16; // edx@19
  int v17; // eax@19
  int v18; // eax@22
  int (__cdecl *v19)(int, int); // ecx@22
  int v20; // [sp+10h] [bp-5Ch]@11
  char v21; // [sp+14h] [bp-58h]@19
  int v22; // [sp+20h] [bp-4Ch]@19
  unsigned int v23; // [sp+24h] [bp-48h]@19
  int v24; // [sp+40h] [bp-2Ch]@19

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 24);
  v6 = *(_DWORD *)(v5 + 580);
  v7 = v5 + 580;
  if ( v6 == v5 + 580 )
    return 0;
  while ( 1 )
  {
    v8 = *(_DWORD *)(v6 + 12);
    if ( *(_DWORD *)(v6 + 8) == a2 )
    {
      if ( *(_BYTE *)(v8 + 17) & 8 )
      {
        v9 = 2 * *(_WORD *)(v8 + 18) | 1;
      }
      else
      {
        v9 = *(_DWORD *)v8;
        if ( !(*(_DWORD *)v8 & 1) )
          v9 = *(_DWORD *)(v9 + 8);
      }
      if ( v9 == a3 )
        break;
    }
    v6 = *(_DWORD *)v6;
    if ( v6 == v7 )
      return 0;
  }
  if ( *(_BYTE *)(v8 + 17) & 8 )
  {
    v11 = 2 * *(_WORD *)(v8 + 18) | 1;
    v20 = 2 * *(_WORD *)(v8 + 18) | 1;
  }
  else
  {
    v11 = *(_DWORD *)v8;
    if ( !(*(_DWORD *)v8 & 1) )
      v11 = *(_DWORD *)(v11 + 8);
    v20 = v11;
  }
  v12 = *(_DWORD *)a2;
  ++*(_DWORD *)(v6 + 28);
  if ( *(_DWORD *)(v8 + 12) >= *(_DWORD *)(v12 + 12) )
    v13 = -2147483647;
  else
    v13 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * *(_DWORD *)(v8 + 12));
  if ( (*(int (__cdecl **)(int, int, int, signed int, int, _DWORD))(v6 + 20))(
         a1,
         a2,
         v11,
         v13,
         a4,
         *(_DWORD *)(v6 + 24)) )
  {
    v14 = sub_10010550(a1, *(_DWORD *)(v6 + 24));
    memset(&v21, 0, 0x58u);
    v15 = *(_DWORD *)(v14 + 12);
    v23 = v14;
    v4 = a1;
    v16 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 56) = &v21;
    v17 = *(_DWORD *)(v6 + 16);
    v22 = v15;
    v24 = v16;
    if ( v17 )
    {
      if ( *(_BYTE *)(v8 + 16) & 0x20 )
      {
        sub_100302A0(a1, a2, v17, 0, 1, a4, (_DWORD *)a4);
        *(_DWORD *)(a1 + 56) = v24;
        return sub_100519C0(a1, v6);
      }
      v18 = a2;
      v19 = *(int (__cdecl **)(int, int))(*(_DWORD *)(*(_DWORD *)a2 + 4) + 48);
      if ( v19 )
        v18 = v19(a1, a2);
      (*(void (__cdecl **)(int, int, int, int))(v6 + 16))(a1, v18, v20, a4);
    }
    *(_DWORD *)(a1 + 56) = v24;
  }
  return sub_100519C0(v4, v6);
}

//----- (10051BC0) --------------------------------------------------------
_DWORD *__cdecl sub_10051BC0(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int v5; // ST08_4@1

  v5 = *(_DWORD *)(*(_DWORD *)(sub_10010550(a1, *(a4 - 2) & 0xFFFFFFF8) + 24) + 8);
  *a5 = *a4;
  return sub_10051A40(a1, a2, v5, (int)a5);
}

//----- (10051C00) --------------------------------------------------------
_DWORD *(__cdecl *__cdecl sub_10051C00(int a1, signed int a2, char a3, int a4))(int a1, int a2, int a3, int a4)
{
  _DWORD *(__cdecl *result)(int, int, int, int); // eax@2
  int v5; // eax@3
  int v6; // eax@6

  if ( a3 & 0x20 )
  {
    v5 = a2;
    if ( (!(a2 & 1) || a2 == -2147483647 || (v5 = sub_100387A0(a1, a2 >> 1, 0)) != 0)
      && (v6 = sub_10028940(a1, 0, (int)sub_10051BC0, 1, 0, *(_DWORD *)(*(_DWORD *)(a4 + 4) + 4) & 0xFFFFFFF8, v5)) != 0 )
    {
      result = *(_DWORD *(__cdecl **)(int, int, int, int))(v6 + 4);
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = sub_10051A40;
  }
  return result;
}

//----- (10051C70) --------------------------------------------------------
_DWORD *__cdecl sub_10051C70(int a1, _DWORD *a2, signed int a3, int a4, int a5)
{
  int *v5; // ebx@1
  int (__cdecl **v6)(int, int, int, int, int); // eax@1
  _DWORD *result; // eax@4
  int v8; // esi@7
  int v9; // eax@8
  int v10; // eax@12
  _DWORD *v11; // edi@12
  int v12; // eax@16
  int v13; // ecx@17
  void (__cdecl *v14)(int, int, _DWORD *); // eax@21
  signed int (*v15)(); // esi@24
  unsigned int v16; // ecx@25
  int v17; // ecx@28
  void (__cdecl *v18)(int, int, _DWORD *); // ecx@29
  int v19; // esi@35
  signed int (*v20)(); // edi@36
  int v21; // eax@37
  int v22; // eax@41
  int v23; // eax@43
  void (__cdecl *v24)(int, int *, _DWORD *); // eax@43
  int v25; // [sp+4h] [bp-18h]@7
  int v26; // [sp+8h] [bp-14h]@10
  int v27; // [sp+Ch] [bp-10h]@20
  int v28; // [sp+10h] [bp-Ch]@24
  signed int (*v29)(); // [sp+14h] [bp-8h]@24
  int v30; // [sp+18h] [bp-4h]@12

  v5 = a2;
  v6 = *(int (__cdecl ***)(int, int, int, int, int))(*a2 + 4);
  if ( v6 != &off_101614B0 && (!v6 || *v6 != off_101614B0) )
  {
    sub_100110F0(a1, (int)sub_1003ED50, 0, 15, *(_DWORD *)(*(_DWORD *)(a2[1] + 8) & 0xFFFFFFFE));
    return 0;
  }
  if ( a3 & 1 && a3 != -2147483647 )
  {
    v8 = a3;
    v25 = a3;
  }
  else
  {
    v9 = sub_10038B20(a1, a3);
    if ( !v9 )
      return 0;
    v25 = v9;
    v8 = v9;
  }
  if ( !sub_10015D00(a1, (unsigned int)v5, v8, &v26, (unsigned int *)&a2) )
    return 0;
  v10 = *(_DWORD *)(a1 + 24);
  v11 = a2;
  v30 = *(_DWORD *)(a1 + 24);
  if ( a2 )
  {
    v12 = v26;
    if ( (int *)v26 == v5 )
      goto LABEL_34;
    v13 = *(_DWORD *)(*(_DWORD *)v26 + 4);
    if ( (int (__cdecl **)(int, int, int, int, int))v13 == &off_101614B0
      || v13 && *(int (__cdecl **)(int, int, int, int, int))v13 == off_101614B0 )
    {
      v16 = a2[3];
      if ( v16 >= *(_DWORD *)(*(_DWORD *)v26 + 12) )
        v27 = -2147483647;
      else
        v27 = *(_DWORD *)(*(_DWORD *)(v26 + 4) + 4 * v16);
      v17 = *((_BYTE *)a2 + 16);
      v15 = (signed int (*)())a2[1];
      v29 = (signed int (*)())a2[2];
      v28 = v17;
    }
    else
    {
      if ( !(*(int (__cdecl **)(int, int, signed int, int *))(v13 + 16))(a1, v26, a3, &v27) )
      {
        v14 = *(void (__cdecl **)(int, int, _DWORD *))(*(_DWORD *)(*(_DWORD *)v26 + 4) + 52);
        if ( v14 )
          v14(a1, v26, a2);
        return 0;
      }
      v11 = a2;
      v12 = v26;
      v15 = sub_100104C0;
      v29 = sub_100104C0;
      v28 = 1;
    }
    v18 = *(void (__cdecl **)(int, int, _DWORD *))(*(_DWORD *)(*(_DWORD *)v12 + 4) + 52);
    if ( v18 )
      v18(a1, v12, v11);
    if ( !sub_10018AC0(a1, (unsigned int)v5, v25, v27, v15, v29, v28, &a2) )
      return 0;
    v8 = v25;
LABEL_33:
    v11 = a2;
LABEL_34:
    if ( v11 )
      goto LABEL_35;
    return 0;
  }
  v11 = (_DWORD *)sub_10051890(v10, *v5, v8);
  a2 = v11;
  if ( !v11 )
  {
    if ( !sub_10018AC0(a1, (unsigned int)v5, v8, -2147483647, 0, 0, 1, &a2) )
      return 0;
    goto LABEL_33;
  }
LABEL_35:
  v19 = sub_10051860(*v5, v30, v8);
  if ( v19 )
    goto LABEL_48;
  v20 = (signed int (*)())sub_10051C00(a1, v25, *((_BYTE *)v11 + 16), v11[2]);
  if ( !v20 )
    return 0;
  v21 = sub_10011830(a1, 0x20u);
  v19 = v21;
  if ( !v21 )
    return 0;
  *(_DWORD *)(v21 + 20) = 0;
  *(_DWORD *)(v21 + 24) = 0;
  if ( !sub_1003AB10(a1, v21 + 24, (unsigned int)"wp->closure") )
  {
    sub_10010340(a1, v19);
    return 0;
  }
  v22 = v30;
  *(_DWORD *)v19 = v30 + 580;
  *(_DWORD *)(v19 + 4) = *(_DWORD *)(v22 + 584);
  **(_DWORD **)(v22 + 584) = v19;
  *(_DWORD *)(v22 + 584) = v19;
  *(_DWORD *)(v19 + 8) = v5;
  *(_DWORD *)(v19 + 12) = a2;
  *(_DWORD *)(v19 + 16) = a2[2];
  *(_DWORD *)(v19 + 28) = 1;
  a2 = sub_10015C70(a1, (unsigned int)v5, (int)a2, 0, *((_BYTE *)a2 + 16), (signed int (*)())a2[1], v20);
  if ( a2 )
  {
LABEL_48:
    v23 = a5;
    *(_DWORD *)(v19 + 20) = a4;
    *(_DWORD *)(v19 + 24) = v23;
    v24 = *(void (__cdecl **)(int, int *, _DWORD *))(*(_DWORD *)(*v5 + 4) + 52);
    if ( v24 )
      v24(a1, v5, a2);
    result = (_DWORD *)1;
  }
  else
  {
    result = sub_100519C0(a1, v19);
  }
  return result;
}
// 101614B0: using guessed type int (__cdecl *off_101614B0)(int, int, int, int, int);

//----- (10051F80) --------------------------------------------------------
_DWORD *__cdecl sub_10051F80(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int *v5; // edx@1
  unsigned int v6; // esi@1
  int v7; // ecx@3
  int v8; // eax@4
  _DWORD *result; // eax@13

  v5 = (unsigned int *)(*(_DWORD *)(a1 + 24) + 580);
  v6 = *v5;
  if ( (unsigned int *)*v5 == v5 )
  {
LABEL_9:
    if ( a4 )
      *a4 = 0;
    if ( a5 )
      *a5 = 0;
    result = (_DWORD *)1;
  }
  else
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(v6 + 8) == a2 )
      {
        v7 = *(_DWORD *)(v6 + 12);
        if ( *(_BYTE *)(v7 + 17) & 8 )
        {
          v8 = 2 * *(_WORD *)(v7 + 18) | 1;
        }
        else
        {
          v8 = *(_DWORD *)v7;
          if ( !(*(_DWORD *)v7 & 1) )
            v8 = *(_DWORD *)(v8 + 8);
        }
        if ( v8 == a3 )
          break;
      }
      v6 = *(_DWORD *)v6;
      if ( (unsigned int *)v6 == v5 )
        goto LABEL_9;
    }
    if ( a4 )
      *a4 = *(_DWORD *)(v6 + 20);
    if ( a5 )
      *a5 = *(_DWORD *)(v6 + 24);
    result = sub_100519C0(a1, v6);
  }
  return result;
}

//----- (10052020) --------------------------------------------------------
signed int __cdecl sub_10052020(int a1, int a2)
{
  unsigned int *v2; // ebp@1
  unsigned int v3; // esi@1
  unsigned int *v4; // edi@2
  signed int result; // eax@5

  v2 = (unsigned int *)(*(_DWORD *)(a1 + 24) + 580);
  v3 = *v2;
  if ( (unsigned int *)*v2 == v2 )
  {
LABEL_5:
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      v4 = *(unsigned int **)v3;
      if ( *(_DWORD *)(v3 + 8) == a2 && !sub_100519C0(a1, v3) )
        break;
      v3 = (unsigned int)v4;
      if ( v4 == v2 )
        goto LABEL_5;
    }
    result = 0;
  }
  return result;
}

//----- (10052070) --------------------------------------------------------
signed int __cdecl sub_10052070(int a1)
{
  _DWORD **v1; // ebp@1
  _DWORD *v2; // esi@1
  _DWORD *v3; // edi@2
  signed int result; // eax@4

  v1 = (_DWORD **)(*(_DWORD *)(a1 + 24) + 580);
  v2 = *v1;
  if ( *v1 == v1 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      v3 = (_DWORD *)*v2;
      if ( !sub_100519C0(a1, (unsigned int)v2) )
        break;
      v2 = v3;
      if ( v3 == v1 )
        goto LABEL_4;
    }
    result = 0;
  }
  return result;
}

//----- (100520B0) --------------------------------------------------------
#error "100520D1: call analysis failed (funcsize=24)"

//----- (10052100) --------------------------------------------------------
signed int __cdecl sub_10052100(int a1, _DWORD *a2)
{
  unsigned int v2; // ecx@2
  int v3; // eax@3
  unsigned int v4; // edi@4
  void *v5; // eax@4
  char v7; // [sp+0h] [bp-8h]@0

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)a1 != 1 || (unsigned int)(*(_DWORD *)(a1 + 36) + 4) <= *(_DWORD *)(a1 + 40) )
      goto LABEL_6;
    sub_100110F0(*(_DWORD *)(a1 + 8), (int)sub_1003ED50, 0, 63, v7);
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 40);
    if ( !v2 )
      goto LABEL_6;
    v3 = *(_DWORD *)(a1 + 36);
    if ( v3 + 4 <= v2 )
      goto LABEL_6;
    v4 = (unsigned int)(v3 + 8195) >> 13 << 13;
    v5 = sub_10011870(*(_DWORD *)(a1 + 8), *(void **)(a1 + 32), v4);
    if ( v5 )
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_DWORD *)(a1 + 40) = v4;
LABEL_6:
      *(_DWORD *)(*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36)) = *a2;
      *(_DWORD *)(a1 + 36) += 4;
      return 1;
    }
  }
  return 0;
}

//----- (10052190) --------------------------------------------------------
int __cdecl sub_10052190(int a1, void *a2, size_t a3)
{
  int result; // eax@3
  char v4; // [sp+0h] [bp-8h]@0

  if ( *(_DWORD *)a1 != 1 || a3 + *(_DWORD *)(a1 + 36) <= *(_DWORD *)(a1 + 40) )
  {
    memcpy(a2, (const void *)(*(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 32)), a3);
    *(_DWORD *)(a1 + 36) += a3;
    result = 1;
  }
  else
  {
    sub_100110F0(*(_DWORD *)(a1 + 8), (int)sub_1003ED50, 0, 63, v4);
    result = 0;
  }
  return result;
}

//----- (100521F0) --------------------------------------------------------
int __cdecl sub_100521F0(int a1, void *a2, size_t a3)
{
  size_t v3; // ecx@2
  size_t v4; // eax@3
  unsigned int v5; // edi@4
  void *v6; // eax@4
  char v8; // [sp+0h] [bp-Ch]@0

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)a1 != 1 || a3 + *(_DWORD *)(a1 + 36) <= *(_DWORD *)(a1 + 40) )
      goto LABEL_6;
    sub_100110F0(*(_DWORD *)(a1 + 8), (int)sub_1003ED50, 0, 63, v8);
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 40);
    if ( !v3 )
      goto LABEL_6;
    v4 = a3 + *(_DWORD *)(a1 + 36);
    if ( v4 <= v3 )
      goto LABEL_6;
    v5 = (v4 + 0x1FFF) >> 13 << 13;
    v6 = sub_10011870(*(_DWORD *)(a1 + 8), *(void **)(a1 + 32), (v4 + 0x1FFF) >> 13 << 13);
    if ( v6 )
    {
      *(_DWORD *)(a1 + 32) = v6;
      *(_DWORD *)(a1 + 40) = v5;
LABEL_6:
      memcpy((void *)(*(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 32)), a2, a3);
      *(_DWORD *)(a1 + 36) += a3;
      return 1;
    }
  }
  return 0;
}

//----- (10052290) --------------------------------------------------------
int __cdecl sub_10052290(int a1, int a2)
{
  unsigned int v2; // ecx@2
  unsigned int v3; // eax@3
  unsigned int v4; // edi@4
  void *v5; // eax@4
  int v6; // ecx@6
  int result; // eax@6
  char v8; // [sp+0h] [bp-Ch]@0

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)a1 != 1 || (unsigned int)(a2 + *(_DWORD *)(a1 + 36)) <= *(_DWORD *)(a1 + 40) )
      goto LABEL_6;
    sub_100110F0(*(_DWORD *)(a1 + 8), (int)sub_1003ED50, 0, 63, v8);
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 40);
    if ( !v2 )
      goto LABEL_6;
    v3 = a2 + *(_DWORD *)(a1 + 36);
    if ( v3 <= v2 )
      goto LABEL_6;
    v4 = (v3 + 0x1FFF) >> 13 << 13;
    v5 = sub_10011870(*(_DWORD *)(a1 + 8), *(void **)(a1 + 32), (v3 + 0x1FFF) >> 13 << 13);
    if ( v5 )
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_DWORD *)(a1 + 40) = v4;
LABEL_6:
      v6 = *(_DWORD *)(a1 + 36);
      result = v6 + *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 36) = a2 + v6;
      return result;
    }
  }
  return 0;
}

//----- (10052320) --------------------------------------------------------
signed int __cdecl sub_10052320(int a1, int a2, int a3)
{
  int v4; // eax@7
  unsigned int v5; // eax@10
  unsigned int v6; // ecx@17
  unsigned int v7; // edi@19
  void *v8; // eax@19
  unsigned int v9; // eax@29
  void *v10; // eax@31
  int v11; // [sp-10h] [bp-2Ch]@12
  char **(__cdecl *v12)(int, int, int); // [sp-Ch] [bp-28h]@12
  int v13; // [sp-4h] [bp-20h]@11
  char v14; // [sp+0h] [bp-1Ch]@0
  char v15; // [sp+Ch] [bp-10h]@4

  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 != 2 )
      {
        sub_10050B00((int)&v15, 12, "%d", a3);
        sub_100110F0(*(_DWORD *)(a1 + 8), (int)sub_1003ED50, 0, 67, (unsigned int)&v15);
        return 0;
      }
      if ( a2 >= 0 || !*(_DWORD *)a1 || (v4 = *(_DWORD *)(a1 + 40) + a2, v4 < 0) )
      {
        sub_100110F0(*(_DWORD *)(a1 + 8), (int)sub_1003ED50, 0, 66, v14);
        return 0;
      }
      *(_DWORD *)(a1 + 36) = v4;
      return 1;
    }
    v5 = a2 + *(_DWORD *)(a1 + 36);
    if ( (v5 & 0x80000000) != 0 )
    {
      v13 = 64;
LABEL_12:
      v12 = sub_1003ED50;
      v11 = *(_DWORD *)(a1 + 8);
LABEL_13:
      sub_100110F0(v11, (int)v12, 0, v13, v14);
      return 0;
    }
    if ( a2 > 0 )
    {
      if ( *(_DWORD *)a1 )
      {
        if ( *(_DWORD *)a1 == 1 && v5 > *(_DWORD *)(a1 + 40) )
        {
          v13 = 63;
          goto LABEL_12;
        }
      }
      else
      {
        v6 = *(_DWORD *)(a1 + 40);
        if ( v6 && v5 > v6 )
        {
          v7 = (v5 + 0x1FFF) >> 13 << 13;
          v8 = sub_10011870(*(_DWORD *)(a1 + 8), *(void **)(a1 + 32), v7);
          if ( !v8 )
            return 0;
          *(_DWORD *)(a1 + 32) = v8;
          *(_DWORD *)(a1 + 40) = v7;
        }
      }
    }
    *(_DWORD *)(a1 + 36) += a2;
  }
  else
  {
    if ( a2 < 0 )
    {
      v13 = 64;
      v12 = sub_1003ED50;
      v11 = *(_DWORD *)(a1 + 8);
      goto LABEL_13;
    }
    if ( *(_DWORD *)a1 )
    {
      if ( (unsigned int)a2 > *(_DWORD *)(a1 + 40) )
      {
        v13 = 65;
        v12 = sub_1003ED50;
        v11 = *(_DWORD *)(a1 + 8);
        goto LABEL_13;
      }
    }
    else if ( (unsigned int)a2 > *(_DWORD *)(a1 + 36) )
    {
      v9 = *(_DWORD *)(a1 + 40);
      if ( v9 )
      {
        if ( a2 > v9 )
        {
          v10 = sub_10011870(*(_DWORD *)(a1 + 8), *(void **)(a1 + 32), (unsigned int)(a2 + 0x1FFF) >> 13 << 13);
          if ( !v10 )
            return 0;
          *(_DWORD *)(a1 + 32) = v10;
          *(_DWORD *)(a1 + 40) = (unsigned int)(a2 + 0x1FFF) >> 13 << 13;
        }
      }
    }
    *(_DWORD *)(a1 + 36) = a2;
  }
  return 1;
}

//----- (100524F0) --------------------------------------------------------
int __cdecl sub_100524F0(int a1)
{
  return *(_DWORD *)(a1 + 36);
}

//----- (10052500) --------------------------------------------------------
int *__cdecl sub_10052500(int a1)
{
  return sub_10010340(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 32));
}

//----- (10052520) --------------------------------------------------------
int __cdecl sub_10052520(int a1, int *a2)
{
  int v2; // ecx@1
  int result; // eax@1
  int v4; // eax@2

  v2 = a1;
  result = 1;
  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)a1 == 1 )
      result = (**(int (***)(void))(a1 + 4))();
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 4);
    a1 = *a2;
    result = (*(int (__cdecl **)(int, int *))(v4 + 4))(v2, &a1);
  }
  return result;
}

//----- (10052560) --------------------------------------------------------
signed int __cdecl sub_10052560(int a1, int a2, int a3)
{
  int v4; // eax@5
  int v5; // edx@6
  int v6; // ecx@6

  if ( *(_DWORD *)a1 )
  {
    if ( !(*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 8))(a1, a2, a3) )
      return 0;
  }
  else if ( !(*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 12))(a1, a2, a3) )
  {
    return 0;
  }
  v4 = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 4) + 24))(a1) & 3;
  if ( v4 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    v6 = 4 - v4;
    if ( *(_DWORD *)a1 )
    {
      if ( !(*(int (__cdecl **)(int, int, signed int))(v5 + 20))(a1, v6, 1) )
        return 0;
    }
    else if ( !(*(int (__cdecl **)(int, void *, int))(v5 + 12))(a1, &unk_1057271C, v6) )
    {
      return 0;
    }
  }
  return 1;
}

//----- (100525F0) --------------------------------------------------------
signed int __cdecl sub_100525F0(char *a1, unsigned int *a2)
{
  char *v2; // esi@1
  unsigned int *v3; // edi@1
  char *v4; // eax@2
  char v5; // cl@3
  int v6; // eax@6
  signed int result; // eax@10

  v2 = a1;
  v3 = a2;
  if ( !*(_DWORD *)a1 )
  {
    v4 = (char *)*a2;
    do
      v5 = *v4++;
    while ( v5 );
    a1 = &v4[-*a2 - 1];
  }
  sub_10052520((int)v2, (int *)&a1);
  if ( *(_DWORD *)v2 == 1 )
  {
    v6 = sub_10011830(*((_DWORD *)v2 + 2), (unsigned int)(a1 + 1));
    *v3 = v6;
    if ( !v6 )
      return 0;
  }
  if ( !sub_10052560((int)v2, *v3, (int)a1) )
  {
    if ( *(_DWORD *)v2 == 1 )
      sub_10010340(*((_DWORD *)v2 + 2), *v3);
    return 0;
  }
  result = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 == 1 )
  {
    a1[*v3] = 0;
  }
  else
  {
    if ( result == 2 )
    {
      sub_10010340(*((_DWORD *)v2 + 2), *v3);
      *v3 = 0;
    }
    result = 1;
  }
  return result;
}

//----- (100526B0) --------------------------------------------------------
int __cdecl sub_100526B0(char *a1, unsigned int *a2)
{
  unsigned int *v2; // esi@1
  int result; // eax@1

  v2 = a2;
  a2 = (unsigned int *)(*a2 == 0);
  result = sub_10052520((int)a1, (int *)&a2);
  if ( result )
  {
    if ( a2 )
    {
      *v2 = 0;
      result = 1;
    }
    else
    {
      result = sub_100525F0(a1, v2);
    }
  }
  return result;
}

//----- (10052700) --------------------------------------------------------
int __cdecl sub_10052700(unsigned int a1, int *a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  int result; // eax@5
  unsigned int v5; // ebp@6
  int v6; // esi@7
  int v7; // ecx@9
  unsigned int v8; // eax@9
  int v9; // edx@10
  int v10; // edi@16
  int v11; // eax@18
  unsigned int v12; // edx@20
  char *v13; // ecx@21
  int v14; // esi@21
  unsigned int v15; // edi@27
  unsigned int v16; // edx@27
  char *v17; // ecx@28
  int v18; // eax@28
  int v19; // eax@30

  v2 = a1;
  if ( !*(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)*a2;
    if ( v3 & 0x40000000 )
      a1 = v3 & ((v3 & 0x80000000) != 0 ? 0x3FFFFFFF : 0x7FFF);
    else
      a1 = *(_DWORD *)*a2;
  }
  result = sub_10052520(v2, (int *)&a1);
  if ( result )
  {
    v5 = 2 * a1;
    if ( *(_DWORD *)v2 == 1 )
    {
      result = sub_10011830(*(_DWORD *)(v2 + 8), v5 + 2);
      v6 = result;
      if ( !result )
        return result;
    }
    else
    {
      v7 = *a2;
      v8 = *(_DWORD *)*a2;
      if ( v8 & 0x40000000 )
      {
        v9 = *(_DWORD *)(v7 + 4);
        if ( *(_DWORD *)v9 & 0x40000000 )
        {
          v6 = sub_1001A200(*a2);
        }
        else if ( (v8 & 0x80000000) == 0 )
        {
          v6 = *(_DWORD *)(v9 + 4) + 2 * ((v8 >> 15) & 0x7FFF);
        }
        else
        {
          v6 = *(_DWORD *)(v9 + 4);
        }
      }
      else
      {
        v6 = *(_DWORD *)(v7 + 4);
      }
    }
    v10 = v5 & 3;
    if ( v5 & 3 )
    {
      v10 = 4 - v10;
      v5 += v10;
    }
    v11 = (*(int (__cdecl **)(int, unsigned int))(*(_DWORD *)(v2 + 4) + 16))(v2, v5);
    if ( v11 )
    {
      if ( !*(_DWORD *)v2 )
      {
        v12 = 0;
        if ( a1 )
        {
          v13 = (char *)v11;
          v14 = v6 - v11;
          do
          {
            *(_WORD *)v13 = *(_WORD *)&v13[v14];
            ++v12;
            v13 += 2;
          }
          while ( v12 < a1 );
        }
        if ( v10 )
          memset((void *)(v5 + v11 - v10), 0, v10);
        return 1;
      }
      if ( *(_DWORD *)v2 != 1 )
        return 1;
      v15 = a1;
      v16 = 0;
      if ( a1 )
      {
        v17 = (char *)v6;
        v18 = v11 - v6;
        do
        {
          *(_WORD *)v17 = *(_WORD *)&v17[v18];
          v15 = a1;
          ++v16;
          v17 += 2;
        }
        while ( v16 < a1 );
      }
      *(_WORD *)(v6 + 2 * v15) = 0;
      v19 = sub_10010FD0(*(_DWORD *)(v2 + 8), v6, a1);
      *a2 = v19;
      if ( v19 )
        return 1;
    }
    if ( *(_DWORD *)v2 == 1 )
      sub_10010340(*(_DWORD *)(v2 + 8), v6);
    result = 0;
  }
  return result;
}

//----- (100528A0) --------------------------------------------------------
int __cdecl sub_100528A0(unsigned int a1, int *a2)
{
  int *v2; // esi@1
  int result; // eax@1

  v2 = a2;
  a2 = (int *)(*a2 == 0);
  result = sub_10052520(a1, (int *)&a2);
  if ( result )
  {
    if ( a2 )
    {
      *v2 = 0;
      result = 1;
    }
    else
    {
      result = sub_10052700(a1, v2);
    }
  }
  return result;
}

//----- (100528F0) --------------------------------------------------------
int __cdecl sub_100528F0(int a1, double **a2)
{
  double *v2; // eax@6
  int result; // eax@7
  double v4; // [sp+10h] [bp-8h]@2

  if ( !*(_DWORD *)a1 )
    v4 = **a2;
  result = 0;
  if ( sub_10052520(a1, (int *)&v4) )
  {
    if ( sub_10052520(a1, (int *)&v4 + 1) )
    {
      if ( *(_DWORD *)a1 != 1 || (v2 = sub_10010360(*(_DWORD *)(a1 + 8), v4), (*a2 = v2) != 0) )
        result = 1;
    }
  }
  return result;
}

//----- (10052970) --------------------------------------------------------
signed int __cdecl sub_10052970(_DWORD *a1, signed int *a2)
{
  _DWORD *v2; // esi@1
  signed int *v3; // edi@1
  signed int result; // eax@8
  unsigned int v5; // [sp+8h] [bp-4h]@13

  v2 = a1;
  v3 = a2;
  if ( !*a1 )
  {
    if ( *a2 )
    {
      if ( *a2 == -2147483647 )
        a1 = (_DWORD *)10;
      else
        a1 = (_DWORD *)(*a2 & 7);
    }
    else
    {
      a1 = (_DWORD *)8;
    }
  }
  if ( sub_10052520((int)v2, (int *)&a1) )
  {
    switch ( a1 )
    {
      case 8u:
        *v3 = 0;
        result = 1;
        break;
      case 0xAu:
        *v3 = -2147483647;
        result = 1;
        break;
      case 4u:
        if ( !*v2 )
          v5 = *v3 & 0xFFFFFFF8;
        if ( !sub_10052700((unsigned int)v2, (int *)&v5) )
          goto LABEL_8;
        if ( *v2 != 1 )
          goto LABEL_37;
        *v3 = v5 | 4;
        result = 1;
        break;
      case 2u:
        if ( !*v2 )
          v5 = *v3 & 0xFFFFFFF8;
        if ( !sub_100528F0((int)v2, (double **)&v5) )
          goto LABEL_8;
        if ( *v2 != 1 )
          goto LABEL_37;
        *v3 = v5 | 2;
        result = 1;
        break;
      case 0u:
        if ( !*v2 )
          v5 = *v3 & 0xFFFFFFF8;
        if ( !sub_100183B0((int)v2, (int)&v5) )
          goto LABEL_8;
        if ( *v2 != 1 )
          goto LABEL_37;
        *v3 = v5;
        result = 1;
        break;
      case 6u:
        if ( !*v2 )
          v5 = *v3 >> 3;
        if ( !sub_10052520((int)v2, (int *)&v5) )
          goto LABEL_8;
        if ( *v2 != 1 )
          goto LABEL_37;
        *v3 = 8 * v5 | 6;
        result = 1;
        break;
      default:
        if ( !*v2 )
          v5 = *v3 >> 1;
        if ( !sub_10052520((int)v2, (int *)&v5) )
          goto LABEL_8;
        if ( *v2 == 1 )
          *v3 = 2 * v5 | 1;
LABEL_37:
        result = 1;
        break;
    }
  }
  else
  {
LABEL_8:
    result = 0;
  }
  return result;
}

//----- (10052B60) --------------------------------------------------------
signed int __cdecl sub_10052B60(int a1, int *a2, _DWORD *a3)
{
  unsigned int v3; // ebx@1
  int v4; // edi@1
  int v5; // edi@3
  _DWORD *v6; // eax@5
  int v7; // eax@8
  unsigned int *v8; // eax@9

  v3 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 20);
  if ( v3 == v4 )
  {
    if ( v4 )
      v5 = 2 * v4;
    else
      v5 = 8;
    v6 = sub_10011870(*(_DWORD *)(a1 + 8), *(void **)(a1 + 12), 4 * v5);
    if ( !v6 )
      return 0;
    *(_DWORD *)(a1 + 12) = v6;
    *(_DWORD *)(a1 + 20) = v5;
  }
  else
  {
    v6 = *(_DWORD **)(a1 + 12);
  }
  v6[v3] = a2;
  v7 = *(_DWORD *)(a1 + 24);
  if ( v7 )
  {
    v8 = sub_1003F720(v7, *a2, 1);
    if ( !v8 )
    {
      sub_10011170(*(_DWORD *)(a1 + 8));
      return 0;
    }
    v8[1] = *a2;
    v8[2] = v3;
  }
  *a3 = v3 + 1;
  *(_DWORD *)(a1 + 16) = v3 + 1;
  return 1;
}

//----- (10052C00) --------------------------------------------------------
unsigned int __cdecl sub_10052C00(int a1, const char *a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // ST0C_4@3
  int (__cdecl **v4)(int, int); // eax@3
  int v5; // eax@3
  unsigned int v6; // esi@4
  int *v7; // edi@5
  unsigned int *v8; // eax@5
  int v9; // ecx@5
  int v10; // eax@6
  unsigned int *v11; // eax@7
  unsigned int result; // eax@8
  unsigned int v13; // esi@9
  const char ***v14; // ebx@10

  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 < 0xA )
    goto LABEL_17;
  if ( !*(_DWORD *)(a1 + 24) )
  {
    v3 = *(_DWORD *)(a1 + 16);
    v4 = sub_1003F250();
    v5 = sub_1003F6B0(v4, 0, 12, v3);
    *(_DWORD *)(a1 + 24) = v5;
    if ( v5 )
    {
      v6 = 0;
      if ( v2 )
      {
        do
        {
          v7 = *(int **)(*(_DWORD *)(a1 + 12) + 4 * v6);
          v8 = sub_1003F720(*(_DWORD *)(a1 + 24), *v7, 1);
          v9 = *v7;
          v8[2] = v6++;
          v8[1] = v9;
        }
        while ( v6 < v2 );
      }
    }
  }
  v10 = *(_DWORD *)(a1 + 24);
  if ( v10 && (v11 = sub_1003F720(v10, (int)a2, 0), *v11) )
  {
    result = v11[2] + 1;
  }
  else
  {
LABEL_17:
    v13 = 0;
    if ( v2 )
    {
      v14 = *(const char ****)(a1 + 12);
      while ( strcmp(a2, **v14) )
      {
        ++v13;
        ++v14;
        if ( v13 >= v2 )
          goto LABEL_13;
      }
      result = v13 + 1;
    }
    else
    {
LABEL_13:
      result = 0;
    }
  }
  return result;
}

//----- (10052CE0) --------------------------------------------------------
int __cdecl sub_10052CE0(int a1, int a2)
{
  int result; // eax@2

  if ( (unsigned int)(a2 - 1) < *(_DWORD *)(a1 + 16) )
    result = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (a2 - 1));
  else
    result = 0;
  return result;
}

//----- (10052D00) --------------------------------------------------------
int __cdecl sub_10052D00(int a1, _BYTE *a2)
{
  _BYTE *v2; // esi@1
  int result; // eax@1

  v2 = a2;
  a2 = (_BYTE *)*a2;
  result = sub_10052520(a1, (int *)&a2);
  if ( result )
  {
    *v2 = (_BYTE)a2;
    result = 1;
  }
  return result;
}

//----- (10052D40) --------------------------------------------------------
int __cdecl sub_10052D40(int a1, _WORD *a2)
{
  _WORD *v2; // esi@1
  int result; // eax@1

  v2 = a2;
  a2 = (_WORD *)*a2;
  result = sub_10052520(a1, (int *)&a2);
  if ( result )
  {
    *v2 = (_WORD)a2;
    result = 1;
  }
  return result;
}

//----- (10052D80) --------------------------------------------------------
signed int __cdecl sub_10052D80(unsigned int a1)
{
  unsigned int v1; // ecx@1
  signed int result; // eax@1

  v1 = a1;
  result = 0;
  if ( (a1 - 1) & a1 )
    result = 1;
  if ( a1 >> 16 )
  {
    result += 16;
    v1 = a1 >> 16;
  }
  if ( v1 >> 8 )
  {
    result += 8;
    v1 >>= 8;
  }
  if ( v1 >> 4 )
  {
    result += 4;
    v1 >>= 4;
  }
  if ( v1 >> 2 )
  {
    result += 2;
    v1 >>= 2;
  }
  if ( v1 & 0xFFFFFFFE )
    ++result;
  return result;
}

//----- (10052DD0) --------------------------------------------------------
void __cdecl sub_10052DD0(double a1, double a2)
{
  sub_10052E40(a1, a2);
}

//----- (10052DF0) --------------------------------------------------------
double __cdecl sub_10052DF0(double a1, double a2)
{
  HIDWORD(a1) = HIDWORD(a2) ^ (HIDWORD(a1) ^ HIDWORD(a2)) & 0x7FFFFFFF;
  return a1;
}

//----- (10052E20) --------------------------------------------------------
void __cdecl sub_10052E20(double a1, double a2)
{
  sub_100530E0(a1, a2);
}

//----- (10052E40) --------------------------------------------------------
double __cdecl sub_10052E40(double a1, double a2)
{
  double v2; // st7@1
  int v3; // edx@1
  int v4; // eax@1
  double result; // st7@4
  int v6; // esi@5
  double v7; // st7@11
  int v8; // eax@25
  double v9; // st7@30
  int v10; // esi@32
  double v11; // st7@33
  double v12; // [sp+18h] [bp-8h]@1
  double v13; // [sp+2Ch] [bp+Ch]@1
  double v14; // [sp+2Ch] [bp+Ch]@36

  v2 = a2;
  v12 = a2;
  v13 = a1;
  v3 = HIDWORD(v12) & 0x7FFFFFFF;
  v4 = HIDWORD(v13) & 0x7FFFFFFF;
  if ( (HIDWORD(v12) & 0x7FFFFFFF | ((LODWORD(v12) | (unsigned int)-LODWORD(v12)) >> 31)) > 0x7FF00000
    || (v4 | ((LODWORD(v13) | (unsigned int)-LODWORD(v13)) >> 31)) > 0x7FF00000 )
  {
    result = v2 + a1;
  }
  else if ( LODWORD(v12) | (HIDWORD(v12) - 1072693248) )
  {
    v6 = (SHIDWORD(v12) >> 30) & 2 | (SHIDWORD(v13) >> 31) & 1;
    if ( v4 | LODWORD(v13) )
    {
      if ( !(v3 | LODWORD(v12)) )
        goto LABEL_40;
LABEL_10:
      if ( v3 == 2146435072 )
      {
        if ( v4 == 2146435072 )
        {
          switch ( v6 )
          {
            case 0:
              v7 = dbl_10163190;
              goto LABEL_17;
            case 1:
              return -dbl_10163190 - dbl_10163188;
            case 2:
              return dbl_10163190 * 3.0 + dbl_10163188;
            case 3:
              return dbl_10163190 * -3.0 - dbl_10163188;
            default:
              break;
          }
        }
        else
        {
          switch ( v6 )
          {
            case 2:
              goto LABEL_8;
            case 3:
              goto LABEL_9;
            case 0:
              return dbl_10572720;
            case 1:
              return -dbl_10572720;
            default:
              break;
          }
        }
      }
      if ( v4 != 2146435072 )
      {
        v8 = (v4 - v3) >> 20;
        if ( v8 <= 60 )
        {
          if ( SHIDWORD(v12) >= 0 || v8 >= -60 )
          {
            v9 = sub_100537F0(a1 / v2);
            result = sub_10053810(v9);
          }
          else
          {
            result = 0.0;
          }
        }
        else
        {
          result = dbl_101631A8 * 0.5 + dbl_10163198;
        }
        if ( v6 )
        {
          v10 = v6 - 1;
          if ( v10 )
          {
            v11 = result - dbl_101631A8;
            if ( v10 == 1 )
              result = dbl_101631A0 - v11;
            else
              result = v11 - dbl_101631A0;
          }
          else
          {
            v14 = result;
            HIDWORD(v14) ^= 0x80000000;
            result = v14;
          }
        }
      }
      else
      {
LABEL_40:
        v7 = dbl_10163198;
        if ( SHIDWORD(v13) >= 0 )
LABEL_17:
          result = v7 + dbl_10163188;
        else
          result = -dbl_10163198 - dbl_10163188;
      }
    }
    else
    {
      switch ( v6 )
      {
        case 0:
        case 1:
          result = a1;
          break;
        case 2:
LABEL_8:
          result = dbl_10163188 + dbl_101631A0;
          break;
        case 3:
LABEL_9:
          result = -dbl_101631A0 - dbl_10163188;
          break;
        default:
          goto LABEL_10;
      }
    }
  }
  else
  {
    result = sub_10053810(a1);
  }
  return result;
}
// 10163188: using guessed type double dbl_10163188;
// 10163190: using guessed type double dbl_10163190;
// 10163198: using guessed type double dbl_10163198;
// 101631A0: using guessed type double dbl_101631A0;
// 101631A8: using guessed type double dbl_101631A8;
// 10572720: using guessed type double dbl_10572720;

//----- (100530E0) --------------------------------------------------------
double __cdecl sub_100530E0(double a1, double a2)
{
  double result; // st7@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@9
  int v6; // eax@13
  int v7; // eax@14
  int v8; // eax@17
  int v9; // eax@45
  double v10; // st6@49
  double v11; // st7@50
  double v12; // st5@62
  double v13; // st6@62
  double v14; // ST3C_8@62
  double v15; // st4@62
  double v16; // st6@62
  double v17; // st5@62
  signed int v18; // eax@63
  double v19; // st6@64
  double v20; // ST3C_8@64
  double v21; // rtt@64
  int v22; // eax@65
  int v23; // esi@65
  int v24; // eax@65
  signed int v25; // ecx@66
  double v26; // ST3C_8@70
  double v27; // st5@70
  double v28; // st7@70
  double v29; // st6@70
  double v30; // ST3C_8@70
  double v31; // st3@70
  double v32; // ST3C_8@70
  double v33; // rt0@70
  double v34; // rt1@70
  double v35; // st6@70
  double v36; // st4@70
  double v37; // ST3C_8@70
  double v38; // st7@70
  double v39; // st6@70
  double v40; // ST3C_8@70
  double *v41; // eax@70
  double v42; // st5@70
  double v43; // st7@70
  double v44; // st6@70
  double v45; // st5@70
  double v46; // ST3C_8@70
  double v47; // st4@70
  double v48; // st5@70
  double v49; // st4@71
  double v50; // ST44_8@73
  double v51; // st3@73
  double v52; // st6@73
  double v53; // st5@73
  double v54; // st3@73
  int v55; // edx@73
  int v56; // esi@73
  int v57; // ecx@83
  int v58; // eax@83
  int v59; // eax@84
  int v60; // edx@84
  int v61; // ebx@84
  double v62; // ST3C_8@87
  double v63; // st3@87
  double v64; // st5@87
  double v65; // st6@87
  double v66; // rtt@87
  double v67; // st3@87
  double v68; // rt1@87
  double v69; // st4@87
  double v70; // st5@87
  double v71; // st7@87
  double v72; // st6@87
  double v73; // ST3C_8@87
  double v74; // ST3C_8@89
  signed int v75; // [sp+30h] [bp-1Ch]@65
  int v76; // [sp+34h] [bp-18h]@45
  double v77; // [sp+34h] [bp-18h]@71
  double v78; // [sp+3Ch] [bp-10h]@1
  double v79; // [sp+3Ch] [bp-10h]@73
  double v80; // [sp+3Ch] [bp-10h]@84
  double v81; // [sp+44h] [bp-8h]@1

  result = a1;
  v78 = a1;
  v81 = a2;
  v3 = HIDWORD(v81) & 0x7FFFFFFF;
  v4 = HIDWORD(v78) & 0x7FFFFFFF;
  if ( !(LODWORD(v81) | ((*(_QWORD *)&a2 & 0x7FFFFFFFFFFFFFFFui64) >> 32)) )
    return dbl_101631E0;
  if ( v4 > 2146435072 || v4 == 2146435072 && LODWORD(v78) || v3 > 2146435072 || v3 == 2146435072 && LODWORD(a2) )
    return a1 + a2;
  v5 = 0;
  if ( SHIDWORD(v78) >= 0 )
    goto LABEL_20;
  if ( v3 >= 1128267776 )
  {
    v5 = 2;
    goto LABEL_20;
  }
  if ( v3 < 1072693248 )
  {
LABEL_20:
    if ( LODWORD(a2) )
      goto LABEL_35;
    goto LABEL_21;
  }
  v6 = (v3 >> 20) - 1023;
  if ( v6 > 20 )
  {
    v7 = LODWORD(a2) >> (52 - ((v3 >> 20) + 1));
    if ( v7 << (52 - ((v3 >> 20) + 1)) == LODWORD(a2) )
      v5 = 2 - ((LODWORD(a2) >> (52 - ((v3 >> 20) + 1))) & 1);
    else
      v5 = 0;
    goto LABEL_20;
  }
  if ( LODWORD(a2) )
    goto LABEL_35;
  v8 = v3 >> (20 - ((v3 >> 20) + 1));
  if ( v8 << (20 - ((v3 >> 20) + 1)) == v3 )
    v5 = 2 - ((v3 >> (20 - ((v3 >> 20) + 1))) & 1);
LABEL_21:
  if ( v3 == 2146435072 )
  {
    result = a2;
    if ( LODWORD(v78) | (v4 - 1072693248) )
    {
      if ( v4 >= 1072693248 )
      {
        if ( SHIDWORD(v81) >= 0 )
          return result;
        return dbl_10572728;
      }
      if ( SHIDWORD(v81) >= 0 )
        return dbl_10572728;
      return -a2;
    }
    return result / result;
  }
  if ( v3 == 1072693248 )
  {
    if ( SHIDWORD(v81) < 0 )
      result = dbl_101631E0 / a1;
    return result;
  }
  if ( HIDWORD(v81) == 0x40000000 )
    return result * result;
  if ( HIDWORD(v81) == 1071644672 && SHIDWORD(v78) >= 0 )
  {
    sub_10053AC0(a1);
    return result;
  }
LABEL_35:
  result = sub_100537F0(a1);
  if ( !LODWORD(v78) && (v4 == 2146435072 || !v4 || v4 == 1072693248) )
  {
    if ( SHIDWORD(v81) < 0 )
      result = dbl_101631E0 / result;
    if ( SHIDWORD(v78) >= 0 )
      return result;
    if ( v5 | (v4 - 1072693248) )
    {
      if ( v5 == 1 )
        result = -result;
      return result;
    }
    goto LABEL_47;
  }
  v9 = (SHIDWORD(v78) >> 31) + 1;
  v76 = (SHIDWORD(v78) >> 31) + 1;
  if ( !(v5 | v9) )
  {
    result = a1;
LABEL_47:
    result = result - result;
    return result / result;
  }
  v10 = dbl_101631E0;
  if ( v3 <= 1105199104 )
  {
    v18 = 0;
    if ( v4 < 0x100000 )
    {
      v18 = -53;
      v19 = result * dbl_101631F0;
      v20 = v19;
      v4 = HIDWORD(v20);
      v21 = v19;
      v10 = dbl_101631E0;
      result = v21;
    }
    v22 = v18 + (v4 >> 20) - 1023;
    v23 = v4 & 0xFFFFF;
    v75 = v22;
    v24 = v23 | 0x3FF00000;
    if ( v23 > 235662 )
    {
      if ( v23 >= 767610 )
      {
        ++v75;
        v25 = 0;
        v24 -= 0x100000;
      }
      else
      {
        v25 = 1;
      }
    }
    else
    {
      v25 = 0;
    }
    v26 = result;
    HIDWORD(v26) = v24;
    v27 = v26;
    v28 = v26 - dbl_101631B0[v25];
    v29 = v10 / (v26 + dbl_101631B0[v25]);
    v30 = v29 * v28;
    LODWORD(v30) = 0;
    v31 = v30;
    v32 = dbl_10572728;
    HIDWORD(v32) = ((v25 + 2) << 18) + ((v24 | 0x40000000) >> 1);
    v33 = v31;
    v34 = v29 * v28;
    v35 = v29 * (v28 - v31 * v32 - (v27 - (v32 - dbl_101631B0[v25])) * v31);
    v36 = v34
        * v34
        * (v34
         * v34)
        * (((((dbl_10163230 * (v34 * v34) + dbl_10163228) * (v34 * v34) + dbl_10163220) * (v34 * v34) + dbl_10163218)
          * (v34
           * v34)
          + dbl_10163210)
         * (v34
          * v34)
         + dbl_10163208)
        + (v31 + v34) * v35;
    v37 = v33 * v33 + 3.0 + v36;
    LODWORD(v37) = 0;
    v38 = v31 * v37;
    v39 = v35 * v37 + v34 * (v36 - (v37 - 3.0 - v33 * v33));
    v40 = v39 + v31 * v37;
    LODWORD(v40) = 0;
    v41 = (double *)((char *)&unk_101631C0 + 8 * v25);
    v42 = v39 - (v40 - v38);
    v43 = dbl_10163288 * v40;
    v44 = v40 * dbl_10163290 + v42 * dbl_10163280 + dbl_101631D0[v25];
    v45 = (double)v75;
    v46 = v44 + v43 + *v41 + v45;
    LODWORD(v46) = 0;
    v47 = v46 - v45 - *v41;
    v9 = v76;
    v48 = v44;
    v16 = v46;
    v17 = v48 - (v47 - v43);
    v11 = dbl_101631E0;
  }
  else
  {
    v11 = dbl_101631E0;
    if ( v3 > 1139802112 )
    {
      if ( v4 <= 1072693247 )
      {
        if ( SHIDWORD(v81) >= 0 )
        {
LABEL_53:
          result = dbl_10163200;
          return result * result;
        }
        return dbl_101631F8 * dbl_101631F8;
      }
      if ( v4 >= 1072693248 )
        goto LABEL_93;
    }
    if ( v4 < 1072693247 )
    {
      if ( SHIDWORD(v81) < 0 )
        return dbl_101631F8 * dbl_101631F8;
      goto LABEL_53;
    }
    if ( v4 > 1072693248 )
    {
LABEL_93:
      if ( SHIDWORD(v81) <= 0 )
        goto LABEL_53;
      return dbl_101631F8 * dbl_101631F8;
    }
    v12 = dbl_101632A0 * (a1 - 1.0);
    v13 = dbl_101632A8 * (a1 - 1.0)
        - (a1 - 1.0) * (a1 - 1.0) * (0.5 - (0.3333333333333333 - (a1 - 1.0) * 0.25) * (a1 - 1.0)) * dbl_10163298;
    v14 = v13 + v12;
    LODWORD(v14) = 0;
    v15 = v13;
    v16 = v14;
    v17 = v15 - (v14 - v12);
  }
  v49 = v11;
  v77 = v11;
  if ( !(v9 | (v5 - 1)) )
  {
    v49 = -v11;
    v77 = -v11;
  }
  v50 = a2;
  LODWORD(v50) = 0;
  v51 = v16;
  v52 = a2 * v17 + (a2 - v50) * v16;
  v53 = v50 * v51;
  v54 = v52 + v50 * v51;
  v79 = v54;
  v55 = HIDWORD(v79);
  v56 = HIDWORD(v79);
  if ( SHIDWORD(v79) < 1083179008 )
  {
    if ( (HIDWORD(v79) & 0x7FFFFFFF) >= 1083231232 )
    {
      if ( LODWORD(v79) | (HIDWORD(v79) + 1064252416) )
        return v49 * dbl_10163200 * dbl_10163200;
      if ( v54 - v53 >= v52 )
        return v49 * dbl_10163200 * dbl_10163200;
    }
  }
  else
  {
    if ( LODWORD(v79) | (HIDWORD(v79) - 1083179008) )
      return v49 * dbl_101631F8 * dbl_101631F8;
    if ( v54 - v53 < v52 + dbl_10163278 )
      return v49 * dbl_101631F8 * dbl_101631F8;
  }
  v57 = HIDWORD(v79) & 0x7FFFFFFF;
  v58 = 0;
  if ( (HIDWORD(v79) & 0x7FFFFFFF) > 1071644672 )
  {
    v80 = dbl_10572728;
    v59 = v55 + (0x100000 >> ((v57 >> 20) + 2));
    v60 = (((v55 + (0x100000 >> ((v57 >> 20) + 2))) >> 20) & 0x7FF) - 1023;
    v61 = v59 & ~(0xFFFFF >> v60);
    v58 = (v59 & 0xFFFFF | 0x100000) >> (20 - v60);
    HIDWORD(v80) = v61;
    if ( v56 < 0 )
      v58 = -v58;
    v53 = v53 - v80;
  }
  v62 = v52 + v53;
  LODWORD(v62) = 0;
  v63 = v52 - (v62 - v53);
  v64 = dbl_10163268 * v62;
  v65 = v62 * dbl_10163270 + v63 * dbl_10163260;
  v66 = v65 + v64;
  v67 = v66
      - v66
      * v66
      * ((((dbl_10163258 * (v66 * v66) + dbl_10163250) * (v66 * v66) + dbl_10163248) * (v66 * v66) + dbl_10163240)
       * (v66
        * v66)
       + dbl_10163238);
  v68 = v49;
  v69 = v67 * v66 / (v67 - dbl_101631E8) - (v65 - (v66 - v64) + (v65 - (v66 - v64)) * v66);
  v70 = v11;
  v71 = v68;
  v72 = v70 - (v69 - v66);
  v73 = v72;
  if ( (signed int)(((v58 << 20) + HIDWORD(v73)) & 0xFFF00000) > 0 )
  {
    v74 = v72;
    HIDWORD(v74) += v58 << 20;
    result = v74 * v71;
  }
  else
  {
    result = sub_100539B0(v72, v58) * v77;
  }
  return result;
}
// 101631B0: using guessed type double dbl_101631B0[];
// 101631D0: using guessed type double dbl_101631D0[];
// 101631E0: using guessed type double dbl_101631E0;
// 101631E8: using guessed type double dbl_101631E8;
// 101631F0: using guessed type double dbl_101631F0;
// 101631F8: using guessed type double dbl_101631F8;
// 10163200: using guessed type double dbl_10163200;
// 10163208: using guessed type double dbl_10163208;
// 10163210: using guessed type double dbl_10163210;
// 10163218: using guessed type double dbl_10163218;
// 10163220: using guessed type double dbl_10163220;
// 10163228: using guessed type double dbl_10163228;
// 10163230: using guessed type double dbl_10163230;
// 10163238: using guessed type double dbl_10163238;
// 10163240: using guessed type double dbl_10163240;
// 10163248: using guessed type double dbl_10163248;
// 10163250: using guessed type double dbl_10163250;
// 10163258: using guessed type double dbl_10163258;
// 10163260: using guessed type double dbl_10163260;
// 10163268: using guessed type double dbl_10163268;
// 10163270: using guessed type double dbl_10163270;
// 10163278: using guessed type double dbl_10163278;
// 10163280: using guessed type double dbl_10163280;
// 10163288: using guessed type double dbl_10163288;
// 10163290: using guessed type double dbl_10163290;
// 10163298: using guessed type double dbl_10163298;
// 101632A0: using guessed type double dbl_101632A0;
// 101632A8: using guessed type double dbl_101632A8;
// 10572728: using guessed type double dbl_10572728;

//----- (100537F0) --------------------------------------------------------
double __cdecl sub_100537F0(double a1)
{
  HIDWORD(a1) &= 0x7FFFFFFFu;
  return a1;
}

//----- (10053810) --------------------------------------------------------
double __cdecl sub_10053810(double a1)
{
  double result; // st7@1
  int v2; // esi@1
  signed int v3; // eax@12
  double v4; // st7@13
  double v5; // st6@20
  double v6; // st6@20

  result = a1;
  v2 = HIDWORD(a1) & 0x7FFFFFFF;
  if ( (HIDWORD(a1) & 0x7FFFFFFF) < 1141899264 )
  {
    if ( v2 >= 1071382528 )
    {
      v4 = sub_100537F0(a1);
      if ( v2 >= 1072889856 )
      {
        if ( v2 >= 1073971200 )
        {
          result = -1.0 / v4;
          v3 = 3;
        }
        else
        {
          v3 = 2;
          result = (v4 - 1.5) / (v4 * 1.5 + dbl_10163348);
        }
      }
      else if ( v2 >= 1072037888 )
      {
        v3 = 1;
        result = (v4 - dbl_10163348) / (v4 + dbl_10163348);
      }
      else
      {
        v3 = 0;
        result = (v4 * 2.0 - dbl_10163348) / (v4 + 2.0);
      }
    }
    else
    {
      if ( v2 < 1042284544 && dbl_10163350 + a1 > dbl_10163348 )
        return result;
      v3 = -1;
    }
    v5 = result * result;
    v6 = (v5
        * (((((dbl_10163340 * (v5 * v5) + dbl_10163330) * (v5 * v5) + dbl_10163320) * (v5 * v5) + dbl_10163310)
          * (v5
           * v5)
          + dbl_10163300)
         * (v5
          * v5)
         + dbl_101632F0)
        + v5
        * v5
        * ((((dbl_10163338 * (v5 * v5) + dbl_10163328) * (v5 * v5) + dbl_10163318) * (v5 * v5) + dbl_10163308)
         * (v5
          * v5)
         + dbl_101632F8))
       * result;
    if ( v3 >= 0 )
    {
      result = dbl_101632B0[v3] - (v6 - dbl_101632D0[v3] - result);
      if ( SHIDWORD(a1) < 0 )
        result = -result;
    }
    else
    {
      result = result - v6;
    }
  }
  else if ( v2 > 2146435072 || v2 == 2146435072 && LODWORD(a1) )
  {
    result = a1 + a1;
  }
  else if ( SHIDWORD(a1) <= 0 )
  {
    result = -dbl_101632C8 - dbl_101632E8;
  }
  else
  {
    result = dbl_101632E8 + dbl_101632C8;
  }
  return result;
}
// 101632B0: using guessed type double dbl_101632B0[];
// 101632C8: using guessed type double dbl_101632C8;
// 101632D0: using guessed type double dbl_101632D0[];
// 101632E8: using guessed type double dbl_101632E8;
// 101632F0: using guessed type double dbl_101632F0;
// 101632F8: using guessed type double dbl_101632F8;
// 10163300: using guessed type double dbl_10163300;
// 10163308: using guessed type double dbl_10163308;
// 10163310: using guessed type double dbl_10163310;
// 10163318: using guessed type double dbl_10163318;
// 10163320: using guessed type double dbl_10163320;
// 10163328: using guessed type double dbl_10163328;
// 10163330: using guessed type double dbl_10163330;
// 10163338: using guessed type double dbl_10163338;
// 10163340: using guessed type double dbl_10163340;
// 10163348: using guessed type double dbl_10163348;
// 10163350: using guessed type double dbl_10163350;

//----- (100539B0) --------------------------------------------------------
double __cdecl sub_100539B0(double a1, int a2)
{
  double result; // st7@1
  int v3; // ecx@1
  int v4; // eax@1
  double v5; // ST48_8@3
  int v6; // eax@7
  double v7; // ST48_8@11
  double v8; // ST48_8@15
  double v9; // [sp+8h] [bp-48h]@8
  double v10; // [sp+48h] [bp-8h]@1

  result = a1;
  v10 = a1;
  v3 = HIDWORD(v10);
  v4 = (SHIDWORD(v10) >> 20) & 0x7FF;
  if ( !v4 )
  {
    if ( !(LODWORD(v10) | HIDWORD(v10) & 0x7FFFFFFF) )
      return result;
    result = a1 * dbl_10163358;
    v5 = a1 * dbl_10163358;
    v3 = HIDWORD(v5);
    v4 = ((SHIDWORD(v5) >> 20) & 0x7FF) - 54;
    if ( a2 < -50000 )
      return result * dbl_10163370;
  }
  if ( v4 == 2047 )
    return result + result;
  v6 = a2 + v4;
  if ( v6 > 2046 )
  {
    v9 = result;
    return sub_10052DF0(dbl_10163368, v9) * dbl_10163368;
  }
  if ( v6 <= 0 )
  {
    if ( v6 > -54 )
    {
      v8 = result;
      HIDWORD(v8) = v3 & 0x800FFFFF | ((v6 + 54) << 20);
      result = dbl_10163360 * v8;
    }
    else
    {
      v9 = result;
      if ( a2 > 50000 )
        return sub_10052DF0(dbl_10163368, v9) * dbl_10163368;
      result = sub_10052DF0(dbl_10163370, result) * dbl_10163370;
    }
  }
  else
  {
    v7 = result;
    HIDWORD(v7) = v3 & 0x800FFFFF | (v6 << 20);
    result = v7;
  }
  return result;
}
// 10163358: using guessed type double dbl_10163358;
// 10163360: using guessed type double dbl_10163360;
// 10163368: using guessed type double dbl_10163368;
// 10163370: using guessed type double dbl_10163370;

//----- (10053AC0) --------------------------------------------------------
void __cdecl sub_10053AC0(double a1)
{
  sub_10053AE0(a1);
}

//----- (10053AE0) --------------------------------------------------------
double __cdecl sub_10053AE0(double a1)
{
  double result; // st7@1
  unsigned int v2; // edx@1
  int v3; // eax@1
  int v4; // edi@3
  int v5; // ebx@7
  int i; // esi@10
  signed int v7; // ebx@13
  int v8; // eax@13
  unsigned int v9; // ebx@15
  int v10; // eax@15
  unsigned int v11; // ecx@15
  unsigned int v12; // esi@15
  int v13; // edx@16
  int v14; // edx@18
  unsigned int v15; // esi@19
  unsigned int v16; // edx@20
  int v17; // ebp@20
  int v18; // edx@29
  unsigned int v19; // ecx@39
  double v20; // ST1C_8@41
  int v21; // [sp+0h] [bp-14h]@15
  int v22; // [sp+4h] [bp-10h]@15
  signed int v23; // [sp+8h] [bp-Ch]@15
  double v24; // [sp+Ch] [bp-8h]@1
  signed int v25; // [sp+18h] [bp+4h]@15

  result = a1;
  v24 = a1;
  v2 = LODWORD(a1);
  v3 = HIDWORD(v24);
  if ( (HIDWORD(a1) & 0x7FF00000) == 2146435072 )
    return a1 + a1 * a1;
  v4 = 0;
  if ( SHIDWORD(v24) > 0 )
    goto LABEL_44;
  if ( !(LODWORD(a1) | HIDWORD(v24) & 0x7FFFFFFF) )
    return result;
  if ( SHIDWORD(v24) >= 0 )
  {
LABEL_44:
    v5 = SHIDWORD(v24) >> 20;
    if ( !(SHIDWORD(v24) >> 20) )
    {
      if ( !HIDWORD(v24) )
      {
        do
        {
          v3 |= v2 >> 11;
          v5 -= 21;
          v2 <<= 21;
        }
        while ( !v3 );
      }
      for ( i = 0; !(v3 & 0x100000); ++i )
        v3 *= 2;
      v5 += 1 - i;
      v3 |= v2 >> (32 - i);
      v2 <<= i;
    }
    v7 = v5 - 1023;
    v8 = v3 & 0xFFFFF | 0x100000;
    if ( v7 & 1 )
    {
      v8 = (v2 >> 31) + 2 * v8;
      v2 *= 2;
    }
    v23 = v7 >> 1;
    v9 = 0;
    v10 = (v2 >> 31) + 2 * v8;
    v11 = 2 * v2;
    v21 = 0;
    v22 = 0;
    v25 = 0;
    v12 = 0x200000;
    do
    {
      v13 = v12 + v4;
      if ( (signed int)(v12 + v4) <= v10 )
      {
        v10 -= v13;
        v25 += v12;
        v4 = v13 + v12;
      }
      v14 = (unsigned __int64)v11 >> 31;
      v11 *= 2;
      v12 >>= 1;
      v10 = v14 + 2 * v10;
    }
    while ( v12 );
    v15 = 2147483648;
    do
    {
      v16 = v15 + v21;
      v17 = v4;
      if ( v4 < v10 || v4 == v10 && v16 <= v11 )
      {
        v21 = v16 + v15;
        if ( (v16 & 0x80000000) == 0x80000000 && !(v16 & 0x80000000 & v21) )
          ++v4;
        v10 -= v17;
        if ( v11 < v16 )
          --v10;
        v11 -= v16;
        v9 = v15 + v22;
        v22 += v15;
      }
      v18 = (unsigned __int64)v11 >> 31;
      v11 *= 2;
      v15 >>= 1;
      v10 = v18 + 2 * v10;
    }
    while ( v15 );
    if ( v10 | v11 && dbl_10163378 - dbl_10163380 >= dbl_10163378 )
    {
      if ( v9 == -1 )
      {
        v9 = 0;
        ++v25;
      }
      else if ( dbl_10163380 + dbl_10163378 <= dbl_10163378 )
      {
        v9 += v9 & 1;
      }
      else
      {
        if ( v9 == -2 )
          ++v25;
        v9 += 2;
      }
    }
    v19 = v9 >> 1;
    if ( v25 & 1 )
      v19 |= 0x80000000;
    HIDWORD(v20) = (v25 >> 1) + 1071644672 + (v23 << 20);
    LODWORD(v20) = v19;
    result = v20;
  }
  else
  {
    result = (a1 - a1) / (a1 - a1);
  }
  return result;
}
// 10163378: using guessed type double dbl_10163378;
// 10163380: using guessed type double dbl_10163380;

//----- (10053CF0) --------------------------------------------------------
int __cdecl sub_10053CF0(unsigned int a1, unsigned int a2)
{
  int result; // eax@2
  void (__cdecl *v3)(unsigned int); // [sp+0h] [bp-10h]@11
  int v4; // [sp+4h] [bp-Ch]@8
  int (__cdecl *v5)(unsigned int); // [sp+8h] [bp-8h]@7
  int v6; // [sp+Ch] [bp-4h]@11

  if ( word_10572730 == 9320 )
  {
    if ( a1 <= 0xFFFFFF7 )
    {
      if ( a2 < (unsigned __int16)word_10572732 )
      {
        v5 = (int (__cdecl *)(unsigned int))dword_10572740[13 * a2];
        if ( v5 )
          v4 = v5(a2);
        else
          v4 = 1;
        if ( v4 )
        {
          v6 = sub_100542D0(a1, a2);
          v3 = (void (__cdecl *)(unsigned int))dword_10572744[13 * a2];
          if ( v3 )
            v3(a2);
        }
        else
        {
          v6 = 0;
        }
        result = v6;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10572730: using guessed type __int16 word_10572730;
// 10572732: using guessed type __int16 word_10572732;
// 10572740: using guessed type int dword_10572740[];
// 10572744: using guessed type int dword_10572744[];

//----- (10053DA0) --------------------------------------------------------
void *__cdecl sub_10053DA0(unsigned int a1, unsigned int a2, unsigned int a3)
{
  void *v4; // [sp+8h] [bp-8h]@3
  unsigned int v5; // [sp+Ch] [bp-4h]@0

  if ( is_mul_ok(a2, a1) && a2 * a1 < 0xFFFFFFFF )
  {
    v5 = a1 * a2;
    v4 = (void *)sub_10053CF0(a1 * a2, a3);
  }
  else
  {
    v4 = 0;
  }
  if ( v4 )
    memset(v4, 0, v5);
  return v4;
}

//----- (10053E10) --------------------------------------------------------
int *__cdecl sub_10053E10(unsigned int a1, unsigned int a2)
{
  int *result; // eax@1
  int (__cdecl *v3)(unsigned int); // [sp+0h] [bp-Ch]@7
  int *v4; // [sp+4h] [bp-8h]@4
  int (__cdecl *v5)(unsigned int); // [sp+8h] [bp-4h]@3

  result = (int *)(unsigned __int16)word_10572730;
  if ( word_10572730 == 9320 && a2 < (unsigned __int16)word_10572732 )
  {
    result = (int *)dword_10572740[13 * a2];
    v5 = (int (__cdecl *)(unsigned int))dword_10572740[13 * a2];
    if ( v5 )
    {
      result = (int *)v5(a2);
      v4 = result;
    }
    else
    {
      v4 = (int *)1;
    }
    if ( v4 )
    {
      result = sub_10054490(a1, a2);
      v3 = (int (__cdecl *)(unsigned int))dword_10572744[13 * a2];
      if ( v3 )
        result = (int *)v3(a2);
    }
  }
  return result;
}
// 10572730: using guessed type __int16 word_10572730;
// 10572732: using guessed type __int16 word_10572732;
// 10572740: using guessed type int dword_10572740[];
// 10572744: using guessed type int dword_10572744[];

//----- (10053EA0) --------------------------------------------------------
int __cdecl sub_10053EA0(int a1, void *a2)
{
  char *v2; // ecx@4
  signed int v4; // [sp+4h] [bp-4h]@3

  if ( word_10572730 == 9320 && a1 < (unsigned int)(unsigned __int16)word_10572732 )
  {
    v2 = (char *)&unk_10572750 + 52 * a1;
    *(_DWORD *)a2 = *(_DWORD *)v2;
    *((_DWORD *)a2 + 1) = *((_DWORD *)v2 + 1);
    *((_DWORD *)a2 + 2) = *((_DWORD *)v2 + 2);
    *((_DWORD *)a2 + 3) = *((_DWORD *)v2 + 3);
    *((_DWORD *)a2 + 4) = *((_DWORD *)v2 + 4);
    *((_DWORD *)a2 + 5) = *((_DWORD *)v2 + 5);
    *((_DWORD *)a2 + 7) = 8 * *((_DWORD *)a2 + 1) + 8;
    *((_DWORD *)a2 + 6) = *((_DWORD *)a2 + 4) - *((_DWORD *)a2 + 7);
    *((_DWORD *)a2 + 8) = 10000 * (unsigned __int64)*((_DWORD *)a2 + 4) / *((_DWORD *)a2 + 3);
    *((_DWORD *)a2 + 9) = 10000 * (unsigned __int64)*((_DWORD *)a2 + 5) / *((_DWORD *)a2 + 3);
    *((_DWORD *)a2 + 10) = 10000 * (unsigned __int64)*((_DWORD *)a2 + 7) / *((_DWORD *)a2 + 3);
    v4 = 0;
  }
  else
  {
    memset(a2, 204, 0x2Cu);
    *((_DWORD *)a2 + 6) = -1;
    v4 = -1;
  }
  return v4;
}
// 10572730: using guessed type __int16 word_10572730;
// 10572732: using guessed type __int16 word_10572732;

//----- (10053FC0) --------------------------------------------------------
void *__cdecl sub_10053FC0(void *a1, unsigned int a2, unsigned int a3)
{
  void (__cdecl *v4)(unsigned int); // [sp+0h] [bp-10h]@15
  int v5; // [sp+4h] [bp-Ch]@12
  int (__cdecl *v6)(unsigned int); // [sp+8h] [bp-8h]@11
  void *v7; // [sp+Ch] [bp-4h]@2

  if ( word_10572730 == 9320 )
  {
    if ( a3 < (unsigned __int16)word_10572732 )
    {
      if ( a1 )
      {
        if ( a2 )
        {
          if ( a2 <= 0xFFFFFF7 )
          {
            v6 = (int (__cdecl *)(unsigned int))dword_10572740[13 * a3];
            if ( v6 )
              v5 = v6(a3);
            else
              v5 = 1;
            if ( v5 )
            {
              v7 = sub_100546E0(a1, a2, a3);
              v4 = (void (__cdecl *)(unsigned int))dword_10572744[13 * a3];
              if ( v4 )
                v4(a3);
            }
            else
            {
              v7 = 0;
            }
          }
          else
          {
            v7 = 0;
          }
        }
        else
        {
          sub_10053E10((unsigned int)a1, a3);
          v7 = 0;
        }
      }
      else
      {
        v7 = (void *)sub_10053CF0(a2, a3);
      }
    }
    else
    {
      v7 = 0;
    }
  }
  else
  {
    v7 = 0;
  }
  return v7;
}
// 10572730: using guessed type __int16 word_10572730;
// 10572732: using guessed type __int16 word_10572732;
// 10572740: using guessed type int dword_10572740[];
// 10572744: using guessed type int dword_10572744[];

//----- (100540D0) --------------------------------------------------------
unsigned int __cdecl sub_100540D0(int a1)
{
  unsigned int result; // eax@2
  int v2; // ST18_4@11
  int v3; // edx@11
  unsigned int v4; // ST28_4@11
  unsigned int v5; // ST20_4@11
  void (__cdecl *v6)(unsigned int); // [sp+0h] [bp-20h]@11
  int v7; // [sp+4h] [bp-1Ch]@8
  int *v8; // [sp+10h] [bp-10h]@7
  unsigned int v9; // [sp+18h] [bp-8h]@7

  if ( word_10572730 == 9320 )
  {
    if ( a1 )
    {
      if ( (signed int)(unsigned __int16)word_10572732 < 8 )
      {
        v9 = (unsigned __int16)word_10572732++;
        v8 = &dword_10572734[13 * v9];
        if ( *(_DWORD *)a1 )
          v7 = (*(int (__cdecl **)(_DWORD))a1)(v9);
        else
          v7 = 1;
        if ( v7 )
        {
          v2 = *(_DWORD *)(a1 + 12);
          v3 = (int)(v8 + 3);
          *(_DWORD *)v3 = *(_DWORD *)a1;
          *(_DWORD *)(v3 + 4) = *(_DWORD *)(a1 + 4);
          *(_DWORD *)(v3 + 8) = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(v3 + 12) = *(_DWORD *)(a1 + 12);
          v8[10] = v2;
          v8[11] = 8;
          v8[12] = v8[11];
          v4 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(v4 + 4) = v2 - 8;
          *(_DWORD *)v4 = 0;
          v5 = v4 + (*(_DWORD *)(v4 + 4) & 0xFFFFFFFC);
          *(_DWORD *)(v5 + 4) = 8;
          *(_DWORD *)v5 = *(_DWORD *)(v4 + 4);
          v8[2] = v5;
          *(_DWORD *)(v5 + 4) &= 0xFFFFFFFE;
          sub_100549D0(v4, 0, v9);
          v6 = *(void (__cdecl **)(unsigned int))(a1 + 4);
          if ( v6 )
            v6(v9);
          result = v9;
        }
        else
        {
          result = -1;
        }
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10572730: using guessed type __int16 word_10572730;
// 10572732: using guessed type __int16 word_10572732;
// 10572734: using guessed type int dword_10572734[];

//----- (10054250) --------------------------------------------------------
__int16 *sub_10054250()
{
  signed int i; // [sp+0h] [bp-4h]@1

  memset(&word_10572730, 0, 0x1A4u);
  for ( i = 0; i < 8; ++i )
  {
    dword_10572734[13 * i] = (int)&dword_10572734[13 * i];
    dword_10572738[13 * i] = (int)&dword_10572734[13 * i];
  }
  word_10572730 = 9320;
  return &word_10572730;
}
// 10572730: using guessed type __int16 word_10572730;
// 10572734: using guessed type int dword_10572734[];
// 10572738: using guessed type int dword_10572738[];

//----- (100542D0) --------------------------------------------------------
int __cdecl sub_100542D0(unsigned int a1, unsigned int a2)
{
  int result; // eax@2
  unsigned int v3; // [sp+0h] [bp-24h]@6
  int *v4; // [sp+Ch] [bp-18h]@5
  unsigned int v5; // [sp+10h] [bp-14h]@19
  int v6; // [sp+14h] [bp-10h]@25
  int v7; // [sp+18h] [bp-Ch]@19
  int i; // [sp+1Ch] [bp-8h]@9

  if ( a1 )
  {
    if ( a1 <= 0xFFFFFF7 )
    {
      v4 = &dword_10572734[13 * a2];
      if ( a1 >= 8 )
        v3 = a1 + (-a1 & 3) + 8;
      else
        v3 = 16;
      ++v4[7];
      if ( v3 >= 0xC800 )
      {
        for ( i = v4[1]; (int *)i != v4 && *(_DWORD *)(i - 4) < v3; i = *(_DWORD *)(i + 4) )
          ;
      }
      else
      {
        for ( i = *v4; (int *)i != v4 && *(_DWORD *)(i - 4) < v3; i = *(_DWORD *)i )
          ;
      }
      if ( (int *)i == v4 )
      {
        v6 = 0;
      }
      else
      {
        v7 = i - 8;
        v5 = *(_DWORD *)(i - 8 + 4) & 0xFFFFFFFC;
        if ( ++v4[8] > (unsigned int)v4[9] )
          v4[9] = v4[8];
        sub_100549D0(v7, 1, a2);
        if ( v5 >= v3 + 16 )
        {
          sub_10054920(v7, v3, a2);
          v5 = v3;
        }
        v4[11] += v5;
        if ( v4[11] > (unsigned int)v4[12] )
          v4[12] = v4[11];
        v6 = i;
      }
      if ( !v6 )
        --v4[7];
      result = v6;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10572734: using guessed type int dword_10572734[];

//----- (10054490) --------------------------------------------------------
int *__cdecl sub_10054490(unsigned int a1, unsigned int a2)
{
  int *result; // eax@1
  int v3; // ST18_4@9
  int *v4; // [sp+0h] [bp-10h]@1
  bool v5; // [sp+7h] [bp-9h]@2
  int *v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@1

  result = (int *)(a1 - 8);
  v7 = a1 - 8;
  v6 = &dword_10572734[13 * a2];
  v4 = &dword_10572734[13 * a2];
  if ( a1 )
  {
    result = &dword_10572734[13 * a2];
    v5 = a1 >= v4[5] && (result = (int *)(v4[6] + v4[5]), a1 <= (unsigned int)result);
  }
  else
  {
    v5 = 0;
  }
  if ( v5 )
  {
    result = (int *)(a1 - 8);
    if ( !(*(_DWORD *)(v7 + 4) & 1) )
    {
      --v6[8];
      v6[11] -= *(_DWORD *)(v7 + 4) & 0xFFFFFFFC;
      v3 = sub_10054560(v7, a2, 0);
      result = (int *)sub_100549D0(v3, 0, a2);
    }
  }
  return result;
}
// 10572734: using guessed type int dword_10572734[];

//----- (10054560) --------------------------------------------------------
int __cdecl sub_10054560(int a1, unsigned int a2, unsigned int a3)
{
  int result; // eax@3
  unsigned int v4; // [sp+8h] [bp-14h]@4
  unsigned int v5; // [sp+Ch] [bp-10h]@4
  unsigned int v6; // [sp+10h] [bp-Ch]@5
  unsigned int v7; // [sp+14h] [bp-8h]@9
  unsigned int v8; // [sp+18h] [bp-4h]@4

  if ( a1 && a2 < (unsigned __int16)word_10572732 )
  {
    v4 = a1 + (*(_DWORD *)(a1 + 4) & 0xFFFFFFFC);
    v8 = a1 - (*(_DWORD *)a1 & 0xFFFFFFFC);
    v5 = *(_DWORD *)(a1 + 4) & 0xFFFFFFFC;
    if ( *(_DWORD *)(v4 + 4) & 1 )
      v6 = *(_DWORD *)(v4 + 4) & 0xFFFFFFFC;
    else
      v6 = 0;
    if ( v8 != a1 && *(_DWORD *)(v8 + 4) & 1 )
      v7 = *(_DWORD *)(v8 + 4) & 0xFFFFFFFC;
    else
      v7 = 0;
    if ( a3 )
    {
      if ( v6 < a3 )
      {
        if ( v7 < a3 )
        {
          if ( v7 + v6 < a3 )
          {
            v6 = 0;
            v7 = 0;
          }
        }
        else
        {
          v6 = 0;
        }
      }
      else
      {
        v7 = 0;
      }
    }
    if ( v6 )
    {
      sub_100549D0(v4, 1, a2);
      v5 += v6;
      *(_DWORD *)(a1 + 4) = v5 | *(_DWORD *)(a1 + 4) & 3;
      v4 += *(_DWORD *)(v4 + 4) & 0xFFFFFFFC;
      *(_DWORD *)v4 = *(_DWORD *)(a1 + 4);
    }
    if ( v7 )
    {
      sub_100549D0(v8, 1, a2);
      a1 = v8;
      *(_DWORD *)(v8 + 4) = (v7 + v5) | *(_DWORD *)(v8 + 4) & 3;
      *(_DWORD *)v4 = *(_DWORD *)(v8 + 4);
    }
    result = a1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10572732: using guessed type __int16 word_10572732;

//----- (100546E0) --------------------------------------------------------
void *__cdecl sub_100546E0(void *a1, unsigned int a2, unsigned int a3)
{
  void *result; // eax@2
  int v4; // eax@19
  int v5; // eax@25
  unsigned int v6; // [sp+0h] [bp-24h]@12
  int *v7; // [sp+4h] [bp-20h]@3
  bool v8; // [sp+Bh] [bp-19h]@4
  int *v9; // [sp+Ch] [bp-18h]@1
  void *v10; // [sp+10h] [bp-14h]@1
  int v11; // [sp+14h] [bp-10h]@15
  unsigned int v12; // [sp+1Ch] [bp-8h]@14
  char *v13; // [sp+20h] [bp-4h]@14

  v9 = &dword_10572734[13 * a3];
  v10 = a1;
  if ( a2 <= 0xFFFFFF7 )
  {
    v7 = &dword_10572734[13 * a3];
    if ( a1 )
      v8 = (unsigned int)a1 >= v7[5] && (unsigned int)a1 <= v7[6] + v7[5];
    else
      v8 = 0;
    if ( v8 )
    {
      if ( a2 >= 8 )
        v6 = a2 + (-a2 & 3) + 8;
      else
        v6 = 16;
      v13 = (char *)a1 - 8;
      v12 = *((_DWORD *)a1 - 1) & 0xFFFFFFFC;
      if ( v12 >= v6 )
      {
        if ( v12 > v6 + 16 )
        {
          v9[11] -= v12 - v6;
          v5 = sub_10054920((int)v13, v6, a3);
          sub_10054560(v5, a3, 0);
        }
      }
      else
      {
        v11 = sub_10054560((int)v13, a3, v6 - v12);
        if ( (*(_DWORD *)(v11 + 4) & 0xFFFFFFFC) < v6 )
        {
          --v9[8];
          v9[11] -= v12;
          v10 = (void *)sub_100542D0(v6 - 8, a3);
          ++v9[8];
          v9[11] += v12;
          if ( v10 )
          {
            memcpy(v10, a1, v12 - 8);
            sub_10054490((unsigned int)a1, a3);
          }
        }
        else
        {
          v10 = (void *)(v11 + 8);
          if ( (void *)(v11 + 8) != a1 )
            memcpy_0(v10, a1, v12 - 8);
          if ( (*(_DWORD *)(v11 + 4) & 0xFFFFFFFC) > v6 + 16 )
          {
            v4 = sub_10054920(v11, v6, a3);
            sub_10054560(v4, a3, 0);
          }
          v9[11] += (*(_DWORD *)(v11 + 4) & 0xFFFFFFFC) - v12;
        }
      }
      result = v10;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10572734: using guessed type int dword_10572734[];

//----- (10054920) --------------------------------------------------------
int __cdecl sub_10054920(int a1, int a2, unsigned int a3)
{
  int result; // eax@5
  _DWORD *v4; // ST10_4@6

  if ( a1 && (unsigned int)(*(_DWORD *)(a1 + 4) - a2) >= 0x10 && a3 <= (unsigned __int16)word_10572732 && !(a2 & 3) )
  {
    v4 = (_DWORD *)(a1 + (*(_DWORD *)(a1 + 4) & 0xFFFFFFFC));
    *(_DWORD *)(a2 + a1 + 4) = (*(_DWORD *)(a1 + 4) & 0xFFFFFFFC) - a2;
    *(_DWORD *)(a2 + a1) = a2;
    *v4 = *(_DWORD *)(a2 + a1 + 4);
    sub_100549D0(a2 + a1, 0, a3);
    *(_DWORD *)(a1 + 4) = a2 | *(_DWORD *)(a1 + 4) & 3;
    result = a2 + a1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10572732: using guessed type __int16 word_10572732;

//----- (100549D0) --------------------------------------------------------
unsigned int __cdecl sub_100549D0(unsigned int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax@2
  int *v4; // ST18_4@9
  unsigned int v5; // ST1C_4@9
  int v6; // ST20_4@9
  unsigned int v7; // ST10_4@10
  int v8; // ST14_4@10
  int v9; // ST08_4@12
  _DWORD *v10; // ST0C_4@12
  int *v11; // [sp+28h] [bp-4h]@7

  if ( a1 )
  {
    result = (unsigned __int16)word_10572732;
    if ( a3 <= (unsigned __int16)word_10572732 )
    {
      if ( a2 )
      {
        if ( a2 == 1 )
        {
          v9 = *(_DWORD *)(a1 + 8);
          v10 = *(_DWORD **)(a1 + 12);
          *(_DWORD *)(v9 + 4) = v10;
          *v10 = v9;
          result = a1;
          *(_DWORD *)(a1 + 4) &= 0xFFFFFFFE;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 4) |= 1u;
        *(_DWORD *)(a1 + 8) = a1 + 8;
        *(_DWORD *)(a1 + 12) = a1 + 8;
        v11 = &dword_10572734[13 * a3];
        if ( (*(_DWORD *)(a1 + 4) & 0xFFFFFFFC) - 8 < 0xC800
          && a1 <= dword_10572734[13 * a3 + 5] + ((unsigned int)dword_10572734[13 * a3 + 6] >> 1) )
        {
          v7 = a1 + 8;
          v8 = *v11;
          *(_DWORD *)(v8 + 4) = a1 + 8;
          *(_DWORD *)v7 = v8;
          *(_DWORD *)(v7 + 4) = v11;
          result = a1 + 8;
          *v11 = a1 + 8;
        }
        else
        {
          v4 = (int *)v11[1];
          v5 = a1 + 8;
          v6 = *v4;
          *(_DWORD *)(v6 + 4) = a1 + 8;
          *(_DWORD *)v5 = v6;
          *(_DWORD *)(v5 + 4) = v4;
          result = (unsigned int)v4;
          *v4 = a1 + 8;
        }
      }
    }
  }
  return result;
}
// 10572732: using guessed type __int16 word_10572732;
// 10572734: using guessed type int dword_10572734[];

//----- (10054B20) --------------------------------------------------------
char __usercall sub_10054B20@<al>(int a1@<ebx>, int a2@<esi>, int a3, _WORD *a4)
{
  int v4; // ebp@1
  __int16 v5; // dx@1
  int v6; // eax@1
  char result; // al@2
  __int16 *v8; // edi@5
  signed int v9; // ecx@6
  __int16 v10; // dx@6
  int v11; // eax@6
  __int16 v12; // cx@7
  __int16 v13; // dx@7
  __int16 v14; // cx@9
  __int16 v15; // dx@9
  __int16 *v16; // [sp+4h] [bp-48h]@5
  int v17; // [sp+Ch] [bp-40h]@5
  __int16 v18; // [sp+10h] [bp-3Ch]@5
  __int16 v19; // [sp+14h] [bp-38h]@7
  __int16 v20; // [sp+18h] [bp-34h]@7
  int v21; // [sp+1Ch] [bp-30h]@10
  _WORD *v22; // [sp+20h] [bp-2Ch]@1
  __int16 v23; // [sp+28h] [bp-24h]@5

  v4 = a3;
  *(_WORD *)(a3 + 394) = 1;
  v5 = word_105728D8[15];
  v22 = a4;
  *(_WORD *)(a3 + 428) = v5;
  *(_WORD *)(a3 + 430) = word_105728D8[15];
  v6 = *(_DWORD *)(a2 + 4) & 0x18;
  if ( v6 == 16 )
    result = 3;
  else
    result = (v6 == 8) + 1;
  if ( result )
  {
    v16 = &v18;
    v8 = &v23;
    v17 = (unsigned __int8)result;
    do
    {
      v8[1] = *(_WORD *)(a2 + 10);
      v9 = *(_WORD *)(a2 + 8);
      v10 = *(_WORD *)(a1 + 2);
      *v8 = *(_WORD *)(a2 + 8) / 4;
      v16[1] = v10;
      v11 = *(_DWORD *)(a2 + 4) & 0x18;
      *((_DWORD *)v8 - 1) = 96;
      v8[2] = 2447;
      if ( v11 == 16 )
      {
        v12 = *(_WORD *)(a2 + 8) / 6;
        v13 = *(_WORD *)a1;
        v18 = v12 + *(_WORD *)a1 - v23 / 2 - 5;
        v19 = v13 + 3 * v12 - v23 / 2;
        v4 = a3;
        v20 = v13 + 5 * v12 + 5 - v23 / 2;
      }
      else if ( v11 == 8 )
      {
        v14 = *(_WORD *)(a2 + 8) / 6;
        v15 = *(_WORD *)a1;
        v18 = v14 + *(_WORD *)a1 - v23 / 2;
        v4 = a3;
        v19 = v15 + 5 * v14 - v23 / 2;
      }
      else
      {
        v21 = v23 / 2;
        v18 = *(_WORD *)a1 + v9 / 2 - v23 / 2;
      }
      result = sub_10069D40(v4, (int)(v8 - 2), (int)v16, 0, v22);
      v16 += 2;
      v8 += 6;
      --v17;
    }
    while ( v17 );
  }
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10054CD0) --------------------------------------------------------
char __usercall sub_10054CD0@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  char v7; // bl@4
  int v8; // edi@5
  int v9; // eax@9
  char *v10; // edi@11
  char v11; // al@12
  __int16 v12; // cx@20
  char *v13; // eax@20
  char v14; // cl@21
  int v16; // [sp+Ch] [bp-38h]@20
  int v17; // [sp+10h] [bp-34h]@5
  int v18; // [sp+14h] [bp-30h]@22
  int v19; // [sp+18h] [bp-2Ch]@17
  __int16 v20; // [sp+1Ch] [bp-28h]@22
  __int16 v21; // [sp+1Eh] [bp-26h]@22
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  char v25[20]; // [sp+2Ch] [bp-18h]@10

  v24 = a4;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v23 = a2;
  v22 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v7 = 0;
  if ( v6 )
  {
    v8 = 0;
    v17 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1005C160(a3, a5, v8) > (unsigned __int8)v7 )
        v7 = sub_1005C160(a3, a5, v8);
      ++v8;
      --v17;
    }
    while ( v17 );
  }
  v9 = *(_DWORD *)(a3 + 4);
  if ( ~(unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7) & 1 )
  {
    sub_1005BD10(a3, (int)a5, v25);
    if ( *(_DWORD *)(a3 + 4) & 0x1000 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 32;
      sub_1005C490(*(_BYTE *)(a3 + 13), &v25[strlen(v25)]);
    }
  }
  else
  {
    if ( !(v9 & 0x1000) )
      return v9;
    sub_1005C490(*(_BYTE *)(a3 + 13), v25);
  }
  switch ( v7 )
  {
    case 3:
      v19 = byte_10658E06 != 0 ? 35087 : 35304;
      break;
    case 2:
      v19 = 35169;
      break;
    default:
      v19 = 35215;
      break;
  }
  v12 = *(_WORD *)v23 + *(_WORD *)(a3 + 8) / 2;
  v13 = v25;
  HIWORD(v16) = *(_WORD *)(v23 + 2) - 6;
  LOWORD(v16) = v12;
  do
    v14 = *v13++;
  while ( v14 );
  v21 = (_WORD)v13 - (unsigned int)&v25[1];
  v18 = 105;
  v20 = 0;
  LOBYTE(v9) = sub_100698B0(v24, (int)&v18, (int)&v16, v25, v22);
  return v9;
}
// 10658E06: using guessed type char byte_10658E06;
// 10054CD0: using guessed type char var_18[20];

//----- (10054EA0) --------------------------------------------------------
char __usercall sub_10054EA0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  __int16 v5; // [sp+0h] [bp-34h]@1
  __int16 v6; // [sp+2h] [bp-32h]@1
  __int16 v7; // [sp+4h] [bp-30h]@1
  __int16 v8; // [sp+6h] [bp-2Eh]@1
  float v9; // [sp+8h] [bp-2Ch]@1
  float v10; // [sp+Ch] [bp-28h]@1
  char v11; // [sp+10h] [bp-24h]@1
  char v12; // [sp+20h] [bp-14h]@1

  sub_1005C100(*(_BYTE *)(a4 + 13), (int)&v11, (int)&v12);
  v10 = *(float *)(a2 + 8);
  v9 = *(float *)(a2 + 4);
  v7 = 0;
  v8 = 0;
  v5 = 0;
  v6 = 0;
  sub_1006B030(a3, (int)&v11, (int *)&v5, &v9, a1);
  return sub_1006B030(a3, (int)&v12, (int *)&v7, &v10, a1);
}

//----- (10054F30) --------------------------------------------------------
char __usercall sub_10054F30@<al>(int a1@<edx>, const void *a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // eax@1
  char v6; // al@2
  int v7; // edi@5
  char *v8; // esi@5
  __int16 v9; // cx@12
  int v10; // eax@12
  int v11; // eax@13
  int v12; // edx@13
  int v13; // esi@13
  int v14; // eax@13
  int v15; // eax@15
  int v16; // edx@15
  int v17; // esi@15
  int v18; // esi@18
  char *v19; // edi@18
  float *v20; // ebx@18
  double v21; // st7@21
  int v22; // edx@23
  char v24; // [sp+13h] [bp-5Dh]@4
  int v25; // [sp+14h] [bp-5Ch]@5
  int v26; // [sp+14h] [bp-5Ch]@18
  const void *v27; // [sp+18h] [bp-58h]@1
  __int16 v28; // [sp+1Ch] [bp-54h]@13
  __int16 v29; // [sp+1Eh] [bp-52h]@12
  __int16 v30; // [sp+20h] [bp-50h]@13
  __int16 v31; // [sp+22h] [bp-4Eh]@13
  __int16 v32; // [sp+24h] [bp-4Ch]@13
  __int16 v33; // [sp+26h] [bp-4Ah]@13
  int v34; // [sp+28h] [bp-48h]@1
  int v35; // [sp+2Ch] [bp-44h]@1
  float v36[3]; // [sp+30h] [bp-40h]@23
  char v37; // [sp+3Ch] [bp-34h]@18
  char v38; // [sp+40h] [bp-30h]@5

  v35 = a3;
  v5 = *(_DWORD *)(a4 + 4) & 0x18;
  v27 = a2;
  v34 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v24 = v6;
  if ( v6 )
  {
    v7 = 0;
    v8 = &v38;
    v25 = (unsigned __int8)v6;
    do
    {
      sub_1005C440(*(_BYTE *)(a4 + 13), (int)(v8 - 4));
      if ( *((_BYTE *)v27 + v7) )
      {
        switch ( sub_1005C160(a4, v27, v7) )
        {
          case 3:
            *(_DWORD *)v8 = byte_10658E06 != 0 ? 37135 : 37352;
            break;
          case 2:
            *(_DWORD *)v8 = 37217;
            break;
          default:
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        *(_DWORD *)v8 = 37263;
      }
      ++v7;
      v8 += 16;
      --v25;
    }
    while ( v25 );
  }
  v9 = *(_WORD *)(a4 + 10) + *(_WORD *)(a5 + 2) + 20;
  v10 = *(_DWORD *)(a4 + 4) & 0x18;
  v29 = *(_WORD *)(a4 + 10) + *(_WORD *)(a5 + 2) + 20;
  if ( v10 == 16 )
  {
    v11 = *(_WORD *)(a4 + 8) / 6;
    v12 = *(_WORD *)a5;
    v28 = v12 + v11 - 4;
    v13 = v11 + v12 + 2 * v11 + 1;
    v14 = v11 + v12 + 4 * v11 + 6;
    v30 = v13;
    v32 = v14;
    v31 = v9;
    v33 = v9;
  }
  else if ( v10 == 8 )
  {
    v15 = *(_WORD *)(a4 + 8) / 6;
    v16 = *(_WORD *)a5;
    v17 = v16 + v15 + 1;
    v14 = v15 + v16 + 4 * v15 - 1;
    v28 = v17;
    v30 = v14;
    v31 = v9;
  }
  else
  {
    LOWORD(v14) = *(_WORD *)a5 + *(_WORD *)(a4 + 8) / 2 + 1;
    v28 = *(_WORD *)a5 + *(_WORD *)(a4 + 8) / 2 + 1;
  }
  if ( v24 )
  {
    v18 = 0;
    v19 = &v37;
    v20 = (float *)((char *)v27 + 60);
    v26 = (unsigned __int8)v24;
    do
    {
      if ( *((_BYTE *)v27 + v18) && sub_1005C160(a4, v27, v18) )
        v21 = *v20;
      else
        v21 = 9.8999998e24;
      v22 = v34;
      v36[v18] = v21;
      LOBYTE(v14) = sub_1006B030(v35, (int)v19, (int *)&v28 + v18, &v36[v18], v22);
      ++v18;
      ++v20;
      v19 += 16;
      --v26;
    }
    while ( v26 );
  }
  return v14;
}
// 10658E06: using guessed type char byte_10658E06;
// 10054F30: using guessed type float var_40[3];

//----- (10055130) --------------------------------------------------------
int __usercall sub_10055130@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  __int16 v4; // cx@1
  int result; // eax@1
  signed int v6; // ecx@3
  __int16 v7; // ax@5
  __int16 v8; // ax@7
  __int16 v9; // dx@7
  __int16 v10; // ax@10
  __int16 v11; // ax@12
  int v12; // [sp+4h] [bp-8h]@1
  __int16 v13; // [sp+8h] [bp-4h]@3
  __int16 v14; // [sp+Ah] [bp-2h]@1

  v4 = *(_WORD *)(a2 + 2) + *(_WORD *)(a3 + 10);
  HIWORD(v12) = *(_WORD *)(a2 + 2);
  result = *(_DWORD *)(a3 + 4) & 0x18;
  v14 = v4;
  if ( result == 16 )
  {
    if ( !*(_BYTE *)a4 )
    {
      v6 = *(_WORD *)(a3 + 8);
      LOWORD(v12) = *(_WORD *)a2 - 5;
      v13 = v12 + v6 / 3;
      result = sub_1006D760(a1, (int)&v12, (int)&v13, 0);
    }
    if ( !*(_BYTE *)(a4 + 1) )
    {
      v7 = *(_WORD *)(a3 + 8) / 3;
      LOWORD(v12) = v7 + *(_WORD *)a2;
      v13 = v12 + v7;
      result = sub_1006D760(a1, (int)&v12, (int)&v13, 0);
    }
    if ( !*(_BYTE *)(a4 + 2) )
    {
      v8 = *(_WORD *)(a3 + 8) / 3;
      v9 = *(_WORD *)a2 + 2 * v8 + 5;
LABEL_15:
      LOWORD(v12) = v9;
      v13 = v9 + v8;
      return sub_1006D760(a1, (int)&v12, (int)&v13, 0);
    }
  }
  else
  {
    if ( result != 8 )
    {
      if ( *(_BYTE *)a4 )
        return result;
      v8 = *(_WORD *)(a3 + 8) / 3;
      v9 = v8 + *(_WORD *)a2;
      goto LABEL_15;
    }
    if ( !*(_BYTE *)a4 )
    {
      v10 = *(_WORD *)a2 + *(_WORD *)(a3 + 8) / 3;
      LOWORD(v12) = *(_WORD *)a2;
      v13 = v10;
      result = sub_1006D760(a1, (int)&v12, (int)&v13, 0);
    }
    if ( !*(_BYTE *)(a4 + 1) )
    {
      v11 = *(_WORD *)(a3 + 8) / 3;
      LOWORD(v12) = *(_WORD *)a2 + 2 * v11;
      v13 = v12 + v11;
      result = sub_1006D760(a1, (int)&v12, (int)&v13, 0);
    }
  }
  return result;
}

//----- (100552F0) --------------------------------------------------------
int __usercall sub_100552F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, float a4)
{
  int v4; // edx@1
  int v5; // esi@1
  int v7; // [sp+8h] [bp+4h]@2

  v4 = *(_WORD *)(a1 + 2);
  v5 = v4 + *(_WORD *)(a3 + 10);
  if ( *(float *)(a2 + 8) - *(float *)(a2 + 4) != 0.0 )
  {
    *(float *)&v7 = (a4 - *(float *)(a2 + 4)) / (*(float *)(a2 + 8) - *(float *)(a2 + 4));
    v5 -= (signed int)(*(float *)&v7 * (double)(v5 - v4 - 1));
  }
  return v5;
}

//----- (10055350) --------------------------------------------------------
int __usercall sub_10055350@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  float *v6; // edi@1
  float *v7; // edx@1
  signed int v8; // ecx@1
  double v9; // st7@3
  __int64 v10; // rax@8
  int v11; // ecx@8
  int v12; // eax@8
  __int16 v13; // si@9
  __int16 v14; // cx@9
  __int16 v15; // ST28_2@9
  __int16 v16; // di@11
  __int16 v17; // cx@11
  __int16 v18; // ST28_2@11
  __int16 v19; // si@12
  __int16 v20; // di@12
  int v21; // esi@14
  int v22; // eax@16
  int v23; // eax@17
  int v24; // eax@22
  double v25; // st7@22
  float v26; // ST10_4@22
  int v27; // eax@22
  int v28; // edi@23
  bool v29; // zf@25
  char v31; // [sp+17h] [bp-61h]@9
  unsigned __int8 v32; // [sp+17h] [bp-61h]@22
  int v33; // [sp+18h] [bp-60h]@14
  __int16 v34; // [sp+24h] [bp-54h]@9
  __int16 v35; // [sp+26h] [bp-52h]@22
  __int16 v36; // [sp+28h] [bp-50h]@9
  __int16 v37; // [sp+2Ch] [bp-4Ch]@9
  int v38; // [sp+30h] [bp-48h]@1
  int v39; // [sp+34h] [bp-44h]@9
  __int16 v40; // [sp+38h] [bp-40h]@9
  __int16 v41; // [sp+3Ch] [bp-3Ch]@9
  char *v42; // [sp+40h] [bp-38h]@9
  int v43; // [sp+44h] [bp-34h]@9
  int v44; // [sp+48h] [bp-30h]@9
  int v45; // [sp+4Ch] [bp-2Ch]@22
  int v46; // [sp+50h] [bp-28h]@8
  int v47; // [sp+54h] [bp-24h]@8
  __int16 v48; // [sp+58h] [bp-20h]@8
  __int16 v49; // [sp+5Ah] [bp-1Eh]@8
  float v50[3]; // [sp+5Ch] [bp-1Ch]@1
  int v51; // [sp+68h] [bp-10h]@8
  __int16 v52; // [sp+6Ch] [bp-Ch]@8
  int v53; // [sp+6Eh] [bp-Ah]@8

  v5 = a1;
  v38 = a2;
  *(_WORD *)(a3 + 396) = 2;
  v6 = v50;
  v7 = (float *)(a5 + 48);
  v8 = 3;
  do
  {
    if ( *(float *)(a5 + 8) >= (double)*v7 )
    {
      if ( *(float *)(a5 + 4) <= (double)*v7 )
        v9 = *v7;
      else
        v9 = *(float *)(a5 + 4);
    }
    else
    {
      v9 = *(float *)(a5 + 8);
    }
    *v6 = v9;
    ++v7;
    ++v6;
    --v8;
  }
  while ( v8 );
  v10 = *(_WORD *)(v5 + 8);
  v48 = 0;
  v11 = (((BYTE4(v10) & 3) + (signed int)v10) >> 2) - 10;
  v12 = *(_DWORD *)(v5 + 4) & 0x18;
  v46 = 105;
  v47 = 1423;
  v49 = 6;
  v51 = 96;
  LOWORD(v53) = 2;
  v52 = v11;
  if ( v12 == 16 )
  {
    v13 = *(_WORD *)a4;
    v14 = *(_WORD *)(v5 + 8) / 6;
    v15 = *(_WORD *)(v5 + 8) / 8;
    LOWORD(v39) = *(_WORD *)a4 + v15 + v14 - 2;
    v40 = 3 * v14 + v13 + v15 + 3;
    v41 = v13 + 5 * v14 + v15 + 8;
    v43 = a5 + 79;
    v42 = (char *)(a5 + 72);
    v44 = a5 + 86;
    v34 = v13 - v52 / 2 + v14 - 5;
    v31 = 3;
    v36 = v13 + 3 * v14 - v52 / 2;
    v37 = 5 * v14 - v52 / 2 + v13 + 5;
  }
  else if ( v12 == 8 )
  {
    v16 = *(_WORD *)a4;
    v17 = *(_WORD *)(v5 + 8) / 6;
    v18 = *(_WORD *)(v5 + 8) / 8;
    LOWORD(v39) = *(_WORD *)a4 + v18 + v17 + 3;
    v40 = 5 * v17 + v16 + v18 + 3;
    v42 = (char *)(a5 + 72);
    v43 = a5 + 79;
    v31 = 2;
    v34 = v17 + v16 - v52 / 2;
    v36 = v16 + 5 * v17 - v52 / 2;
  }
  else
  {
    v19 = *(_WORD *)a4;
    v20 = *(_WORD *)(v5 + 8) / 2;
    LOWORD(v39) = *(_WORD *)a4 + *(_WORD *)(v5 + 8) / 8 + v20 + 3;
    v42 = (char *)(a5 + 72);
    v31 = 1;
    v34 = v20 + v19 - (signed __int16)v11 / 2;
  }
  if ( v31 )
  {
    v21 = 0;
    v33 = (unsigned __int8)v31;
    do
    {
      if ( *(_BYTE *)(v21 + a5) )
      {
        v22 = (unsigned __int8)sub_1005C160(v5, (const void *)a5, v21) - 1;
        if ( v22 )
        {
          v23 = v22 - 1;
          if ( v23 )
          {
            if ( v23 == 1 )
              HIWORD(v53) = 2312;
          }
          else
          {
            HIWORD(v53) = 2411;
          }
        }
        else
        {
          HIWORD(v53) = 2543;
        }
        v24 = sub_100552F0(a4, a5, v5, v50[v21]);
        v25 = *(float *)(a5 + 4);
        v45 = v24;
        v26 = v25;
        v27 = sub_100552F0(a4, a5, v5, v26);
        v32 = (v27 - v45) / ((signed __int16)v53 + 1);
        *(&v35 + 2 * v21) = sub_100552F0(a4, a5, v5, *(float *)(a5 + 4)) - 3;
        if ( v32 )
        {
          v28 = v32;
          do
          {
            sub_10069D40(a3, (int)&v51, (int)(&v34 + 2 * v21), 0, (_WORD *)v38);
            *(&v35 + 2 * v21) += -1 - v53;
            --v28;
          }
          while ( v28 );
        }
        v29 = (*(_DWORD *)(v5 + 4) & 0x100) == 0;
        *((_WORD *)&v39 + 2 * v21 + 1) = *(_WORD *)(a4 + 2) + 12;
        if ( !v29 )
          sub_100698B0(a3, (int)&v46, (int)(&v39 + v21), (&v42)[4 * v21], v38);
      }
      ++v21;
      --v33;
    }
    while ( v33 );
  }
  return sub_10055130(a3, a4, v5, a5);
}
// 10055350: using guessed type float var_1C[3];

//----- (100556E0) --------------------------------------------------------
char __usercall sub_100556E0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4)
{
  int v4; // eax@1
  int v5; // eax@2
  int v6; // ecx@2
  int v7; // edx@2
  __int16 v8; // ST30_2@2
  __int16 v9; // ax@4
  __int16 v10; // cx@4
  int v11; // eax@6
  __int16 v12; // ax@9
  __int16 v13; // ax@11
  __int16 v14; // ax@11
  __int16 v15; // ST28_2@13
  __int16 v16; // ax@13
  __int16 v17; // ST28_2@13
  __int16 v18; // ax@13
  bool v19; // zf@13
  char v21; // [sp+Bh] [bp-25h]@2
  __int16 v22; // [sp+Ch] [bp-24h]@9
  __int16 v23; // [sp+Ch] [bp-24h]@11
  int v24; // [sp+10h] [bp-20h]@8
  int v25; // [sp+14h] [bp-1Ch]@7
  __int16 v26; // [sp+18h] [bp-18h]@11
  __int16 *v27; // [sp+1Ch] [bp-14h]@7
  signed int v28; // [sp+20h] [bp-10h]@8
  __int16 v29; // [sp+24h] [bp-Ch]@2
  __int16 v30; // [sp+26h] [bp-Ah]@2
  __int16 v31; // [sp+28h] [bp-8h]@2

  v4 = *(_DWORD *)(a1 + 4) & 0x18;
  if ( v4 == 16 )
  {
    v5 = *(_WORD *)(a1 + 8) / 6;
    v6 = *(_WORD *)(a1 + 8) / 8;
    v29 = *a4 - v6 + v5 - 5;
    v7 = 3 * v5 - v6;
    v8 = v6;
    LOWORD(v6) = *a4;
    v21 = 3;
    v30 = *a4 + v7;
    v31 = v6 + 5 * v5 + 5 - v8;
  }
  else if ( v4 == 8 )
  {
    v9 = *(_WORD *)(a1 + 8) / 6;
    v10 = *(_WORD *)(a1 + 8) / 8;
    v29 = v9 + *a4 - v10;
    v21 = 2;
    v30 = *a4 + 5 * v9 - v10;
  }
  else
  {
    v21 = 1;
    v29 = *a4 + *(_WORD *)(a1 + 8) / 2 - *(_WORD *)(a1 + 8) / 8;
  }
  LOBYTE(v11) = v21;
  if ( v21 )
  {
    v27 = &v29;
    v25 = (unsigned __int8)v21;
    do
    {
      v24 = (unsigned __int16)*v27;
      v28 = 2;
      do
      {
        *(_WORD *)(a3 + 440) = word_105728D8[15];
        *(_WORD *)(a3 + 442) = word_105728D8[15];
        *(_WORD *)(a3 + 428) = word_105728D8[15];
        *(_WORD *)(a3 + 430) = word_105728D8[15];
        v22 = sub_100552F0((int)a4, a2, a1, *(float *)(a2 + 16));
        v12 = sub_100552F0((int)a4, a2, a1, *(float *)(a2 + 20));
        if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 13) & 1 )
        {
          *(_WORD *)(a3 + 440) = word_105728D8[11];
          *(_WORD *)(a3 + 442) = word_105728D8[11];
          *(_WORD *)(a3 + 428) = word_105728D8[11];
          *(_WORD *)(a3 + 430) = word_105728D8[11];
          sub_1009E590(a3 + 392, v24, v12, 3, v22 - v12, 1);
        }
        v13 = sub_100552F0((int)a4, a2, a1, *(float *)(a2 + 12));
        *(_WORD *)(a3 + 440) = word_105728D8[8];
        *(_WORD *)(a3 + 442) = word_105728D8[8];
        *(_WORD *)(a3 + 428) = word_105728D8[8];
        *(_WORD *)(a3 + 430) = word_105728D8[8];
        sub_1009E590(a3 + 392, v24, v22, 3, v13 - v22, 1);
        v23 = sub_100552F0((int)a4, a2, a1, *(float *)(a2 + 24));
        v14 = sub_100552F0((int)a4, a2, a1, *(float *)(a2 + 28));
        v26 = v14;
        if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 13) & 1 )
        {
          *(_WORD *)(a3 + 440) = word_105728D8[11];
          *(_WORD *)(a3 + 442) = word_105728D8[11];
          *(_WORD *)(a3 + 428) = word_105728D8[11];
          *(_WORD *)(a3 + 430) = word_105728D8[11];
          sub_1009E590(a3 + 392, v24, v14, 3, v23 - v14, 1);
          v14 = v26;
        }
        v15 = v14;
        v16 = sub_100552F0((int)a4, a2, a1, *(float *)(a2 + 32));
        *(_WORD *)(a3 + 440) = word_105728D8[8];
        *(_WORD *)(a3 + 442) = word_105728D8[8];
        *(_WORD *)(a3 + 428) = word_105728D8[8];
        *(_WORD *)(a3 + 430) = word_105728D8[8];
        sub_1009E590(a3 + 392, v24, v16, 3, v15 - v16, 1);
        v17 = sub_100552F0((int)a4, a2, a1, *(float *)(a2 + 20));
        v18 = sub_100552F0((int)a4, a2, a1, *(float *)(a2 + 24));
        *(_WORD *)(a3 + 440) = word_105728D8[4];
        *(_WORD *)(a3 + 442) = word_105728D8[4];
        *(_WORD *)(a3 + 428) = word_105728D8[4];
        *(_WORD *)(a3 + 430) = word_105728D8[4];
        sub_1009E590(a3 + 392, v24, v18, 3, v17 - v18, 1);
        v11 = *(_WORD *)(a1 + 8) / 4;
        v19 = v28-- == 1;
        v24 = v24 + v11 - 3;
      }
      while ( !v19 );
      ++v27;
      --v25;
    }
    while ( v25 );
  }
  return v11;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10055B70) --------------------------------------------------------
char __cdecl sub_10055B70(int a1, int a2, _WORD *a3, int a4, _WORD *a5)
{
  int v5; // edx@2
  int v6; // ecx@2
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8041:
      v5 = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 60) = *(_DWORD *)(a4 + 48);
      v6 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a4 + 64) = v5;
      *(_DWORD *)(a4 + 68) = v6;
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_DWORD *)(a2 + 4) & 0x200 )
        sub_1005BCC0(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), (int)a3);
      sub_10054B20((int)a3, a2, a1, a5);
      sub_100556E0(a2, a4, a1, a3);
      if ( *(_DWORD *)(a2 + 4) & 0x400 )
        sub_10054EA0((int)a5, a4, a1, a2);
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10054F30((int)a5, (const void *)a4, a1, a2, (int)a3);
      sub_10054CD0((int)a5, (int)a3, a2, a1, (const void *)a4);
      sub_10055350(a2, (int)a5, a1, (int)a3, a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10054F30((int)a5, (const void *)a4, a1, a2, (int)a3);
      sub_10054CD0((int)a5, (int)a3, a2, a1, (const void *)a4);
      goto LABEL_13;
    default:
LABEL_13:
      result = 1;
      break;
  }
  return result;
}

//----- (10055D20) --------------------------------------------------------
char __usercall sub_10055D20@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  char v7; // bl@4
  int v8; // edi@5
  int v9; // eax@9
  char *v10; // edi@11
  char v11; // al@12
  __int16 v12; // cx@20
  char *v13; // eax@20
  char v14; // cl@21
  int v16; // [sp+Ch] [bp-38h]@20
  int v17; // [sp+10h] [bp-34h]@5
  int v18; // [sp+14h] [bp-30h]@22
  int v19; // [sp+18h] [bp-2Ch]@17
  __int16 v20; // [sp+1Ch] [bp-28h]@22
  __int16 v21; // [sp+1Eh] [bp-26h]@22
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  char v25[20]; // [sp+2Ch] [bp-18h]@10

  v24 = a4;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v23 = a2;
  v22 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v7 = 0;
  if ( v6 )
  {
    v8 = 0;
    v17 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1005C160(a3, a5, v8) > (unsigned __int8)v7 )
        v7 = sub_1005C160(a3, a5, v8);
      ++v8;
      --v17;
    }
    while ( v17 );
  }
  v9 = *(_DWORD *)(a3 + 4);
  if ( ~(unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7) & 1 )
  {
    sub_1005BD10(a3, (int)a5, v25);
    if ( *(_DWORD *)(a3 + 4) & 0x1000 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 32;
      sub_1005C490(*(_BYTE *)(a3 + 13), &v25[strlen(v25)]);
    }
  }
  else
  {
    if ( !(v9 & 0x1000) )
      return v9;
    sub_1005C490(*(_BYTE *)(a3 + 13), v25);
  }
  switch ( v7 )
  {
    case 3:
      v19 = byte_10658E06 != 0 ? 35087 : 35304;
      break;
    case 2:
      v19 = 35169;
      break;
    default:
      v19 = 35215;
      break;
  }
  v12 = *(_WORD *)v23 + *(_WORD *)(a3 + 8) / 2;
  v13 = v25;
  HIWORD(v16) = *(_WORD *)(a3 + 10) + *(_WORD *)(v23 + 2) + 18;
  LOWORD(v16) = v12;
  do
    v14 = *v13++;
  while ( v14 );
  v21 = (_WORD)v13 - (unsigned int)&v25[1];
  v18 = 105;
  v20 = 0;
  LOBYTE(v9) = sub_100698B0(v24, (int)&v18, (int)&v16, v25, v22);
  return v9;
}
// 10658E06: using guessed type char byte_10658E06;
// 10055D20: using guessed type char var_18[20];

//----- (10055EF0) --------------------------------------------------------
char __usercall sub_10055EF0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // esi@1
  signed int v6; // eax@1
  signed __int16 v7; // si@1
  float v8; // ST24_4@1
  double v9; // st7@1
  int v10; // edi@1
  char v11; // bl@1
  double v12; // st6@1
  unsigned int v13; // eax@1
  double v14; // st5@2
  int v15; // ebp@3
  int v16; // ebx@3
  int v17; // esi@3
  signed int v18; // edi@3
  char result; // al@4
  __int16 v20; // [sp+10h] [bp-64h]@1
  signed int v21; // [sp+14h] [bp-60h]@1
  float v22; // [sp+18h] [bp-5Ch]@1
  int v23; // [sp+1Ch] [bp-58h]@1
  __int16 v24; // [sp+20h] [bp-54h]@3
  __int16 v25; // [sp+22h] [bp-52h]@3
  float v26; // [sp+24h] [bp-50h]@1
  int v27; // [sp+28h] [bp-4Ch]@1
  int v28; // [sp+2Ch] [bp-48h]@1
  __int16 v29; // [sp+30h] [bp-44h]@2
  __int16 v30[7]; // [sp+32h] [bp-42h]@2
  float v31[4]; // [sp+40h] [bp-34h]@2
  char v32; // [sp+50h] [bp-24h]@1
  int v33; // [sp+54h] [bp-20h]@3
  char v34; // [sp+60h] [bp-14h]@1
  int v35; // [sp+64h] [bp-10h]@3

  v5 = a1;
  v27 = a3;
  v28 = a2;
  sub_1005C100(*(_BYTE *)(a1 + 13), (int)&v34, (int)&v32);
  v6 = *(_WORD *)(v5 + 8);
  v22 = *(float *)(a5 + 8);
  v7 = *(_WORD *)(v5 + 10);
  v8 = *(float *)(a5 + 4);
  v9 = v8;
  v23 = *(_WORD *)a4;
  v10 = v6 / 2;
  v11 = 1;
  v21 = 1;
  v26 = (v22 - v8) / 5.0;
  v12 = v26;
  v20 = *(_WORD *)(a4 + 2);
  v13 = 0;
  do
  {
    v14 = (double)v21++;
    *(__int16 *)((char *)&v29 + v13 * 2) = v23 + v10 + 2;
    v31[v13 / 2] = v14 * v12 + v9;
    v30[v13] = v7 + v20 - v7 / 5 * (unsigned __int8)v11++ + 2;
    v13 += 2;
  }
  while ( (unsigned __int8)v11 < 5u );
  v15 = v28;
  v16 = v27;
  v33 = 34191;
  v35 = 34191;
  v24 = v23 + v10 + 2;
  v25 = v20 + 2;
  sub_1006B030(v27, (int)&v32, (int *)&v24, &v22, v28);
  v17 = 0;
  v18 = 4;
  do
  {
    result = sub_1006B030(v16, (int)&v34, (int *)((char *)&v29 + v17 * 4), &v31[v17], v15);
    ++v17;
    --v18;
  }
  while ( v18 );
  return result;
}
// 10055EF0: using guessed type float var_34[4];
// 10055EF0: using guessed type __int16 var_42[7];

//----- (10056070) --------------------------------------------------------
char __usercall sub_10056070@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  int v7; // edi@5
  char *v8; // esi@5
  int v9; // eax@12
  int v10; // ecx@12
  int v11; // esi@12
  char result; // al@12
  int v13; // esi@13
  char *v14; // edi@13
  float *v15; // ebp@13
  double v16; // st7@16
  char v17; // [sp+Fh] [bp-61h]@4
  int v18; // [sp+10h] [bp-60h]@5
  int v19; // [sp+10h] [bp-60h]@13
  int v20; // [sp+14h] [bp-5Ch]@1
  int v21; // [sp+1Ch] [bp-54h]@1
  __int16 v22; // [sp+24h] [bp-4Ch]@12
  __int16 v23; // [sp+26h] [bp-4Ah]@12
  __int16 v24; // [sp+28h] [bp-48h]@12
  __int16 v25; // [sp+2Ah] [bp-46h]@12
  float v26[3]; // [sp+30h] [bp-40h]@18
  char v27; // [sp+3Ch] [bp-34h]@13
  char v28; // [sp+40h] [bp-30h]@5

  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v21 = a2;
  v20 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v17 = v6;
  if ( v6 )
  {
    v7 = 0;
    v8 = &v28;
    v18 = (unsigned __int8)v6;
    do
    {
      sub_1005C440(*(_BYTE *)(a3 + 13), (int)(v8 - 4));
      if ( *((_BYTE *)a5 + v7) )
      {
        switch ( sub_1005C160(a3, a5, v7) )
        {
          case 3:
            *(_DWORD *)v8 = byte_10658E06 != 0 ? 37135 : 37352;
            break;
          case 2:
            *(_DWORD *)v8 = 37217;
            break;
          default:
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        *(_DWORD *)v8 = 37263;
      }
      ++v7;
      v8 += 16;
      --v18;
    }
    while ( v18 );
  }
  v9 = *(_WORD *)(a3 + 8) / 6;
  v10 = *(_WORD *)v21;
  v11 = v10 + v9 - 8;
  v24 = v9 + v10 + 4 * v9 + 11;
  LOWORD(v9) = *(_WORD *)(a3 + 10) + *(_WORD *)(v21 + 2);
  v22 = v11;
  LOWORD(v9) = v9 + 18;
  v23 = v9;
  v25 = v9;
  result = v17;
  if ( v17 )
  {
    v13 = 0;
    v14 = &v27;
    v15 = (float *)((char *)a5 + 60);
    v19 = (unsigned __int8)v17;
    do
    {
      if ( *((_BYTE *)a5 + v13) && sub_1005C160(a3, a5, v13) )
        v16 = *v15;
      else
        v16 = 9.8999998e24;
      v26[v13] = v16;
      result = sub_1006B030(a4, (int)v14, (int *)&v22 + v13, &v26[v13], v20);
      ++v13;
      ++v15;
      v14 += 16;
      --v19;
    }
    while ( v19 );
  }
  return result;
}
// 10658E06: using guessed type char byte_10658E06;
// 10056070: using guessed type float var_40[3];

//----- (10056200) --------------------------------------------------------
__int16 __usercall sub_10056200@<ax>(int a1@<edi>, int a2, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  __int16 result; // ax@1
  signed int v6; // eax@2
  __int16 v7; // bx@2
  __int16 v8; // ST2C_2@2
  __int16 v9; // si@2
  __int16 v10; // ST18_2@2
  __int16 v11; // [sp+Ch] [bp-4h]@1
  int i; // [sp+14h] [bp+4h]@1

  *(_WORD *)(a1 + 394) = 1;
  *(_WORD *)(a1 + 428) = word_105728D8[15];
  *(_WORD *)(a1 + 430) = word_105728D8[15];
  v3 = a2;
  v4 = *(_BYTE *)(a2 + 12);
  result = *(_WORD *)a3 + *(_WORD *)(a2 + 8) / 4 - 4;
  v11 = *(_WORD *)a3 + *(_WORD *)(a2 + 8) / 4 - 4;
  for ( i = 0; i < v4; ++i )
  {
    v6 = (signed int)((double)*(_WORD *)(v3 + 8) * 0.12);
    v7 = v6;
    v8 = *(_WORD *)a3 + 3 * (*(_WORD *)(v3 + 8) / 4 + 3) - v6;
    LOWORD(v6) = i * (*(_WORD *)(v3 + 10) / (v4 - 1));
    v9 = *(_WORD *)(a3 + 2) + v6;
    v10 = *(_WORD *)(a3 + 2) + v6;
    *(_WORD *)(a1 + 438) = v11;
    *(_WORD *)(a1 + 436) = v9;
    sub_1009E7F0(a1 + 392, v7 + v11, v10, 0);
    *(_WORD *)(a1 + 438) = v8;
    *(_WORD *)(a1 + 436) = v9;
    sub_1009E7F0(a1 + 392, v7 + v8, v9, 0);
    v4 = *(_BYTE *)(v3 + 12);
    result = i + 1;
  }
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10056330) --------------------------------------------------------
int __usercall sub_10056330@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>, _BYTE *a4)
{
  _BYTE *v4; // ebp@1
  _BYTE *v5; // eax@2
  int v6; // ecx@2
  int result; // eax@2
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  __int16 v10; // [sp+4h] [bp-4h]@2
  __int16 v11; // [sp+6h] [bp-2h]@2

  v4 = a4;
  if ( !*a4 )
  {
    v5 = (_BYTE *)*a2;
    v6 = *a2 + 24;
    a4 = v5;
    v11 = *(_WORD *)(a3 + 10) + HIWORD(v5);
    v10 = v6;
    result = sub_1006D760(a1, (int)&a4, (int)&v10, 0);
  }
  if ( !v4[1] )
  {
    v8 = *(_WORD *)(a3 + 8);
    a4 = (_BYTE *)*a2;
    v9 = HIWORD(a4) + *(_WORD *)(a3 + 10);
    LOWORD(a4) = v8 - 24 + (_WORD)a4;
    v10 = (_WORD)a4 + 24;
    v11 = v9;
    result = sub_1006D760(a1, (int)&a4, (int)&v10, 0);
  }
  return result;
}

//----- (100563C0) --------------------------------------------------------
int __usercall sub_100563C0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, float a4)
{
  int v4; // edx@1
  int v5; // esi@1
  int v7; // [sp+8h] [bp+4h]@2

  v4 = *(_WORD *)(a1 + 2);
  v5 = v4 + *(_WORD *)(a3 + 10);
  if ( *(float *)(a2 + 8) - *(float *)(a2 + 4) != 0.0 )
  {
    *(float *)&v7 = (a4 - *(float *)(a2 + 4)) / (*(float *)(a2 + 8) - *(float *)(a2 + 4));
    v5 -= (signed int)(*(float *)&v7 * (double)(v5 - v4 - 1));
  }
  return v5;
}

//----- (10056420) --------------------------------------------------------
void __cdecl sub_10056420(int a1, int a2, int a3, int a4, float a5, float a6)
{
  char v6; // [sp+15h] [bp-133h]@1
  char v7; // [sp+16h] [bp-132h]@1
  char v8; // [sp+17h] [bp-131h]@1
  float v9; // [sp+18h] [bp-130h]@2
  float v10; // [sp+1Ch] [bp-12Ch]@5
  int v11; // [sp+20h] [bp-128h]@11
  __int16 v12; // [sp+24h] [bp-124h]@11
  __int16 v13; // [sp+26h] [bp-122h]@11
  __int16 v14; // [sp+28h] [bp-120h]@11
  __int16 v15; // [sp+2Ah] [bp-11Eh]@11
  __int16 v16; // [sp+2Ch] [bp-11Ch]@11
  __int16 v17; // [sp+2Eh] [bp-11Ah]@11
  __int16 v18; // [sp+30h] [bp-118h]@11
  __int16 v19; // [sp+32h] [bp-116h]@11
  __int16 v20; // [sp+34h] [bp-114h]@11
  __int16 v21; // [sp+36h] [bp-112h]@11
  __int16 v22; // [sp+38h] [bp-110h]@11
  __int16 v23; // [sp+3Ah] [bp-10Eh]@11
  __int16 v24; // [sp+3Ch] [bp-10Ch]@11
  __int16 v25; // [sp+3Eh] [bp-10Ah]@11
  __int16 v26; // [sp+40h] [bp-108h]@11
  __int16 v27; // [sp+42h] [bp-106h]@11
  float v28; // [sp+44h] [bp-104h]@1
  char v29; // [sp+48h] [bp-100h]@11

  v28 = 0.93199998;
  v7 = 0;
  sub_1009C2B0(7, &v8);
  sub_1009BA00(9041, &v6, 1, &v7);
  if ( v6 )
  {
    sub_1009BA00(9040, &v9, 4, &v28);
  }
  else
  {
    sub_1009BA00(9040, &v9, 4, &v28);
    v6 = 0;
    sub_1009B9C0(9040, (int)&v9, 4);
    sub_1009B9C0(9041, (int)&v6, 1);
  }
  if ( v8 )
  {
    v10 = v9;
  }
  else
  {
    if ( !sub_10075ED0(0x57u, &v10) )
      v10 = v9;
    if ( v10 != v9 )
    {
      v6 = 1;
      sub_1009B9C0(9040, (int)&v9, 4);
      sub_1009B9C0(9041, (int)&v6, 1);
    }
  }
  if ( *(_BYTE *)(a2 + 13) == 13 )
  {
    *(_WORD *)(a1 + 440) = word_105728D8[6];
    *(_WORD *)(a1 + 442) = word_105728D8[6];
    LOWORD(v11) = (signed int)a5;
    HIWORD(v11) = sub_100563C0(a3, a4, a2, v10);
    v12 = (signed int)a5;
    v14 = v11 - 5;
    v16 = v11 - 5;
    v20 = v11 - 5;
    v22 = v11 - 5;
    v13 = HIWORD(v11) - 6;
    v15 = HIWORD(v11) - 6;
    v23 = HIWORD(v11) + 6;
    v25 = HIWORD(v11) + 6;
    v17 = HIWORD(v11) - 4;
    v21 = HIWORD(v11) + 4;
    v18 = v11 - 2;
    v19 = HIWORD(v11);
    v24 = (signed int)a5;
    v26 = (signed int)a5;
    v27 = HIWORD(v11);
    sub_1009ED40(a1 + 392, 9, (int)&v11, 64, (int)&v29);
    LOWORD(v11) = (signed int)(a6 + 1.0);
    HIWORD(v11) = sub_100563C0(a3, a4, a2, v10);
    v12 = (signed int)(a6 + 1.0);
    v13 = HIWORD(v11) - 6;
    v15 = HIWORD(v11) - 6;
    v14 = v11 + 5;
    v16 = v11 + 5;
    v17 = HIWORD(v11) - 4;
    v18 = v11 + 2;
    v19 = HIWORD(v11);
    v20 = v11 + 5;
    v22 = v11 + 5;
    v23 = HIWORD(v11) + 6;
    v25 = HIWORD(v11) + 6;
    v21 = HIWORD(v11) + 4;
    v24 = (signed int)(a6 + 1.0);
    v26 = (signed int)(a6 + 1.0);
    v27 = HIWORD(v11);
    sub_1009ED40(a1 + 392, 9, (int)&v11, 64, (int)&v29);
  }
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (100566F0) --------------------------------------------------------
signed int __usercall sub_100566F0@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  _BYTE *v6; // esi@1
  float *v7; // edx@1
  float *v8; // ecx@1
  double v9; // st7@4
  int v10; // eax@10
  int v11; // ecx@10
  int v12; // edx@10
  int v13; // ecx@10
  unsigned __int8 v14; // al@10
  int v15; // esi@11
  int v16; // eax@12
  int v17; // eax@13
  __int16 v18; // ax@18
  char *v19; // ebx@18
  _WORD *v20; // ST10_4@18
  __int16 *v21; // esi@18
  __int16 v22; // ax@18
  __int16 v23; // bx@21
  signed int result; // eax@23
  unsigned __int8 v25; // [sp+17h] [bp-129h]@10
  int v26; // [sp+1Ch] [bp-124h]@18
  __int16 v27; // [sp+20h] [bp-120h]@19
  __int16 v28; // [sp+22h] [bp-11Eh]@21
  __int16 v29; // [sp+24h] [bp-11Ch]@21
  __int16 v30; // [sp+26h] [bp-11Ah]@21
  __int16 v31; // [sp+28h] [bp-118h]@21
  __int16 v32; // [sp+2Ah] [bp-116h]@21
  int v33; // [sp+2Ch] [bp-114h]@1
  int v34; // [sp+30h] [bp-110h]@1
  _WORD *v35; // [sp+34h] [bp-10Ch]@1
  __int16 v36; // [sp+38h] [bp-108h]@10
  char v37[2]; // [sp+3Ah] [bp-106h]@18
  __int16 v38; // [sp+3Ch] [bp-104h]@10
  float v39[3]; // [sp+44h] [bp-FCh]@1
  char v40; // [sp+50h] [bp-F0h]@21
  int v41; // [sp+130h] [bp-10h]@10
  __int16 v42; // [sp+134h] [bp-Ch]@10
  __int16 v43; // [sp+136h] [bp-Ah]@18
  __int16 v44; // [sp+138h] [bp-8h]@15

  v5 = a1;
  v35 = (_WORD *)a2;
  v34 = a1;
  *(_WORD *)(a3 + 396) = 2;
  v6 = (_BYTE *)a5;
  v7 = v39;
  v8 = (float *)(a5 + 48);
  v33 = 3;
  do
  {
    if ( *v6 )
    {
      if ( *(float *)(a5 + 8) >= (double)*v8 )
      {
        if ( *(float *)(a5 + 4) <= (double)*v8 )
          v9 = *v8;
        else
          v9 = *(float *)(a5 + 4);
      }
      else
      {
        v9 = *(float *)(a5 + 8);
      }
      *v7 = v9;
    }
    ++v6;
    ++v8;
    ++v7;
    --v33;
  }
  while ( v33 );
  v10 = *(_WORD *)(v5 + 8) / 6;
  v11 = *(_WORD *)a4;
  v12 = v11 + v10 - 10;
  v13 = v10 + 2 + v11 + 4 * (v10 + 2);
  v14 = 0;
  *(_WORD *)(a3 + 426) = 2;
  *(_WORD *)(a3 + 424) = 2;
  v41 = 96;
  v42 = 4;
  v36 = v12;
  v38 = v13;
  v25 = 0;
  do
  {
    v15 = v14;
    if ( !*(_BYTE *)(v14 + a5) )
      goto LABEL_22;
    v16 = (unsigned __int8)sub_1005C160(v5, (const void *)a5, v14) - 1;
    if ( !v16 )
    {
LABEL_17:
      v44 = 2543;
      *(_WORD *)(a3 + 440) = word_105728D8[15];
      *(_WORD *)(a3 + 442) = word_105728D8[15];
      goto LABEL_18;
    }
    v17 = v16 - 1;
    if ( v17 )
    {
      if ( v17 != 1 )
        goto LABEL_17;
      v44 = 2312;
      *(_WORD *)(a3 + 440) = word_105728D8[15];
      *(_WORD *)(a3 + 442) = word_105728D8[8];
    }
    else
    {
      v44 = 2411;
      *(_WORD *)(a3 + 440) = word_105728D8[15];
      *(_WORD *)(a3 + 442) = word_105728D8[11];
    }
LABEL_18:
    v18 = sub_100563C0(a4, a5, v5, v39[v15]);
    v19 = &v37[4 * v15];
    v43 = *(_WORD *)(v34 + 10) + *(_WORD *)(a4 + 2) - v18;
    v20 = v35;
    *(_WORD *)v19 = v18;
    v21 = &v36 + 2 * v15;
    sub_10069D40(a3, (int)&v41, (int)v21, 0, v20);
    v22 = *v21 + 1;
    LOWORD(v26) = *v21 + 1;
    if ( v25 )
      v27 = v26 - 11;
    else
      v27 = v26 + 12;
    v23 = *(_WORD *)v19;
    v29 = v22;
    v31 = v22;
    HIWORD(v26) = v23;
    v30 = v23 + 12;
    v28 = v23;
    v32 = v23;
    sub_1009ED40(a3 + 392, 4, (int)&v26, 56, (int)&v40);
    v5 = v34;
    v14 = v25;
LABEL_22:
    v25 = ++v14;
  }
  while ( v14 < 2u );
  sub_10056330(a3, (_DWORD *)a4, v5, (_BYTE *)a5);
  result = 1;
  *(_WORD *)(a3 + 426) = 1;
  *(_WORD *)(a3 + 424) = 1;
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];
// 100566F0: using guessed type float var_FC[3];
// 100566F0: using guessed type char var_106[2];

//----- (100569B0) --------------------------------------------------------
int __usercall sub_100569B0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, __int16 *a4)
{
  __int16 v4; // cx@1
  __int16 v5; // ax@1
  __int16 v6; // ax@2
  __int16 v7; // ST0C_2@3
  __int16 v8; // ax@4
  __int16 v9; // ax@4
  __int16 v10; // ST24_2@6
  __int16 v11; // ax@6
  __int16 v12; // ST04_2@6
  __int16 v13; // ST24_2@6
  __int16 v14; // ax@6
  int result; // eax@6
  __int16 v16; // [sp+8h] [bp-1Ch]@2
  __int16 v17; // [sp+8h] [bp-1Ch]@4
  __int16 *v18; // [sp+Ch] [bp-18h]@1
  __int16 v19; // [sp+10h] [bp-14h]@4
  signed int v20; // [sp+14h] [bp-10h]@1
  __int16 v21; // [sp+18h] [bp-Ch]@1
  __int16 v22; // [sp+1Ah] [bp-Ah]@1

  v4 = *a4;
  v5 = *(_WORD *)(a1 + 8) / 4;
  v21 = *a4 + v5 - 4;
  v22 = v5 + v4 + 2 * v5 + 5;
  v18 = &v21;
  v20 = 2;
  do
  {
    *(_WORD *)(a3 + 440) = word_105728D8[15];
    *(_WORD *)(a3 + 442) = word_105728D8[15];
    *(_WORD *)(a3 + 428) = word_105728D8[15];
    *(_WORD *)(a3 + 430) = word_105728D8[15];
    v16 = sub_100563C0((int)a4, a2, a1, *(float *)(a2 + 16));
    v6 = sub_100563C0((int)a4, a2, a1, *(float *)(a2 + 20));
    if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 13) & 1 )
    {
      *(_WORD *)(a3 + 440) = word_105728D8[11];
      *(_WORD *)(a3 + 442) = word_105728D8[11];
      *(_WORD *)(a3 + 428) = word_105728D8[11];
      v7 = *v18;
      *(_WORD *)(a3 + 430) = word_105728D8[11];
      sub_1009E590(a3 + 392, v7, v6, 6, v16 - v6, 1);
    }
    v8 = sub_100563C0((int)a4, a2, a1, *(float *)(a2 + 12));
    *(_WORD *)(a3 + 440) = word_105728D8[8];
    *(_WORD *)(a3 + 442) = word_105728D8[8];
    *(_WORD *)(a3 + 428) = word_105728D8[8];
    *(_WORD *)(a3 + 430) = word_105728D8[8];
    sub_1009E590(a3 + 392, *v18, v16, 6, v8 - v16, 1);
    v17 = sub_100563C0((int)a4, a2, a1, *(float *)(a2 + 24));
    v9 = sub_100563C0((int)a4, a2, a1, *(float *)(a2 + 28));
    v19 = v9;
    if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 13) & 1 )
    {
      *(_WORD *)(a3 + 440) = word_105728D8[11];
      *(_WORD *)(a3 + 442) = word_105728D8[11];
      *(_WORD *)(a3 + 428) = word_105728D8[11];
      *(_WORD *)(a3 + 430) = word_105728D8[11];
      sub_1009E590(a3 + 392, *v18, v9, 6, v17 - v9, 1);
      v9 = v19;
    }
    v10 = v9;
    v11 = sub_100563C0((int)a4, a2, a1, *(float *)(a2 + 32));
    *(_WORD *)(a3 + 440) = word_105728D8[8];
    *(_WORD *)(a3 + 442) = word_105728D8[8];
    *(_WORD *)(a3 + 428) = word_105728D8[8];
    v12 = *v18;
    *(_WORD *)(a3 + 430) = word_105728D8[8];
    sub_1009E590(a3 + 392, v12, v11, 6, v10 - v11, 1);
    v13 = sub_100563C0((int)a4, a2, a1, *(float *)(a2 + 20));
    v14 = sub_100563C0((int)a4, a2, a1, *(float *)(a2 + 24));
    *(_WORD *)(a3 + 440) = word_105728D8[4];
    *(_WORD *)(a3 + 442) = word_105728D8[4];
    *(_WORD *)(a3 + 428) = word_105728D8[4];
    *(_WORD *)(a3 + 430) = word_105728D8[4];
    result = sub_1009E590(a3 + 392, *v18, v14, 6, v13 - v14, 1);
    ++v18;
    --v20;
  }
  while ( v20 );
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10056D50) --------------------------------------------------------
void __usercall sub_10056D50(int a1@<esi>, int a2, int a3, int a4)
{
  __int16 *v4; // ebp@1
  __int16 v5; // ax@1
  signed int v6; // kr00_4@1
  __int16 v7; // dx@1
  __int16 v8; // ST2C_2@1
  __int16 v9; // di@1
  __int16 v10; // bx@1
  float v11; // ST1C_4@1
  float v12; // ST18_4@1
  int v13; // [sp+20h] [bp+8h]@1

  *(_WORD *)(a1 + 394) = 1;
  *(_WORD *)(a1 + 428) = word_105728D8[15];
  *(_WORD *)(a1 + 430) = word_105728D8[15];
  v4 = (__int16 *)a3;
  v5 = *(_WORD *)(a3 + 2);
  v13 = (unsigned __int16)(v5 + *(_WORD *)(a2 + 10));
  v6 = *(_WORD *)(a2 + 8);
  v7 = *v4;
  v8 = v5;
  *(_WORD *)(a1 + 436) = v5;
  v9 = v7 + v6 / 4 - 4;
  v10 = v6 / 4 + 3 + v7 + 2 * (v6 / 4 + 3);
  *(_WORD *)(a1 + 438) = v9;
  sub_1009E7F0(a1 + 392, v9, v13, 0);
  *(_WORD *)(a1 + 438) = v10;
  *(_WORD *)(a1 + 436) = v8;
  sub_1009E7F0(a1 + 392, v10, v13, 0);
  v11 = (double)v10;
  v12 = (double)v9;
  sub_10056420(a1, a2, (int)v4, a4, v12, v11);
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10056E50) --------------------------------------------------------
char __cdecl sub_10056E50(int a1, int a2, __int16 *a3, int a4, _WORD *a5)
{
  _BYTE *v5; // ecx@2
  int v6; // eax@2
  signed int v7; // edx@2
  double v8; // st7@3
  char result; // al@4

  switch ( *a5 )
  {
    case 0x8041:
      v5 = (_BYTE *)(a4 + 93);
      v6 = a4 + 60;
      v7 = 3;
      do
      {
        v8 = *(float *)(v6 - 12);
        v6 += 4;
        *(float *)(v6 - 4) = v8;
        *v5++ = 0;
        --v7;
      }
      while ( v7 );
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_DWORD *)(a2 + 4) & 0x200 )
        sub_1005BCC0(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), (int)a3);
      sub_10056D50(a1, a2, (int)a3, a4);
      if ( *(_BYTE *)(a2 + 4) & 0x40 )
        sub_10056200(a1, a2, (int)a3);
      sub_100569B0(a2, a4, a1, a3);
      if ( *(_DWORD *)(a2 + 4) & 0x400 )
        sub_10055EF0(a2, (int)a5, a1, (int)a3, a4);
      sub_10055D20((int)a5, (int)a3, a2, a1, (const void *)a4);
      sub_100566F0(a2, (int)a5, a1, (int)a3, a4);
      if ( !(*(_DWORD *)(a2 + 4) & 0x800) )
        goto LABEL_16;
      sub_10056070((int)a5, (int)a3, a2, a1, (const void *)a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10056070((int)a5, (int)a3, a2, a1, (const void *)a4);
      sub_10055D20((int)a5, (int)a3, a2, a1, (const void *)a4);
      goto LABEL_16;
    default:
LABEL_16:
      result = 1;
      break;
  }
  return result;
}

//----- (10057020) --------------------------------------------------------
char __usercall sub_10057020@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // eax@1
  char v6; // cl@2
  bool v7; // al@3
  int v8; // edi@5
  int v9; // ebx@5
  unsigned int v10; // eax@10
  char *v11; // eax@12
  char *v12; // edx@12
  char v13; // cl@13
  char v14; // al@15
  char *v15; // edi@29
  char v16; // al@30
  unsigned int v17; // edi@45
  int v18; // eax@45
  __int16 v19; // ax@46
  int v20; // eax@48
  __int16 v21; // cx@48
  char *v22; // eax@51
  char v23; // cl@52
  int v24; // edi@56
  int v25; // esi@56
  char v27; // [sp+Eh] [bp-42h]@2
  char v28; // [sp+Fh] [bp-41h]@4
  int v29; // [sp+10h] [bp-40h]@46
  int v30; // [sp+14h] [bp-3Ch]@1
  int v31; // [sp+18h] [bp-38h]@53
  int v32; // [sp+1Ch] [bp-34h]@39
  __int16 v33; // [sp+20h] [bp-30h]@53
  __int16 v34; // [sp+22h] [bp-2Eh]@53
  int v35; // [sp+24h] [bp-2Ch]@1
  int v36; // [sp+28h] [bp-28h]@1
  char v37[4]; // [sp+2Ch] [bp-24h]@12
  char v38; // [sp+40h] [bp-10h]@32

  v36 = a3;
  v5 = *(_DWORD *)(a4 + 4) & 0x18;
  v30 = a2;
  v35 = a1;
  if ( v5 == 16 )
  {
    v6 = 3;
    v27 = 3;
  }
  else
  {
    v7 = v5 == 8;
    v27 = v7 + 1;
    v6 = v7 + 1;
  }
  v28 = 0;
  if ( v6 )
  {
    v8 = 0;
    v9 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1005C160(a4, (const void *)a5, v8) > (unsigned __int8)v28 )
        v28 = sub_1005C160(a4, (const void *)a5, v8);
      ++v8;
      --v9;
    }
    while ( v9 );
    v6 = v27;
  }
  v10 = *(_DWORD *)(a4 + 4);
  if ( !(~(unsigned __int8)(*(_DWORD *)(a4 + 4) >> 7) & 1) )
  {
    if ( !(v10 & 0x1000) )
      return v10;
    sub_1005C490(*(_BYTE *)(a4 + 13), v37);
    goto LABEL_36;
  }
  if ( !(~(unsigned __int8)(v10 >> 14) & 1) )
  {
    v11 = sub_10070850(*(_WORD *)(a5 + 40));
    v12 = v37;
    do
    {
      v13 = *v11;
      *v12++ = *v11++;
    }
    while ( v13 );
    goto LABEL_26;
  }
  v14 = *(_BYTE *)(a4 + 13);
  if ( v14 != 2 || v6 != 1 )
  {
    if ( v14 != 3 || v6 != 1 )
    {
      if ( v14 != 8 && v14 != 7 || v6 != 1 )
      {
        sub_1005BD10(a4, a5, v37);
LABEL_26:
        v6 = v27;
        goto LABEL_27;
      }
      strcpy(v37, "OIL");
    }
    else
    {
      strcpy(v37, "FPRES");
    }
  }
  else
  {
    strcpy(v37, "FFLOW");
  }
LABEL_27:
  if ( !(*(_DWORD *)(a4 + 4) & 0x1000) )
    goto LABEL_37;
  if ( v6 == 2 )
  {
    sub_1005C490(*(_BYTE *)(a4 + 13), &v38);
    goto LABEL_33;
  }
  v15 = (char *)&v36 + 3;
  do
    v16 = (v15++)[1];
  while ( v16 );
  *(_WORD *)v15 = 32;
  sub_1005C490(*(_BYTE *)(a4 + 13), &v37[strlen(v37)]);
LABEL_36:
  v6 = v27;
LABEL_37:
  if ( v6 != 1 )
  {
LABEL_33:
    switch ( v28 )
    {
      case 3:
        v32 = byte_10658E06 != 0 ? 35087 : 35304;
        break;
      case 2:
        v32 = 35169;
        break;
      default:
        v32 = 35215;
        break;
    }
    goto LABEL_45;
  }
  switch ( v28 )
  {
    case 3:
      v32 = byte_10658E06 != 0 ? 2319 : 2536;
      break;
    case 2:
      v32 = 2401;
      break;
    default:
      v32 = 2447;
      break;
  }
LABEL_45:
  v17 = *(_DWORD *)(a4 + 4);
  v18 = *(_DWORD *)(a4 + 4) & 0x18;
  if ( v18 == 16 )
  {
    v19 = *(_WORD *)(v30 + 2) - 8;
    LOWORD(v29) = *(_WORD *)v30 + *(_WORD *)(a4 + 8) / 2;
    HIWORD(v29) = v19;
  }
  else
  {
    if ( v18 == 8 )
    {
      v20 = v30;
      v21 = *(_WORD *)v30 + *(_WORD *)(a4 + 8) / 2 + 1;
    }
    else
    {
      v20 = v30;
      v21 = *(_WORD *)v30;
    }
    HIWORD(v29) = *(_WORD *)(v20 + 2) + 19;
    LOWORD(v29) = v21;
  }
  v22 = v37;
  do
    v23 = *v22++;
  while ( v23 );
  v34 = (_WORD)v22 - (unsigned int)&v37[1];
  v31 = 105;
  v33 = 0;
  if ( v27 == 2 && v17 & 0x1000 && ~(unsigned __int8)(v17 >> 7) & 1 )
  {
    v24 = v35;
    v25 = v36;
    sub_100698B0(v36, (int)&v31, (int)&v29, &v38, v35);
    HIWORD(v29) = *(_WORD *)(v30 + 2);
    LOBYTE(v10) = sub_100698B0(v25, (int)&v31, (int)&v29, v37, v24);
  }
  else
  {
    LOBYTE(v10) = sub_100698B0(v36, (int)&v31, (int)&v29, v37, v35);
  }
  return v10;
}
// 10658E06: using guessed type char byte_10658E06;

//----- (100573C0) --------------------------------------------------------
unsigned __int8 __usercall sub_100573C0@<al>(int a1@<eax>, int a2@<ecx>, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // eax@1
  unsigned __int8 result; // al@2
  _WORD *v7; // esi@5
  _BYTE *v8; // edi@5
  int v9; // ebx@5
  __int16 v10; // dx@7
  __int16 v11; // [sp+4h] [bp-Ch]@7
  __int16 v12; // [sp+6h] [bp-Ah]@4
  __int16 v13; // [sp+8h] [bp-8h]@7
  int v14; // [sp+Ah] [bp-6h]@4

  v5 = *(_DWORD *)(a1 + 4) & 0x18;
  if ( v5 == 16 )
    result = 3;
  else
    result = (v5 == 8) + 1;
  LOWORD(v14) = *(_WORD *)(a2 + 2) + 4;
  v12 = v14 + 18;
  if ( result )
  {
    v7 = a5;
    v8 = a4;
    v9 = result;
    do
    {
      if ( !*v8 )
      {
        v10 = *v7 - 36;
        v11 = *v7 + 12;
        v13 = v10;
        result = sub_1006D760(a3, (int)&v13, (int)&v11, 0);
      }
      ++v8;
      v7 += 2;
      --v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (10057450) --------------------------------------------------------
unsigned __int8 __usercall sub_10057450@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  _BYTE *v5; // ebx@1
  int v6; // eax@1
  char *v7; // esi@5
  int v8; // edi@5
  int v9; // edx@7
  int v10; // edi@9
  int *v11; // esi@9
  signed int v12; // eax@22
  char v13; // dl@25
  __int16 v14; // cx@29
  char *v15; // eax@29
  int v16; // ecx@31
  int v17; // eax@31
  signed int v18; // edi@32
  __int16 v19; // si@32
  int v20; // edx@32
  int v21; // eax@34
  int v22; // esi@37
  char *v23; // edi@37
  float *v24; // ebx@37
  double v25; // st7@40
  float *v26; // ecx@42
  char v28; // [sp+13h] [bp-61h]@2
  int v29; // [sp+14h] [bp-60h]@9
  int v30; // [sp+14h] [bp-60h]@37
  int v31; // [sp+1Ch] [bp-58h]@1
  __int16 v32; // [sp+24h] [bp-50h]@31
  char v33; // [sp+26h] [bp-4Eh]@29
  __int16 v34; // [sp+28h] [bp-4Ch]@35
  __int16 v35; // [sp+2Ch] [bp-48h]@32
  int v36; // [sp+30h] [bp-44h]@1
  char v37[12]; // [sp+34h] [bp-40h]@42
  char v38; // [sp+40h] [bp-34h]@5
  unsigned int v39; // [sp+44h] [bp-30h]@9
  char v40; // [sp+48h] [bp-2Ch]@37

  v5 = (_BYTE *)a5;
  v6 = *(_DWORD *)(a4 + 4) & 0x18;
  v31 = a2;
  v36 = a1;
  if ( v6 == 16 )
    v28 = 3;
  else
    v28 = (v6 == 8) + 1;
  if ( v28 )
  {
    v7 = &v38;
    v8 = (unsigned __int8)v28;
    do
    {
      sub_1005C440(*(_BYTE *)(a4 + 13), (int)v7);
      v7 += 16;
      --v8;
    }
    while ( v8 );
  }
  LOBYTE(v9) = v28;
  if ( (unsigned __int8)v28 <= 1u )
  {
    if ( v28 != 1 )
      goto LABEL_28;
    if ( *(_BYTE *)a5 )
    {
      switch ( sub_1005C160(a4, (const void *)a5, 0) )
      {
        case 3:
          v12 = byte_10658E06 != 0 ? 20751 : 20968;
          break;
        case 2:
          v12 = 20833;
          break;
        default:
          goto LABEL_24;
      }
    }
    else
    {
LABEL_24:
      v12 = 20879;
    }
    v13 = ~*(_BYTE *)(a4 + 6);
    v39 = v12;
    if ( !(v13 & 1) )
      v39 = *(_DWORD *)(a5 + 44) | v12 & 0xFFFF3FFF;
  }
  else
  {
    if ( !v28 )
      goto LABEL_31;
    v10 = 0;
    v11 = (int *)&v39;
    v29 = (unsigned __int8)v28;
    do
    {
      if ( *(_BYTE *)(v10 + a5) )
      {
        switch ( sub_1005C160(a4, (const void *)a5, v10) )
        {
          case 3:
            *v11 = byte_10658E06 != 0 ? 37135 : 37352;
            break;
          case 2:
            *v11 = 37217;
            break;
          default:
            goto LABEL_14;
        }
      }
      else
      {
LABEL_14:
        *v11 = 37263;
      }
      if ( !(~*(_BYTE *)(a4 + 6) & 1) )
        *v11 = *(_DWORD *)(a5 + 44) | *v11 & 0xFFFF3FFF;
      ++v10;
      v11 += 4;
      --v29;
    }
    while ( v29 );
  }
  LOBYTE(v9) = v28;
LABEL_28:
  if ( (_BYTE)v9 )
  {
    v14 = *(_WORD *)(v31 + 2) + 19;
    v15 = &v33;
    v9 = (unsigned __int8)v9;
    do
    {
      *(_WORD *)v15 = v14;
      v15 += 4;
      --v9;
    }
    while ( v9 );
  }
LABEL_31:
  v16 = *(_WORD *)v31;
  v17 = *(_DWORD *)(a4 + 4) & 0x18;
  v32 = v16 + *(_WORD *)(a4 + 8);
  if ( v17 == 16 )
  {
    v18 = *(_WORD *)(a4 + 8);
    v19 = *(_WORD *)(a4 + 8) / 6;
    v32 = v16 + v19 + 1;
    v20 = v18 / 2 + v16 + 1;
    v35 = v19 + v16 + 4 * v19 + 1;
  }
  else
  {
    if ( v17 != 8 )
      goto LABEL_36;
    v21 = *(_WORD *)(a4 + 8) / 6;
    v32 = v16 + v21 - 7;
    v20 = v21 + v16 + 4 * v21 + 9;
  }
  v34 = v20;
LABEL_36:
  if ( v28 )
  {
    v22 = 0;
    v23 = &v40;
    v24 = (float *)(a5 + 60);
    v30 = (unsigned __int8)v28;
    do
    {
      if ( *(_BYTE *)(v22 + a5) && sub_1005C160(a4, (const void *)a5, v22) )
        v25 = *v24;
      else
        v25 = 9.8999998e24;
      v26 = (float *)&v37[4 * v22];
      *v26 = v25;
      if ( 9.8999998e24 != *v26 && *(_BYTE *)(v22 + a5) )
      {
        if ( *(_DWORD *)(a4 + 4) & 0x40000 )
          *(_WORD *)v23 &= 0xFDFFu;
        sub_1006B030(a3, (int)(v23 - 8), (int *)&v32 + v22, (float *)&v37[4 * v22], v36);
      }
      ++v22;
      ++v24;
      v23 += 16;
      --v30;
    }
    while ( v30 );
    v5 = (_BYTE *)a5;
  }
  return sub_100573C0(a4, v31, a3, v5, &v32);
}
// 10658E06: using guessed type char byte_10658E06;
// 10057450: using guessed type char var_40[12];

//----- (10057750) --------------------------------------------------------
char __cdecl sub_10057750(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // edx@2
  int v6; // ecx@2
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8041:
      v5 = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 60) = *(_DWORD *)(a4 + 48);
      v6 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a4 + 64) = v5;
      *(_DWORD *)(a4 + 68) = v6;
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_DWORD *)(a2 + 4) & 0x200 )
        sub_1005BCC0(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), a3);
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10057450((int)a5, a3, a1, a2, a4);
      sub_10057020((int)a5, a3, a1, a2, a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10057450((int)a5, a3, a1, a2, a4);
      sub_10057020((int)a5, a3, a1, a2, a4);
      goto LABEL_11;
    default:
LABEL_11:
      result = 1;
      break;
  }
  return result;
}

//----- (100578B0) --------------------------------------------------------
int __usercall sub_100578B0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // ebx@1
  signed int v6; // eax@2
  __int16 v7; // dx@2
  int v8; // eax@2
  __int16 v9; // ax@4
  __int16 v10; // di@4
  signed int v11; // ecx@4
  __int16 v12; // ax@5
  __int16 v13; // si@5
  signed int v14; // eax@7
  int v15; // edx@7
  int v16; // eax@7
  int v17; // eax@9
  int v18; // edi@9
  int v19; // esi@9
  signed int v20; // ecx@9
  __int16 v22; // [sp+10h] [bp-20h]@0
  __int16 v23; // [sp+12h] [bp-1Eh]@0
  __int16 v24; // [sp+14h] [bp-1Ch]@0
  __int16 v25; // [sp+16h] [bp-1Ah]@0
  __int16 v26; // [sp+18h] [bp-18h]@0
  __int16 v27; // [sp+1Ah] [bp-16h]@0
  __int16 v28; // [sp+20h] [bp-10h]@0
  __int16 v29; // [sp+22h] [bp-Eh]@0
  __int16 v30; // [sp+28h] [bp-8h]@0
  __int16 v31; // [sp+2Ah] [bp-6h]@0

  v3 = a3;
  *(_WORD *)(a3 + 394) = 1;
  v4 = a1;
  *(_WORD *)(a3 + 428) = word_105728D8[15];
  *(_WORD *)(a3 + 430) = word_105728D8[15];
  v5 = *(_DWORD *)(a2 + 4);
  if ( v5 & 0x200000 )
  {
    if ( (v5 & 0x200000) == 0x200000 )
    {
      v14 = (signed int)((double)(10 * *(_WORD *)(a2 + 8)) * 0.2);
      v15 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * ((signed __int16)v14 + 5)) >> 32) >> 2)
                             + ((unsigned int)((unsigned __int64)(1717986919i64 * ((signed __int16)v14 + 5)) >> 32) >> 31));
      HIWORD(a3) = *(_WORD *)(v4 + 2);
      v25 = *(_WORD *)(v4 + 2);
      v27 = *(_WORD *)(v4 + 2);
      v16 = v5 & 0x18;
      v23 = *(_WORD *)(v4 + 2) + *(_WORD *)(a2 + 10);
      v31 = *(_WORD *)(v4 + 2) + *(_WORD *)(a2 + 10);
      v29 = *(_WORD *)(v4 + 2) + *(_WORD *)(a2 + 10);
      if ( v16 != 8 && v16 != 16 )
      {
        LOWORD(v19) = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
        LOWORD(a3) = *(_WORD *)v4;
        v24 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
        v22 = *(_WORD *)v4;
        v30 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
      }
      else
      {
        v17 = *(_WORD *)(a2 + 8);
        v18 = *(_WORD *)v4;
        v19 = v17 - v15 + v18;
        v20 = 10 * (signed __int16)v17 / 2 + 5;
        LOWORD(a3) = v18 + v15;
        v24 = v18 + v20 / 10;
        v22 = v18 + v15;
        v30 = v18 + v20 / 10;
      }
      v28 = v19;
      v26 = v19;
    }
  }
  else
  {
    v6 = (signed int)((double)(10 * *(_WORD *)(a2 + 10)) * 0.2);
    v7 = ((signed int)((unsigned __int64)(1717986919i64 * ((signed __int16)v6 + 5)) >> 32) >> 2)
       + ((unsigned int)((unsigned __int64)(1717986919i64 * ((signed __int16)v6 + 5)) >> 32) >> 31);
    LOWORD(a3) = *(_WORD *)v4;
    v24 = *(_WORD *)v4;
    v26 = *(_WORD *)v4;
    v8 = v5 & 0x18;
    v22 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
    v30 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
    v28 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
    if ( v8 != 8 && v8 != 16 )
    {
      v12 = *(_WORD *)(v4 + 2);
      v13 = *(_WORD *)(a2 + 10);
      HIWORD(a3) = *(_WORD *)(v4 + 2);
      v27 = v12 + v13;
      v25 = v12 + v13;
      v23 = *(_WORD *)(v4 + 2);
      v29 = v12 + v13;
      v31 = v12 + v13;
    }
    else
    {
      v9 = *(_WORD *)(a2 + 10);
      v10 = *(_WORD *)(v4 + 2);
      v11 = 10 * v9 / 2 + 5;
      HIWORD(a3) = v10 + v7;
      v27 = v9 - v7 + v10;
      v25 = v10 + v11 / 10;
      v23 = v10 + v7;
      v29 = v9 - v7 + v10;
      v31 = v10 + v11 / 10;
    }
  }
  *(_WORD *)(v3 + 438) = a3;
  *(_WORD *)(v3 + 436) = HIWORD(a3);
  sub_1009E7F0(v3 + 392, v26, v27, 0);
  *(_WORD *)(v3 + 438) = v22;
  *(_WORD *)(v3 + 436) = v23;
  sub_1009E7F0(v3 + 392, v28, v29, 0);
  *(_WORD *)(v3 + 438) = v24;
  *(_WORD *)(v3 + 436) = v25;
  return sub_1009E7F0(v3 + 392, v30, v31, 2);
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10057B70) --------------------------------------------------------
char __usercall sub_10057B70@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  int v7; // edi@5
  int v8; // ebx@5
  int v9; // eax@9
  char *v10; // edi@11
  char v11; // al@12
  char *v12; // eax@15
  char v13; // cl@16
  void *v14; // ecx@24
  int v15; // eax@25
  __int16 v16; // ax@27
  signed int v17; // eax@30
  char *v18; // eax@31
  char v20; // [sp+Bh] [bp-35h]@4
  int v21; // [sp+Ch] [bp-34h]@1
  int v22; // [sp+10h] [bp-30h]@31
  int v23; // [sp+14h] [bp-2Ch]@34
  int v24; // [sp+18h] [bp-28h]@21
  __int16 v25; // [sp+1Ch] [bp-24h]@36
  __int16 v26; // [sp+1Eh] [bp-22h]@33
  int v27; // [sp+20h] [bp-20h]@1
  int v28; // [sp+24h] [bp-1Ch]@1
  char v29[20]; // [sp+28h] [bp-18h]@10

  v28 = a4;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v21 = a2;
  v27 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v20 = 0;
  if ( v6 )
  {
    v7 = 0;
    v8 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1005C160(a3, a5, v7) > (unsigned __int8)v20 )
        v20 = sub_1005C160(a3, a5, v7);
      ++v7;
      --v8;
    }
    while ( v8 );
  }
  v9 = *(_DWORD *)(a3 + 4);
  if ( ~(unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7) & 1 )
  {
    sub_1005BD10(a3, (int)a5, v29);
    if ( *(_DWORD *)(a3 + 4) & 0x1000 )
    {
      v10 = (char *)&v28 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 32;
      sub_1005C490(*(_BYTE *)(a3 + 13), &v29[strlen(v29)]);
    }
    else if ( *(_BYTE *)(a3 + 13) == 20 )
    {
      v12 = (char *)&v28 + 3;
      do
        v13 = (v12++)[1];
      while ( v13 );
      *(_DWORD *)v12 = 1296389152;
      *((_WORD *)v12 + 2) = 80;
    }
  }
  else
  {
    if ( !(v9 & 0x1000) )
      return v9;
    sub_1005C490(*(_BYTE *)(a3 + 13), v29);
  }
  switch ( v20 )
  {
    case 3:
      v24 = byte_10658E06 != 0 ? 2319 : 2536;
      break;
    case 2:
      v24 = 2401;
      break;
    default:
      v24 = 2447;
      break;
  }
  v14 = (void *)(*(_DWORD *)(a3 + 4) >> 17);
  if ( ~(_BYTE)v14 & 1 )
  {
    v17 = *(_WORD *)(a3 + 8);
    v14 = (void *)v21;
    v24 |= 0x8000u;
    v16 = *(_WORD *)v21 + v17 / 2;
  }
  else
  {
    v15 = *(_DWORD *)(a3 + 4) & 0xC000;
    if ( v15 )
    {
      if ( v15 == 0x4000 )
      {
        v14 = (void *)v21;
        v16 = *(_WORD *)v21 + *(_WORD *)(a3 + 8);
        v24 |= 0x4000u;
      }
      else
      {
        v16 = *(_WORD *)v21 + *(_WORD *)(a3 + 8) / 2;
        v24 |= 0x8000u;
      }
    }
    else
    {
      v16 = *(_WORD *)v21;
    }
  }
  LOWORD(v22) = v16;
  v18 = v29;
  do
    LOBYTE(v14) = *v18++;
  while ( (_BYTE)v14 );
  v26 = (_WORD)v18 - (unsigned int)&v29[1];
  if ( sub_10079360(v14) )
  {
    HIWORD(v22) = *(_WORD *)(v21 + 2) - 7;
    v23 = 4;
  }
  else
  {
    HIWORD(v22) = *(_WORD *)(v21 + 2) - 6;
    v23 = 3;
  }
  v25 = 0;
  LOBYTE(v9) = sub_100698B0(v28, (int)&v23, (int)&v22, v29, v27);
  return v9;
}
// 10658E06: using guessed type char byte_10658E06;
// 10057B70: using guessed type char var_18[20];

//----- (10057DF0) --------------------------------------------------------
char __usercall sub_10057DF0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  __int16 v7; // cx@1
  __int16 v8; // dx@1
  __int16 v10; // [sp+8h] [bp-38h]@1
  __int16 v11; // [sp+Ah] [bp-36h]@1
  __int16 v12; // [sp+Ch] [bp-34h]@1
  __int16 v13; // [sp+Eh] [bp-32h]@1
  float v14; // [sp+10h] [bp-30h]@1
  float v15; // [sp+14h] [bp-2Ch]@1
  int v16; // [sp+18h] [bp-28h]@1
  char v17; // [sp+1Ch] [bp-24h]@1
  char v18; // [sp+2Ch] [bp-14h]@1

  v5 = a1;
  v16 = a5;
  sub_1005C100(*(_BYTE *)(a1 + 13), (int)&v17, (int)&v18);
  v6 = *(_WORD *)(v5 + 10) + *(_WORD *)(a2 + 2);
  v7 = *(_WORD *)a2;
  v15 = *(float *)(a4 + 8);
  v8 = *(_WORD *)(v5 + 8);
  v14 = *(float *)(a4 + 4);
  v13 = v6 + 14;
  v11 = v6 + 14;
  v10 = v7;
  v12 = v7 + v8 + 1;
  sub_1006B030(a3, (int)&v17, (int *)&v10, &v14, a5);
  return sub_1006B030(a3, (int)&v18, (int *)&v12, &v15, a5);
}

//----- (10057EB0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __usercall sub_10057EB0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  char v3; // al@1
  int v4; // ebx@4
  int v5; // eax@4
  __int16 v6; // bp@6
  __int16 v7; // ST22_2@6
  int result; // eax@6
  __int16 v9; // ax@7
  __int16 v10; // ST22_2@7
  signed int v11; // ecx@8
  signed int i; // ebx@8
  __int16 v13; // ax@9
  int v14; // ebx@11
  int v15; // eax@11
  __int16 v16; // bp@13
  __int16 v17; // ax@14
  __int16 v18; // ST20_2@14
  signed int v19; // ecx@15
  signed int j; // ebx@15
  __int16 v21; // ax@16
  signed int v22; // [sp+0h] [bp-10h]@4
  signed int v23; // [sp+0h] [bp-10h]@11
  __int16 v24; // [sp+0h] [bp-10h]@13
  __int16 v25; // [sp+2h] [bp-Eh]@6
  int v26; // [sp+8h] [bp-8h]@0
  __int16 v27; // [sp+Ch] [bp-4h]@0 OVERLAPPED

  v3 = 0;
  if ( !(*(_DWORD *)(a2 + 4) & 0x200000) )
    v3 = 1;
  *(_WORD *)(a1 + 394) = 1;
  *(_WORD *)(a1 + 428) = word_105728D8[15];
  *(_WORD *)(a1 + 430) = word_105728D8[15];
  if ( v3 )
  {
    v22 = 10 * *(_WORD *)(a2 + 10);
    v4 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * (v22 / 2 + 5)) >> 32) >> 2)
                          + ((unsigned int)((unsigned __int64)(1717986919i64 * (v22 / 2 + 5)) >> 32) >> 31));
    v5 = *(_DWORD *)(a2 + 4) & 0x18;
    if ( v5 != 8 && v5 != 16 )
    {
      v9 = *(_WORD *)(a2 + 10);
      v6 = v9 + *(_WORD *)(a3 + 2);
      v10 = v9 + *(_WORD *)(a3 + 2);
      result = ((signed __int16)(signed int)((double)(10 * v9) * 0.7) + 5) / 10;
      v25 = v10 - result;
    }
    else
    {
      v6 = *(_WORD *)(a3 + 2) + ((signed __int16)(signed int)((double)v22 * 0.75) + 5) / 10;
      v7 = v6;
      result = *(_DWORD *)(&v27 - 1) - v4;
      v25 = v6 - v4;
    }
    v11 = *(_BYTE *)(a2 + 12);
    for ( i = 1; i <= v11; ++i )
    {
      v13 = *(_WORD *)a3 + (unsigned int)(i * *(_WORD *)(a2 + 8) / (v11 + 1));
      *(_WORD *)(a1 + 436) = v6;
      *(_WORD *)(a1 + 438) = v13;
      result = sub_1009E7F0(a1 + 392, v13, v25, 0);
      v11 = *(_BYTE *)(a2 + 12);
    }
  }
  else
  {
    v23 = 10 * *(_WORD *)(a2 + 8);
    v14 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * (v23 / 2 + 5)) >> 32) >> 2)
                           + ((unsigned int)((unsigned __int64)(1717986919i64 * (v23 / 2 + 5)) >> 32) >> 31));
    v15 = *(_DWORD *)(a2 + 4) & 0x18;
    if ( v15 != 8 && v15 != 16 )
    {
      v17 = *(_WORD *)(a2 + 8);
      v16 = v17 + *(_WORD *)a3;
      v18 = v17 + *(_WORD *)a3;
      result = ((signed __int16)(signed int)((double)(10 * v17) * 0.7) + 5) / 10;
      v24 = v18 - result;
    }
    else
    {
      v16 = *(_WORD *)a3 + ((signed __int16)(signed int)((double)v23 * 0.75) + 5) / 10;
      LOWORD(v26) = v16;
      result = v26 - v14;
      v24 = v16 - v14;
    }
    v19 = *(_BYTE *)(a2 + 12);
    for ( j = 1; j <= v19; ++j )
    {
      v21 = *(_WORD *)(a3 + 2) + (unsigned int)(j * *(_WORD *)(a2 + 10) / (v19 + 1));
      *(_WORD *)(a1 + 438) = v16;
      *(_WORD *)(a1 + 436) = v21;
      result = sub_1009E7F0(a1 + 392, v24, v21, 0);
      v19 = *(_BYTE *)(a2 + 12);
    }
  }
  return result;
}
// 10057EB0: variables would overlap: ST24_2.2 and ST22_4.4
// 10057EB0: failed to widen chains
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10058160) --------------------------------------------------------
int __usercall sub_10058160@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int result; // eax@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  bool v7; // zf@5
  __int16 v8; // cx@8
  __int16 v9; // dx@8
  __int16 v10; // [sp+4h] [bp-Ch]@4
  __int16 v11; // [sp+6h] [bp-Ah]@4
  int v12; // [sp+8h] [bp-8h]@1

  result = *(_DWORD *)a1;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v12 = *(_DWORD *)a1;
  if ( v5 == 8 || v5 == 16 )
  {
    v7 = *(_BYTE *)a4 == 0;
    v10 = v12 + *(_WORD *)(a3 + 8);
    if ( v7 )
    {
      v11 = HIWORD(v12) + *(_WORD *)(a3 + 10) / 2;
      result = sub_1006D760(a2, (int)&v12, (int)&v10, 0);
    }
    if ( !*(_BYTE *)(a4 + 1) )
    {
      v8 = *(_WORD *)(a3 + 10);
      v9 = *(_WORD *)(a1 + 2);
      HIWORD(v12) += *(_WORD *)(a3 + 10) / 2;
      v11 = v8 + v9;
      result = sub_1006D760(a2, (int)&v12, (int)&v10, 0);
    }
  }
  else if ( !*(_BYTE *)a4 )
  {
    v6 = v12 + *(_WORD *)(a3 + 8);
    v11 = *(_WORD *)(a3 + 10) + HIWORD(result);
    v10 = v6;
    result = sub_1006D760(a2, (int)&v12, (int)&v10, 0);
  }
  return result;
}

//----- (10058240) --------------------------------------------------------
int __usercall sub_10058240@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>, float a4)
{
  int v4; // esi@1
  char v5; // al@1
  bool v6; // zf@2
  int v7; // eax@2
  int v8; // ecx@3
  int v9; // esi@3
  float v10; // ST10_4@6
  float v11; // ST10_4@6
  int v13; // eax@8
  int v14; // esi@9
  int v15; // ecx@9
  float v16; // ST10_4@13
  int v17; // [sp+10h] [bp-4h]@0

  v4 = a1;
  v5 = ((unsigned __int8)*(_DWORD *)(a2 + 4) >> 1) & 1;
  if ( !(*(_DWORD *)(a2 + 4) & 0x200000) )
  {
    v6 = v5 == 0;
    v7 = *(_WORD *)v4;
    if ( v6 )
    {
      v9 = v7 + 1;
      v8 = v7 + *(_WORD *)(a2 + 8);
    }
    else
    {
      v8 = v7 + 1;
      v9 = v7 + *(_WORD *)(a2 + 8);
    }
    if ( *(float *)(a3 + 8) - *(float *)(a3 + 4) != 0.0 )
    {
      v10 = (a4 - *(float *)(a3 + 4)) / (*(float *)(a3 + 8) - *(float *)(a3 + 4));
      v11 = (double)(v8 - v9) * v10;
      return v9 + (signed int)sub_100A7380(v11, 1.0);
    }
    return v9;
  }
  if ( (*(_DWORD *)(a2 + 4) & 0x200000) == 0x200000 )
  {
    v6 = v5 == 0;
    v13 = *(_WORD *)(v4 + 2);
    if ( v6 )
    {
      v15 = v13 + 1;
      v14 = v13 + *(_WORD *)(a2 + 10);
    }
    else
    {
      v14 = v13 + 1;
      v15 = v13 + *(_WORD *)(a2 + 10);
    }
    if ( *(float *)(a3 + 8) - *(float *)(a3 + 4) == 0.0 )
      return v15;
    v16 = (a4 - *(float *)(a3 + 4)) / (*(float *)(a3 + 8) - *(float *)(a3 + 4));
    return v14 - (signed int)(v16 * (double)(v14 - v15));
  }
  return v17;
}

//----- (10058350) --------------------------------------------------------
int __usercall sub_10058350@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4)
{
  int v4; // ebp@1
  int v5; // edi@1
  signed int v6; // ecx@2
  int v7; // eax@2
  double v8; // st7@4
  signed int v9; // ecx@6
  int v10; // eax@6
  double v11; // st7@8
  char *v12; // eax@11
  __int16 v13; // ax@12
  float v14; // ST18_4@12
  double v15; // st7@14
  float v16; // ST18_4@14
  __int16 v17; // dx@14
  __int16 v18; // ax@14
  double v19; // st7@14
  float v20; // ST18_4@14
  __int16 v21; // ax@14
  double v22; // st7@16
  float v23; // ST18_4@16
  __int16 v24; // ax@16
  __int16 v25; // ST10_2@16
  __int16 v26; // dx@16
  __int16 v27; // ax@16
  double v28; // st7@16
  float v29; // ST18_4@16
  __int16 v30; // ax@16
  bool v31; // zf@16
  char *v33; // [sp+Ch] [bp-1Ch]@2
  int v34; // [sp+10h] [bp-18h]@14
  __int16 v35; // [sp+14h] [bp-14h]@14
  int v36; // [sp+18h] [bp-10h]@2
  int v37; // [sp+20h] [bp-8h]@2
  char *v38; // [sp+2Ch] [bp+4h]@2

  v4 = a4;
  v5 = a1;
  if ( *(_DWORD *)(a4 + 4) & 0x200000 )
  {
    v33 = (char *)&v36 + 2;
    v9 = *(_WORD *)(a4 + 8);
    v38 = (char *)&v37 + 2;
    v10 = *(_DWORD *)(v4 + 4) & 0x18;
    if ( v10 != 8 && v10 != 16 )
    {
      LOWORD(v36) = *(_WORD *)a2 + v9 / 2;
      LOWORD(v37) = ((signed int)((unsigned __int64)(1717986919i64 * (10 * v9 / 2 + 5)) >> 32) >> 2)
                  + ((unsigned int)((unsigned __int64)(1717986919i64 * (10 * v9 / 2 + 5)) >> 32) >> 31)
                  + v36;
    }
    else
    {
      v11 = (double)(10 * *(_WORD *)(v4 + 8));
      LOWORD(v36) = *(_WORD *)a2 + *(_WORD *)(v4 + 8) / 2 - (5 - (signed int)(-0.15 * v11)) / 10;
      LOWORD(v37) = v36 + ((signed __int16)(signed int)(v11 * 0.3) + 5) / 10;
    }
  }
  else
  {
    v33 = (char *)&v37;
    v6 = *(_WORD *)(a4 + 10);
    v38 = (char *)&v36;
    v7 = *(_DWORD *)(v4 + 4) & 0x18;
    if ( v7 != 8 && v7 != 16 )
    {
      HIWORD(v36) = *(_WORD *)(a2 + 2) + v6 / 2;
      HIWORD(v37) = ((signed int)((unsigned __int64)(1717986919i64 * (10 * v6 / 2 + 5)) >> 32) >> 2)
                  + ((unsigned int)((unsigned __int64)(1717986919i64 * (10 * v6 / 2 + 5)) >> 32) >> 31)
                  + HIWORD(v36);
    }
    else
    {
      v8 = (double)(10 * *(_WORD *)(v4 + 10));
      HIWORD(v36) = *(_WORD *)(a2 + 2) + *(_WORD *)(v4 + 10) / 2 - (5 - (signed int)(-0.15 * v8)) / 10;
      HIWORD(v37) = HIWORD(v36) + ((signed __int16)(signed int)(v8 * 0.3) + 5) / 10;
    }
  }
  if ( *(_BYTE *)(v4 + 4) & 2 )
  {
    v12 = v38;
    v38 = v33;
    v33 = v12;
  }
  v13 = sub_10058240(a2, v4, v5, *(float *)(v5 + 16));
  v14 = *(float *)(v5 + 20);
  *(_WORD *)v38 = v13;
  *(_WORD *)v33 = sub_10058240(a2, v4, v5, v14);
  *(_WORD *)(a3 + 440) = word_105728D8[11];
  *(_WORD *)(a3 + 442) = word_105728D8[11];
  *(_WORD *)(a3 + 428) = word_105728D8[11];
  *(_WORD *)(a3 + 430) = word_105728D8[11];
  if ( ~(unsigned __int8)(*(_DWORD *)(v4 + 4) >> 13) & 1 )
    sub_1009E590(a3 + 392, v36, SHIWORD(v36), v37 - v36, HIWORD(v37) - HIWORD(v36), 1);
  v15 = *(float *)(v5 + 12);
  *(_WORD *)v33 = *(_WORD *)v38;
  v16 = v15;
  *(_WORD *)v38 = sub_10058240(a2, v4, v5, v16);
  *(_WORD *)(a3 + 440) = word_105728D8[8];
  *(_WORD *)(a3 + 442) = word_105728D8[8];
  *(_WORD *)(a3 + 428) = word_105728D8[8];
  v17 = HIWORD(v37);
  *(_WORD *)(a3 + 430) = word_105728D8[8];
  v34 = a3 + 392;
  sub_1009E590(a3 + 392, v36, SHIWORD(v36), v37 - v36, v17 - HIWORD(v36), 1);
  v18 = sub_10058240(a2, v4, v5, *(float *)(v5 + 24));
  v19 = *(float *)(v5 + 28);
  *(_WORD *)v38 = v18;
  v20 = v19;
  v21 = sub_10058240(a2, v4, v5, v20);
  *(_WORD *)v33 = v21;
  *(_WORD *)(a3 + 440) = word_105728D8[11];
  *(_WORD *)(a3 + 442) = word_105728D8[11];
  *(_WORD *)(a3 + 428) = word_105728D8[11];
  *(_WORD *)(a3 + 430) = word_105728D8[11];
  v35 = v21;
  if ( ~(unsigned __int8)(*(_DWORD *)(v4 + 4) >> 13) & 1 )
  {
    sub_1009E590(v34, v36, SHIWORD(v36), v37 - v36, HIWORD(v37) - HIWORD(v36), 1);
    v21 = v35;
  }
  v22 = *(float *)(v5 + 32);
  *(_WORD *)v38 = v21;
  v23 = v22;
  *(_WORD *)v33 = sub_10058240(a2, v4, v5, v23);
  *(_WORD *)(a3 + 440) = word_105728D8[8];
  *(_WORD *)(a3 + 442) = word_105728D8[8];
  *(_WORD *)(a3 + 428) = word_105728D8[8];
  v24 = HIWORD(v36);
  v25 = HIWORD(v37) - HIWORD(v36);
  v26 = v37;
  *(_WORD *)(a3 + 430) = word_105728D8[8];
  sub_1009E590(v34, v36, v24, v26 - v36, v25, 1);
  v27 = sub_10058240(a2, v4, v5, *(float *)(v5 + 20));
  v28 = *(float *)(v5 + 24);
  *(_WORD *)v38 = v27;
  v29 = v28;
  v30 = sub_10058240(a2, v4, v5, v29);
  v31 = (*(_DWORD *)(v4 + 4) & 0x800000) == 0;
  *(_WORD *)v33 = v30;
  if ( v31 )
  {
    *(_WORD *)(a3 + 440) = word_105728D8[4];
    *(_WORD *)(a3 + 442) = word_105728D8[4];
    *(_WORD *)(a3 + 428) = word_105728D8[4];
    *(_WORD *)(a3 + 430) = word_105728D8[4];
  }
  else
  {
    *(_WORD *)(a3 + 440) = word_105728D8[15];
    *(_WORD *)(a3 + 442) = word_105728D8[15];
    *(_WORD *)(a3 + 428) = word_105728D8[15];
    *(_WORD *)(a3 + 430) = word_105728D8[15];
  }
  return sub_1009E590(v34, v36, SHIWORD(v36), v37 - v36, HIWORD(v37) - HIWORD(v36), 1);
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (100588B0) --------------------------------------------------------
signed int __usercall sub_100588B0@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4)
{
  int v4; // edi@1
  _BYTE *v5; // ebx@1
  float *v6; // edx@1
  float *v7; // ecx@1
  double v8; // st7@4
  float v9; // ebx@12
  int v10; // eax@12
  __int16 v11; // ax@14
  __int16 v12; // cx@14
  unsigned int v13; // edx@15
  bool v14; // zf@16
  unsigned __int16 v15; // ax@17
  __int16 v16; // dx@17
  int v17; // eax@17
  float v18; // ecx@17
  __int16 v19; // dx@22
  int v20; // ecx@22
  __int16 v21; // ax@26
  __int16 v22; // ax@27
  char v23; // al@28
  __int16 v24; // cx@30
  __int16 v25; // ax@33
  int v26; // eax@37
  unsigned __int16 v27; // cx@40
  __int16 v28; // bx@40
  char v29; // al@40
  int v30; // eax@41
  int v31; // ecx@41
  __int16 v32; // ax@45
  int v33; // ST14_4@45
  __int16 v34; // cx@46
  char v35; // al@47
  __int16 v36; // ax@49
  __int16 v37; // ax@52
  int v38; // ST14_4@52
  char v39; // cl@52
  int v40; // ebx@57
  __int16 v41; // ax@57
  signed int result; // eax@62
  __int16 v43; // [sp+4h] [bp-134h]@0
  int v44; // [sp+8h] [bp-130h]@0
  char v45; // [sp+10h] [bp-128h]@22
  char v46; // [sp+11h] [bp-127h]@22
  int v47; // [sp+14h] [bp-124h]@1
  int v48; // [sp+18h] [bp-120h]@1
  float v49; // [sp+1Ch] [bp-11Ch]@3
  __int16 v50; // [sp+20h] [bp-118h]@17
  __int16 v51; // [sp+22h] [bp-116h]@20
  __int16 v52; // [sp+24h] [bp-114h]@17
  __int16 v53; // [sp+26h] [bp-112h]@18
  __int16 v54; // [sp+28h] [bp-110h]@17
  __int16 v55; // [sp+2Ah] [bp-10Eh]@18
  __int16 v56; // [sp+2Ch] [bp-10Ch]@17
  __int16 v57; // [sp+2Eh] [bp-10Ah]@20
  int v58; // [sp+30h] [bp-108h]@1
  int v59; // [sp+34h] [bp-104h]@1
  __int16 v60; // [sp+38h] [bp-100h]@57
  __int16 v61; // [sp+3Ah] [bp-FEh]@57
  __int16 v62; // [sp+3Ch] [bp-FCh]@57
  __int16 v63; // [sp+3Eh] [bp-FAh]@57
  __int16 v64; // [sp+40h] [bp-F8h]@57
  __int16 v65; // [sp+42h] [bp-F6h]@57
  __int16 v66; // [sp+44h] [bp-F4h]@57
  __int16 v67; // [sp+46h] [bp-F2h]@57
  __int16 v68; // [sp+48h] [bp-F0h]@57
  __int16 v69; // [sp+4Ah] [bp-EEh]@57
  float v70; // [sp+4Ch] [bp-ECh]@1
  float v71; // [sp+50h] [bp-E8h]@40
  float v72; // [sp+54h] [bp-E4h]@57
  char v73; // [sp+58h] [bp-E0h]@21

  v4 = a1;
  *(_WORD *)(a2 + 396) = 2;
  v58 = FNT_get_fnt_hdr(3);
  v48 = 10 * *(_WORD *)(a3 + 10);
  v47 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * (v48 / 2 + 5)) >> 32) >> 2)
                         + ((unsigned int)((unsigned __int64)(1717986919i64 * (v48 / 2 + 5)) >> 32) >> 31));
  v59 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64
                                                          * ((signed __int16)(signed int)((double)v48 * 0.2) + 5)) >> 32) >> 2)
                         + ((unsigned int)((unsigned __int64)(1717986919i64
                                                            * ((signed __int16)(signed int)((double)v48 * 0.2) + 5)) >> 32) >> 31));
  v5 = (_BYTE *)v4;
  v6 = &v70;
  v7 = (float *)(v4 + 48);
  v48 = 3;
  do
  {
    if ( *v5 == 1 )
    {
      v49 = *v7;
      if ( (LODWORD(v49) & 0x7F800000) == 2139095040 )
      {
        v8 = *(float *)(v4 + 4);
      }
      else if ( *(float *)(v4 + 8) >= (double)*v7 )
      {
        if ( *(float *)(v4 + 4) <= (double)*v7 )
          v8 = *v7;
        else
          v8 = *(float *)(v4 + 4);
      }
      else
      {
        v8 = *(float *)(v4 + 8);
      }
      *v6 = v8;
    }
    ++v5;
    ++v7;
    ++v6;
    --v48;
  }
  while ( v48 );
  LODWORD(v9) = (unsigned __int16)(*(_WORD *)(a4 + 2) - 4);
  v10 = *(_DWORD *)(a3 + 4) & 0x18;
  if ( v10 != 8 && v10 != 16 )
  {
    v48 = 10 * *(_WORD *)(a3 + 10);
    v13 = (unsigned __int64)(1717986919i64 * ((signed __int16)(signed int)((double)v48 * 1.8) + 5)) >> 32;
    v11 = *(_WORD *)(a3 + 10);
    v12 = *(_WORD *)(a4 + 2);
    v48 = (unsigned __int16)(((signed int)v13 >> 2) + (v13 >> 31));
  }
  else
  {
    v48 = 10 * *(_WORD *)(a3 + 10);
    v11 = *(_WORD *)(a4 + 2);
    v48 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64
                                                            * ((signed __int16)(signed int)((double)v48 * 0.9) + 5)) >> 32) >> 2)
                           + ((unsigned int)((unsigned __int64)(1717986919i64
                                                              * ((signed __int16)(signed int)((double)v48 * 0.9) + 5)) >> 32) >> 31));
    v12 = v47;
  }
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  v14 = *(_BYTE *)v4 == 1;
  v47 = (unsigned __int16)(v12 + v11);
  if ( v14 )
  {
    v15 = sub_10058240(a4, a3, v4, v70);
    LODWORD(v18) = v15;
    v52 = (signed __int16)v48 / 2 + v15;
    v16 = v15 - (signed __int16)v48 / 2;
    v17 = *(_DWORD *)(a3 + 4);
    v49 = v18;
    v50 = LOWORD(v18);
    v56 = LOWORD(v18);
    LOWORD(v18) = v47;
    v54 = v16;
    if ( (v17 & 0x18) == 16 )
    {
      LODWORD(v18) = v47 - v59 + 1;
      v53 = LOWORD(v9) - v59 + 1;
      v55 = LOWORD(v9) - v59 + 1;
    }
    else
    {
      v53 = LOWORD(v9);
      v55 = LOWORD(v9);
    }
    v57 = LOWORD(v18);
    v51 = LOWORD(v18);
    if ( v17 & 0x1000000 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[6];
      *(_WORD *)(a2 + 430) = word_105728D8[6];
      *(_WORD *)(a2 + 440) = word_105728D8[6];
      *(_WORD *)(a2 + 442) = word_105728D8[6];
      sub_1009ED40(a2 + 392, 3, (int)&v50, 56, (int)&v73);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_105728D8[6];
        v19 = word_105728D8[1];
        *(_WORD *)(a2 + 438) = LOWORD(v49) + 1;
        *(_WORD *)(a2 + 436) = LOWORD(v9) + 10;
        v20 = v58;
        *(_WORD *)(a2 + 430) = v19;
        v45 = *(_BYTE *)(v4 + 72);
        v46 = 0;
        sub_1009DAB0(a2 + 392, v20, &v45, 0, 1, v43, v44);
      }
      *(_WORD *)(a2 + 426) = 1;
      *(_WORD *)(a2 + 424) = 1;
      *(_WORD *)(a2 + 428) = word_105728D8[1];
      *(_WORD *)(a2 + 430) = word_105728D8[1];
      sub_1009F430(a2 + 392, 4, (int)&v50, 2);
      goto LABEL_36;
    }
    if ( sub_1005C160(a3, (const void *)v4, 0) == 3 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      *(_WORD *)(a2 + 430) = word_105728D8[8];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[8];
      sub_1009ED40(a2 + 392, 3, (int)&v50, 56, (int)&v73);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_105728D8[8];
        v21 = word_105728D8[15];
        *(_WORD *)(a2 + 438) = LOWORD(v49) + 1;
        *(_WORD *)(a2 + 430) = v21;
        *(_WORD *)(a2 + 436) = LOWORD(v9) + 10;
        v45 = *(_BYTE *)(v4 + 72);
        v46 = 0;
        sub_1009DAB0(a2 + 392, v58, &v45, 0, 1, v43, v44);
      }
      *(_WORD *)(a2 + 426) = 1;
      *(_WORD *)(a2 + 424) = 1;
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      v22 = word_105728D8[15];
      goto LABEL_35;
    }
    v23 = sub_1005C160(a3, (const void *)v4, 0);
    *(_WORD *)(a2 + 428) = word_105728D8[15];
    if ( v23 == 2 )
    {
      *(_WORD *)(a2 + 430) = word_105728D8[11];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[11];
      sub_1009ED40(a2 + 392, 3, (int)&v50, 56, (int)&v73);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        v24 = word_105728D8[11];
LABEL_33:
        *(_WORD *)(a2 + 428) = v24;
        v25 = word_105728D8[1];
        *(_WORD *)(a2 + 438) = LOWORD(v49) + 1;
        *(_WORD *)(a2 + 430) = v25;
        *(_WORD *)(a2 + 436) = LOWORD(v9) + 10;
        v45 = *(_BYTE *)(v4 + 72);
        v46 = 0;
        sub_1009DAB0(a2 + 392, v58, &v45, 0, 1, v43, v44);
        goto LABEL_34;
      }
    }
    else
    {
      *(_WORD *)(a2 + 430) = word_105728D8[15];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[15];
      sub_1009ED40(a2 + 392, 3, (int)&v50, 56, (int)&v73);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        v24 = word_105728D8[15];
        goto LABEL_33;
      }
    }
LABEL_34:
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
    *(_WORD *)(a2 + 428) = word_105728D8[1];
    v22 = word_105728D8[1];
LABEL_35:
    *(_WORD *)(a2 + 430) = v22;
    sub_1009F430(a2 + 392, 4, (int)&v50, 2);
LABEL_36:
    *(_WORD *)(a2 + 424) = 2;
    *(_WORD *)(a2 + 426) = 2;
  }
  v26 = *(_DWORD *)(a3 + 4) & 0x18;
  if ( v26 != 8 && v26 != 16 || !*(_BYTE *)(v4 + 1) )
    goto LABEL_55;
  v27 = *(_WORD *)(a4 + 2) + *(_WORD *)(a3 + 10) + 4;
  LODWORD(v49) = (unsigned __int16)v47;
  v47 = v27;
  v28 = sub_10058240(a4, a3, v4, v71);
  v29 = *(_DWORD *)(a3 + 4) & 0x18;
  v50 = v28;
  v52 = (signed __int16)v48 / 2 + v28;
  v54 = v28 - (signed __int16)v48 / 2;
  v56 = v28;
  if ( v29 == 16 )
  {
    v30 = LODWORD(v49) + v59 - 1;
    v31 = v47 + v59 - 1;
  }
  else
  {
    LOWORD(v30) = LOWORD(v49);
    LOWORD(v31) = v47;
  }
  v57 = v30;
  v51 = v30;
  v55 = v31;
  v53 = v31;
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  if ( sub_1005C160(a3, (const void *)v4, 1) == 3 )
  {
    *(_WORD *)(a2 + 428) = word_105728D8[15];
    *(_WORD *)(a2 + 430) = word_105728D8[8];
    *(_WORD *)(a2 + 440) = word_105728D8[15];
    *(_WORD *)(a2 + 442) = word_105728D8[8];
    sub_1009ED40(a2 + 392, 3, (int)&v50, 56, (int)&v73);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[8];
      v32 = v47 - 2;
      *(_WORD *)(a2 + 430) = word_105728D8[15];
      *(_WORD *)(a2 + 436) = v32;
      v33 = v58;
      *(_WORD *)(a2 + 438) = v28 + 1;
      v45 = *(_BYTE *)(v4 + 79);
      v46 = 0;
      sub_1009DAB0(a2 + 392, v33, &v45, 0, 1, v43, v44);
    }
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
    *(_WORD *)(a2 + 428) = word_105728D8[15];
    v34 = word_105728D8[15];
    goto LABEL_54;
  }
  v35 = sub_1005C160(a3, (const void *)v4, 1);
  *(_WORD *)(a2 + 428) = word_105728D8[15];
  if ( v35 == 2 )
  {
    *(_WORD *)(a2 + 430) = word_105728D8[11];
    *(_WORD *)(a2 + 440) = word_105728D8[15];
    *(_WORD *)(a2 + 442) = word_105728D8[11];
    sub_1009ED40(a2 + 392, 3, (int)&v50, 56, (int)&v73);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      v36 = word_105728D8[11];
LABEL_52:
      *(_WORD *)(a2 + 428) = v36;
      v37 = v47 - 2;
      *(_WORD *)(a2 + 430) = word_105728D8[1];
      *(_WORD *)(a2 + 436) = v37;
      v38 = v58;
      *(_WORD *)(a2 + 438) = v28 + 1;
      v39 = *(_BYTE *)(v4 + 79);
      v46 = 0;
      v45 = v39;
      sub_1009DAB0(a2 + 392, v38, &v45, 0, 1, v43, v44);
      goto LABEL_53;
    }
  }
  else
  {
    *(_WORD *)(a2 + 430) = word_105728D8[15];
    *(_WORD *)(a2 + 440) = word_105728D8[15];
    *(_WORD *)(a2 + 442) = word_105728D8[15];
    sub_1009ED40(a2 + 392, 3, (int)&v50, 56, (int)&v73);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      v36 = word_105728D8[15];
      goto LABEL_52;
    }
  }
LABEL_53:
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  *(_WORD *)(a2 + 428) = word_105728D8[1];
  v34 = word_105728D8[1];
LABEL_54:
  *(_WORD *)(a2 + 430) = v34;
  sub_1009F430(a2 + 392, 4, (int)&v50, 2);
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  v9 = v49;
LABEL_55:
  if ( (*(_DWORD *)(a3 + 4) & 0x18) == 16 && *(_BYTE *)(v4 + 2) )
  {
    v47 = (unsigned __int16)(LOWORD(v9) + v59 - 3);
    v40 = 3 - v59 + LODWORD(v9);
    v41 = sub_10058240(a4, a3, v4, v72);
    v62 = (signed __int16)v48 / 2 + v41 - 4;
    v60 = v41;
    v64 = v41;
    v68 = v41;
    v66 = v41 - (signed __int16)v48 / 2 + 4;
    v61 = v40;
    v69 = v40;
    v63 = ((signed __int16)v40 + (signed __int16)v47) / 2;
    v65 = v47;
    v67 = ((signed __int16)v40 + (signed __int16)v47) / 2;
    *(_WORD *)(a2 + 426) = 2;
    *(_WORD *)(a2 + 424) = 2;
    if ( sub_1005C160(a3, (const void *)v4, 2) == 3 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      *(_WORD *)(a2 + 430) = word_105728D8[8];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[8];
      sub_1009F430(a2 + 392, 5, (int)&v60, 2);
      sub_1009ED40(a2 + 392, 3, (int)&v60, 56, (int)&v73);
    }
    else if ( sub_1005C160(a3, (const void *)v4, 2) == 2 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      *(_WORD *)(a2 + 430) = word_105728D8[11];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[11];
      sub_1009F430(a2 + 392, 5, (int)&v60, 2);
      sub_1009ED40(a2 + 392, 3, (int)&v60, 56, (int)&v73);
    }
    else
    {
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      *(_WORD *)(a2 + 430) = word_105728D8[15];
      sub_1009F430(a2 + 392, 5, (int)&v60, 2);
    }
  }
  result = 1;
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  return result;
}
// 1009B1EA: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10059450) --------------------------------------------------------
signed int __usercall sub_10059450@<eax>(int a1@<eax>, int a2@<esi>, int a3, __int16 *a4)
{
  int v4; // edi@1
  _BYTE *v5; // ebx@1
  float *v6; // edx@1
  float *v7; // ecx@1
  double v8; // st7@4
  float v9; // ebx@12
  int v10; // eax@12
  __int16 v11; // ax@14
  __int16 v12; // cx@14
  unsigned int v13; // edx@15
  bool v14; // zf@16
  unsigned __int16 v15; // ax@17
  __int16 v16; // dx@17
  int v17; // eax@17
  float v18; // ecx@17
  __int16 v19; // dx@22
  __int16 v20; // cx@22
  int v21; // ecx@22
  __int16 v22; // ax@26
  __int16 v23; // dx@26
  __int16 v24; // ax@27
  char v25; // al@28
  __int16 v26; // ax@30
  __int16 v27; // cx@30
  __int16 v28; // dx@30
  int v29; // eax@37
  unsigned __int16 v30; // cx@40
  __int16 v31; // bx@40
  char v32; // al@40
  int v33; // eax@41
  int v34; // ecx@41
  __int16 v35; // ax@45
  int v36; // ST14_4@45
  __int16 v37; // cx@46
  char v38; // al@47
  __int16 v39; // ax@49
  __int16 v40; // ax@52
  int v41; // ST14_4@52
  char v42; // cl@52
  int v43; // ebx@57
  __int16 v44; // ax@57
  signed int result; // eax@62
  __int16 v46; // [sp+4h] [bp-134h]@0
  int v47; // [sp+8h] [bp-130h]@0
  char v48; // [sp+10h] [bp-128h]@22
  char v49; // [sp+11h] [bp-127h]@22
  int v50; // [sp+14h] [bp-124h]@1
  int v51; // [sp+18h] [bp-120h]@1
  float v52; // [sp+1Ch] [bp-11Ch]@3
  __int16 v53; // [sp+20h] [bp-118h]@20
  __int16 v54; // [sp+22h] [bp-116h]@17
  __int16 v55; // [sp+24h] [bp-114h]@18
  __int16 v56; // [sp+26h] [bp-112h]@17
  __int16 v57; // [sp+28h] [bp-110h]@18
  __int16 v58; // [sp+2Ah] [bp-10Eh]@17
  __int16 v59; // [sp+2Ch] [bp-10Ch]@20
  __int16 v60; // [sp+2Eh] [bp-10Ah]@17
  int v61; // [sp+30h] [bp-108h]@1
  int v62; // [sp+34h] [bp-104h]@1
  __int16 v63; // [sp+38h] [bp-100h]@57
  __int16 v64; // [sp+3Ah] [bp-FEh]@57
  __int16 v65; // [sp+3Ch] [bp-FCh]@57
  __int16 v66; // [sp+3Eh] [bp-FAh]@57
  __int16 v67; // [sp+40h] [bp-F8h]@57
  __int16 v68; // [sp+42h] [bp-F6h]@57
  __int16 v69; // [sp+44h] [bp-F4h]@57
  __int16 v70; // [sp+46h] [bp-F2h]@57
  __int16 v71; // [sp+48h] [bp-F0h]@57
  __int16 v72; // [sp+4Ah] [bp-EEh]@57
  float v73; // [sp+4Ch] [bp-ECh]@1
  float v74; // [sp+50h] [bp-E8h]@40
  float v75; // [sp+54h] [bp-E4h]@57
  char v76; // [sp+58h] [bp-E0h]@21

  v4 = a1;
  *(_WORD *)(a2 + 396) = 2;
  v61 = FNT_get_fnt_hdr(3);
  v51 = 10 * *(_WORD *)(a3 + 8);
  v50 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * (v51 / 2 + 5)) >> 32) >> 2)
                         + ((unsigned int)((unsigned __int64)(1717986919i64 * (v51 / 2 + 5)) >> 32) >> 31));
  v62 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64
                                                          * ((signed __int16)(signed int)((double)v51 * 0.2) + 5)) >> 32) >> 2)
                         + ((unsigned int)((unsigned __int64)(1717986919i64
                                                            * ((signed __int16)(signed int)((double)v51 * 0.2) + 5)) >> 32) >> 31));
  v5 = (_BYTE *)v4;
  v6 = &v73;
  v7 = (float *)(v4 + 48);
  v51 = 3;
  do
  {
    if ( *v5 == 1 )
    {
      v52 = *v7;
      if ( (LODWORD(v52) & 0x7F800000) == 2139095040 )
      {
        v8 = *(float *)(v4 + 4);
      }
      else if ( *(float *)(v4 + 8) >= (double)*v7 )
      {
        if ( *(float *)(v4 + 4) <= (double)*v7 )
          v8 = *v7;
        else
          v8 = *(float *)(v4 + 4);
      }
      else
      {
        v8 = *(float *)(v4 + 8);
      }
      *v6 = v8;
    }
    ++v5;
    ++v7;
    ++v6;
    --v51;
  }
  while ( v51 );
  LODWORD(v9) = (unsigned __int16)(*a4 - 4);
  v10 = *(_DWORD *)(a3 + 4) & 0x18;
  if ( v10 != 8 && v10 != 16 )
  {
    v51 = 10 * *(_WORD *)(a3 + 8);
    v13 = (unsigned __int64)(1717986919i64 * ((signed __int16)(signed int)((double)v51 * 1.8) + 5)) >> 32;
    v11 = *(_WORD *)(a3 + 8);
    v12 = *a4;
    v51 = (unsigned __int16)(((signed int)v13 >> 2) + (v13 >> 31));
  }
  else
  {
    v51 = 10 * *(_WORD *)(a3 + 8);
    v11 = *a4;
    v51 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64
                                                            * ((signed __int16)(signed int)((double)v51 * 0.9) + 5)) >> 32) >> 2)
                           + ((unsigned int)((unsigned __int64)(1717986919i64
                                                              * ((signed __int16)(signed int)((double)v51 * 0.9) + 5)) >> 32) >> 31));
    v12 = v50;
  }
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  v14 = *(_BYTE *)v4 == 1;
  v50 = (unsigned __int16)(v12 + v11);
  if ( v14 )
  {
    v15 = sub_10058240((int)a4, a3, v4, v73);
    LODWORD(v18) = v15;
    v56 = (signed __int16)v51 / 2 + v15;
    v16 = v15 - (signed __int16)v51 / 2;
    v17 = *(_DWORD *)(a3 + 4);
    v52 = v18;
    v54 = LOWORD(v18);
    v60 = LOWORD(v18);
    LOWORD(v18) = v50;
    v58 = v16;
    if ( (v17 & 0x18) == 16 )
    {
      LODWORD(v18) = v50 - v62 + 1;
      v55 = LOWORD(v9) - v62 + 1;
      v57 = LOWORD(v9) - v62 + 1;
    }
    else
    {
      v55 = LOWORD(v9);
      v57 = LOWORD(v9);
    }
    v59 = LOWORD(v18);
    v53 = LOWORD(v18);
    if ( v17 & 0x1000000 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[6];
      *(_WORD *)(a2 + 430) = word_105728D8[6];
      *(_WORD *)(a2 + 440) = word_105728D8[6];
      *(_WORD *)(a2 + 442) = word_105728D8[6];
      sub_1009ED40(a2 + 392, 3, (int)&v53, 56, (int)&v76);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_105728D8[6];
        v19 = word_105728D8[1];
        v20 = LOWORD(v52);
        *(_WORD *)(a2 + 438) = LOWORD(v9) + 6;
        *(_WORD *)(a2 + 436) = v20 + 3;
        v21 = v61;
        *(_WORD *)(a2 + 430) = v19;
        v48 = *(_BYTE *)(v4 + 72);
        v49 = 0;
        sub_1009DAB0(a2 + 392, v21, &v48, 0, 1, v46, v47);
      }
      *(_WORD *)(a2 + 426) = 1;
      *(_WORD *)(a2 + 424) = 1;
      *(_WORD *)(a2 + 428) = word_105728D8[1];
      *(_WORD *)(a2 + 430) = word_105728D8[1];
      sub_1009F430(a2 + 392, 4, (int)&v53, 2);
      goto LABEL_36;
    }
    if ( sub_1005C160(a3, (const void *)v4, 0) == 3 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      *(_WORD *)(a2 + 430) = word_105728D8[8];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[8];
      sub_1009ED40(a2 + 392, 3, (int)&v53, 56, (int)&v76);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_105728D8[8];
        v22 = word_105728D8[15];
        v23 = LOWORD(v52) + 1;
        *(_WORD *)(a2 + 438) = LOWORD(v9) + 10;
        *(_WORD *)(a2 + 430) = v22;
        *(_WORD *)(a2 + 436) = v23;
        v48 = *(_BYTE *)(v4 + 72);
        v49 = 0;
        sub_1009DAB0(a2 + 392, v61, &v48, 0, 1, v46, v47);
      }
      *(_WORD *)(a2 + 426) = 1;
      *(_WORD *)(a2 + 424) = 1;
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      v24 = word_105728D8[15];
      goto LABEL_35;
    }
    v25 = sub_1005C160(a3, (const void *)v4, 0);
    *(_WORD *)(a2 + 428) = word_105728D8[15];
    if ( v25 == 2 )
    {
      *(_WORD *)(a2 + 430) = word_105728D8[11];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[11];
      sub_1009ED40(a2 + 392, 3, (int)&v53, 56, (int)&v76);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_105728D8[11];
        v26 = word_105728D8[1];
        v27 = LOWORD(v9) + 10;
        v28 = LOWORD(v52) + 1;
LABEL_33:
        *(_WORD *)(a2 + 438) = v27;
        *(_WORD *)(a2 + 430) = v26;
        *(_WORD *)(a2 + 436) = v28;
        v48 = *(_BYTE *)(v4 + 72);
        v49 = 0;
        sub_1009DAB0(a2 + 392, v61, &v48, 0, 1, v46, v47);
        goto LABEL_34;
      }
    }
    else
    {
      *(_WORD *)(a2 + 430) = word_105728D8[15];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[15];
      sub_1009ED40(a2 + 392, 3, (int)&v53, 56, (int)&v76);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_105728D8[15];
        v26 = word_105728D8[1];
        v27 = LOWORD(v9) + 6;
        v28 = LOWORD(v52) + 3;
        goto LABEL_33;
      }
    }
LABEL_34:
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
    *(_WORD *)(a2 + 428) = word_105728D8[1];
    v24 = word_105728D8[1];
LABEL_35:
    *(_WORD *)(a2 + 430) = v24;
    sub_1009F430(a2 + 392, 4, (int)&v53, 2);
LABEL_36:
    *(_WORD *)(a2 + 424) = 2;
    *(_WORD *)(a2 + 426) = 2;
  }
  v29 = *(_DWORD *)(a3 + 4) & 0x18;
  if ( v29 != 8 && v29 != 16 || !*(_BYTE *)(v4 + 1) )
    goto LABEL_55;
  v30 = *a4 + *(_WORD *)(a3 + 8) + 4;
  LODWORD(v52) = (unsigned __int16)v50;
  v50 = v30;
  v31 = sub_10058240((int)a4, a3, v4, v74);
  v32 = *(_DWORD *)(a3 + 4) & 0x18;
  v54 = v31;
  v56 = (signed __int16)v51 / 2 + v31;
  v58 = v31 - (signed __int16)v51 / 2;
  v60 = v31;
  if ( v32 == 16 )
  {
    v33 = LODWORD(v52) + v62 - 1;
    v34 = v50 + v62 - 1;
  }
  else
  {
    LOWORD(v33) = LOWORD(v52);
    LOWORD(v34) = v50;
  }
  v59 = v33;
  v53 = v33;
  v57 = v34;
  v55 = v34;
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  if ( sub_1005C160(a3, (const void *)v4, 1) == 3 )
  {
    *(_WORD *)(a2 + 428) = word_105728D8[15];
    *(_WORD *)(a2 + 430) = word_105728D8[8];
    *(_WORD *)(a2 + 440) = word_105728D8[15];
    *(_WORD *)(a2 + 442) = word_105728D8[8];
    sub_1009ED40(a2 + 392, 3, (int)&v53, 56, (int)&v76);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[8];
      v35 = v50 - 5;
      *(_WORD *)(a2 + 430) = word_105728D8[15];
      *(_WORD *)(a2 + 438) = v35;
      v36 = v61;
      *(_WORD *)(a2 + 436) = v31 + 4;
      v48 = *(_BYTE *)(v4 + 79);
      v49 = 0;
      sub_1009DAB0(a2 + 392, v36, &v48, 0, 1, v46, v47);
    }
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
    *(_WORD *)(a2 + 428) = word_105728D8[15];
    v37 = word_105728D8[15];
    goto LABEL_54;
  }
  v38 = sub_1005C160(a3, (const void *)v4, 1);
  *(_WORD *)(a2 + 428) = word_105728D8[15];
  if ( v38 == 2 )
  {
    *(_WORD *)(a2 + 430) = word_105728D8[11];
    *(_WORD *)(a2 + 440) = word_105728D8[15];
    *(_WORD *)(a2 + 442) = word_105728D8[11];
    sub_1009ED40(a2 + 392, 3, (int)&v53, 56, (int)&v76);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      v39 = word_105728D8[11];
LABEL_52:
      *(_WORD *)(a2 + 428) = v39;
      v40 = v50 - 5;
      *(_WORD *)(a2 + 430) = word_105728D8[1];
      *(_WORD *)(a2 + 438) = v40;
      v41 = v61;
      *(_WORD *)(a2 + 436) = v31 + 4;
      v42 = *(_BYTE *)(v4 + 79);
      v49 = 0;
      v48 = v42;
      sub_1009DAB0(a2 + 392, v41, &v48, 0, 1, v46, v47);
      goto LABEL_53;
    }
  }
  else
  {
    *(_WORD *)(a2 + 430) = word_105728D8[15];
    *(_WORD *)(a2 + 440) = word_105728D8[15];
    *(_WORD *)(a2 + 442) = word_105728D8[15];
    sub_1009ED40(a2 + 392, 3, (int)&v53, 56, (int)&v76);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      v39 = word_105728D8[15];
      goto LABEL_52;
    }
  }
LABEL_53:
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  *(_WORD *)(a2 + 428) = word_105728D8[1];
  v37 = word_105728D8[1];
LABEL_54:
  *(_WORD *)(a2 + 430) = v37;
  sub_1009F430(a2 + 392, 4, (int)&v53, 2);
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  v9 = v52;
LABEL_55:
  if ( (*(_DWORD *)(a3 + 4) & 0x18) == 16 && *(_BYTE *)(v4 + 2) )
  {
    v50 = (unsigned __int16)(LOWORD(v9) + v62 - 3);
    v43 = 3 - v62 + LODWORD(v9);
    v44 = sub_10058240((int)a4, a3, v4, v75);
    v66 = (signed __int16)v51 / 2 + v44 - 4;
    v64 = v44;
    v68 = v44;
    v72 = v44;
    v70 = v44 - (signed __int16)v51 / 2 + 4;
    v63 = v43;
    v71 = v43;
    v65 = ((signed __int16)v43 + (signed __int16)v50) / 2;
    v67 = v50;
    v69 = ((signed __int16)v43 + (signed __int16)v50) / 2;
    *(_WORD *)(a2 + 426) = 2;
    *(_WORD *)(a2 + 424) = 2;
    if ( sub_1005C160(a3, (const void *)v4, 2) == 3 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      *(_WORD *)(a2 + 430) = word_105728D8[8];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[8];
      sub_1009F430(a2 + 392, 5, (int)&v63, 2);
      sub_1009ED40(a2 + 392, 3, (int)&v63, 56, (int)&v76);
    }
    else if ( sub_1005C160(a3, (const void *)v4, 2) == 2 )
    {
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      *(_WORD *)(a2 + 430) = word_105728D8[11];
      *(_WORD *)(a2 + 440) = word_105728D8[15];
      *(_WORD *)(a2 + 442) = word_105728D8[11];
      sub_1009F430(a2 + 392, 5, (int)&v63, 2);
      sub_1009ED40(a2 + 392, 3, (int)&v63, 56, (int)&v76);
    }
    else
    {
      *(_WORD *)(a2 + 428) = word_105728D8[15];
      *(_WORD *)(a2 + 430) = word_105728D8[15];
      sub_1009F430(a2 + 392, 5, (int)&v63, 2);
    }
  }
  result = 1;
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  return result;
}
// 1009B1EA: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005A000) --------------------------------------------------------
char __cdecl sub_1005A000(int a1, int a2, int *a3, int a4, _WORD *a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edx@4
  int v9; // ecx@4
  char result; // al@4
  int v11; // [sp+Ch] [bp-4h]@1

  v5 = *(_DWORD *)(a2 + 4);
  v6 = *a3;
  v7 = *(_DWORD *)(a2 + 4) & 0x800;
  v11 = *a3;
  if ( v7 )
    HIWORD(v11) = HIWORD(v6) + 26;
  switch ( *a5 )
  {
    case 0x8041:
      v8 = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 60) = *(_DWORD *)(a4 + 48);
      v9 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a4 + 64) = v8;
      *(_DWORD *)(a4 + 68) = v9;
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( v5 & 0x200 )
        sub_1005BCC0(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), (int)&v11);
      sub_100578B0((int)&v11, a2, a1);
      if ( *(_BYTE *)(a2 + 4) & 0x40 )
        sub_10057EB0(a1, a2, (int)&v11);
      sub_10058350(a4, (int)&v11, a1, a2);
      if ( *(_DWORD *)(a2 + 4) & 0x400 )
        sub_10057DF0(a2, (int)&v11, a1, a4, (int)a5);
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10057750(a1, a2, (int)a3, a4, a5);
      else
        sub_10057B70((int)a5, (int)&v11, a2, a1, (const void *)a4);
      sub_10058160((int)&v11, a1, a2, a4);
      if ( *(_DWORD *)(a2 + 4) & 0x200000 )
      {
        sub_10059450(a4, a1, a2, (__int16 *)&v11);
        result = 1;
      }
      else
      {
        sub_100588B0(a4, a1, a2, (int)&v11);
        result = 1;
      }
      break;
    case 0x8015:
    case 0x8016:
      if ( v7 != 2048 )
      {
        sub_10057B70((int)a5, (int)&v11, a2, a1, (const void *)a4);
        goto LABEL_20;
      }
      sub_10057750(a1, a2, (int)a3, a4, a5);
      result = 1;
      break;
    default:
LABEL_20:
      result = 1;
      break;
  }
  return result;
}

//----- (1005A230) --------------------------------------------------------
int __usercall sub_1005A230@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4, int a5)
{
  _WORD *v5; // ebx@1
  double v6; // st7@1
  __int16 v7; // cx@1
  int v8; // ebp@1
  double v9; // ST34_8@3
  signed int v10; // eax@3
  signed int v11; // eax@3
  __int16 v12; // cx@3
  int result; // eax@4
  int v14; // ecx@6
  int v15; // eax@6
  int v16; // edx@6
  int v17; // ebx@6
  int v18; // ecx@6
  double v19; // st6@7
  __int16 *v20; // ecx@10
  __int16 v21; // ax@11
  double v22; // st6@25
  int v23; // ecx@26
  bool v24; // zf@27
  int v25; // ecx@31
  signed int v26; // ST3C_4@33
  int v27; // eax@33
  __int16 v28; // ax@36
  int v29; // ebx@39
  bool v30; // sf@39
  unsigned __int8 v31; // of@39
  int v32; // [sp+4h] [bp-20h]@4
  float v33; // [sp+8h] [bp-1Ch]@1
  int v34; // [sp+Ch] [bp-18h]@4
  signed int v35; // [sp+10h] [bp-14h]@26
  unsigned __int16 v36; // [sp+18h] [bp-Ch]@1
  int v37; // [sp+18h] [bp-Ch]@6
  __int16 v38; // [sp+1Ch] [bp-8h]@1
  __int16 v39; // [sp+20h] [bp-4h]@1
  int v40; // [sp+28h] [bp+4h]@5

  v5 = (_WORD *)a1;
  v33 = *(float *)(a3 + 12) - *(float *)(a3 + 8);
  v6 = v33;
  v36 = *(_WORD *)a1;
  v7 = *(_BYTE *)(a2 + 16) * (*(_WORD *)(a2 + 14) + 1);
  v8 = a4;
  v39 = (*(_WORD *)(a2 + 12) - *(_BYTE *)a3 * (2 * *(_BYTE *)(a3 + 1) + 3) + 5) / (*(_BYTE *)(a3 + 1) * *(_BYTE *)a3);
  v38 = v7 + *(_WORD *)(a1 + 2) - 1;
  if ( *(_DWORD *)(a2 + 8) & 0x4000000 && 0.0 != v6 )
  {
    v9 = (double)(signed __int16)(v7 + *(_WORD *)(a1 + 2) - 1);
    v10 = (signed int)(v9 - (*(float *)(a3 + 16) - *(float *)(a3 + 8)) / v6 * (double)(signed __int16)(v7 - 1));
    *(_WORD *)(a4 + 428) = word_105728D8[11];
    *(_WORD *)(a4 + 430) = word_105728D8[11];
    *(_WORD *)(a4 + 438) = *v5;
    *(_WORD *)(a4 + 436) = v10;
    sub_1009E7F0(a4 + 392, *v5 + *(_WORD *)(a2 + 12), v10, 2);
    v11 = (signed int)(v9
                     - (*(float *)(a3 + 20) - *(float *)(a3 + 8))
                     / v33
                     * (double)(signed __int16)(*(_BYTE *)(a2 + 16) * (*(_WORD *)(a2 + 14) + 1) - 1));
    *(_WORD *)(a4 + 428) = word_105728D8[8];
    *(_WORD *)(a4 + 430) = word_105728D8[8];
    v12 = *v5;
    *(_WORD *)(a4 + 436) = v11;
    *(_WORD *)(a4 + 438) = v12;
    sub_1009E7F0(a4 + 392, *v5 + *(_WORD *)(a2 + 12), v11, 2);
    v6 = v33;
  }
  *(_WORD *)(a4 + 440) = HIWORD(a5);
  *(_WORD *)(a4 + 442) = HIWORD(a5);
  *(_WORD *)(a4 + 428) = HIWORD(a5);
  *(_WORD *)(a4 + 430) = HIWORD(a5);
  result = v36;
  v32 = v36;
  v34 = 0;
  if ( *(_BYTE *)a3 )
  {
    while ( 1 )
    {
      v40 = 0;
      if ( *(_BYTE *)(a3 + 1) )
        break;
LABEL_39:
      v29 = *(_BYTE *)a3;
      result = v34 + 1;
      v31 = __OFSUB__(v34 + 1, v29);
      v30 = v34 + 1 - v29 < 0;
      v32 += (*(_WORD *)(a2 + 12) - v29 * (2 * *(_BYTE *)(a3 + 1) + 3) + 5) / (v29 * *(_BYTE *)(a3 + 1)) + 5;
      ++v34;
      if ( !(v30 ^ v31) )
        return result;
    }
    while ( 1 )
    {
      v14 = *(_BYTE *)a3;
      v37 = (unsigned __int16)(v38 - *(_WORD *)(a2 + 14));
      v15 = (*(_WORD *)(a2 + 12) - v14 * (2 * *(_BYTE *)(a3 + 1) + 3) + 5) / (v14 * *(_BYTE *)(a3 + 1));
      v16 = v40;
      v17 = v34;
      v18 = v34 + v40 * v14;
      v32 += v40 * (v15 + 2);
      if ( *(_BYTE *)(v18 + *(_DWORD *)(a3 + 4)) )
        break;
LABEL_38:
      v40 = v16 + 1;
      if ( v16 + 1 >= *(_BYTE *)(a3 + 1) )
        goto LABEL_39;
    }
    v19 = *(float *)(*(_DWORD *)(a3 + 28) + 4 * v18);
    if ( v34 != *(_BYTE *)(*(_DWORD *)(a3 + 44) + v40) || *(float *)(a3 + 16) < v19 && *(_DWORD *)(a2 + 8) & 0x4000000 )
    {
      if ( *(float *)(a3 + 16) < v19 && *(float *)(a3 + 20) >= v19 && *(_DWORD *)(a2 + 8) & 0x4000000 )
      {
        *(_WORD *)(v8 + 440) = word_105728D8[11];
        *(_WORD *)(v8 + 442) = word_105728D8[11];
        v20 = word_105728D8;
        if ( v34 != *(_BYTE *)(*(_DWORD *)(a3 + 44) + v40) )
        {
          *(_WORD *)(v8 + 428) = word_105728D8[11];
          v21 = word_105728D8[11];
          goto LABEL_22;
        }
      }
      else
      {
        if ( *(float *)(a3 + 20) >= v19 || !(*(_DWORD *)(a2 + 8) & 0x4000000) )
        {
          v21 = HIWORD(a5);
          *(_WORD *)(v8 + 440) = HIWORD(a5);
          *(_WORD *)(v8 + 442) = HIWORD(a5);
          *(_WORD *)(v8 + 428) = HIWORD(a5);
          goto LABEL_22;
        }
        *(_WORD *)(v8 + 440) = word_105728D8[8];
        *(_WORD *)(v8 + 442) = word_105728D8[8];
        v20 = word_105728D8;
        if ( v34 != *(_BYTE *)(*(_DWORD *)(a3 + 44) + v40) )
        {
          *(_WORD *)(v8 + 428) = word_105728D8[8];
          v21 = word_105728D8[8];
          goto LABEL_22;
        }
      }
    }
    else
    {
      *(_WORD *)(v8 + 440) = word_105728D8[6];
      *(_WORD *)(v8 + 442) = word_105728D8[6];
      v20 = word_105728D8;
    }
    *(_WORD *)(v8 + 428) = v20[6];
    v21 = word_105728D8[6];
LABEL_22:
    *(_WORD *)(v8 + 430) = v21;
    if ( *(float *)(a3 + 12) < v19 )
      v19 = *(float *)(a3 + 12);
    if ( 0.0 != v6 )
    {
      v22 = (v19 - *(float *)(a3 + 8)) / v6 * (double)*(_BYTE *)(a2 + 16) + 0.5;
      if ( (signed int)v22 > 0 )
      {
        LOWORD(v23) = *(_WORD *)(a2 + 14);
        v35 = (signed int)v22;
        do
        {
          sub_1009E590(v8 + 392, v32, v37, v39, v23, 1);
          v23 = *(_WORD *)(a2 + 14);
          v24 = v35-- == 1;
          v37 += -1 - v23;
        }
        while ( !v24 );
        v6 = v33;
        v17 = v34;
      }
      v16 = v40;
    }
    if ( *(_DWORD *)(a2 + 8) & 0x8000000 )
    {
      v25 = v16 * *(_BYTE *)(a3 + 1);
      if ( *(_BYTE *)(v25 + *(_DWORD *)(a3 + 40) + v17) )
      {
        if ( 0.0 != v6 )
        {
          v26 = *(_BYTE *)(a2 + 16);
          v27 = (signed int)((*(float *)(*(_DWORD *)(a3 + 36) + 4 * (v17 + v25)) - *(float *)(a3 + 8))
                           / v6
                           * (double)v26
                           + 0.5
                           - 1.0);
          if ( v27 >= v26 )
            v27 = *(_BYTE *)(a2 + 16) - 1;
          if ( v27 >= 0 )
          {
            v28 = v38 - v27 * (*(_WORD *)(a2 + 14) + 1) - *(_WORD *)(a2 + 14);
            *(_WORD *)(v8 + 440) = word_105728D8[1];
            *(_WORD *)(v8 + 442) = word_105728D8[1];
            sub_1009E590(v8 + 392, v32, v28, v39, *(_WORD *)(a2 + 14), 1);
            v6 = v33;
          }
          v16 = v40;
        }
      }
    }
    goto LABEL_38;
  }
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005A780) --------------------------------------------------------
char __usercall sub_1005A780@<al>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ST14_2@1
  int v7; // eax@1
  unsigned int v8; // ST08_4@1
  int *v9; // eax@1
  int v10; // ST04_4@1
  signed int v11; // eax@1
  unsigned __int8 v12; // bl@1
  int v13; // ecx@1
  int v14; // eax@1
  __int16 v15; // bp@1
  int v16; // ecx@1
  __int16 v17; // ax@1
  signed int v18; // ebx@1
  _BYTE *v19; // ecx@3
  char v21; // [sp+Ch] [bp-20h]@3
  char v22; // [sp+Dh] [bp-1Fh]@1
  int v23; // [sp+10h] [bp-1Ch]@1
  int v24; // [sp+14h] [bp-18h]@1
  int v25; // [sp+18h] [bp-14h]@1
  int v26; // [sp+1Ch] [bp-10h]@1
  __int16 v27; // [sp+20h] [bp-Ch]@1
  int v28; // [sp+22h] [bp-Ah]@5
  int v29; // [sp+28h] [bp-4h]@1
  int v30; // [sp+34h] [bp+8h]@1

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 4);
  v22 = 0;
  v25 = sub_1006D040(v6);
  v7 = sub_1006D920((*(_DWORD *)(v5 + 4) >> 10) & 0xF, 0);
  v8 = *(_DWORD *)(v5 + 4);
  v23 = v7;
  v9 = sub_1006D000(v8);
  v10 = *(_DWORD *)(v5 + 4);
  v24 = v9[1];
  v26 = BYTE2(v23);
  v27 = 0;
  v11 = sub_1006D070(v10);
  v12 = *(_BYTE *)(a2 + 1);
  v13 = *(_BYTE *)a2;
  v29 = v11;
  v14 = (unsigned __int16)(v12 * ((unsigned int)((*(_WORD *)(v5 + 12) - v13 * (2 * v12 + 3) + 5) / (v12 * v13)) + 2) - 2);
  v23 = v14;
  v15 = *(_WORD *)a4 + (signed __int16)v14 / 2;
  v16 = sub_1006D000(*(_DWORD *)(v5 + 8))[1];
  v17 = *(_BYTE *)(v5 + 16);
  v18 = 0;
  v30 = (unsigned __int16)(*(_WORD *)(a4 + 2) + *(_WORD *)(v16 + 22) + v17 * (*(_WORD *)(v5 + 14) + 1) + 2);
  if ( *(_BYTE *)a2 )
  {
    v23 += 5;
    do
    {
      v19 = *(_BYTE **)(a2 + 44);
      v21 = v18 + 49;
      if ( v18 != *v19 || *(_BYTE *)(a2 + 1) != 1 )
      {
        v28 = a5;
      }
      else
      {
        HIWORD(v28) = word_105728D8[6];
        LOWORD(v28) = a5;
      }
      *(_WORD *)(a3 + 438) = v15;
      *(_WORD *)(a3 + 436) = v30;
      LOBYTE(v17) = sub_1006D8E0(a3, &v21, &v24);
      v15 += v23;
      ++v18;
    }
    while ( v18 < *(_BYTE *)a2 );
  }
  return v17;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005A8F0) --------------------------------------------------------
int __usercall sub_1005A8F0@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4)
{
  __int16 v4; // cx@1
  int result; // eax@1
  int v6; // esi@1
  __int16 v7; // dx@1
  __int16 v8; // dx@1
  int v9; // ebp@1
  bool v10; // zf@1
  signed int v11; // ebx@2
  int v12; // ecx@3
  int v13; // eax@3
  int v14; // ecx@3
  int v15; // ebx@7
  int v16; // [sp+8h] [bp-8h]@1
  __int16 v17; // [sp+Ch] [bp-4h]@3
  __int16 v18; // [sp+Eh] [bp-2h]@1

  v4 = *(_WORD *)a1;
  result = *(_WORD *)(a1 + 2);
  v6 = a4;
  v7 = *(_WORD *)(a4 + 14);
  LOWORD(v16) = v4;
  v8 = result + *(_BYTE *)(a4 + 16) * (v7 + 1) - 1;
  v9 = 0;
  v10 = *(_BYTE *)a2 == 0;
  HIWORD(v16) = result;
  v18 = v8;
  if ( !v10 )
  {
    do
    {
      v11 = 0;
      if ( *(_BYTE *)(a2 + 1) )
      {
        do
        {
          v12 = *(_BYTE *)a2;
          v13 = (*(_WORD *)(a4 + 12) - v12 * (2 * *(_BYTE *)(a2 + 1) + 3) + 5) / (v12 * *(_BYTE *)(a2 + 1));
          v14 = *(_DWORD *)(a2 + 4) + v11 * v12;
          LOWORD(v16) = v11 * (v13 + 2) + v16;
          v17 = v16 + v13;
          if ( !*(_BYTE *)(v14 + v9) )
            sub_1006D760(a3, (int)&v16, (int)&v17, 0);
          ++v11;
        }
        while ( v11 < *(_BYTE *)(a2 + 1) );
        v6 = a4;
      }
      v15 = *(_BYTE *)a2;
      ++v9;
      result = (*(_WORD *)(v6 + 12) - v15 * (2 * *(_BYTE *)(a2 + 1) + 3) + 5) / (v15 * *(_BYTE *)(a2 + 1)) + 5;
      LOWORD(v16) = result + v16;
    }
    while ( v9 < v15 );
  }
  return result;
}

//----- (1005A9F0) --------------------------------------------------------
char __cdecl sub_1005A9F0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // eax@4
  int v6; // esi@4
  unsigned int v7; // eax@4
  int *v8; // eax@5
  int v9; // edi@5
  unsigned __int8 v10; // bl@6
  int v11; // eax@7
  int v12; // ecx@7

  if ( *a5 == 32802 )
  {
LABEL_4:
    v5 = sub_1006CFD0(*(_DWORD *)(a2 + 4));
    v6 = v5;
    *(_WORD *)(a1 + 440) = v5;
    *(_WORD *)(a1 + 442) = v5;
    v7 = *(_DWORD *)(a2 + 8);
    if ( v7 & 0x2000000 )
    {
      v8 = sub_1006D000(v7);
      v9 = a3;
      sub_1009F8C0(
        a1 + 392,
        *(_WORD *)a3,
        *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 12),
        *(_WORD *)(v8[1] + 22) + *(_BYTE *)(a2 + 16) * (*(_WORD *)(a2 + 14) + 1) + 2);
    }
    else
    {
      sub_1009F8C0(
        a1 + 392,
        *(_WORD *)a3,
        *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 12),
        *(_BYTE *)(a2 + 16) * (*(_WORD *)(a2 + 14) + 1) - 1);
      v9 = a3;
    }
    sub_1005A230(v9, a2, a4, a1, v6);
    if ( *(_DWORD *)(a2 + 8) & 0x2000000 )
      sub_1005A780(a2, a4, a1, a3, v6);
    if ( *(_DWORD *)(a2 + 8) & 0x10000000 )
      sub_1005A8F0(a3, a4, a1, a2);
    return 1;
  }
  if ( *a5 != 32833 )
  {
    if ( *a5 == 32888 )
      goto LABEL_4;
    return 1;
  }
  v10 = *(_BYTE *)a4 * *(_BYTE *)(a4 + 1);
  *(_DWORD *)(a4 + 28) = sub_100034E0(a1, 4 * v10);
  if ( !v10 )
    return 1;
  v11 = 0;
  v12 = v10;
  do
  {
    *(float *)(v11 + *(_DWORD *)(a4 + 28)) = *(float *)(v11 + *(_DWORD *)(a4 + 32));
    v11 += 4;
    --v12;
  }
  while ( v12 );
  return 1;
}

//----- (1005AB70) --------------------------------------------------------
__int16 __usercall sub_1005AB70@<ax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4)
{
  int v4; // eax@1
  __int16 result; // ax@3

  v4 = *(_WORD *)(a3 + 8) / 2;
  if ( v4 >= *(_WORD *)(a3 + 10) / 2 )
    LOWORD(v4) = *(_WORD *)(a3 + 10) / 2;
  *a4 = v4;
  *(_WORD *)a2 = *(_WORD *)a1 + *(_WORD *)(a3 + 8) / 2;
  result = *(_WORD *)(a1 + 2) + *(_WORD *)(a3 + 10) / 2;
  *(_WORD *)(a2 + 2) = result;
  return result;
}

//----- (1005ABC0) --------------------------------------------------------
signed __int16 __usercall sub_1005ABC0@<ax>(int a1@<edx>, int a2, int a3, __int16 a4, __int16 a5)
{
  signed __int16 result; // ax@1
  __int16 v6; // di@2
  __int16 v7; // bx@2
  __int16 v8; // ST28_2@2
  signed int v9; // eax@2
  int v10; // [sp+14h] [bp-2Ch]@2
  int v11; // [sp+18h] [bp-28h]@2
  double v12; // [sp+20h] [bp-20h]@2
  double v13; // [sp+28h] [bp-18h]@2
  double v14; // [sp+30h] [bp-10h]@2
  long double v15; // [sp+38h] [bp-8h]@2

  result = a5;
  if ( a4 != a5 )
  {
    sub_1005AB70(a1, (int)&v11, a3, &v10);
    v6 = v10;
    v7 = v11;
    v15 = (double)a4 * 0.01745329251994333;
    v12 = (double)(signed __int16)v10;
    v13 = (double)(signed __int16)v11;
    v8 = (signed int)(cos(v15) * v12 + v13);
    v14 = (double)SHIWORD(v11);
    v9 = (signed int)(v14 - sin(v15) * v12);
    v10 = a5;
    *(_WORD *)(a2 + 426) = 3;
    *(_WORD *)(a2 + 424) = 3;
    *(_WORD *)(a2 + 396) = 2;
    *(_WORD *)(a2 + 438) = v8;
    *(_WORD *)(a2 + 436) = v9;
    v15 = (double)a5 * 0.01745329251994333;
    sub_1009F9B0(
      a2 + 392,
      v7,
      SHIWORD(v11),
      v6,
      1,
      (signed int)(cos(v15) * v12 + v13),
      (signed int)(v14 - sin(v15) * v12));
    result = 1;
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
  }
  return result;
}

//----- (1005AD20) --------------------------------------------------------
int __usercall sub_1005AD20@<eax>(int a1@<edx>, int a2, int a3, __int16 a4, __int16 a5)
{
  int v5; // eax@1
  double v6; // st7@2
  bool v7; // sf@4
  unsigned __int8 v8; // of@4
  long double v9; // st7@11
  double v10; // st6@11
  signed int v11; // eax@11
  double v12; // st5@11
  long double v13; // st4@11
  int result; // eax@13
  __int16 v15; // [sp+Ch] [bp-3Ch]@1
  double v16; // [sp+10h] [bp-38h]@2
  int v17; // [sp+18h] [bp-30h]@1
  __int16 v18; // [sp+1Ch] [bp-2Ch]@1
  __int16 v19; // [sp+1Eh] [bp-2Ah]@11
  int v20; // [sp+20h] [bp-28h]@11
  long double v21; // [sp+28h] [bp-20h]@11
  double v22; // [sp+30h] [bp-18h]@11
  long double v23; // [sp+38h] [bp-10h]@11
  double v24; // [sp+40h] [bp-8h]@11

  *(_WORD *)(a2 + 396) = 2;
  *(_WORD *)(a2 + 426) = 3;
  *(_WORD *)(a2 + 424) = 3;
  sub_1005AB70(a1, (int)&v18, a3, &v15);
  v5 = *(_BYTE *)(a3 + 12);
  v17 = 0;
  if ( v5 > 0 )
  {
    while ( 1 )
    {
      *(float *)&v16 = 210.0 - (double)v17 * 225.0 / (double)(v5 - 1);
      v6 = *(float *)&v16;
      if ( *(float *)&v16 < 0.0 )
      {
        *(float *)&v16 = v6 + 360.0;
        v6 = *(float *)&v16;
      }
      v8 = __OFSUB__(a4, a5);
      v7 = (signed __int16)(a4 - a5) < 0;
      if ( a4 <= a5 )
        goto LABEL_8;
      LODWORD(v16) = a4;
      if ( (double)a4 < v6 )
        break;
      LODWORD(v16) = a5;
      if ( (double)a5 > v6 )
        break;
LABEL_11:
      v21 = v6 * 0.01745329251994333;
      v23 = cos(v21);
      v22 = (double)v15;
      v24 = (double)v18;
      v16 = (double)v19;
      v9 = sin(v21);
      v10 = v16;
      v11 = (signed int)(v16 - v22 * v9);
      LODWORD(v16) = v15 - 7;
      v12 = (double)SLODWORD(v16);
      *(_WORD *)(a2 + 438) = (signed int)(v23 * v22 + v24);
      v13 = v23;
      *(_WORD *)(a2 + 436) = v11;
      LOWORD(v20) = (signed int)(v13 * v12 + v24);
      HIWORD(v20) = (signed int)(v10 - v9 * v12);
      sub_1009E7F0(a2 + 392, v20, SHIWORD(v20), 0);
LABEL_12:
      v5 = *(_BYTE *)(a3 + 12);
      if ( ++v17 >= v5 )
        goto LABEL_13;
    }
    v8 = __OFSUB__(a4, a5);
    v7 = (signed __int16)(a4 - a5) < 0;
LABEL_8:
    if ( !(v7 ^ v8) )
      goto LABEL_12;
    LODWORD(v16) = a4;
    if ( (double)a4 < v6 )
    {
      LODWORD(v16) = a5;
      if ( (double)a5 > v6 )
        goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_13:
  result = a2;
  *(_WORD *)(a2 + 424) = 1;
  *(_WORD *)(a2 + 426) = 1;
  return result;
}

//----- (1005AF30) --------------------------------------------------------
signed __int16 __usercall sub_1005AF30@<ax>(int a1@<eax>, int a2, int a3)
{
  *(_WORD *)(a1 + 394) = 1;
  *(_WORD *)(a1 + 428) = word_105728D8[15];
  *(_WORD *)(a1 + 430) = word_105728D8[15];
  return sub_1005ABC0(a3, a1, a2, 210, 345);
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005AF80) --------------------------------------------------------
char __usercall sub_1005AF80@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  char v7; // bl@4
  int v8; // edi@5
  int v9; // eax@9
  char *v10; // edi@11
  char v11; // al@12
  int v12; // ecx@20
  char *v13; // eax@20
  char v14; // cl@21
  int v16; // [sp+Ch] [bp-38h]@20
  int v17; // [sp+10h] [bp-34h]@5
  int v18; // [sp+14h] [bp-30h]@22
  int v19; // [sp+18h] [bp-2Ch]@17
  __int16 v20; // [sp+1Ch] [bp-28h]@22
  __int16 v21; // [sp+1Eh] [bp-26h]@22
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  char v25[20]; // [sp+2Ch] [bp-18h]@10

  v24 = a4;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v23 = a2;
  v22 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v7 = 0;
  if ( v6 )
  {
    v8 = 0;
    v17 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1005C160(a3, a5, v8) > (unsigned __int8)v7 )
        v7 = sub_1005C160(a3, a5, v8);
      ++v8;
      --v17;
    }
    while ( v17 );
  }
  v9 = *(_DWORD *)(a3 + 4);
  if ( ~(unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7) & 1 )
  {
    sub_1005BD10(a3, (int)a5, v25);
    if ( *(_DWORD *)(a3 + 4) & 0x1000 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 32;
      sub_1005C490(*(_BYTE *)(a3 + 13), &v25[strlen(v25)]);
    }
  }
  else
  {
    if ( !(v9 & 0x1000) )
      return v9;
    sub_1005C490(*(_BYTE *)(a3 + 13), v25);
  }
  switch ( v7 )
  {
    case 3:
      v19 = byte_10658E06 != 0 ? 35087 : 35304;
      break;
    case 2:
      v19 = 35169;
      break;
    default:
      v19 = 35215;
      break;
  }
  v12 = *(_WORD *)(a3 + 10);
  LOWORD(v16) = *(_WORD *)v23 + *(_WORD *)(a3 + 8) / 2;
  HIWORD(v16) = *(_WORD *)(v23 + 2)
              + 2
              * (((unsigned __int64)(1431655766i64 * v12) >> 32)
               + ((unsigned int)((unsigned __int64)(1431655766i64 * v12) >> 32) >> 31));
  v13 = v25;
  do
    v14 = *v13++;
  while ( v14 );
  v21 = (_WORD)v13 - (unsigned int)&v25[1];
  v18 = 105;
  v20 = 0;
  LOBYTE(v9) = sub_100698B0(v24, (int)&v18, (int)&v16, v25, v22);
  return v9;
}
// 10658E06: using guessed type char byte_10658E06;
// 1005AF80: using guessed type char var_18[20];

//----- (1005B160) --------------------------------------------------------
char __usercall sub_1005B160@<al>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ebx@1
  __int16 v7; // dx@1
  __int16 v8; // cx@1
  __int16 v10; // [sp+Ch] [bp-38h]@1
  __int16 v11; // [sp+Eh] [bp-36h]@1
  __int16 v12; // [sp+10h] [bp-34h]@1
  __int16 v13; // [sp+12h] [bp-32h]@1
  float v14; // [sp+14h] [bp-30h]@1
  float v15; // [sp+18h] [bp-2Ch]@1
  int v16; // [sp+1Ch] [bp-28h]@1
  char v17; // [sp+20h] [bp-24h]@1
  char v18; // [sp+30h] [bp-14h]@1

  v5 = a2;
  v6 = a1;
  v16 = a5;
  sub_1005C100(*(_BYTE *)(a2 + 13), (int)&v17, (int)&v18);
  v7 = *(_WORD *)(v5 + 8);
  v8 = *(_WORD *)v6;
  v15 = *(float *)(a4 + 8);
  LOWORD(v5) = *(_WORD *)(v5 + 10);
  v14 = *(float *)(a4 + 4);
  LOWORD(v6) = *(_WORD *)(v6 + 2);
  v12 = v8 + v7 + 11;
  v10 = v8 - 7;
  v13 = (signed __int16)v5 / 2 + v6 + 28;
  v11 = v6 + v5 - 21;
  sub_1006B030(a3, (int)&v17, (int *)&v10, &v14, a5);
  return sub_1006B030(a3, (int)&v18, (int *)&v12, &v15, a5);
}

//----- (1005B230) --------------------------------------------------------
char __usercall sub_1005B230@<al>(int a1@<edx>, int a2@<ecx>, int a3, const void *a4, int a5)
{
  int v5; // eax@1
  int v6; // ebx@2
  int v7; // edi@5
  char *v8; // esi@5
  int v9; // ebp@5
  __int16 v10; // ax@12
  __int16 v11; // ax@12
  int v12; // esi@13
  char *v13; // edi@13
  float *v14; // ebp@13
  double v15; // st7@17
  int v17; // [sp+10h] [bp-60h]@1
  int v18; // [sp+1Ch] [bp-54h]@1
  __int16 v19; // [sp+24h] [bp-4Ch]@12
  __int16 v20; // [sp+26h] [bp-4Ah]@12
  float v21[3]; // [sp+30h] [bp-40h]@19
  char v22; // [sp+3Ch] [bp-34h]@13
  char v23; // [sp+40h] [bp-30h]@5

  v18 = a1;
  v5 = *(_DWORD *)(a2 + 4) & 0x18;
  v17 = a2;
  if ( v5 == 16 )
    LOBYTE(v6) = 3;
  else
    LOBYTE(v6) = (v5 == 8) + 1;
  if ( (_BYTE)v6 )
  {
    v7 = 0;
    v8 = &v23;
    v9 = (unsigned __int8)v6;
    do
    {
      sub_1005C440(*(_BYTE *)(a2 + 13), (int)(v8 - 4));
      if ( *((_BYTE *)a4 + v7) )
      {
        switch ( sub_1005C160(v17, a4, v7) )
        {
          case 3:
            *(_DWORD *)v8 = byte_10658E06 != 0 ? 40207 : 40424;
            break;
          case 2:
            *(_DWORD *)v8 = 40289;
            break;
          default:
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        *(_DWORD *)v8 = 40335;
      }
      a2 = v17;
      ++v7;
      v8 += 16;
      --v9;
    }
    while ( v9 );
  }
  v10 = *(_WORD *)(a2 + 10) + *(_WORD *)(v18 + 2);
  v19 = *(_WORD *)v18 + *(_WORD *)(a2 + 8) / 2;
  v11 = v10 - 17;
  v20 = v11;
  if ( (_BYTE)v6 )
  {
    v12 = 0;
    v13 = &v22;
    v14 = (float *)((char *)a4 + 60);
    v6 = (unsigned __int8)v6;
    while ( 1 )
    {
      v15 = *((_BYTE *)a4 + v12) && sub_1005C160(a2, a4, v12) ? *v14 : 9.8999998e24;
      v21[v12] = v15;
      LOBYTE(v11) = sub_1006B030(a3, (int)v13, (int *)&v19 + v12, &v21[v12], a5);
      ++v12;
      ++v14;
      v13 += 16;
      if ( !--v6 )
        break;
      a2 = v17;
    }
  }
  return v11;
}
// 10658E06: using guessed type char byte_10658E06;
// 1005B230: using guessed type float var_40[3];

//----- (1005B3B0) --------------------------------------------------------
int __usercall sub_1005B3B0@<eax>(int result@<eax>, int a2@<ecx>, int a3)
{
  if ( *(_BYTE *)(a2 + 12) > 1u )
  {
    *(_WORD *)(result + 428) = word_105728D8[15];
    *(_WORD *)(result + 430) = word_105728D8[15];
    result = sub_1005AD20(a3, result, a2, 210, 345);
  }
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005B400) --------------------------------------------------------
int __usercall sub_1005B400@<eax>(int *a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // eax@1
  __int16 v4; // dx@1
  __int16 v6; // [sp+0h] [bp-8h]@1
  __int16 v7; // [sp+2h] [bp-6h]@1
  int v8; // [sp+4h] [bp-4h]@1

  v3 = *a1;
  v4 = v3 + *(_WORD *)(a2 + 8);
  v8 = v3;
  v7 = *(_WORD *)(a2 + 10) + HIWORD(v3);
  v6 = v4;
  return sub_1006D760(a3, (int)&v8, (int)&v6, 0);
}

//----- (1005B440) --------------------------------------------------------
double __cdecl sub_1005B440(float a1)
{
  int v1; // ecx@0
  double result; // st7@2
  float v3; // ST00_4@3
  float v4; // ST00_4@3
  float v5; // ST00_4@4

  if ( *(float *)(v1 + 8) - *(float *)(v1 + 4) == 0.0 )
  {
    result = (float)210.0;
  }
  else
  {
    v3 = (a1 - *(float *)(v1 + 4)) / (*(float *)(v1 + 8) - *(float *)(v1 + 4));
    v4 = 210.0 - v3 * 225.0;
    result = v4;
    if ( v4 < 0.0 )
    {
      v5 = result + 360.0;
      result = v5;
    }
  }
  return result;
}

//----- (1005B4B0) --------------------------------------------------------
signed int __cdecl sub_1005B4B0(int a1, int a2, int a3, int a4)
{
  float *v4; // edx@1
  float *v5; // ecx@1
  signed int v6; // esi@1
  double v7; // st7@3
  char v8; // al@8
  __int16 v9; // cx@13
  long double v10; // st7@13
  __int16 v11; // di@13
  int v12; // esi@13
  double v13; // st7@13
  double v14; // st7@13
  signed int result; // eax@13
  double v16; // [sp+14h] [bp-60h]@13
  int v17; // [sp+1Ch] [bp-58h]@13
  double v18; // [sp+24h] [bp-50h]@13
  int v19; // [sp+30h] [bp-44h]@13
  long double v20; // [sp+34h] [bp-40h]@13
  double v21; // [sp+3Ch] [bp-38h]@13
  long double v22; // [sp+44h] [bp-30h]@13
  long double v23; // [sp+4Ch] [bp-28h]@1
  int v24; // [sp+60h] [bp-14h]@13
  int v25; // [sp+64h] [bp-10h]@13
  __int16 v26; // [sp+68h] [bp-Ch]@13
  __int16 v27; // [sp+6Ah] [bp-Ah]@13
  __int16 v28; // [sp+6Ch] [bp-8h]@13
  __int16 v29; // [sp+6Eh] [bp-6h]@13
  int v30; // [sp+70h] [bp-4h]@13

  *(_WORD *)(a1 + 396) = 2;
  v4 = (float *)&v23;
  v5 = (float *)(a4 + 48);
  v6 = 3;
  do
  {
    if ( *(float *)(a4 + 8) >= (double)*v5 )
    {
      if ( *(float *)(a4 + 4) <= (double)*v5 )
        v7 = *v5;
      else
        v7 = *(float *)(a4 + 4);
    }
    else
    {
      v7 = *(float *)(a4 + 8);
    }
    *v4 = v7;
    ++v5;
    ++v4;
    --v6;
  }
  while ( v6 );
  v8 = sub_1005C160(a2, (const void *)a4, 0);
  *(_WORD *)(a1 + 426) = 3;
  *(_WORD *)(a1 + 424) = 3;
  if ( v8 == 3 )
  {
    *(_WORD *)(a1 + 428) = word_105728D8[15];
    *(_WORD *)(a1 + 430) = word_105728D8[8];
  }
  else if ( v8 == 2 )
  {
    *(_WORD *)(a1 + 428) = word_105728D8[15];
    *(_WORD *)(a1 + 430) = word_105728D8[11];
  }
  else
  {
    *(_WORD *)(a1 + 428) = word_105728D8[15];
    *(_WORD *)(a1 + 430) = word_105728D8[15];
  }
  sub_1005AB70(a3, (int)&v17, a2, &v16);
  *(float *)&v18 = sub_1005B440(*(float *)&v23);
  v9 = HIWORD(v17);
  v10 = *(float *)&v18 * 0.01745329251994333;
  v11 = v17;
  v22 = v10;
  *(_WORD *)(a1 + 438) = v17;
  *(_WORD *)(a1 + 436) = v9;
  v12 = SLOWORD(v16);
  v20 = cos(v10);
  v23 = (double)(SLOWORD(v16) - 16);
  v19 = SLOWORD(v16);
  v21 = (double)v11;
  v17 = SHIWORD(v17);
  LOWORD(v24) = (signed int)(v20 * v23 + v21);
  v16 = (double)v17;
  v22 = sin(v22);
  HIWORD(v24) = (signed int)(v16 - v22 * v23);
  sub_1009E7F0(a1 + 392, v24, SHIWORD(v24), 0);
  v13 = (double)(v12 - 8);
  LOWORD(v17) = (signed int)(v20 * v13 + v21);
  HIWORD(v17) = (signed int)(v16 - v13 * v22);
  v23 = (*(float *)&v18 + 90.0) * 0.01745329251994333;
  LOWORD(v25) = (signed int)(cos(v23) * 4.0 + (double)(signed __int16)v17);
  v18 = (double)SHIWORD(v17);
  v14 = (double)v19;
  HIWORD(v25) = (signed int)(v18 - sin(v23) * 4.0);
  v26 = (signed int)(v20 * v14 + v21);
  v27 = (signed int)(v16 - v14 * v22);
  v29 = 2 * HIWORD(v17) - HIWORD(v25);
  v28 = 2 * v17 - v25;
  v30 = v24;
  sub_1009F430(a1 + 392, 5, (int)&v24, 2);
  result = 1;
  *(_WORD *)(a1 + 426) = 1;
  *(_WORD *)(a1 + 424) = 1;
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005B7A0) --------------------------------------------------------
signed int __usercall sub_1005B7A0@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4)
{
  int v4; // ebp@1
  int v5; // edi@1
  signed int v6; // eax@1
  __int16 v7; // ST2C_2@3
  signed int v8; // eax@3
  __int16 v9; // cx@3
  signed int v10; // eax@6
  __int16 v11; // ST2C_2@6
  signed int v12; // eax@7
  __int16 v13; // di@7
  signed int result; // eax@7
  __int16 v15; // [sp+Ch] [bp-4h]@1
  __int16 v16; // [sp+Ch] [bp-4h]@3
  int v17; // [sp+14h] [bp+4h]@1
  int v18; // [sp+14h] [bp+4h]@3
  int v19; // [sp+14h] [bp+4h]@3
  int v20; // [sp+14h] [bp+4h]@6
  int v21; // [sp+14h] [bp+4h]@7

  v4 = a4;
  v5 = a1;
  v17 = (unsigned __int16)(signed int)sub_1005B440(*(float *)(a1 + 16));
  v6 = (signed int)sub_1005B440(*(float *)(v5 + 20));
  *(_WORD *)(a3 + 440) = word_105728D8[11];
  *(_WORD *)(a3 + 442) = word_105728D8[11];
  *(_WORD *)(a3 + 428) = word_105728D8[11];
  *(_WORD *)(a3 + 430) = word_105728D8[11];
  v15 = v6;
  if ( ~(unsigned __int8)(*(_DWORD *)(v4 + 4) >> 13) & 1 )
  {
    sub_1005ABC0(a2, a3, v4, v17, v6);
    sub_1005AD20(a2, a3, v4, v17, v15);
  }
  v7 = v17;
  v8 = (signed int)sub_1005B440(*(float *)(v5 + 12));
  *(_WORD *)(a3 + 440) = word_105728D8[8];
  *(_WORD *)(a3 + 442) = word_105728D8[8];
  *(_WORD *)(a3 + 428) = word_105728D8[8];
  *(_WORD *)(a3 + 430) = word_105728D8[8];
  v18 = (unsigned __int16)v8;
  sub_1005ABC0(a2, a3, v4, v8, v7);
  sub_1005AD20(a2, a3, v4, v18, v7);
  v19 = (unsigned __int16)(signed int)sub_1005B440(*(float *)(v5 + 24));
  v9 = (signed int)sub_1005B440(*(float *)(v5 + 28));
  *(_WORD *)(a3 + 440) = word_105728D8[11];
  *(_WORD *)(a3 + 442) = word_105728D8[11];
  *(_WORD *)(a3 + 428) = word_105728D8[11];
  *(_WORD *)(a3 + 430) = word_105728D8[11];
  v16 = v9;
  if ( ~(unsigned __int8)(*(_DWORD *)(v4 + 4) >> 13) & 1 )
  {
    sub_1005ABC0(a2, a3, v4, v19, v9);
    sub_1005AD20(a2, a3, v4, v19, v16);
    v9 = v16;
  }
  if ( *(float *)(v5 + 8) > (double)*(float *)(v5 + 28) )
  {
    v20 = (unsigned __int16)v9;
    v10 = (signed int)sub_1005B440(*(float *)(v5 + 32));
    *(_WORD *)(a3 + 440) = word_105728D8[8];
    *(_WORD *)(a3 + 442) = word_105728D8[8];
    *(_WORD *)(a3 + 428) = word_105728D8[8];
    v11 = v10;
    *(_WORD *)(a3 + 430) = word_105728D8[8];
    sub_1005ABC0(a2, a3, v4, v20, v10);
    sub_1005AD20(a2, a3, v4, v20, v11);
  }
  v21 = (unsigned __int16)(signed int)sub_1005B440(*(float *)(v5 + 20));
  v12 = (signed int)sub_1005B440(*(float *)(v5 + 24));
  *(_WORD *)(a3 + 440) = word_105728D8[4];
  v13 = v12;
  *(_WORD *)(a3 + 442) = word_105728D8[4];
  *(_WORD *)(a3 + 428) = word_105728D8[4];
  *(_WORD *)(a3 + 430) = word_105728D8[4];
  sub_1005ABC0(a2, a3, v4, v21, v12);
  sub_1005AD20(a2, a3, v4, v21, v13);
  result = 1;
  *(_WORD *)(a3 + 426) = 1;
  *(_WORD *)(a3 + 424) = 1;
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005BAE0) --------------------------------------------------------
char __cdecl sub_1005BAE0(int a1, int a2, int *a3, int a4, _WORD *a5)
{
  int v5; // edx@2
  int v6; // ecx@2
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8041:
      v5 = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 60) = *(_DWORD *)(a4 + 48);
      v6 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a4 + 64) = v5;
      *(_DWORD *)(a4 + 68) = v6;
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_DWORD *)(a2 + 4) & 0x200 )
        sub_1005BCC0(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), (int)a3);
      sub_1005AF30(a1, a2, (int)a3);
      if ( *(_BYTE *)(a2 + 4) & 0x40 )
        sub_1005B3B0(a1, a2, (int)a3);
      sub_1005B7A0(a4, (int)a3, a1, a2);
      if ( *(_DWORD *)(a2 + 4) & 0x400 )
        sub_1005B160((int)a3, a2, a1, a4, (int)a5);
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_1005B230((int)a3, a2, a1, (const void *)a4, (int)a5);
      sub_1005AF80((int)a5, (int)a3, a2, a1, (const void *)a4);
      if ( *(_BYTE *)a4 != 1 )
      {
        sub_1005B400(a3, a2, a1);
        if ( *(_BYTE *)a4 != 1 )
          goto LABEL_17;
      }
      sub_1005B4B0(a1, a2, (int)a3, a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_1005B230((int)a3, a2, a1, (const void *)a4, (int)a5);
      sub_1005AF80((int)a5, (int)a3, a2, a1, (const void *)a4);
      goto LABEL_17;
    default:
LABEL_17:
      result = 1;
      break;
  }
  return result;
}

//----- (1005BCC0) --------------------------------------------------------
int __cdecl sub_1005BCC0(int a1, __int16 a2, __int16 a3, int a4)
{
  *(_WORD *)(a1 + 440) = word_105728D8[12];
  *(_WORD *)(a1 + 442) = word_105728D8[12];
  return sub_1009F8C0(a1 + 392, *(_WORD *)a4, *(_WORD *)(a4 + 2), a2, a3);
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005BD10) --------------------------------------------------------
char *__cdecl sub_1005BD10(int a1, int a2, _BYTE *a3)
{
  char *result; // eax@2
  _BYTE *v4; // edx@2
  char v5; // cl@3
  _BYTE *v6; // edx@6
  char v7; // cl@7
  _BYTE *v8; // edx@9
  char v9; // cl@10
  _BYTE *v10; // edx@12
  char v11; // cl@13
  _BYTE *v12; // edx@15
  char v13; // cl@16
  _BYTE *v14; // edx@18
  char v15; // cl@19
  _BYTE *v16; // edx@21
  char v17; // cl@22
  _BYTE *v18; // edx@24
  char v19; // cl@25
  _BYTE *v20; // edx@27
  char v21; // cl@28
  _BYTE *v22; // edx@30
  char v23; // cl@31
  _BYTE *v24; // edx@33
  char v25; // cl@34
  _BYTE *v26; // edx@36
  char v27; // cl@37
  _BYTE *v28; // edx@39
  char v29; // cl@40
  _BYTE *v30; // edx@42
  char v31; // cl@43
  _BYTE *v32; // edx@45
  char v33; // cl@46
  _BYTE *v34; // edx@48
  char v35; // cl@49
  _BYTE *v36; // edx@51
  char v37; // cl@52
  _BYTE *v38; // edx@54
  char v39; // cl@55
  _BYTE *v40; // edx@57
  char v41; // cl@58
  _BYTE *v42; // edx@60
  char v43; // cl@61
  _BYTE *v44; // edx@63
  char v45; // cl@64
  _BYTE *v46; // edx@66
  char v47; // cl@67
  _BYTE *v48; // edx@69
  char v49; // cl@70
  _BYTE *v50; // edx@72
  char v51; // cl@73
  _BYTE *v52; // edx@75
  char v53; // cl@76
  _BYTE *v54; // edx@78
  char v55; // cl@79

  if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 14) & 1 )
  {
    result = (char *)*(_BYTE *)(a1 + 13);
    switch ( result )
    {
      case 0x14u:
        result = sub_10070850(0x5FDu);
        v6 = a3;
        do
        {
          v7 = *result;
          *v6++ = *result++;
        }
        while ( v7 );
        break;
      case 0x15u:
        result = sub_10070850(0xC01u);
        v8 = a3;
        do
        {
          v9 = *result;
          *v8++ = *result++;
        }
        while ( v9 );
        break;
      case 0x16u:
        result = sub_10070850(0x10E6u);
        v10 = a3;
        do
        {
          v11 = *result;
          *v10++ = *result++;
        }
        while ( v11 );
        break;
      case 0x13u:
        result = sub_10070850(0xB3Du);
        v12 = a3;
        do
        {
          v13 = *result;
          *v12++ = *result++;
        }
        while ( v13 );
        break;
      case 0xFu:
        result = sub_10070850(0xFE2u);
        v14 = a3;
        do
        {
          v15 = *result;
          *v14++ = *result++;
        }
        while ( v15 );
        break;
      case 0xDu:
        result = sub_10070850(0x123Au);
        v16 = a3;
        do
        {
          v17 = *result;
          *v16++ = *result++;
        }
        while ( v17 );
        break;
      case 0xEu:
        result = sub_10070850(0x1240u);
        v18 = a3;
        do
        {
          v19 = *result;
          *v18++ = *result++;
        }
        while ( v19 );
        break;
      case 0u:
        result = sub_10070850(0x1650u);
        v20 = a3;
        do
        {
          v21 = *result;
          *v20++ = *result++;
        }
        while ( v21 );
        break;
      case 1u:
        result = sub_10070850(0x116Eu);
        v22 = a3;
        do
        {
          v23 = *result;
          *v22++ = *result++;
        }
        while ( v23 );
        break;
      case 2u:
        result = sub_10070850(0xAFEu);
        v24 = a3;
        do
        {
          v25 = *result;
          *v24++ = *result++;
        }
        while ( v25 );
        break;
      case 3u:
        result = sub_10070850(0xB0Cu);
        v26 = a3;
        do
        {
          v27 = *result;
          *v26++ = *result++;
        }
        while ( v27 );
        break;
      case 4u:
        result = sub_10070850(0xB23u);
        v28 = a3;
        do
        {
          v29 = *result;
          *v28++ = *result++;
        }
        while ( v29 );
        break;
      case 5u:
        result = sub_10070850(0x822u);
        v30 = a3;
        do
        {
          v31 = *result;
          *v30++ = *result++;
        }
        while ( v31 );
        break;
      case 0x12u:
        result = sub_10070850(0x19B3u);
        v32 = a3;
        do
        {
          v33 = *result;
          *v32++ = *result++;
        }
        while ( v33 );
        break;
      case 6u:
        result = sub_10070850(0x553u);
        v34 = a3;
        do
        {
          v35 = *result;
          *v34++ = *result++;
        }
        while ( v35 );
        break;
      case 7u:
        result = sub_10070850(0x1307u);
        v36 = a3;
        do
        {
          v37 = *result;
          *v36++ = *result++;
        }
        while ( v37 );
        break;
      case 8u:
        result = sub_10070850(0x1303u);
        v38 = a3;
        do
        {
          v39 = *result;
          *v38++ = *result++;
        }
        while ( v39 );
        break;
      case 9u:
        result = sub_10070850(0x2CAu);
        v40 = a3;
        do
        {
          v41 = *result;
          *v40++ = *result++;
        }
        while ( v41 );
        break;
      case 0xAu:
        result = sub_10070850(0x3EBu);
        v42 = a3;
        do
        {
          v43 = *result;
          *v42++ = *result++;
        }
        while ( v43 );
        break;
      case 0xBu:
        result = sub_10070850(0xC06u);
        v44 = a3;
        do
        {
          v45 = *result;
          *v44++ = *result++;
        }
        while ( v45 );
        break;
      case 0xCu:
        result = sub_10070850(0x46Au);
        v46 = a3;
        do
        {
          v47 = *result;
          *v46++ = *result++;
        }
        while ( v47 );
        break;
      case 0x10u:
        result = sub_10070850(0xE44u);
        v48 = a3;
        do
        {
          v49 = *result;
          *v48++ = *result++;
        }
        while ( v49 );
        break;
      case 0x11u:
        result = sub_10070850(0x1AB6u);
        v50 = a3;
        do
        {
          v51 = *result;
          *v50++ = *result++;
        }
        while ( v51 );
        break;
      case 0x17u:
        result = sub_10070850(0x1950u);
        v52 = a3;
        do
        {
          v53 = *result;
          *v52++ = *result++;
        }
        while ( v53 );
        break;
      case 0x1Bu:
        result = sub_10070850(0x5ABu);
        v54 = a3;
        do
        {
          v55 = *result;
          *v54++ = *result++;
        }
        while ( v55 );
        break;
      default:
        *a3 = 0;
        break;
    }
  }
  else
  {
    result = sub_10070850(*(_WORD *)(a2 + 40));
    v4 = a3;
    do
    {
      v5 = *result;
      *v4++ = *result++;
    }
    while ( v5 );
  }
  return result;
}

//----- (1005C100) --------------------------------------------------------
int __cdecl sub_1005C100(unsigned __int8 a1, int a2, int a3)
{
  int result; // eax@1

  *(_WORD *)(a2 + 8) = *((_WORD *)*(&off_100D5618 + a1) + 2);
  *(_BYTE *)(a2 + 10) = 4;
  *(_DWORD *)a2 = 89;
  *(_DWORD *)(a2 + 4) = 1423;
  *(_BYTE *)(a2 + 11) = 0;
  *(_WORD *)(a2 + 12) = 0;
  *(_DWORD *)a3 = *(_DWORD *)a2;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  result = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a3 + 12) = result;
  *(_DWORD *)(a3 + 4) = 17807;
  return result;
}
// 100D5618: using guessed type void *off_100D5618;

//----- (1005C160) --------------------------------------------------------
char __cdecl sub_1005C160(int a1, const void *a2, int a3)
{
  int v3; // edx@1
  char v4; // dl@1
  char result; // al@2
  double v6; // st7@3
  double v7; // st6@3
  float v8; // ST1C_4@3
  double v9; // st5@3
  char v10; // bl@5
  double v11; // st3@9
  double v12; // st4@9
  bool v13; // c0@9
  bool v14; // c3@9
  double v15; // st3@9
  double v16; // st2@9
  char v17; // cl@11
  char v18; // al@15
  bool v19; // c0@16
  double v20; // st5@16
  double v21; // st2@18
  double v22; // st7@18
  double v23; // st5@18
  double v24; // st4@18
  double v25; // st3@18
  bool v26; // c0@20
  double v27; // st5@20
  double v28; // st2@22
  bool v29; // c0@26
  bool v30; // c3@26
  double v31; // st6@26
  double v32; // rt2@31
  double v33; // st4@31
  double v34; // st7@31
  double v35; // rtt@35
  double v36; // st5@35
  double v37; // st7@35
  float v38; // [sp+14h] [bp-6Ch]@1
  char v39[4]; // [sp+1Ch] [bp-64h]@1
  float v40; // [sp+20h] [bp-60h]@3
  float v41; // [sp+24h] [bp-5Ch]@3
  float v42; // [sp+28h] [bp-58h]@3
  float v43; // [sp+2Ch] [bp-54h]@4
  float v44; // [sp+30h] [bp-50h]@6
  float v45; // [sp+34h] [bp-4Ch]@9
  float v46; // [sp+38h] [bp-48h]@9
  float v47; // [sp+3Ch] [bp-44h]@9
  float v48[8]; // [sp+58h] [bp-28h]@1
  char v49[3]; // [sp+79h] [bp-7h]@24

  v3 = *(_DWORD *)(a1 + 4) >> 13;
  qmemcpy(v39, a2, 0x60u);
  v4 = ~(_BYTE)v3 & 1;
  v38 = v48[a3];
  if ( !v39[a3] )
    return 0;
  v6 = v41;
  v7 = v40;
  v8 = (v41 - v40) * 0.0015999999595806;
  v9 = v8;
  if ( v8 < v42 - v40 )
    goto LABEL_8;
  if ( v43 - v7 <= v9 )
  {
    if ( v44 - v7 > v9 )
    {
      v10 = (v4 != 0) + 1;
      goto LABEL_9;
    }
LABEL_8:
    v10 = 1;
    goto LABEL_9;
  }
  v10 = 3;
LABEL_9:
  v11 = v6 - v47;
  v12 = v47;
  v13 = v11 < v9;
  v14 = v11 == v9;
  v15 = v45;
  v16 = v46;
  if ( !v13 && !v14 )
    goto LABEL_44;
  if ( v6 - v16 > v9 )
  {
    v17 = 3;
    goto LABEL_15;
  }
  if ( v6 - v15 > v9 )
    v17 = (v4 != 0) + 1;
  else
LABEL_44:
    v17 = 1;
LABEL_15:
  v18 = *(_BYTE *)(a1 + 13);
  if ( v18 )
  {
    if ( v18 == 1 )
    {
      v26 = v16 - v15 < v9;
      v27 = v46;
      if ( v26 )
      {
        v45 = v15 + *(float *)(dword_1068B5C0 + 32) - v16;
        v15 = v45;
      }
      v28 = *(float *)(dword_1068B5C0 + 32) - v27;
      v47 = v12 + v28;
      v22 = v15;
      v41 = v41 + v28;
      v46 = v27 + v28;
      v23 = v47;
      v24 = v46;
      v25 = v41;
    }
    else
    {
      v25 = v41;
      v22 = v45;
      v23 = v47;
      v24 = v46;
    }
  }
  else
  {
    v19 = v16 - v15 < v9;
    v20 = v46;
    if ( v19 )
    {
      v45 = v15 + *(float *)(dword_1068B5C0 + 28) - v16;
      v15 = v45;
    }
    v21 = *(float *)(dword_1068B5C0 + 28) - v20;
    v47 = v12 + v21;
    v22 = v15;
    v41 = v41 + v21;
    v46 = v20 + v21;
    v23 = v47;
    v24 = v46;
    v25 = v41;
  }
  result = v49[a3];
  if ( !result || (*(_DWORD *)(a1 + 4) & 7) != 4 )
  {
    v29 = v38 < v7;
    v30 = v38 == v7;
    v31 = v38;
    if ( v29 || v30 )
      return v10;
    if ( v25 <= v31 )
      return v17;
    if ( v44 > v31 )
    {
      v34 = v24;
    }
    else
    {
      v32 = v24;
      v33 = v22;
      v34 = v32;
      if ( v33 >= v31 )
        return 1;
    }
    if ( v43 > v31 )
    {
      v37 = v23;
    }
    else
    {
      v35 = v23;
      v36 = v34;
      v37 = v35;
      if ( v36 >= v31 )
        return (v4 != 0) + 1;
    }
    if ( v42 <= v31 && v31 <= v37 )
      return 3;
    return 1;
  }
  return result;
}
// 1068B5C0: using guessed type int dword_1068B5C0;
// 1005C160: using guessed type char var_64[4];
// 1005C160: using guessed type float var_28[8];
// 1005C160: using guessed type char var_7[3];

//----- (1005C440) --------------------------------------------------------
int __cdecl sub_1005C440(unsigned __int8 a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_BYTE *)(a2 + 10) = *((_BYTE *)*(&off_100D5618 + a1) + 8);
  *(_WORD *)(a2 + 8) = *((_WORD *)*(&off_100D5618 + a1) + 3);
  *(_BYTE *)(a2 + 11) = *((_BYTE *)*(&off_100D5618 + a1) + 9);
  *(_DWORD *)(a2 + 4) = 40335;
  *(_DWORD *)a2 = 89;
  *(_WORD *)(a2 + 12) = 0;
  return result;
}
// 100D5618: using guessed type void *off_100D5618;

//----- (1005C490) --------------------------------------------------------
char *__cdecl sub_1005C490(unsigned __int8 a1, _BYTE *a2)
{
  _BYTE *v2; // esi@1
  char *result; // eax@1
  char v4; // cl@3
  char v5; // cl@6
  char v6; // cl@9
  char v7; // cl@12
  char v8; // cl@15
  char v9; // cl@18
  char v10; // cl@21
  char v11; // cl@24
  char v12; // cl@27
  char v13; // [sp+8h] [bp-14h]@1
  unsigned int v14; // [sp+10h] [bp-Ch]@2

  v2 = a2;
  sub_1005C440(a1, (int)&v13);
  result = (char *)(a1 - 1);
  switch ( a1 )
  {
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 0xFu:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x17u:
      result = sub_100793E0(v14, 0);
      do
      {
        v4 = *result;
        *v2++ = *result++;
      }
      while ( v4 );
      break;
    case 1u:
    case 0x11u:
      result = sub_100793E0(0xDu, 0);
      do
      {
        v5 = *result;
        *v2++ = *result++;
      }
      while ( v5 );
      break;
    case 8u:
      result = sub_100793E0(v14, 0);
      do
      {
        v6 = *result;
        *v2++ = *result++;
      }
      while ( v6 );
      break;
    case 0x10u:
      result = sub_100793E0(0xCu, 0);
      do
      {
        v7 = *result;
        *v2++ = *result++;
      }
      while ( v7 );
      break;
    case 9u:
    case 0xAu:
    case 0xBu:
      result = sub_100793E0(0x18u, 0);
      do
      {
        v8 = *result;
        *v2++ = *result++;
      }
      while ( v8 );
      break;
    case 0xCu:
      result = sub_100793E0(0x13u, 0);
      do
      {
        v9 = *result;
        *v2++ = *result++;
      }
      while ( v9 );
      break;
    case 0x16u:
      result = sub_100793E0(0xAu, 0);
      do
      {
        v10 = *result;
        *v2++ = *result++;
      }
      while ( v10 );
      break;
    case 0x1Au:
      result = sub_100793E0(0x26u, 0);
      do
      {
        v11 = *result;
        *v2++ = *result++;
      }
      while ( v11 );
      break;
    case 0x1Bu:
      result = sub_100793E0(0x1Du, 0);
      do
      {
        v12 = *result;
        *v2++ = *result++;
      }
      while ( v12 );
      break;
    default:
      *a2 = 0;
      break;
  }
  return result;
}

//----- (1005C6E0) --------------------------------------------------------
_WORD *__usercall sub_1005C6E0@<eax>(_WORD *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, __int16 a5)
{
  _WORD *result; // eax@1
  _WORD *v6; // [sp+0h] [bp-4h]@1

  v6 = a1;
  sub_10070660(*(char **)(a2 + 8), (int *)&v6, 0);
  result = v6;
  *(_WORD *)a4 = *(_WORD *)a3 + *v6;
  *(_WORD *)(a4 + 2) = *(_WORD *)(a3 + 2) + result[1] + a5 * *(_WORD *)(a2 + 18);
  return result;
}

//----- (1005C720) --------------------------------------------------------
__int16 __usercall sub_1005C720@<ax>(int a1@<eax>, _WORD *a2@<ecx>, int a3, int a4)
{
  _WORD *v4; // edi@1
  int v5; // ebp@1
  _WORD *v6; // ebx@1
  signed int v7; // eax@1
  __int16 v8; // ax@3
  __int16 v9; // cx@3
  __int16 result; // ax@5
  char v11; // [sp+10h] [bp-4h]@1
  __int16 v12; // [sp+12h] [bp-2h]@1

  v4 = (_WORD *)a1;
  v5 = *(_DWORD *)(a4 + 12);
  v6 = a2;
  sub_1005C6E0(a2, (int)a2, a1, (int)&v11, 0);
  *(_WORD *)(a3 + 284) = 0;
  *(_WORD *)(a3 + 286) = 0;
  *(_WORD *)(a3 + 288) = 0;
  *(_WORD *)(a3 + 290) = v12 + v6[9] * v6[8];
  ((void (__cdecl *)(int, _DWORD, char *, _DWORD, void *))dword_1068B040[2 * (**((_DWORD **)v6 + 2) & 0xFF)])(
    a3,
    *((_DWORD *)v6 + 2),
    &v11,
    *(_DWORD *)(a4 + 16),
    &unk_100E4624);
  v7 = *(_WORD *)(a3 + 276);
  if ( *v4 < v7 )
    LOWORD(v7) = *v4;
  *(_WORD *)(v5 + 36) = v7;
  v8 = *(_WORD *)(a3 + 278);
  *(_WORD *)(v5 + 38) = v8;
  v9 = *(_WORD *)(a3 + 280);
  *(_DWORD *)(v5 + 8) = 99;
  *(_WORD *)(v5 + 40) = v9;
  *(_DWORD *)(v5 + 12) = 5;
  *(_DWORD *)(v5 + 16) = 1;
  *(_WORD *)(v5 + 42) = v8;
  *(_WORD *)(v5 + 16) = *v4 + v6[10];
  if ( !v6[10] )
    *(_WORD *)(v5 + 16) = *(_WORD *)(v5 + 40) + 2;
  *(_WORD *)(v5 + 18) = v8;
  result = *(_WORD *)(a3 + 282) + v6[9] * (v6[8] - 1) - *(_WORD *)(a3 + 278) + 1;
  *(_WORD *)(v5 + 14) = result;
  *(_WORD *)(v5 + 22) = v6[8];
  return result;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1005C840) --------------------------------------------------------
int __usercall sub_1005C840@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  int result; // eax@1

  result = (unsigned __int16)(*(_WORD *)(a1 + 38) + *(_WORD *)(a2 + 16) * *(_WORD *)(a2 + 18));
  if ( *(_WORD *)(a2 + 4) & 0x800 )
  {
    if ( (signed __int16)result >= (signed int)*(_WORD *)(a3 + 290) )
      LOWORD(result) = *(_WORD *)(a3 + 290);
    result = (unsigned __int16)result;
  }
  return result;
}

//----- (1005C870) --------------------------------------------------------
__int16 __usercall sub_1005C870@<ax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, int a5, __int16 a6, __int16 a7)
{
  _DWORD *v7; // ecx@1
  void (__cdecl *v8)(int, _DWORD, int *, int, void *, int); // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  int v12; // [sp+0h] [bp-4h]@1

  v12 = a1;
  v7 = *(_DWORD **)(a2 + 8);
  v12 = 0;
  v8 = (void (__cdecl *)(int, _DWORD, int *, int, void *, int))dword_1068B040[2 * (*v7 & 0xFF)];
  *(_WORD *)(a3 + 284) = 0;
  *(_WORD *)(a3 + 286) = 0;
  *(_WORD *)(a3 + 288) = 0;
  *(_WORD *)(a3 + 290) = *(_WORD *)(a2 + 18) * *(_WORD *)(a2 + 16) - a7;
  *(_WORD *)(a4 + 6) = a6;
  v8(a3, *(_DWORD *)(a2 + 8), &v12, a5, &unk_100E4624, v12);
  v9 = *(_WORD *)(a3 + 282) - *(_WORD *)(a3 + 278);
  v10 = *(_WORD *)(a2 + 18);
  if ( v10 > v9 )
    LOWORD(v9) = v10;
  return v9;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1005C900) --------------------------------------------------------
char __usercall sub_1005C900@<al>(__int16 a1@<ax>, int a2@<edx>, int a3, int a4)
{
  char result; // al@3

  if ( a1 < 0 || a1 >= (signed int)*(_WORD *)(a2 + 8) )
    result = 0;
  else
    result = (*(int (__cdecl **)(int, int, __int16))(*(_DWORD *)(a2 + 12) + 28))(a3, a4, a1);
  return result;
}

//----- (1005C930) --------------------------------------------------------
signed int __usercall sub_1005C930@<eax>(__int16 a1@<ax>, int a2@<ecx>, int a3@<edi>, char a4, char a5)
{
  __int16 v5; // si@1
  __int16 v6; // ax@1
  signed int result; // eax@2
  int v8; // eax@6

  v5 = a1;
  v6 = *(_WORD *)(a2 + 4);
  *(_WORD *)(a2 + 2) = v5;
  if ( v5 < v6 || (result = a3 + v6, v5 >= result) || a5 )
  {
    *(_WORD *)(a2 + 4) = v5;
    if ( a4 )
      *(_WORD *)(a2 + 4) = v5 - (a3 + 1) / 2 + 1;
    v8 = *(_WORD *)(a2 + 8) - a3;
    if ( *(_WORD *)(a2 + 4) < v8 )
      LOWORD(v8) = *(_WORD *)(a2 + 4);
    result = (signed __int16)v8 < 0 ? 0 : (signed __int16)v8;
    *(_WORD *)(a2 + 4) = result;
  }
  return result;
}

//----- (1005C9A0) --------------------------------------------------------
BOOL __usercall sub_1005C9A0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@1

  v2 = *(_BYTE *)(a1 + 4) & 0x60;
  return v2 == 64 || v2 == 32 && *(_WORD *)(a2 + 10) < *(_WORD *)(a2 + 8);
}

//----- (1005C9D0) --------------------------------------------------------
__int16 __usercall sub_1005C9D0@<ax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, int a5, int a6, __int16 a7)
{
  int v7; // ebp@1
  int v8; // eax@1
  char v9; // cl@1
  __int16 v10; // cx@1
  int v11; // ecx@1
  __int16 v12; // cx@8
  __int16 v13; // dx@10
  __int16 v14; // ax@10
  __int16 v15; // cx@15
  char v16; // al@15
  _WORD *v17; // ST10_4@15
  char v18; // ST18_1@15
  int v19; // eax@17
  __int16 result; // ax@20
  bool v21; // [sp+4h] [bp-34h]@6
  char v22; // [sp+5h] [bp-33h]@1
  bool v23; // [sp+6h] [bp-32h]@3
  char v24; // [sp+7h] [bp-31h]@1
  int v25; // [sp+8h] [bp-30h]@1
  __int16 v26; // [sp+Ch] [bp-2Ch]@8
  __int16 v27; // [sp+10h] [bp-28h]@14
  __int16 v28; // [sp+14h] [bp-24h]@15
  __int16 v29; // [sp+16h] [bp-22h]@15
  void (__cdecl *v30)(int, _DWORD, int, _DWORD, void *); // [sp+18h] [bp-20h]@1
  int v31; // [sp+1Ch] [bp-1Ch]@1
  int v32; // [sp+20h] [bp-18h]@1
  _WORD *v33; // [sp+24h] [bp-14h]@1
  int v34; // [sp+28h] [bp-10h]@1
  __int16 v35; // [sp+2Ch] [bp-Ch]@15
  __int16 v36; // [sp+2Eh] [bp-Ah]@15
  __int16 v37; // [sp+30h] [bp-8h]@1

  v31 = a5;
  v7 = *(_DWORD *)(a5 + 12);
  v8 = *(_DWORD *)v7;
  v33 = (_WORD *)a1;
  v9 = *(_BYTE *)(a4 + 3);
  v32 = a6;
  v25 = v8;
  v24 = v9;
  LOWORD(v8) = *(_WORD *)(a3 + 4);
  v22 = *(_BYTE *)(a4 + 9);
  v10 = *(_WORD *)(a3 + 4);
  v30 = (void (__cdecl *)(int, _DWORD, int, _DWORD, void *))dword_1068B040[2 * (**(_DWORD **)(a3 + 8) & 0xFF)];
  v11 = v10 & 0x300;
  v34 = 96;
  v37 = v8 & 0x1F | 32 * (v8 & 0x1F | 0x40);
  if ( a6 )
  {
    *(_BYTE *)(a4 + 3) = 0;
    *(_BYTE *)(a4 + 9) = 0;
  }
  v23 = *(_BYTE *)(a6 + *(_DWORD *)(v7 + 4)) != 0;
  v21 = v11 == 512 || v11 == 256 && !*(_BYTE *)(a6 + *(_DWORD *)(v7 + 4));
  *(_WORD *)(a4 + 284) = 0;
  *(_WORD *)(a4 + 286) = 0;
  *(_WORD *)(a4 + 288) = 0;
  *(_WORD *)(a4 + 290) = *(_WORD *)(v7 + 38) + *(_WORD *)(a3 + 16) * *(_WORD *)(a3 + 18) - *(_WORD *)(a2 + 2);
  *(_WORD *)(v31 + 6) = a7;
  v30(a4, *(_DWORD *)(a3 + 8), a2, *(_DWORD *)(v25 + 4 * a6), &unk_100E4624);
  v12 = *(_WORD *)(a4 + 278);
  v26 = *(_WORD *)(a3 + 18);
  if ( *(_WORD *)(a3 + 18) <= *(_WORD *)(a4 + 282) - (signed int)*(_WORD *)(a4 + 278) )
    v26 = *(_WORD *)(a4 + 282) - *(_WORD *)(a4 + 278);
  v13 = *(_WORD *)(a2 + 2);
  v14 = *(_WORD *)(a4 + 278);
  if ( v12 > v13 )
  {
    if ( *(_WORD *)(a4 + 282) > *(_WORD *)(a3 + 18) + v13 )
      v14 = *(_WORD *)(a4 + 278);
    else
      v14 = *(_WORD *)(a2 + 2);
  }
  v27 = v26 + v12;
  if ( v21 )
  {
    v15 = *(_WORD *)(v7 + 36);
    v29 = v14;
    v16 = *(_BYTE *)(a4 + 3);
    v36 = v26;
    v28 = v15;
    v17 = v33;
    v35 = *(_WORD *)(v7 + 16) - *(_WORD *)(v7 + 36) - 2;
    v18 = v16;
    *(_BYTE *)(a4 + 3) = 0;
    sub_10069D40(a4, (int)&v34, (int)&v28, 0, v17);
    *(_BYTE *)(a4 + 3) = v18;
  }
  if ( v23 )
  {
    v19 = v32;
    if ( *(_BYTE *)(v32 + *(_DWORD *)(v7 + 4)) == 2 )
      *(_BYTE *)(*(_DWORD *)(v25 + 4 * v32) + 4) |= 8u;
    *(_WORD *)(a4 + 284) = 0;
    *(_WORD *)(a4 + 286) = 0;
    *(_WORD *)(a4 + 288) = 0;
    *(_WORD *)(a4 + 290) = *(_WORD *)(v7 + 38) + *(_WORD *)(a3 + 16) * *(_WORD *)(a3 + 18) - *(_WORD *)(a2 + 2);
    *(_WORD *)(v31 + 6) = a7;
    v30(a4, *(_DWORD *)(a3 + 8), a2, *(_DWORD *)(v25 + 4 * v19), v33);
  }
  *(_BYTE *)(a4 + 9) = v22;
  result = v27;
  *(_BYTE *)(a4 + 3) = v24;
  *(_WORD *)(a2 + 2) += v26;
  return result;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1005CC40) --------------------------------------------------------
unsigned int __usercall sub_1005CC40@<eax>(_WORD *a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // eax@1
  char *v7; // ecx@1
  int v8; // edi@1
  unsigned int result; // eax@1
  bool v10; // zf@1
  int v11; // esi@2
  int v12; // eax@2
  __int16 v13; // ax@5
  bool v14; // sf@5
  int v15; // eax@6
  __int16 v16; // ax@9
  __int16 v17; // dx@13
  char v18; // cl@13
  char v19; // ST27_1@13
  int v20; // eax@14
  __int16 v21; // ax@18
  int v22; // [sp+14h] [bp-34h]@2
  int v23; // [sp+14h] [bp-34h]@6
  int v24; // [sp+18h] [bp-30h]@1
  int v25; // [sp+1Ch] [bp-2Ch]@1
  _WORD *v26; // [sp+20h] [bp-28h]@1
  __int16 v27; // [sp+24h] [bp-24h]@1
  int v28; // [sp+2Ch] [bp-1Ch]@1
  __int16 v29; // [sp+30h] [bp-18h]@13
  __int16 v30; // [sp+32h] [bp-16h]@13
  char v31; // [sp+34h] [bp-14h]@1
  int v32; // [sp+38h] [bp-10h]@1
  __int16 v33; // [sp+3Ch] [bp-Ch]@13
  __int16 v34; // [sp+3Eh] [bp-Ah]@13
  __int16 v35; // [sp+40h] [bp-8h]@1

  v26 = a1;
  v5 = *(_DWORD *)(a2 + 12);
  v25 = a2;
  v6 = *(_WORD *)(a4 + 16) - *(_WORD *)(a2 + 10);
  v7 = (char *)*(_WORD *)(v5 + 34);
  v24 = v5;
  v28 = (int)&v7[v6];
  v27 = *(_WORD *)(v5 + 38);
  sub_1005C6E0(v7, a4, a5, (int)&v31, 0);
  v8 = v25;
  result = *(_WORD *)(a4 + 4) & 0xFFFF001F;
  v10 = *(_WORD *)(v25 + 10) == 0;
  v32 = 96;
  v35 = result | 32 * (result | 0x40);
  if ( v10 )
  {
    if ( *(_WORD *)(a4 + 4) & 0x800 )
      return result;
    v11 = v24;
  }
  else
  {
    v11 = v24;
    v12 = *(_WORD *)(v24 + 34);
    v22 = *(_WORD *)(v24 + 34);
    if ( v12 >= 0 )
    {
      while ( 1 )
      {
        v13 = sub_1005C9D0((int)v26, (int)&v31, a4, a3, v8, v12, *(_WORD *)(v11 + 34) + *(_WORD *)(v8 + 4) - v12);
        v11 = v24;
        v8 = v25;
        v14 = v22-- - 1 < 0;
        v27 = v13;
        if ( v14 )
          break;
        v12 = v22;
      }
    }
    v15 = *(_WORD *)(a4 + 16) - 1;
    v23 = *(_WORD *)(a4 + 16) - 1;
    if ( v15 > v28 )
    {
      while ( 1 )
      {
        v16 = sub_1005C9D0(
                (int)v26,
                (int)&v31,
                a4,
                a3,
                v8,
                v15,
                *(_WORD *)(v11 + 34) + *(_WORD *)(v8 + 4) + *(_WORD *)(a4 + 16) - v15);
        v11 = v24;
        v8 = v25;
        v27 = v16;
        if ( --v23 <= v28 )
          break;
        v15 = v23;
      }
    }
  }
  v17 = *(_WORD *)(a4 + 16) * *(_WORD *)(a4 + 18) - v27;
  v29 = *(_WORD *)(v11 + 36);
  v18 = *(_BYTE *)(a3 + 3);
  v30 = v27;
  v19 = v18;
  v34 = *(_WORD *)(v11 + 38) + v17 - 1;
  v33 = *(_WORD *)(v11 + 16) - *(_WORD *)(v11 + 36) - 2;
  *(_BYTE *)(a3 + 3) = 0;
  sub_10069D40(a3, (int)&v32, (int)&v29, 0, v26);
  *(_BYTE *)(a3 + 3) = v19;
  result = sub_1005C9A0(a4, v8);
  if ( (_BYTE)result )
  {
    v20 = *(_WORD *)(a4 + 16) + *(_WORD *)(v8 + 8) - *(_WORD *)(v8 + 10);
    if ( v20 >= 0xFFFF )
      LOWORD(v20) = -1;
    *(_WORD *)(v11 + 20) = v20;
    *(_WORD *)(v11 + 24) = *(_WORD *)(v8 + 4);
    result = sub_10070710(a3, (int)v26, (char *)(v11 + 8), v11 + 20);
  }
  else if ( (*(_BYTE *)(a4 + 4) & 0x60) == 32 )
  {
    *(_WORD *)(a3 + 396) = 3;
    v21 = word_105728D8[*(_BYTE *)(a4 + 4) & 0x1F];
    *(_WORD *)(a3 + 440) = v21;
    *(_WORD *)(a3 + 442) = v21;
    result = sub_1009F8C0(a3 + 392, *(_WORD *)(v11 + 16), *(_WORD *)(v11 + 18), 5, *(_WORD *)(v11 + 14));
  }
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005CED0) --------------------------------------------------------
__int16 __cdecl sub_1005CED0(int a1, int a2, int a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // ebp@3
  __int16 v10; // ax@7
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v4 = a3;
  v5 = *(_DWORD *)(a3 + 12);
  v6 = *(_WORD *)(v5 + 34);
  v7 = *(_DWORD *)v5;
  v8 = v6 + *(_WORD *)(a2 + 16) - *(_WORD *)(a3 + 10);
  v12 = *(_DWORD *)v5;
  v13 = v6 + *(_WORD *)(a2 + 16) - *(_WORD *)(a3 + 10);
  if ( *(_WORD *)(v5 + 42) < a4 && *(_WORD *)(a3 + 10) < *(_WORD *)(a3 + 8) )
  {
    v9 = v6 + 1;
    if ( v9 <= v8 )
    {
      while ( 1 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 4) + v9) = sub_1005C900(
                                                 *(_WORD *)(v4 + 4) + *(_WORD *)(v5 + 34) - v9,
                                                 v4,
                                                 a1,
                                                 *(_DWORD *)(v7 + 4 * v9));
        if ( !*(_BYTE *)(*(_DWORD *)(v5 + 4) + v9) )
          break;
        v10 = sub_1005C870(
                *(_WORD *)(v4 + 4),
                a2,
                a1,
                v4,
                *(_DWORD *)(v7 + 4 * v9),
                *(_WORD *)(v4 + 4) + *(_WORD *)(v5 + 34) - v9,
                0);
        if ( v10 + (signed int)*(_WORD *)(v5 + 42) > a4
          || (++*(_WORD *)(a3 + 10), *(_WORD *)(v5 + 42) += v10, ++v9, v9 > v13) )
        {
          v4 = a3;
          break;
        }
        v7 = v12;
        v4 = a3;
      }
    }
    LOWORD(v8) = *(_WORD *)(v5 + 34) - v9 + 1;
    *(_WORD *)(v4 + 4) += v8;
    *(_WORD *)(v5 + 34) = v9 - 1;
  }
  return v8;
}

//----- (1005CFD0) --------------------------------------------------------
__int16 __usercall sub_1005CFD0@<ax>(int a1@<eax>, int a2, int a3, __int16 a4)
{
  int v4; // esi@1
  int v5; // ebp@1
  int v6; // edi@1
  int v7; // ebx@1
  int v8; // eax@1
  int v9; // ebx@1
  int v11; // [sp+10h] [bp-8h]@1
  int v12; // [sp+14h] [bp-4h]@1

  v4 = a3;
  v5 = *(_DWORD *)(a3 + 12);
  v6 = a1;
  v7 = *(_WORD *)(a1 + 16);
  v8 = *(_DWORD *)v5;
  v9 = v7 - 1;
  v11 = *(_DWORD *)v5;
  v12 = *(_DWORD *)(v5 + 4);
  if ( v9 > *(_WORD *)(v5 + 34) )
  {
    while ( 1 )
    {
      *(_BYTE *)(v9 + v12) = sub_1005C900(
                               *(_WORD *)(v6 + 16) + *(_WORD *)(v5 + 34) + *(_WORD *)(v4 + 4) - v9,
                               v4,
                               a2,
                               *(_DWORD *)(v11 + 4 * v9));
      if ( !*(_BYTE *)(v9 + *(_DWORD *)(v5 + 4)) )
      {
        LOWORD(v8) = sub_1005CED0(a2, v6, v4, a4);
        goto LABEL_10;
      }
      LOWORD(v8) = sub_1005C870(
                     *(_WORD *)(v6 + 16),
                     v6,
                     a2,
                     v4,
                     *(_DWORD *)(v11 + 4 * v9),
                     *(_WORD *)(v6 + 16) + *(_WORD *)(v5 + 34) + *(_WORD *)(v4 + 4) - v9,
                     *(_WORD *)(v5 + 42) - *(_WORD *)(v5 + 38));
      if ( (signed __int16)v8 + (signed int)*(_WORD *)(v5 + 42) > a4 )
        break;
      ++*(_WORD *)(a3 + 10);
      *(_WORD *)(v5 + 42) += v8;
      if ( --v9 <= *(_WORD *)(v5 + 34) )
        goto LABEL_10;
      v4 = a3;
    }
    LOWORD(v8) = sub_1005CED0(a2, v6, a3, a4);
  }
LABEL_10:
  if ( v9 > *(_WORD *)(v5 + 34) )
  {
    LOWORD(v8) = v12;
    do
      *(_BYTE *)(v9-- + v12) = 0;
    while ( v9 > *(_WORD *)(v5 + 34) );
  }
  return v8;
}

//----- (1005D0F0) --------------------------------------------------------
char __cdecl sub_1005D0F0(int a1, int a2, int a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  int v8; // ebp@1
  int v10; // [sp+10h] [bp-8h]@1
  int v11; // [sp+14h] [bp-4h]@1

  v4 = a3;
  v5 = *(_DWORD *)(a3 + 12);
  v6 = *(_DWORD *)v5;
  v7 = *(_DWORD *)(v5 + 4);
  v8 = 0;
  v10 = *(_DWORD *)v5;
  v11 = *(_DWORD *)(v5 + 4);
  if ( *(_WORD *)(v5 + 34) >= 0 )
  {
    while ( 1 )
    {
      LOBYTE(v7) = sub_1005C900(*(_WORD *)(v5 + 34) + *(_WORD *)(v4 + 4) - v8, v4, a1, *(_DWORD *)(v6 + 4 * v8));
      *(_BYTE *)(v11 + v8) = v7;
      if ( !*(_BYTE *)(*(_DWORD *)(v5 + 4) + v8) )
        break;
      LOWORD(v7) = sub_1005C870(
                     *(_WORD *)(v5 + 34),
                     a2,
                     a1,
                     v4,
                     *(_DWORD *)(v6 + 4 * v8),
                     *(_WORD *)(v5 + 34) + *(_WORD *)(v4 + 4) - v8,
                     0);
      if ( (signed __int16)v7 + (signed int)*(_WORD *)(v5 + 42) > a4
        || (++*(_WORD *)(a3 + 10), *(_WORD *)(v5 + 42) += v7, v7 = *(_WORD *)(v5 + 34), ++v8, v8 > v7) )
      {
        v4 = a3;
        break;
      }
      v6 = v10;
      v4 = a3;
    }
    if ( v8 )
    {
      *(_WORD *)(v4 + 4) += *(_WORD *)(v5 + 34) - v8 + 1;
      *(_WORD *)(v5 + 34) = v8 - 1;
    }
  }
  return v7;
}

//----- (1005D1D0) --------------------------------------------------------
__int16 __usercall sub_1005D1D0@<ax>(__int16 a1@<bx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int v4; // eax@1

  v4 = *(_DWORD *)(a3 + 12);
  *(_WORD *)(v4 + 42) = *(_WORD *)(v4 + 38);
  *(_WORD *)(a3 + 10) = 0;
  if ( !(*(_WORD *)(a2 + 4) & 0x800) || !*(_BYTE *)a3 )
  {
    sub_1005D0F0(a4, a2, a3, a1);
    LOWORD(v4) = sub_1005CFD0(a2, a4, a3, a1);
  }
  return v4;
}

//----- (1005D210) --------------------------------------------------------
int __cdecl sub_1005D210(int a1, int a2, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // ebp@1
  int v8; // eax@1
  void **v9; // ecx@1
  int v10; // edx@1
  int v11; // eax@1
  _WORD *v12; // ecx@1
  signed __int16 v13; // cx@2
  unsigned __int16 v14; // di@4
  char v15; // al@5
  bool v16; // zf@7
  int (__cdecl *v17)(int, _DWORD, char *, void *, int); // ebx@12
  int v18; // eax@12
  unsigned __int16 v19; // cx@14
  unsigned __int16 v20; // ax@21
  __int16 v21; // cx@25
  int v22; // eax@25
  signed int v23; // eax@25
  signed int v24; // eax@26
  unsigned __int16 v25; // cx@27
  unsigned __int16 v26; // dx@27
  int v27; // esi@33
  void **v28; // esi@37
  char v30; // [sp+10h] [bp-38h]@2
  char v31; // [sp+11h] [bp-37h]@1
  char v32; // [sp+12h] [bp-36h]@2
  char v33; // [sp+13h] [bp-35h]@1
  signed __int16 v34; // [sp+14h] [bp-34h]@4
  void *v35; // [sp+18h] [bp-30h]@1
  signed __int16 v36; // [sp+1Ch] [bp-2Ch]@4
  int v37; // [sp+20h] [bp-28h]@1
  char v38; // [sp+24h] [bp-24h]@1
  int v39; // [sp+28h] [bp-20h]@1
  int (__cdecl *v40)(int, _DWORD, char *, void *, int); // [sp+2Ch] [bp-1Ch]@1
  void **v41; // [sp+30h] [bp-18h]@1
  int v42; // [sp+34h] [bp-14h]@1
  int v43; // [sp+38h] [bp-10h]@1
  __int16 v44; // [sp+3Ch] [bp-Ch]@1
  int v45; // [sp+40h] [bp-8h]@1
  char v46; // [sp+44h] [bp-4h]@12
  char v47; // [sp+54h] [bp+Ch]@1

  v7 = a3;
  v8 = *(_DWORD *)(a4 + 12);
  v9 = *(void ***)v8;
  v40 = (int (__cdecl *)(int, _DWORD, char *, void *, int))dword_1068B040[2 * (**(_DWORD **)(a3 + 8) & 0xFF)];
  v10 = *(_DWORD *)(v8 + 4);
  v37 = v8;
  v11 = *(_WORD *)(a3 + 6);
  v41 = v9;
  v33 = 0;
  v43 = v10;
  v45 = 0;
  v35 = (void *)sub_100034E0(a1, v11);
  v44 = -32650;
  sub_1005C6E0(v12, a3, a5, (int)&v38, 0);
  v42 = (unsigned __int16)sub_1005C840(v37, a3, a1);
  v47 = 0;
  v39 = 0;
  v31 = 0;
  if ( a2 >= 0 )
  {
    v13 = 1;
    v32 = -1;
    v30 = 0;
  }
  else
  {
    v13 = -1;
    v32 = 0;
    v30 = -1;
  }
  v14 = *(_WORD *)(a4 + 2);
  v34 = v13;
  v36 = v13;
  if ( a2 )
  {
    while ( 1 )
    {
      v15 = sub_1005C900(v14 + v34, a4, a1, (int)v35);
      if ( !v15 )
        break;
      if ( v15 == 1 )
      {
        ++v39;
        v16 = a2 == v36;
        v14 += v34;
        v34 = v36;
        v47 = 0;
        a2 -= v36;
        if ( v16 )
          goto LABEL_14;
        if ( !(*(_BYTE *)(v7 + 4) & 0x80)
          && !a7
          && (v14 & 0x8000u) == 0
          && (signed __int16)v14 < (signed int)*(_WORD *)(a4 + 8) )
        {
          v17 = v40;
          v18 = *(_DWORD *)(v7 + 8);
          v46 = v30;
          v40(a1, v18, &v38, v35, (int)&v44);
          *(_WORD *)(a4 + 6) = v14;
          if ( (unsigned __int8)v17(a1, *(_DWORD *)(v7 + 8), &v38, v35, a6) == 2 )
          {
            v33 = 1;
            goto LABEL_14;
          }
        }
      }
      else
      {
        v34 += v36;
        ++v47;
      }
    }
    if ( v36 == -1 && v47 && *(_WORD *)(a4 + 4) == *(_WORD *)(a4 + 2) )
    {
      v14 += v34;
      *(_BYTE *)(v37 + 44) = 0;
      v31 = 1;
    }
  }
LABEL_14:
  v19 = *(_WORD *)(a4 + 4);
  if ( (signed __int16)v14 >= (signed __int16)v19 )
  {
    v20 = *(_WORD *)(a4 + 10);
    if ( v20 && (signed __int16)v14 >= (signed __int16)v19 + v20 )
      *(_WORD *)(a4 + 4) = v14 - v20 + 1;
  }
  else
  {
    *(_WORD *)(a4 + 4) = (signed __int16)v14 <= 0 ? 0 : v14;
  }
  if ( v31 )
  {
    v21 = *(_WORD *)(a4 + 2);
    v22 = *(_WORD *)(a4 + 2) - *(_WORD *)(a4 + 10) + 1;
    v23 = v22 <= 0 ? 0 : v22;
    *(_WORD *)(a4 + 4) = v23;
    *(_WORD *)(v37 + 34) = v21 - v23;
  }
  else
  {
    v24 = (signed __int16)v14 <= 0 ? 0 : (signed __int16)v14;
    *(_WORD *)(a4 + 2) = v24;
    if ( *(_WORD *)(v7 + 4) & 0x400 )
    {
      v25 = *(_WORD *)(a4 + 8);
      v26 = *(_WORD *)(v7 + 16);
      if ( v25 > v26 && (_WORD)v24 && (signed __int16)v24 != v25 - *(_WORD *)(a4 + 4) )
        sub_1005C930(v24, a4, v26, 1, 1);
    }
    *(_WORD *)(v37 + 34) = *(_WORD *)(a4 + 2) - *(_WORD *)(a4 + 4);
  }
  if ( v39 )
  {
    sub_1005D1D0(v42, v7, a4, a1);
    v27 = *(_WORD *)(v7 + 16) - 1;
    v16 = *(_WORD *)(v7 + 16) == 1;
    v46 = v32;
    if ( v27 >= 0 && !v16 )
    {
      do
      {
        if ( *(_BYTE *)(v27 + v43) == 1 )
          v40(a1, *(_DWORD *)(v7 + 8), &v38, v41[v27], (int)&v44);
        --v27;
      }
      while ( v27 > 0 );
    }
    v28 = v41;
    if ( !a7 )
    {
      v46 = v30;
      v40(a1, *(_DWORD *)(v7 + 8), &v38, *v41, (int)&v44);
    }
    if ( v33 )
      memcpy(*v28, v35, *(_WORD *)(v7 + 6));
    sub_1005C900(*(_WORD *)(a4 + 2), a4, a1, (int)*v28);
    sub_1005CC40(&unk_100E461C, a4, a1, v7, a5);
  }
  sub_10003450(a1, (unsigned int)v35);
  return v39;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1005D5D0) --------------------------------------------------------
char __cdecl sub_1005D5D0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebp@1
  _DWORD *v6; // ecx@1
  unsigned __int16 v7; // ax@1
  char v8; // dl@1
  int v9; // ebx@1
  int v10; // eax@1
  __int16 v11; // cx@2
  int v12; // edi@4
  bool *v13; // esi@4
  char v14; // al@6
  int v16; // eax@15
  char v17; // cl@18
  char v18; // [sp+12h] [bp-16h]@1
  char v19; // [sp+13h] [bp-15h]@1
  char v20; // [sp+14h] [bp-14h]@1
  _DWORD *v21; // [sp+18h] [bp-10h]@1
  char v22; // [sp+1Ch] [bp-Ch]@1
  int (__cdecl *v23)(int, _DWORD, char *, _DWORD, int); // [sp+20h] [bp-8h]@1
  int v24; // [sp+24h] [bp-4h]@1

  v5 = *(_DWORD *)(a4 + 12);
  v6 = *(_DWORD **)v5;
  v23 = (int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_1068B040[2 * (**(_DWORD **)(a2 + 8) & 0xFF)];
  v21 = v6;
  v18 = 1;
  v7 = sub_1005C840(v5, a2, a1);
  v8 = *(_BYTE *)(a5 + 8);
  v24 = v7;
  v19 = v8;
  v20 = 0;
  sub_1005C6E0((_WORD *)a5, a2, a3, (int)&v22, *(_WORD *)(v5 + 34));
  v9 = a1;
  v10 = a5;
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 256) && ((v11 = *(_WORD *)(a5 + 10), v11 == 47) || v11 == 51) )
  {
    v12 = a2;
    v13 = (bool *)a4;
    v20 = 1;
  }
  else
  {
    v12 = a2;
    v13 = (bool *)a4;
    if ( !(*(_BYTE *)(a2 + 4) & 0x80) )
    {
      *(_DWORD *)(a1 + 284) = *(_DWORD *)(v5 + 36);
      *(_DWORD *)(a1 + 288) = *(_DWORD *)(v5 + 40);
      *(_WORD *)(a4 + 6) = *(_WORD *)(a4 + 2);
      v14 = v23(a1, *(_DWORD *)(a2 + 8), &v22, *v21, a5);
      v18 = v14;
      if ( v14 != 1 )
      {
        *(_WORD *)(a4 + 2) = *(_WORD *)(v5 + 34) + *(_WORD *)(a4 + 4);
        if ( v14 != 3 )
        {
          sub_1005D1D0(v24, a2, a4, a1);
          v9 = a1;
        }
        sub_1005CC40(&unk_100E461C, a4, v9, a2, a3);
        return v18;
      }
      v10 = a5;
    }
  }
  switch ( *(_WORD *)(v10 + 10) )
  {
    case 0x21:
      if ( !(*(_WORD *)(v12 + 4) & 0x800) )
        goto LABEL_15;
      if ( *(_BYTE *)(a1 + 3) )
        goto LABEL_12;
      *v13 = *v13 == 0;
      return 2;
    case 0x38:
    case 0x39:
LABEL_12:
      if ( *(_WORD *)(v12 + 4) & 0x800 && (*v13 || !*(_BYTE *)(a1 + 3)) )
        return v18;
LABEL_15:
      v16 = sub_1005D210(a1, v19, v12, (int)v13, a3, v10, 0);
      goto LABEL_16;
    case 0x2F:
    case 0x35:
      v17 = -v19;
      break;
    case 0x31:
    case 0x33:
      v17 = v19;
      break;
    default:
      return v18;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 256) && (!*v13 || !(*(_WORD *)(v12 + 4) & 0x800)) )
  {
    v16 = sub_1005D210(a1, v17, v12, (int)v13, a3, v10, v20);
LABEL_16:
    if ( v16 )
      return 2;
  }
  return v18;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1005D800) --------------------------------------------------------
char __cdecl sub_1005D800(int a1, int a2, int a3, int a4, __int16 *a5)
{
  int v5; // ebp@1
  _DWORD *v6; // ecx@1
  __int16 v7; // ax@1
  int v8; // esi@3
  int v9; // edx@3
  int v10; // edi@3
  int v11; // edi@6
  _DWORD *v12; // eax@6
  int v13; // ST0C_4@6
  signed int v14; // esi@6
  _WORD *v15; // ecx@6
  int v16; // eax@7
  signed int v17; // esi@8
  bool v18; // zf@8
  _DWORD *v19; // edi@10
  _WORD *v20; // ecx@11
  signed int v21; // esi@12
  char result; // al@14
  __int16 v23; // ax@15
  int v24; // ecx@15
  _DWORD *v25; // ecx@16
  __int16 v26; // ax@16
  __int16 v27; // di@17
  __int16 v28; // ax@17
  __int16 v29; // bx@22
  signed int v30; // esi@22
  int v31; // edi@24
  int v32; // eax@31
  int v33; // edi@32
  int v34; // ebx@35
  int v35; // [sp+Ch] [bp-20h]@1
  int v36; // [sp+10h] [bp-1Ch]@3
  void (__cdecl *v37)(int, _DWORD, int *, _DWORD, __int16 *); // [sp+14h] [bp-18h]@1
  _DWORD *v38; // [sp+18h] [bp-14h]@3
  int v39; // [sp+1Ch] [bp-10h]@3
  __int16 v40; // [sp+20h] [bp-Ch]@1
  int v41; // [sp+24h] [bp-8h]@1
  char v42; // [sp+28h] [bp-4h]@1
  char v43; // [sp+34h] [bp+8h]@1
  int v44; // [sp+34h] [bp+8h]@6

  v5 = a2;
  v6 = *(_DWORD **)(a2 + 8);
  v35 = 0;
  v37 = (void (__cdecl *)(int, _DWORD, int *, _DWORD, __int16 *))dword_1068B040[2 * (*v6 & 0xFF)];
  v41 = 0;
  v42 = 0;
  v7 = *a5;
  v43 = 1;
  v40 = -32650;
  if ( v7 == -32671 || v7 == -32703 )
  {
    v8 = a4;
    v9 = v36;
  }
  else
  {
    v8 = a4;
    v9 = *(_DWORD *)(a4 + 12);
    v38 = *(_DWORD **)v9;
    v10 = *(_DWORD *)(v9 + 4);
    v36 = v9;
    v39 = v10;
  }
  switch ( v7 )
  {
    case 0x8041:
      v11 = sub_100034E0(a1, 48);
      *(_DWORD *)(v8 + 12) = v11;
      v44 = v11;
      v12 = (_DWORD *)sub_100034E0(a1, 4 * *(_WORD *)(v5 + 16));
      *(_DWORD *)v11 = v12;
      v13 = *(_WORD *)(v5 + 16);
      v38 = v12;
      v14 = 0;
      *(_DWORD *)(v11 + 4) = sub_100034E0(a1, v13);
      if ( *(_WORD *)(v5 + 16) )
      {
        do
        {
          v16 = sub_100034E0(a1, *(_WORD *)(v5 + 6));
          HIWORD(v15) = HIWORD(v38);
          v38[v14++] = v16;
        }
        while ( v14 < *(_WORD *)(v5 + 16) );
      }
      *(_DWORD *)(v11 + 28) = *(_DWORD *)(v5 + 12);
      LOWORD(v15) = *(_WORD *)(v5 + 6);
      *(_WORD *)(v11 + 32) = (_WORD)v15;
      sub_1005C6E0(v15, v5, a3, (int)&v35, 0);
      v17 = 0;
      v18 = (*(_WORD *)(v5 + 4) & 0x1000) == 0;
      HIWORD(v35) = 0;
      if ( !v18 && *(_WORD *)(a4 + 8) > 0u )
      {
        do
        {
          v19 = v38;
          (*(void (__cdecl **)(int, _DWORD, signed int))(v44 + 28))(a1, *v38, v17);
          v37(a1, *(_DWORD *)(v5 + 8), &v35, *v19, a5);
          ++v17;
        }
        while ( v17 < *(_WORD *)(a4 + 8) );
      }
      *(_BYTE *)(v44 + 44) = 0;
      sub_1005C720(a3, (_WORD *)v5, a1, a4);
      sub_1005C6E0(v20, v5, a3, (int)&v35, 0);
      *(_BYTE *)(v44 + 45) = 0;
      if ( **(_BYTE **)(v5 + 8) == 108 )
      {
        v21 = 0;
        if ( *(_WORD *)(v5 + 16) )
        {
          do
            v37(a1, *(_DWORD *)(v5 + 8), &v35, v38[v21++], &v40);
          while ( v21 < *(_WORD *)(v5 + 16) );
        }
      }
      result = 2;
      break;
    case 0x8040:
      v23 = sub_1005C840(v9, v5, a1);
      sub_1005D1D0(v23, v5, v8, a1);
      v24 = v36;
      *(_DWORD *)(a1 + 276) = *(_DWORD *)(v36 + 36);
      *(_DWORD *)(a1 + 280) = *(_DWORD *)(v24 + 40);
      result = 2;
      break;
    case 0x8022:
      v25 = v38;
      *(_WORD *)(v9 + 34) = *(_WORD *)(v8 + 2) - *(_WORD *)(v8 + 4);
      *(_DWORD *)(v8 + 16) = *v25;
      v26 = sub_1005C840(v9, v5, a1);
      sub_1005D1D0(v26, v5, v8, a1);
      sub_1005CC40(a5, a4, a1, v5, a3);
      result = 1;
      break;
    case 0x8078:
      v27 = *(_WORD *)(v8 + 8);
      v28 = *(_WORD *)(v8 + 2);
      if ( *(_WORD *)(v8 + 2) < (signed int)*(_WORD *)(v8 + 8) )
      {
        if ( v28 == -1 && v27 )
          *(_WORD *)(v8 + 2) = 0;
      }
      else
      {
        *(_WORD *)(v8 + 4) += v27 - v28 - 1;
        *(_WORD *)(v8 + 4) &= ((signed int)*(_WORD *)(v8 + 4) < 0) - 1;
        *(_WORD *)(v8 + 2) = v27 - 1;
      }
      *(_WORD *)(v9 + 34) = *(_WORD *)(v8 + 2) - *(_WORD *)(v8 + 4);
      v29 = sub_1005C840(v9, v5, a1);
      sub_1005D1D0(v29, v5, v8, a1);
      v30 = 0;
      if ( *(_WORD *)(v5 + 16) )
      {
        do
        {
          if ( *(_BYTE *)(v30 + v39) == 1 )
          {
            v31 = v36;
            if ( v30 || *(_BYTE *)(v36 + 45) )
            {
              if ( v30 <= *(_WORD *)(v36 + 34) && v30 )
              {
                v42 = -1;
                v37(a1, *(_DWORD *)(v5 + 8), &v35, v38[v30], &v40);
              }
              else
              {
                v42 = 0;
                v37(a1, *(_DWORD *)(v5 + 8), &v35, v38[v30], &v40);
                *(_BYTE *)(v31 + 45) = 0;
              }
            }
          }
          ++v30;
        }
        while ( v30 < *(_WORD *)(v5 + 16) );
      }
      v32 = v36;
      if ( *(_WORD *)(v36 + 34) >= 0 )
      {
        *(_DWORD *)(a4 + 16) = *v38;
        v33 = a4;
      }
      else
      {
        v33 = a4;
        *(_DWORD *)(a4 + 16) = 0;
      }
      if ( !*(_BYTE *)(v32 + 44) )
      {
        v34 = sub_100034E0(a1, *(_WORD *)(v5 + 6));
        if ( sub_1005C900(*(_WORD *)(v33 + 2), v33, a1, v34) == 2 )
          sub_1005D210(a1, 1, v5, v33, a3, (int)a5, 0);
        sub_10003450(a1, v34);
        *(_BYTE *)(v36 + 44) = 1;
      }
      sub_1005CC40(a5, v33, a1, v5, a3);
      result = 2;
      break;
    case 0x8048:
      v43 = sub_1005D5D0(a1, v5, a3, v8, (int)a5);
      goto LABEL_40;
    default:
LABEL_40:
      result = v43;
      break;
  }
  return result;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1005DCD0) --------------------------------------------------------
char __usercall sub_1005DCD0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, const char *a4, char a5)
{
  unsigned int v5; // ST14_4@1
  int *v6; // eax@1
  int v7; // ST10_4@1
  signed int v8; // eax@1
  unsigned int v9; // ST08_4@1
  int v10; // eax@1
  unsigned int v11; // ST04_4@1
  signed int v12; // eax@1
  __int16 v13; // dx@1
  int v15; // [sp+0h] [bp-18h]@1
  int v16; // [sp+4h] [bp-14h]@1
  int v17; // [sp+8h] [bp-10h]@1
  __int16 v18; // [sp+Ch] [bp-Ch]@1
  int v19; // [sp+Eh] [bp-Ah]@1
  int v20; // [sp+14h] [bp-4h]@1

  v5 = *(_DWORD *)(a3 + 8);
  v18 = *(_WORD *)(a3 + 12);
  v6 = sub_1006D000(v5);
  v7 = *(_DWORD *)(a3 + 8);
  v15 = *v6;
  v8 = sub_1006D040(v7);
  v9 = *(_DWORD *)(a3 + 8);
  v16 = v8;
  v10 = sub_1006D920(v9, 0);
  v11 = *(_DWORD *)(a3 + 8);
  v17 = v10;
  v19 = sub_1006CFD0(v11);
  v12 = sub_1006D070(*(_DWORD *)(a3 + 8));
  *(_WORD *)(a2 + 438) = *(_WORD *)a1;
  v13 = *(_WORD *)(a1 + 2);
  v20 = v12 | 1;
  *(_WORD *)(a2 + 436) = v13;
  if ( !a5 )
    HIWORD(v19) = word_105728D8[0];
  return sub_1006D980(a2, a4, &v15, *(_WORD *)(v15 + 30));
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005DD70) --------------------------------------------------------
char __usercall sub_1005DD70@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  char v5; // al@1
  int v6; // edi@1
  char v7; // al@1
  int v8; // esi@1
  int v9; // ecx@6
  unsigned __int16 v10; // ax@6
  char v11; // dl@7
  __int16 v12; // bx@11
  __int16 v13; // ax@15
  unsigned int v14; // ecx@15
  __int16 v15; // bx@15
  __int16 v16; // ax@21
  signed int v17; // esi@21
  int v18; // ecx@21
  __int16 v19; // ax@22
  int v20; // edx@23
  int v21; // esi@24
  int v22; // ST20_4@24
  __int16 v23; // ax@26
  __int16 v24; // si@26
  int v25; // ebx@26
  __int16 v26; // cx@26
  __int16 v27; // ST20_2@26
  char v29; // [sp+13h] [bp-49h]@1
  char *v30; // [sp+14h] [bp-48h]@2
  int v31; // [sp+18h] [bp-44h]@7
  int v32; // [sp+1Ch] [bp-40h]@16
  int v33; // [sp+20h] [bp-3Ch]@1
  int v34; // [sp+24h] [bp-38h]@1
  int v35; // [sp+28h] [bp-34h]@6
  int v36; // [sp+2Ch] [bp-30h]@1
  int v37; // [sp+30h] [bp-2Ch]@11
  int v38; // [sp+34h] [bp-28h]@15
  int v39; // [sp+38h] [bp-24h]@11
  int v40; // [sp+3Ch] [bp-20h]@21
  int v41; // [sp+40h] [bp-1Ch]@21
  int v42; // [sp+44h] [bp-18h]@21
  int v43; // [sp+48h] [bp-14h]@21
  int v44; // [sp+4Ch] [bp-10h]@24
  char v45; // [sp+50h] [bp-Ch]@24

  v5 = *(_BYTE *)(a4 + 4);
  v6 = a2;
  LOBYTE(v33) = (*(_BYTE *)(a4 + 4) & 8) != 8;
  v7 = v5 & 7;
  v8 = a1;
  v34 = a1;
  v36 = a4;
  v29 = 1;
  if ( v7 == 1 )
  {
    v30 = sub_10070850(*(_WORD *)a4);
  }
  else if ( v7 == 2 )
  {
    v30 = sub_10070850(*(_WORD *)a4);
  }
  else
  {
    v30 = *(char **)a4;
  }
  v9 = (unsigned __int16)sub_1006D630(v30, *(_DWORD *)(v8 + 8));
  v10 = *(_WORD *)(v8 + 12);
  v35 = v9;
  if ( v10 )
  {
    v31 = v10;
  }
  else
  {
    v11 = *(_BYTE *)(a4 + 4) & 7;
    v31 = (unsigned __int16)v9;
    if ( v11 == 2 )
      v31 = (unsigned __int16)(v35 + sub_1006D630("  ", *(_DWORD *)(v8 + 8)));
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v12 = sub_1006DC60(
              v30,
              *(_DWORD *)(v8 + 8),
              *(_WORD *)(dword_1068B4C0[5 * ((*(_DWORD *)(v8 + 8) >> 10) & 0xF)] + 30),
              (int)&v37,
              (int)&v39);
      sub_1006DB90(v6 + 276, *(_DWORD *)a3, *(_DWORD *)(v8 + 8), (signed __int16)v31);
      *(_WORD *)(v6 + 282) = v12 + *(_WORD *)(v6 + 278) - 1;
      goto LABEL_27;
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) == 33 )
      {
        v29 = 0;
        if ( (_BYTE)v33 )
          v29 = 3;
      }
      break;
    case 0x8022:
    case 0x8078:
      v13 = sub_1006DC60(
              v30,
              *(_DWORD *)(v8 + 8),
              *(_WORD *)(dword_1068B4C0[5 * ((*(_DWORD *)(v8 + 8) >> 10) & 0xF)] + 30),
              (int)&v37,
              (int)&v39);
      v14 = *(_DWORD *)(v8 + 8);
      v15 = v13;
      v38 = (unsigned __int16)v13;
      if ( v14 & 0x8000 )
      {
        v32 = (signed __int16)v31 / 2;
      }
      else if ( v14 & 0x4000 )
      {
        v32 = (signed __int16)v31;
      }
      else
      {
        v32 = 0;
      }
      if ( *(_BYTE *)(v8 + 4) == 1 )
      {
        *(_WORD *)(v6 + 442) = sub_1006CFD0(v14);
        HIWORD(v41) = word_105728D8[0];
        v16 = word_105728D8[14];
        LOWORD(v42) = word_105728D8[15];
        LOWORD(v43) = v42;
        LOWORD(v41) = v16;
        HIWORD(v42) = v16;
        HIWORD(v43) = v16;
        v17 = 0;
        v18 = v31 + 20;
        *(_WORD *)(v6 + 426) = 1;
        *(_WORD *)(v6 + 424) = 1;
        v40 = v18;
        do
        {
          v19 = *((_WORD *)&v41 + 2 * v17 + 1);
          *(_WORD *)(v6 + 428) = *((_WORD *)&v41 + 2 * v17);
          *(_WORD *)(v6 + 430) = v19;
          sub_1009E590(
            v6 + 392,
            v17 + *(_WORD *)a3 - v32 - 10,
            *(_WORD *)(a3 + 2) + v17 - v15 - 5,
            v40,
            v15 - 2 * v17 + 15,
            3);
          ++v17;
        }
        while ( v17 < 3 );
      }
      sub_1005DCD0(a3, v6, v34, v30, v33);
      v20 = v36;
      if ( (*(_BYTE *)(v36 + 4) & 7) == 2 )
      {
        v30 = *(char **)a3;
        LOWORD(v30) = v35 + (_WORD)v30;
        v41 = *(_DWORD *)v34;
        v42 = *(_DWORD *)(v34 + 4);
        v21 = *(_DWORD *)(v34 + 8);
        v44 = *(_DWORD *)(v34 + 12);
        LOWORD(v44) = v44 - v35;
        v22 = *(_WORD *)(v36 + 2);
        v43 = v21;
        _snprintf(&v45, 7u, " %d", v22);
        sub_1005DCD0((int)&v30, v6, (int)&v41, &v45, v33);
        v20 = v36;
      }
      if ( *(_BYTE *)(v20 + 4) & 0x10 )
      {
        v23 = v38;
        v24 = *(_WORD *)(v6 + 398);
        v25 = *(_DWORD *)(v6 + 452);
        v26 = v31;
        v27 = v38 - 4;
        *(_WORD *)(v6 + 440) = -1;
        *(_WORD *)(v6 + 442) = 0;
        *(_WORD *)(v6 + 398) = 1;
        *(_DWORD *)(v6 + 452) = &unk_100C42E0;
        sub_1009F8C0(v6 + 392, *(_WORD *)a3 - v32, *(_WORD *)(a3 + 2) - v23 + 5, v26, v27);
        *(_WORD *)(v6 + 398) = v24;
        *(_DWORD *)(v6 + 452) = v25;
      }
LABEL_27:
      v29 = 2;
      break;
    default:
      return v29;
  }
  return v29;
}
// 105728D8: using guessed type __int16 word_105728D8[];
// 1068B4C0: using guessed type int dword_1068B4C0[];

//----- (1005E1B0) --------------------------------------------------------
char __cdecl sub_1005E1B0(int a1, int a2, int a3, __int16 *a4, int a5)
{
  __int16 v6; // [sp+0h] [bp-8h]@1
  char v7; // [sp+4h] [bp-4h]@1

  v6 = *a4;
  v7 = 1;
  return sub_1005DD70(a2, a1, a3, (int)&v6, a5);
}

//----- (1005E1F0) --------------------------------------------------------
char __cdecl sub_1005E1F0(int a1, int a2, int a3, int a4, int a5)
{
  return sub_1005DD70(a2, a1, a3, a4, a5);
}

//----- (1005E210) --------------------------------------------------------
char __cdecl sub_1005E210(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@4
  signed int v6; // eax@5
  unsigned int v7; // edx@5
  int v8; // eax@5
  unsigned int v9; // ST48_4@5
  int v10; // edx@5
  __int16 v11; // di@5
  signed int v12; // eax@9
  unsigned int v13; // ST48_4@9
  int v14; // eax@9
  unsigned int v15; // ST40_4@9
  int *v16; // eax@9
  int v17; // ST3C_4@9
  __int16 v18; // ax@9
  __int16 v19; // bp@9
  __int16 v20; // bx@9
  __int16 v21; // cx@9
  __int16 v22; // dx@9
  __int16 v23; // cx@9
  __int16 v24; // ax@9
  int v25; // edx@9
  __int16 v26; // cx@9
  char *v27; // [sp+8h] [bp-68h]@7
  __int16 v28; // [sp+8h] [bp-68h]@9
  __int16 v29; // [sp+Ch] [bp-64h]@9
  __int16 v30; // [sp+10h] [bp-60h]@9
  __int16 v31; // [sp+14h] [bp-5Ch]@9
  unsigned int v32; // [sp+18h] [bp-58h]@9
  int v33; // [sp+18h] [bp-58h]@10
  __int16 v34; // [sp+1Ch] [bp-54h]@9
  __int16 v35; // [sp+20h] [bp-50h]@9
  int v36; // [sp+24h] [bp-4Ch]@12
  __int16 v37; // [sp+28h] [bp-48h]@9
  __int16 v38; // [sp+2Ch] [bp-44h]@9
  __int16 v39; // [sp+30h] [bp-40h]@12
  __int16 v40; // [sp+32h] [bp-3Eh]@12
  __int16 v41; // [sp+34h] [bp-3Ch]@12
  __int16 v42; // [sp+36h] [bp-3Ah]@12
  __int16 v43; // [sp+38h] [bp-38h]@12
  __int16 v44; // [sp+3Ah] [bp-36h]@12
  __int16 v45; // [sp+3Ch] [bp-34h]@12
  __int16 v46; // [sp+3Eh] [bp-32h]@12
  int v47; // [sp+40h] [bp-30h]@5
  int v48; // [sp+44h] [bp-2Ch]@5
  int v49; // [sp+48h] [bp-28h]@5
  __int16 v50; // [sp+4Ch] [bp-24h]@5
  int v51; // [sp+4Eh] [bp-22h]@5
  int v52; // [sp+54h] [bp-1Ch]@9
  __int16 v53; // [sp+58h] [bp-18h]@11
  __int16 v54; // [sp+5Ah] [bp-16h]@11
  __int16 v55; // [sp+5Ch] [bp-14h]@11
  __int16 v56; // [sp+5Eh] [bp-12h]@11
  __int16 v57; // [sp+60h] [bp-10h]@11
  __int16 v58; // [sp+62h] [bp-Eh]@11
  __int16 v59; // [sp+64h] [bp-Ch]@11
  __int16 v60; // [sp+66h] [bp-Ah]@11
  __int16 v61; // [sp+68h] [bp-8h]@11
  __int16 v62; // [sp+6Ah] [bp-6h]@11
  __int16 v63; // [sp+6Ch] [bp-4h]@11
  __int16 v64; // [sp+6Eh] [bp-2h]@11
  int v65; // [sp+84h] [bp+14h]@9

  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      v6 = sub_1006D040(*(_DWORD *)(a2 + 12));
      v7 = *(_DWORD *)(a2 + 12);
      v48 = v6;
      v49 = sub_1006D920(v7, 0);
      v8 = sub_1006CFD0(*(_DWORD *)(a2 + 12));
      v9 = *(_DWORD *)(a2 + 12);
      v51 = v8;
      v10 = *sub_1006D000(v9);
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      v11 = *(_WORD *)(a3 + 2);
      v47 = v10;
      v50 = 0;
      *(_WORD *)(a1 + 278) = v11 - *(_WORD *)(v10 + 24) - 1;
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  if ( *(_DWORD *)a2 == 110 )
    v27 = *(char **)a4;
  else
    v27 = sub_10070850(*a4);
  v12 = sub_1006D040(*(_DWORD *)(a2 + 12));
  v13 = *(_DWORD *)(a2 + 12);
  v48 = v12;
  v49 = sub_1006D920(v13, 0);
  v14 = sub_1006CFD0(*(_DWORD *)(a2 + 12));
  v15 = *(_DWORD *)(a2 + 12);
  v51 = v14;
  v16 = sub_1006D000(v15);
  v17 = *(_DWORD *)(a2 + 12);
  v47 = *v16;
  v50 = 0;
  v52 = sub_1006D070(v17);
  v18 = sub_1009DA50(v47, v27, v48);
  v19 = *(_WORD *)a3;
  v20 = *(_WORD *)(a3 + 2);
  v30 = *(_WORD *)a3 + *(_WORD *)(a2 + 4);
  v21 = *(_BYTE *)(a2 + 16);
  v35 = v20 + *(_WORD *)(a2 + 6);
  v22 = v21 + *(_WORD *)a3;
  v23 = v18 + v21 + *(_WORD *)a3 + 6;
  v65 = (unsigned __int16)(v20 + (*(_WORD *)(v47 + 22) >> 1));
  v24 = v51;
  *(_WORD *)(a1 + 428) = v51;
  *(_WORD *)(a1 + 430) = v24;
  *(_WORD *)(a1 + 440) = v24;
  *(_WORD *)(a1 + 442) = v24;
  v31 = v23;
  v38 = v23 - v22;
  v29 = v22;
  *(_WORD *)(a1 + 396) = 3;
  sub_1009E590(a1 + 392, v22 + 1, v20, v23 - v22 - 1, v65 - v20, 1);
  sub_1009E590(a1 + 392, v19, v65 - *(_WORD *)(v47 + 22), v30 - v19 + 1, v20 + *(_WORD *)(v47 + 22) - v65, 1);
  v25 = v47;
  *(_WORD *)(a1 + 436) = v65 - 3;
  *(_WORD *)(a1 + 438) = v29 + 4;
  sub_1006D980(a1, v27, &v47, *(_WORD *)(v25 + 26));
  v32 = (((unsigned int)*(_WORD *)(a2 + 8) >> 12) & 3) + 1;
  v26 = word_105728D8[(unsigned __int8)sub_1007A590(*(_BYTE *)(a2 + 8) & 0x1F)];
  v37 = word_105728D8[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  *(_WORD *)(a1 + 440) = v37;
  *(_WORD *)(a1 + 442) = v37;
  v34 = v26;
  v28 = 0;
  if ( (signed int)(2 - v32) < 2 )
  {
    v33 = 2 - (2 - v32);
    do
    {
      *(_WORD *)(a1 + 428) = v26;
      *(_WORD *)(a1 + 430) = v26;
      v53 = v29 - v28;
      v54 = v28 + v20;
      v55 = v28 + v19;
      v56 = v28 + v20;
      v57 = v28 + v19;
      v58 = v35 - v28;
      v60 = v35 - v28;
      v59 = v30 - v28;
      v61 = v30 - v28;
      v63 = v31 + v28;
      v62 = v28 + v20;
      v64 = v28 + v20;
      sub_1009F430(a1 + 392, 6, (int)&v53, 2);
      v26 = v34;
      ++v28;
      --v33;
    }
    while ( v33 );
  }
  v39 = v31;
  v41 = v31;
  *(_WORD *)(a1 + 428) = v26;
  *(_WORD *)(a1 + 430) = v26;
  v43 = v29;
  v45 = v29;
  v40 = v20;
  v42 = v65;
  v44 = v65;
  v46 = v20;
  v36 = a1 + 392;
  sub_1009F430(a1 + 392, 4, (int)&v39, 2);
  *(_WORD *)(a1 + 428) = v37;
  *(_WORD *)(a1 + 430) = v37;
  if ( !(*(_WORD *)(a2 + 8) & 0xC000) )
  {
    sub_1009E590(v36, v28 + *(_WORD *)a3, v28 + *(_WORD *)(a3 + 2), *(_BYTE *)(a2 + 16) - 1, v35 - 2 * v28 - v20 + 1, 3);
    sub_1009E590(v36, v29, v65 + v28, v38 + 1, v35 - 2 * v28 - v65 + 1, 3);
    sub_1009E590(v36, v31 + v28, v20 + v28, v30 - 2 * v28 - v31 + 1, v35 - 2 * v28 - v20 + 1, 3);
  }
  return 2;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1005E6F0) --------------------------------------------------------
char __usercall sub_1005E6F0@<al>(int a1@<eax>, char *a2@<ecx>)
{
  char *v2; // esi@1
  char v3; // bl@1
  char *v5; // [sp+8h] [bp-8h]@1
  char v6; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v3 = *a2;
  if ( sub_10070660(*(char **)(a1 + 4), (int *)&v6, &v5) )
  {
    do
    {
      if ( *v2 > v3 )
        v3 = *v2;
      ++v2;
    }
    while ( sub_10070660(v5, (int *)&v6, &v5) );
  }
  return v3;
}

//----- (1005E750) --------------------------------------------------------
char __usercall sub_1005E750@<al>(int a1@<esi>, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // edx@1
  char *v6; // edi@1
  char v7; // bl@1
  int v8; // ebp@1
  _BYTE *v9; // ecx@2
  bool v10; // al@9
  bool v11; // al@14
  char v13; // [sp+Fh] [bp-19h]@1
  _DWORD *v14; // [sp+10h] [bp-18h]@2
  int v15; // [sp+14h] [bp-14h]@1
  __int16 v16; // [sp+18h] [bp-10h]@6
  __int16 v17; // [sp+1Ah] [bp-Eh]@6
  char *v18; // [sp+1Ch] [bp-Ch]@1
  int v19; // [sp+20h] [bp-8h]@1
  int v20; // [sp+24h] [bp-4h]@1
  char v21; // [sp+2Ch] [bp+4h]@1

  v5 = *(_DWORD *)(a4 + 4);
  v6 = *(char **)(a2 + 4);
  v20 = *(_DWORD *)(a4 + 8);
  v21 = *(_BYTE *)(a1 + 3);
  v15 = v5;
  v7 = 1;
  v8 = 0;
  v13 = *(_BYTE *)(a1 + 9);
  if ( sub_10070660(v6, &v19, &v18) )
  {
    v9 = (_BYTE *)a4;
    v14 = (_DWORD *)(a4 + 12);
    while ( 1 )
    {
      if ( *a5 != -32696 || *(_BYTE *)(*v9 + v20) == v8 )
      {
        v16 = *(_WORD *)a3 + *(_WORD *)v19;
        v17 = *(_WORD *)(a3 + 2) + *(_WORD *)(v19 + 2);
        v10 = v21 && *(_BYTE *)(v15 + v8) == *v9 && *v9 >= 0;
        *(_BYTE *)(a1 + 3) = v10;
        v11 = v13 && *(_BYTE *)(v15 + v8) == *v9 && *v9 >= 0;
        *(_BYTE *)(a1 + 9) = v11;
        v7 = ((int (__cdecl *)(int, char *, __int16 *, _DWORD, _WORD *))dword_1068B040[2 * (*(_DWORD *)v6 & 0xFF)])(
               a1,
               v6,
               &v16,
               *v14,
               a5);
        *(_BYTE *)(a1 + 3) = v21;
        *(_BYTE *)(a1 + 9) = v13;
      }
      v6 = v18;
      ++v14;
      ++v8;
      if ( !sub_10070660(v18, &v19, &v18) )
        break;
      v9 = (_BYTE *)a4;
    }
  }
  return v7;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1005E8A0) --------------------------------------------------------
char __cdecl sub_1005E8A0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  char v6; // al@1
  char *v7; // ebp@1
  int v8; // ecx@1
  char *v9; // edi@1
  char v10; // bl@1
  int v11; // edi@5
  char v12; // al@8
  char v13; // al@10
  char v14; // al@16
  char *v15; // edi@18
  signed __int16 v16; // bx@18
  signed __int16 v17; // bp@18
  _WORD *v18; // eax@20
  signed int v19; // eax@20
  signed int v20; // eax@22
  signed __int16 v21; // cx@24
  signed int v22; // eax@24
  signed __int16 v23; // dx@26
  signed int v24; // eax@26
  __int16 v25; // dx@29
  char *v26; // eax@32
  char v27; // cl@33
  bool v28; // zf@37
  signed int v30; // [sp+10h] [bp-1Ch]@1
  _DWORD *v31; // [sp+14h] [bp-18h]@19
  signed __int16 v32; // [sp+18h] [bp-14h]@18
  signed __int16 v33; // [sp+1Ch] [bp-10h]@18
  char *v34; // [sp+20h] [bp-Ch]@18
  _WORD *v35; // [sp+24h] [bp-8h]@18
  char *v36; // [sp+28h] [bp-4h]@1
  char v37; // [sp+3Ch] [bp+10h]@32

  v5 = a5;
  v6 = *(_BYTE *)(a5 + 8);
  v7 = (char *)a4;
  v30 = *(_BYTE *)(a5 + 8);
  v8 = *(_WORD *)a5 - 32832;
  v9 = *(char **)(a4 + 4);
  v36 = *(char **)(a4 + 4);
  v10 = 1;
  if ( v8 )
  {
    if ( v8 == 54 )
    {
      if ( v6 )
      {
        if ( v6 == -1 )
        {
          v14 = sub_1005E6F0(a2, v9);
          v5 = a5;
          *(_BYTE *)a4 = v14 <= 0 ? 0 : v14;
        }
        else
        {
          *(_BYTE *)a4 = v6;
        }
      }
      else
      {
        *(_BYTE *)a4 = 0;
      }
    }
    v11 = a3;
  }
  else
  {
    v15 = *(char **)(a2 + 4);
    v16 = 0x7FFF;
    v17 = -32768;
    v33 = -32768;
    v32 = 0x7FFF;
    if ( sub_10070660(*(char **)(a2 + 4), (int *)&v35, &v34) )
    {
      v31 = (_DWORD *)(a4 + 12);
      do
      {
        v18 = v35;
        *(_WORD *)(a1 + 276) = *v35;
        *(_WORD *)(a1 + 278) = v18[1];
        *(_WORD *)(a1 + 280) = *v18;
        *(_WORD *)(a1 + 282) = v18[1];
        ((void (__cdecl *)(int, char *, _WORD *, _DWORD, int))dword_1068B040[2 * (*(_DWORD *)v15 & 0xFF)])(
          a1,
          v15,
          v18,
          *v31,
          a5);
        v19 = *(_WORD *)(a1 + 276);
        if ( v16 < v19 )
          LOWORD(v19) = v16;
        v16 = v19;
        v20 = *(_WORD *)(a1 + 280);
        if ( v33 > v20 )
          LOWORD(v20) = v33;
        v21 = v20;
        v22 = *(_WORD *)(a1 + 278);
        v33 = v21;
        if ( v32 < v22 )
          LOWORD(v22) = v32;
        v23 = v22;
        v24 = *(_WORD *)(a1 + 282);
        v32 = v23;
        if ( v17 > v24 )
          LOWORD(v24) = v17;
        v15 = v34;
        ++v31;
        v17 = v24;
      }
      while ( sub_10070660(v34, (int *)&v35, &v34) );
    }
    v11 = a3;
    *(_WORD *)(a1 + 276) = v16 + *(_WORD *)a3;
    v10 = 2;
    *(_WORD *)(a1 + 278) = v32 + *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v33 + *(_WORD *)a3;
    v25 = v17 + *(_WORD *)(a3 + 2);
    v7 = (char *)a4;
    *(_WORD *)(a1 + 282) = v25;
    v5 = a5;
  }
  if ( *(_WORD *)v5 != -32704 && *(_WORD *)v5 != -32650 )
  {
    v12 = sub_1005E6F0(a2, v36);
    if ( *v7 < v12 )
      v12 = *v7;
    *v7 = v12;
    v13 = sub_1005E750(a1, a2, v11, (int)v7, (_WORD *)a5);
    v5 = a5;
    v10 = v13;
  }
  if ( *(_WORD *)v5 == -32696 && v10 == 1 && *(_BYTE *)(v5 + 8) )
  {
    switch ( *(_WORD *)(v5 + 10) )
    {
      case 0x2F:
      case 0x35:
        v30 = -v30;
        goto LABEL_31;
      case 0x31:
      case 0x33:
LABEL_31:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 256) )
          goto LABEL_32;
        return v10;
      case 0x21:
      case 0x38:
      case 0x39:
LABEL_32:
        v37 = sub_1005E6F0(a2, v36);
        v26 = (char *)(abs(v30) / v30);
        v36 = v26;
        break;
      default:
        return v10;
    }
    while ( 1 )
    {
      v27 = *v7;
      if ( (*v7 <= 0 || (signed int)v26 >= 0) && (v27 >= v37 || (signed int)v26 <= 0) )
        break;
      v28 = v30 == (_DWORD)v26;
      v30 -= (signed int)v26;
      *v7 = (_BYTE)v26 + v27;
      if ( v28 )
        return 2;
      v10 = sub_1005E750(a1, a2, v11, (int)v7, (_WORD *)a5);
      if ( v10 != 1 )
        return v10;
      v26 = v36;
    }
  }
  return v10;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1005EBB0) --------------------------------------------------------
int __cdecl sub_1005EBB0(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // esi@1

  v2 = ((a2 & 0x3F) - 46) << 6;
  v3 = *(int *)((char *)&dword_100D73A0 + v2);
  if ( a2 & 0x40 )
    ++v3;
  return v3 * BYTE1(dword_1068B4C0[5 * ((a1 >> 10) & 0xF) + 4])
       + *(int *)((char *)&dword_100D7398 + v2) * BYTE3(dword_1068B4C0[5 * ((a1 >> 10) & 0xF) + 3])
       + *(_WORD *)(dword_1068B4C0[5 * ((a1 >> 10) & 0xF) + 1] + 28) * (*(int *)((char *)&dword_100D7398 + v2) + v3 - 1);
}
// 100D7398: using guessed type int dword_100D7398;
// 100D73A0: using guessed type int dword_100D73A0;
// 1068B4C0: using guessed type int dword_1068B4C0[];

//----- (1005EC10) --------------------------------------------------------
char __cdecl sub_1005EC10(signed __int16 *a1, _BYTE *a2)
{
  void *v2; // ecx@0
  signed __int16 v3; // ax@1
  void *v4; // ecx@1
  signed __int16 v5; // dx@7

  LOBYTE(v3) = sub_10070320(v2);
  if ( (_BYTE)v3 )
  {
    if ( sub_100702F0(v4) )
    {
      *a2 = 35;
      v3 = *a1;
      if ( *a1 < 0x7FFF )
      {
        if ( v3 / 12 & 1 )
          *a2 = 36;
        v3 = *a1 / 12;
        v5 = *a1 % 12;
        *a1 = v5;
        if ( !v5 )
          *a1 = 12;
      }
    }
    else
    {
      LOBYTE(v3) = (_BYTE)a2;
      *a2 = 37;
    }
  }
  else
  {
    *a2 = 38;
  }
  return v3;
}

//----- (1005EC80) --------------------------------------------------------
__int16 __usercall sub_1005EC80@<ax>(int a1@<eax>, int a2@<esi>, unsigned int a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // ecx@1
  unsigned int v5; // ecx@1
  __int16 result; // ax@1

  v3 = a3 % (3600 * (word_100D739C[32 * ((*(_BYTE *)(a1 + 8) & 0x3F) - 46)] + 1));
  v4 = v3;
  v3 /= 0xE10u;
  *(_WORD *)a2 = v3;
  v5 = -3600 * (unsigned __int16)v3 + v4;
  *(_BYTE *)(a2 + 2) = v5 / 0x3C;
  result = 60 * (char)(v5 / 0x3C);
  *(_BYTE *)(a2 + 3) = v5 % 0x3C;
  return result;
}
// 100D739C: using guessed type __int16 word_100D739C[];

//----- (1005ECE0) --------------------------------------------------------
char *__usercall sub_1005ECE0@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4)
{
  int v4; // esi@1
  void *v5; // ecx@1
  __int16 v6; // ax@2
  char v8; // [sp+4h] [bp-4h]@1
  char v9; // [sp+6h] [bp-2h]@1

  strncpy(&v8, (const char *)(a2 + *(_DWORD *)(a1 + 56) + 69), 2u);
  v9 = 0;
  v4 = a4 + (unsigned __int8)j__atol(&v8);
  if ( sub_100702F0(v5) != 1
    || (v6 = *(_WORD *)(a3 + 8) & 0x3F, v6 == 49)
    || v6 == 48
    || v6 == 47
    || v6 == 50
    || v6 == 51
    || v6 == 46 )
  {
    if ( v4 <= 23 )
    {
      if ( v4 < 0 )
        v4 = 23;
    }
    else
    {
      v4 = 0;
    }
  }
  else if ( v4 <= 12 )
  {
    if ( v4 <= 0 )
      v4 = 12;
  }
  else
  {
    v4 = 1;
  }
  sprintf(&v8, "%02u", v4);
  return strncpy((char *)(a2 + *(_DWORD *)(a1 + 56) + 69), &v8, 2u);
}

//----- (1005EDA0) --------------------------------------------------------
int __usercall sub_1005EDA0@<eax>(unsigned int a1@<eax>, char a2@<cl>)
{
  char v2; // bl@1
  int v3; // ebp@1
  __int16 v4; // bx@1
  int v5; // edi@1
  signed int v6; // esi@6
  char *v7; // eax@7
  int v8; // eax@7

  v2 = a2;
  v3 = sub_1006D000(a1)[1];
  v4 = v2 & 0x3F;
  v5 = 0;
  if ( v4 == 52 || v4 == 53 || v4 == 54 || v4 == 55 || v4 == 56 )
  {
    v6 = 0;
    do
    {
      v7 = sub_100793A0(byte_100D7628[v6]);
      v8 = sub_1009DA50(v3, v7, 0);
      if ( v5 <= v8 )
        v5 = v8;
      ++v6;
    }
    while ( v6 < 4 );
  }
  return v5;
}

//----- (1005EE10) --------------------------------------------------------
char __usercall sub_1005EE10@<al>(int *a1@<ebx>, int a2@<edi>, _DWORD *a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char v5; // cl@1

  v3 = ((*(_BYTE *)(a2 + 8) & 0x3F) - 46) << 6;
  v4 = *(int *)((char *)&dword_100D73A0 + v3) + *(int *)((char *)&dword_100D7398 + v3);
  *a1 = v4;
  v5 = *(_BYTE *)(a2 + 8) & 0x3F;
  if ( v5 == 52 || (*(_BYTE *)(a2 + 8) & 0x3F) == 54 )
  {
    LOBYTE(v4) = sub_100702F0((void *)v5);
    if ( (_BYTE)v4 == 1 )
      ++*a1;
  }
  if ( byte_100D73A5[v3] && *(_BYTE *)(a2 + 8) & 0x40 )
  {
    *a3 = 1;
    ++*a1;
  }
  else
  {
    *a3 = 0;
  }
  return v4;
}
// 100D7398: using guessed type int dword_100D7398;
// 100D73A0: using guessed type int dword_100D73A0;

//----- (1005EE80) --------------------------------------------------------
char __usercall sub_1005EE80@<al>(signed int *a1@<ecx>, int a2@<ebx>, int a3, int a4)
{
  int v4; // ebp@1
  signed int v5; // eax@1
  int v6; // edi@3
  void *v7; // ecx@5
  __int16 v8; // ax@6
  signed __int16 v9; // ax@8
  __int16 v10; // cx@16
  __int16 v11; // ax@17
  __int16 v12; // cx@22
  __int16 v13; // ax@26
  int v14; // eax@31
  char result; // al@32
  signed int v16; // [sp+Ch] [bp-8h]@1
  signed int v17; // [sp+10h] [bp-4h]@3

  v4 = a3;
  v5 = 0;
  v16 = 0;
  if ( a1 )
  {
    v5 = *a1;
    v16 = *a1;
  }
  v17 = 1;
  v6 = (*(_BYTE *)(a3 + 8) & 0x3F) - 46;
  if ( v5 < 0 )
  {
    v5 = -v5;
    v16 = v5;
    v17 = -1;
  }
  sub_1005EC80(a3, (int)&a3, v5);
  if ( sub_100702F0(v7) != 1 || (v8 = *(_WORD *)(v4 + 8) & 0x3F, v8 != 52) && v8 != 54 )
  {
    v9 = a3;
  }
  else
  {
    v9 = a3;
    if ( (_WORD)a3 == 12 )
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -107;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
    else if ( (signed __int16)a3 <= 12 )
    {
      if ( !(_WORD)a3 )
        v9 = 12;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -108;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -107;
      v9 -= 12;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
  }
  v10 = *(_WORD *)(v4 + 8);
  if ( v10 & 0x40 )
  {
    sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), &a03d02u[64 * v6], v17 * v9, BYTE2(a3), BYTE3(a3));
    v11 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( (v11 == 46 || v11 == 47) && !v16 || v17 < 0 )
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 69) = 45;
  }
  else
  {
    v12 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v12 != 50 && v12 != 51 )
      sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), off_100D7368[16 * v6], v17 * v9, BYTE2(a3), BYTE3(a3));
    else
      sprintf(
        (char *)(*(_DWORD *)(a2 + 56) + 69),
        off_100D7368[16 * v6],
        BYTE2(a3),
        (unsigned __int8)(BYTE3(a3) / 10 + 48),
        (unsigned __int8)((unsigned __int16)(BYTE3(a3) % 10) + 48));
  }
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = 0;
  v13 = *(_WORD *)(v4 + 8) & 0x3F;
  if ( v13 != 46 && v13 != 47 && v13 != 52 && v13 != 48 && v13 != 54
    || (v14 = *(_DWORD *)(a2 + 56), *(_WORD *)(v14 + 240) != a4) )
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 1;
    result = 4;
  }
  else
  {
    *(_BYTE *)(v14 + 242) = 2;
    result = 4;
  }
  return result;
}
// 100D7368: using guessed type char *off_100D7368[2];

//----- (1005F070) --------------------------------------------------------
char __cdecl sub_1005F070(signed __int16 *a1, _BYTE *a2)
{
  void *v2; // ecx@1
  char v3; // bl@1
  char result; // al@4
  unsigned int v5; // [sp+8h] [bp-4h]@1

  v3 = sub_10075D30((char *)&v5);
  if ( v3 == 1 )
  {
    if ( sub_10070320(v2) == 1 )
      sub_1007A5C0((int *)&v5, v5);
    sub_10075C30((int)a1, v5);
    sub_1005EC10(a1, a2);
    result = 1;
  }
  else
  {
    *a1 = 0x7FFF;
    sub_1005EC10(a1, a2);
    result = v3;
  }
  return result;
}

//----- (1005F0F0) --------------------------------------------------------
char __usercall sub_1005F0F0@<al>(int a1@<eax>, int a2@<ecx>, signed int *a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  void *v6; // ecx@1
  int v7; // eax@1
  char v8; // bl@1
  unsigned __int16 v9; // ax@4
  __int16 v10; // ax@7
  __int16 v11; // ax@10
  char result; // al@12
  unsigned __int16 v13; // ax@15
  int v14; // ebp@17
  int v15; // eax@18
  __int16 v16; // ax@19
  int v17; // eax@26
  char *v18; // eax@27
  int v19; // ebx@27
  char v20; // dl@28
  char v21; // bl@29
  char *v22; // eax@29
  char v23; // dl@29
  char v24; // cl@30
  __int16 v25; // bp@33
  void *v26; // ecx@34
  __int16 v27; // di@35
  char *v28; // eax@42
  int v29; // edi@42
  char v30; // dl@43
  char v31; // bl@44
  char *v32; // eax@44
  char v33; // dl@44
  char v34; // cl@45
  int v35; // ecx@46
  unsigned int v36; // kr00_4@48
  __int32 v37; // eax@48
  int v38; // ebx@49
  char *v39; // eax@53
  char v40; // dl@54
  char v41; // bl@55
  char *v42; // eax@55
  char v43; // dl@55
  char v44; // cl@56
  int v45; // ecx@57
  __int16 v46; // ax@57
  const char *v47; // ecx@58
  char v48; // kr08_1@58
  char *v49; // eax@58
  char v50; // dl@58
  char v51; // cl@59
  int v52; // ecx@60
  char v53; // cl@62
  int v54; // edx@65
  __int16 v55; // di@75
  bool v56; // zf@79
  unsigned __int16 v57; // ax@82
  __int16 v58; // ax@85
  __int16 v59; // bp@88
  unsigned __int16 v60; // ax@89
  int v61; // ebp@91
  void *v62; // ecx@91
  __int16 v63; // ax@92
  char *v64; // eax@99
  int v65; // edx@99
  char v66; // cl@100
  char v67; // bl@101
  char *v68; // eax@101
  char v69; // bp@101
  char v70; // cl@102
  int v71; // eax@103
  _BYTE *v72; // ecx@103
  __int16 v73; // ax@103
  __int16 v74; // di@109
  signed __int16 v75; // di@114
  const char *v76; // ecx@117
  char *v77; // eax@117
  int v78; // edi@117
  char v79; // dl@118
  __int16 v80; // bp@123
  __int16 v81; // ax@123
  char v82[2]; // [sp+10h] [bp-10h]@33
  char v83; // [sp+12h] [bp-Eh]@34
  char v84; // [sp+13h] [bp-Dh]@33
  int v85; // [sp+14h] [bp-Ch]@1
  int v86; // [sp+18h] [bp-8h]@1
  int v87; // [sp+1Ch] [bp-4h]@1

  v4 = a1;
  v5 = a2;
  v86 = (*(_BYTE *)(a1 + 8) & 0x3F) - 46;
  sub_1005EE10(&v87, a1, &v85);
  v7 = *(_DWORD *)(v5 + 56);
  v8 = 1;
  if ( *(_WORD *)(v7 + 240) != -128 )
  {
    if ( *(_WORD *)(a4 + 10) == 84 )
      *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v7 + 69) != 45) + 43;
    v9 = *(_WORD *)(a4 + 14);
    if ( v9 >= 0x41u && v9 <= 0x5Au || v9 == 32 )
    {
      v10 = *(_WORD *)(v4 + 8) & 0x3F;
      if ( (v10 == 52 || v10 == 54) && sub_100702F0(v6) == 1 )
      {
        v11 = *(_WORD *)(a4 + 14);
        goto LABEL_11;
      }
    }
    v13 = *(_WORD *)(a4 + 14);
    if ( v13 >= 0x30u && v13 <= 0x39u )
    {
      v14 = v85;
      if ( *(_BYTE *)(v4 + 8) & 0x40 )
      {
        v15 = *(_DWORD *)(v5 + 56);
        if ( *(_WORD *)(v15 + 240) == v85 - 1 )
        {
          *(_WORD *)(v15 + 240) = v85;
          v16 = *(_WORD *)(v4 + 8) & 0x3F;
          if ( v16 != 46 && v16 != 47 && v16 != 52 && v16 != 48 && v16 != 54 )
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
          else
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
        }
      }
      v17 = *(_DWORD *)(v5 + 56);
      if ( *(_BYTE *)(v17 + 242) == 2 )
      {
        *(_WORD *)(v17 + v14 + 69) = 12336;
        v18 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        v19 = *(_DWORD *)(v5 + 56) + 70;
        do
          v20 = *v18++;
        while ( v20 );
        v21 = (_BYTE)v18 - v19;
        v22 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
        v23 = (_BYTE)v22 + 1;
        do
          v24 = *v22++;
        while ( v24 );
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)(v21 - ((_BYTE)v22 - v23)) - 1;
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
      }
      if ( (*(_BYTE *)(v4 + 8) & 0x3F) == 49 )
      {
        strncpy(v82, (const char *)(*(_DWORD *)(v5 + 56) + v85 + 69), 3u);
        v25 = word_100D739C[32 * v86];
        v84 = 0;
      }
      else
      {
        strncpy(v82, (const char *)(*(_DWORD *)(v5 + 56) + v14 + 69), 2u);
        v83 = 0;
        if ( sub_100702F0(v26) != 1
          || (v27 = *(_WORD *)(v4 + 8) & 0x3F, v27 == 49)
          || v27 == 48
          || v27 == 47
          || v27 == 50
          || v27 == 51
          || (v25 = 12, v27 == 46) )
        {
          v25 = 23;
        }
      }
      v28 = (char *)(*(_DWORD *)(v5 + 56) + 69);
      v29 = *(_DWORD *)(v5 + 56) + 70;
      do
        v30 = *v28++;
      while ( v30 );
      v31 = (_BYTE)v28 - v29;
      v32 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
      v33 = (_BYTE)v32 + 1;
      do
        v34 = *v32++;
      while ( v34 );
      v35 = *(_DWORD *)(v5 + 56);
      if ( *(_WORD *)(v35 + 240) == (char)(v31 - ((_BYTE)v32 - v33)) - 1 )
      {
        if ( v82[0] == 48 )
        {
          v36 = strlen(v82);
          v37 = j__atol(v82);
          sprintf(v82, "%0*i", v36, 10 * v37);
        }
        v38 = v85;
        v82[*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) - v85] = *(_BYTE *)(a4 + 14);
        if ( j__atol(v82) > v25 )
          *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
        else
          memcpy((void *)(*(_DWORD *)(v5 + 56) + v38 + 69), v82, strlen(v82));
        if ( 10 * j__atol((const char *)(*(_DWORD *)(v5 + 56) + v38 + 69)) <= v25 )
        {
LABEL_69:
          if ( *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) == 58 )
          {
            ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
            return 2;
          }
          return 2;
        }
        v39 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        do
          v40 = *v39++;
        while ( v40 );
        v41 = (_BYTE)v39 - (*(_BYTE *)(v5 + 56) + 70);
        v42 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
        v43 = (_BYTE)v42 + 1;
        do
          v44 = *v42++;
        while ( v44 );
        v45 = *(_DWORD *)(v5 + 56);
        v46 = (char)(v41 - ((_BYTE)v42 - v43)) + 1;
      }
      else
      {
        v47 = (const char *)(v35 + 69);
        v48 = strlen(v47);
        v49 = strchr(v47, 58);
        v50 = (_BYTE)v49 + 1;
        do
          v51 = *v49++;
        while ( v51 );
        v52 = *(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
        if ( v52 >= (char)(v48 - ((_BYTE)v49 - v50)) - 1 )
        {
          if ( *(_WORD *)(a4 + 14) > (unsigned __int16)(unsigned __int8)*(&byte_100D7370[(v86 << 6) - v85] + v52) )
            goto LABEL_69;
          v53 = *(_BYTE *)(a4 + 14);
        }
        else
        {
          v82[v52 - v85] = *(_BYTE *)(a4 + 14);
          if ( j__atol(v82) > v25 )
            goto LABEL_69;
          v53 = *(_BYTE *)(a4 + 14);
        }
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v5 + 56) + 240))++ + *(_DWORD *)(v5 + 56) + 69) = v53;
        v54 = *(_DWORD *)(v5 + 56);
        LOBYTE(v46) = v87 - 1;
        if ( *(_WORD *)(v54 + 240) < v87 - 1 )
          v46 = *(_WORD *)(v54 + 240);
        v45 = *(_DWORD *)(v5 + 56);
        v46 = (char)v46;
      }
      *(_WORD *)(v45 + 240) = v46;
      goto LABEL_69;
    }
    if ( v13 != 43 && v13 != 45 || !(*(_BYTE *)(v4 + 8) & 0x40) )
      return v8;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) != v85 - 1 )
      return 2;
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v85;
    v55 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v55 == 46 || v55 == 47 || v55 == 52 || v55 == 48 )
      goto LABEL_129;
    v56 = v55 == 54;
LABEL_128:
    if ( v56 )
      goto LABEL_129;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
    return 2;
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
    *(_WORD *)(a4 + 14) = 45;
  v57 = *(_WORD *)(a4 + 14);
  if ( v57 >= 0x41u && v57 <= 0x5Au || v57 == 32 )
  {
    v58 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( (v58 == 52 || v58 == 54) && sub_100702F0(v6) == 1 )
    {
      v59 = v85;
      sub_1005EE80(a3, v5, v4, v85);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v59;
      v11 = *(_WORD *)(a4 + 14);
LABEL_11:
      if ( v11 == 80 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 90) = -107;
        return 2;
      }
      if ( v11 == 65 )
      {
        result = 2;
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 90) = -108;
        return result;
      }
      return 2;
    }
  }
  v60 = *(_WORD *)(a4 + 14);
  if ( v60 < 0x30u || v60 > 0x39u )
  {
    if ( v60 != 43 && v60 != 45 || !(*(_BYTE *)(v4 + 8) & 0x40) )
      return v8;
    v80 = v85;
    v86 = 0;
    sub_1005EE80(&v86, v5, v4, v85);
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v80;
    v81 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v81 == 46 || v81 == 47 || v81 == 52 || v81 == 48 )
    {
LABEL_129:
      result = 2;
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
      return result;
    }
    v56 = v81 == 54;
    goto LABEL_128;
  }
  v61 = v85;
  v86 = 0;
  sub_1005EE80(&v86, v5, v4, v85);
  if ( sub_100702F0(v62) == 1 )
  {
    v63 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v63 != 49 && v63 != 48 && v63 != 47 && v63 != 50 && v63 != 51 && v63 != 46 )
      *(_WORD *)(*(_DWORD *)(v5 + 56) + v61 + 69) = 12336;
  }
  *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
  v64 = (char *)(*(_DWORD *)(v5 + 56) + 69);
  v65 = *(_DWORD *)(v5 + 56) + 70;
  do
    v66 = *v64++;
  while ( v66 );
  v67 = (_BYTE)v64 - v65;
  v68 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) - 1;
  v71 = *(_DWORD *)(v5 + 56);
  v72 = (_BYTE *)*(_WORD *)(v71 + 240);
  v72[v71 + 69] = *(_BYTE *)(a4 + 14);
  v73 = *(_WORD *)(v4 + 8) & 0x3F;
  if ( v73 != 46 && v73 != 47 && v73 != 52 && v73 != 48 && v73 != 54 )
    return 2;
  if ( sub_100702F0(v72) != 1
    || (v74 = *(_WORD *)(v4 + 8) & 0x3F, v74 == 49)
    || v74 == 48
    || v74 == 47
    || v74 == 50
    || v74 == 51
    || (v56 = v74 == 46, v75 = 12, v56) )
  {
    v75 = 23;
  }
  if ( 10 * j__atol((const char *)(*(_DWORD *)(v5 + 56) + v85 + 69)) <= v75 )
    return 2;
  v76 = (const char *)(*(_DWORD *)(v5 + 56) + 69);
  v77 = (char *)(*(_DWORD *)(v5 + 56) + 69);
  v78 = *(_DWORD *)(v5 + 56) + 70;
  do
    v79 = *v77++;
  while ( v79 );
  *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)((_BYTE)v77 - v78 - strlen(strchr(v76, 58))) + 1;
  return 2;
}
// 100D739C: using guessed type __int16 word_100D739C[];
// 1005F0F0: using guessed type char var_10[2];

//----- (1005F8E0) --------------------------------------------------------
char __usercall sub_1005F8E0@<al>(char *a1@<eax>, signed int *a2@<edx>, int a3, _BYTE *a4)
{
  char *v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@1
  signed int v7; // ebp@2
  int v8; // ecx@8
  signed int v9; // esi@8
  int v10; // ebx@10
  _BYTE *v11; // edx@11
  __int16 v12; // dx@12
  int v13; // esi@29
  int v14; // esi@33
  char *v15; // ebx@38
  void *v16; // ecx@41
  const char *v17; // ST18_4@49
  char *v18; // ebx@57
  void *v19; // ecx@60
  char *v20; // ebx@68
  _BYTE *v21; // edx@71
  char v22; // cl@72
  int v24; // [sp-8h] [bp-30h]@21
  signed int v25; // [sp-8h] [bp-30h]@28
  int v26; // [sp-4h] [bp-2Ch]@21
  signed int v27; // [sp-4h] [bp-2Ch]@32
  __int16 v28; // [sp+10h] [bp-18h]@8
  unsigned __int8 v29; // [sp+12h] [bp-16h]@8
  unsigned __int8 v30; // [sp+13h] [bp-15h]@8
  int v31; // [sp+14h] [bp-14h]@1
  int v32; // [sp+18h] [bp-10h]@1
  char *v33; // [sp+1Ch] [bp-Ch]@10
  int v34; // [sp+20h] [bp-8h]@10
  int v35; // [sp+24h] [bp-4h]@1

  v4 = a1;
  v5 = *(_BYTE *)(a3 + 8) & 0x3F;
  LOBYTE(a1) = 0;
  *(_DWORD *)v4 = 0;
  *((_DWORD *)v4 + 1) = 0;
  *((_DWORD *)v4 + 2) = 0;
  *((_DWORD *)v4 + 3) = 0;
  *((_DWORD *)v4 + 4) = 0;
  v35 = v5;
  v6 = v5 - 46;
  v32 = 1;
  LOBYTE(v31) = 31;
  v4[20] = 0;
  if ( v5 == 54 )
    v7 = 0;
  else
    v7 = *a2;
  switch ( v5 )
  {
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
      if ( v7 >= 0x7FFFFFFF )
        goto LABEL_78;
      if ( v7 < 0 )
      {
        v7 = -v7;
        v32 = -1;
      }
      sub_1005EC80(a3, (int)&v28, v7);
      v8 = v28;
      v9 = v29;
      if ( v30 + 60 * (v29 + 60 * v28) != v7 || v7 >= 0x7FFFFFFF )
      {
LABEL_78:
        v15 = (&off_100D736C)[64 * v6];
        do
        {
          LOBYTE(a1) = *v15;
          *v4++ = *v15++;
        }
        while ( (_BYTE)a1 );
      }
      else
      {
        v10 = v6 << 6;
        v33 = (&off_100D736C)[v10];
        v34 = (int)v4;
        do
        {
          LOBYTE(a1) = *v33;
          v11 = (_BYTE *)v34;
          ++v33;
          ++v34;
          *v11 = (_BYTE)a1;
        }
        while ( (_BYTE)a1 );
        v12 = *(__int16 *)((char *)word_100D739C + v10);
        if ( v28 <= v12 )
        {
          if ( (a1 = (char *)*(_WORD *)(a3 + 8), v34 = (int)a1, LOWORD(a1) = (unsigned __int8)a1 & 0x3F, (_WORD)a1 != 50)
            && (_WORD)a1 != 51
            || v9 <= v12 )
          {
            if ( v28 || v35 != 47 )
            {
              if ( (_WORD)a1 != 50 && (_WORD)a1 != 51 )
              {
                if ( v35 == 46 || v35 == 47 )
                {
                  v27 = v9;
                  if ( v34 & 0x40 )
                  {
                    v14 = v32;
                    LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v32 * v8, v27);
                    if ( !v7 || v14 < 0 )
                      *v4 = 45;
                  }
                  else
                  {
                    LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100D7368 + v10), v32 * v8, v9);
                  }
                }
                else
                {
                  v25 = v9;
                  if ( v34 & 0x40 )
                  {
                    v13 = v32;
                    LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v32 * v8, v25, v30);
                    if ( v13 < 0 )
                      *v4 = 45;
                  }
                  else
                  {
                    LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100D7368 + v10), v32 * v8, v9, v30);
                  }
                }
              }
              else
              {
                v26 = (unsigned __int8)((unsigned __int16)(v30 % 10) + 48);
                v24 = (unsigned __int8)(v30 / 10 + 48);
                if ( v34 & 0x40 )
                {
                  LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v9, v24, v26);
                  if ( !v7 || v32 < 0 )
                    *v4 = 45;
                }
                else
                {
                  LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100D7368 + v10), v9, v24, v26);
                }
              }
            }
            else
            {
              LOBYTE(a1) = sprintf(
                             v4,
                             "%02u:%c%c",
                             v9,
                             (unsigned __int8)(v30 / 10 + 48),
                             (unsigned __int8)((unsigned __int16)(v30 % 10) + 48));
            }
          }
        }
      }
      break;
    case 55:
      if ( !sub_10075D30((char *)&v34) || v7 >= 86400 )
        goto LABEL_53;
      if ( sub_10070320(v16) == 1 )
        sub_1007A5C0(&v34, v34);
      v7 += 86400
          * (((signed int)(((unsigned __int64)(1037155065i64 * (v34 + v7)) >> 32) - (v34 + v7)) >> 16)
           + ((unsigned int)(((unsigned __int64)(1037155065i64 * (v34 + v7)) >> 32) - (v34 + v7)) >> 31))
          + v34;
      goto LABEL_46;
    case 52:
    case 53:
    case 56:
LABEL_46:
      if ( v7 == -1 || v7 >= 86400 )
      {
LABEL_53:
        v28 = 0x7FFF;
        if ( v5 == 53 || v5 == 56 )
          LOBYTE(v31) = 38;
        else
          sub_1005EC10(&v28, &v31);
        v18 = (&off_100D736C)[64 * (v5 - 46)];
        do
        {
          LOBYTE(a1) = *v18;
          *v4++ = *v18++;
        }
        while ( (_BYTE)a1 );
      }
      else
      {
        sub_10075C30((int)&v28, v7);
        if ( v5 == 53 )
        {
          v17 = off_100D7368[16 * (v5 - 46)];
          LOBYTE(v31) = 38;
          LOBYTE(a1) = sprintf(v4, v17, v28, v29, v30);
        }
        else if ( v5 == 56 )
        {
          LOBYTE(v31) = 38;
          LOBYTE(a1) = sprintf(v4, off_100D7368[16 * (v5 - 46)], v28, v29);
        }
        else
        {
          sub_1005EC10(&v28, &v31);
          LOBYTE(a1) = sprintf(v4, off_100D7368[16 * (v5 - 46)], v28, v29);
        }
      }
      break;
    case 54:
      if ( sub_1005F070(&v28, &v31) )
      {
        if ( sub_100702F0(v19) == 1 )
        {
          if ( v28 && v28 != 12 )
          {
            LOBYTE(a1) = sprintf(v4, "%d:%02d:%02d", v28 % 12, v29, v30);
          }
          else
          {
            sprintf(v4, "%02d:%02d:%02d", 12, v29, v30);
            LOBYTE(a1) = sprintf(v4, "%02d:%02d:%02d", 12, v29, v30);
          }
        }
        else
        {
          LOBYTE(a1) = sprintf(v4, off_100D7368[16 * (v5 - 46)], v28, v29, v30);
        }
      }
      else
      {
        v20 = (&off_100D736C)[64 * (v5 - 46)];
        do
        {
          LOBYTE(a1) = *v20;
          *v4++ = *v20++;
        }
        while ( (_BYTE)a1 );
      }
      break;
    default:
      break;
  }
  if ( ~(unsigned __int8)(*(_WORD *)(a3 + 8) >> 9) & 1 )
  {
    a1 = sub_100793A0(v31);
    v21 = a4;
    do
    {
      v22 = *a1;
      *v21++ = *a1++;
    }
    while ( v22 );
  }
  else
  {
    *a4 = 0;
  }
  return (unsigned int)a1;
}
// 100D7368: using guessed type char *off_100D7368[2];
// 100D736C: using guessed type char *off_100D736C;
// 100D739C: using guessed type __int16 word_100D739C[];

//----- (1005FDE0) --------------------------------------------------------
char __usercall sub_1005FDE0@<al>(signed int *a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // ebx@1
  __int16 v5; // cx@1
  int v6; // ebx@2
  __int16 v7; // ax@4
  char v9; // [sp+4h] [bp-24h]@1
  char v10; // [sp+Ch] [bp-1Ch]@1

  v4 = a2;
  sub_1005F8E0(&v10, a1, a4, &v9);
  *(_WORD *)(a3 + 438) = *(_WORD *)v4;
  *(_WORD *)(a3 + 436) = *(_WORD *)(v4 + 2);
  v5 = *(_WORD *)(a4 + 8);
  if ( ~((unsigned int)*(_WORD *)(a4 + 8) >> 9) & 1 )
    v6 = sub_1005EDA0(*(_DWORD *)(a4 + 4), v5);
  else
    v6 = 0;
  v7 = *(_WORD *)(a4 + 10) - v6;
  if ( v6 > 0 )
    v7 -= *(_WORD *)(dword_1068B4C4[5 * ((*(_DWORD *)(a4 + 4) >> 10) & 0xF)] + 28);
  if ( !*(_WORD *)(a4 + 10) )
    v7 = sub_1005EBB0(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8));
  return sub_1006DCF0(a3, &v10, &v9, v7, v6, *(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8));
}
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (1005FEA0) --------------------------------------------------------
char __cdecl sub_1005FEA0(int a1, int a2, int *a3, signed int *a4, int a5)
{
  signed int *v5; // ecx@1
  signed int v6; // edx@2
  int v7; // ebx@4
  bool v8; // zf@4
  __int16 v9; // ax@8
  _WORD *v10; // esi@8
  unsigned int v11; // ebx@9
  int v12; // eax@9
  int v13; // eax@11
  __int16 v14; // dx@15
  __int16 v15; // cx@15
  __int64 v16; // rax@18
  int v17; // eax@20
  __int16 v18; // bx@20
  signed int v19; // eax@21
  signed int v20; // edx@29
  int v21; // edx@31
  int v22; // edx@32
  int *v23; // ecx@34
  int v24; // esi@34
  signed int v25; // eax@35
  __int16 v26; // ax@37
  int v27; // esi@39
  void *v28; // ecx@39
  signed __int16 v29; // bx@39
  __int16 v30; // ax@41
  int v31; // edi@55
  int v32; // esi@57
  char v33; // al@58
  __int16 v34; // ax@63
  int v35; // edi@67
  char v36; // al@68
  __int16 v37; // ax@75
  int v38; // eax@77
  char v39; // cl@77
  char v40; // al@79
  int v41; // eax@85
  signed int *v42; // edx@85
  const char *v43; // edx@89
  char v44; // kr00_1@89
  char *v45; // eax@89
  char v46; // dl@89
  char v47; // cl@90
  int v48; // ecx@91
  __int16 v49; // ax@92
  int v50; // ebx@97
  __int16 v51; // ax@101
  int v52; // eax@105
  int v53; // esi@105
  __int16 v54; // cx@107
  char v55; // dl@114
  int v56; // edi@120
  int v57; // edi@129
  __int16 v58; // ax@129
  char v59; // al@131
  char v60; // cl@132
  int v61; // ebx@136
  int v62; // ecx@137
  int v63; // edx@137
  unsigned __int8 v64; // al@137
  __int16 v65; // ax@139
  __int16 v66; // ax@146
  int v67; // eax@151
  int v68; // esi@155
  __int16 v69; // cx@156
  signed int *v70; // edx@156
  int v71; // ecx@156
  int v72; // ecx@157
  int v73; // edx@157
  unsigned __int8 v74; // al@157
  __int16 v75; // ax@159
  int v76; // eax@167
  unsigned __int8 v77; // cl@167
  __int16 v78; // ax@171
  int v79; // eax@176
  int v80; // ebx@181
  int *v81; // eax@194
  unsigned __int8 v82; // ST10_1@194
  char *v83; // ebx@194
  int v84; // esi@194
  __int16 v85; // ax@194
  char v87; // [sp+13h] [bp-3Dh]@4
  int v88; // [sp+14h] [bp-3Ch]@5
  int v89; // [sp+18h] [bp-38h]@4
  signed int *v90; // [sp+1Ch] [bp-34h]@1
  int v91; // [sp+20h] [bp-30h]@1
  int *v92; // [sp+24h] [bp-2Ch]@1
  int v93; // [sp+28h] [bp-28h]@4
  int v94; // [sp+2Ch] [bp-24h]@5
  int v95; // [sp+30h] [bp-20h]@85
  char v96[24]; // [sp+34h] [bp-1Ch]@35

  v5 = a4;
  v92 = a3;
  v91 = a2;
  v90 = a4;
  if ( a4 )
    v6 = *a4;
  else
    v6 = 0;
  v7 = (*(_BYTE *)(a2 + 8) & 0x3F) - 46;
  v8 = *(_WORD *)a5 == -32703;
  v89 = v6;
  v87 = 1;
  v93 = v7;
  if ( v8 )
  {
    v88 = 0;
    v94 = 0;
  }
  else
  {
    sub_1005EE10(&v94, a2, &v88);
    v5 = v90;
    v6 = v89;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v9 = *(_WORD *)(a2 + 10);
      v10 = (_WORD *)(a1 + 276);
      if ( v9 )
      {
        sub_1006DB90(a1 + 276, *v92, *(_DWORD *)(a2 + 4), v9);
      }
      else
      {
        v11 = *(_DWORD *)(a2 + 4);
        v12 = sub_1005EBB0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
        sub_1006DB90(a1 + 276, *v92, v11, v12);
      }
      v13 = sub_1005EDA0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
      if ( (!*(_WORD *)(a2 + 10) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v13 > 0 )
      {
        v14 = *(_WORD *)(dword_1068B4C4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v13 + v14;
        v15 = *(_WORD *)(a1 + 280);
        if ( *(_WORD *)(a2 + 10) > 0 )
          *v10 += v13 + v14;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v16 = (signed __int16)v13 + (signed int)v14 + 1;
          LODWORD(v16) = ((signed int)v16 - HIDWORD(v16)) >> 1;
          *v10 -= v16;
          *(_WORD *)(a1 + 280) = v15 - v16;
        }
      }
      return 2;
    case 0x8048:
      v17 = *(_DWORD *)(a1 + 56);
      v18 = *(_WORD *)(v17 + 240);
      if ( v18 == -128 )
      {
        v19 = *(_WORD *)(a5 + 10);
        if ( v19 > 84 )
        {
          if ( v19 != 0x2000 )
            return v87;
        }
        else if ( v19 != 84 )
        {
          if ( v19 == 32 )
          {
            v93 = 0;
            v87 = sub_1005EE80(&v93, a1, a2, v88);
          }
          else if ( v19 == 56 )
          {
            v87 = sub_1005EE80(v5, a1, a2, v88);
          }
          return v87;
        }
        return sub_1005F0F0(a2, a1, v5, a5);
      }
      v20 = *(_WORD *)(a5 + 10);
      if ( v20 > 56 )
      {
        if ( v20 == 57 )
        {
          v60 = *(_BYTE *)(a5 + 8);
          if ( v60 < 0 )
          {
            if ( v18 )
            {
              --*(_WORD *)(v17 + 240);
              if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) )
              {
                v61 = v88;
                do
                {
                  v62 = *(_DWORD *)(a1 + 56);
                  v63 = *(_WORD *)(v62 + 240);
                  v64 = *(_BYTE *)(v63 + v62 + 69);
                  if ( v64 >= 0x30u && v64 <= 0x39u )
                  {
                    v65 = *(_WORD *)(a2 + 8) & 0x3F;
                    if ( v65 != 46 && v65 != 47 && v65 != 52 && v65 != 48 && v65 != 54 )
                      break;
                    if ( v63 != v61 + 1 )
                      break;
                  }
                  --*(_WORD *)(v62 + 240);
                }
                while ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) );
              }
              v66 = *(_WORD *)(a2 + 8) & 0x3F;
              v87 = 2;
              if ( v66 != 46 && v66 != 47 && v66 != 52 && v66 != 48 && v66 != 54
                || (v67 = *(_DWORD *)(a1 + 56), *(_WORD *)(v67 + 240) != v88) )
              {
                *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
              }
              else
              {
                *(_BYTE *)(v67 + 242) = 2;
              }
            }
            else
            {
              v87 = 2;
            }
            goto LABEL_127;
          }
          if ( v60 <= 0 )
            return v87;
          v68 = v94 - 1;
          if ( v18 >= v94 - 1 )
            return 0;
          v69 = *(_WORD *)(v17 + 240);
          v70 = (signed int *)v69;
          *(_WORD *)(v17 + 240) = v69 + 1;
          v71 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
          v90 = v70;
          if ( v71 < v68 )
          {
            do
            {
              v72 = *(_DWORD *)(a1 + 56);
              v73 = *(_WORD *)(v72 + 240);
              v74 = *(_BYTE *)(v73 + v72 + 69);
              if ( v74 >= 0x30u && v74 <= 0x39u )
              {
                v75 = *(_WORD *)(a2 + 8) & 0x3F;
                if ( v75 != 46 && v75 != 47 && v75 != 52 && v75 != 48 && v75 != 54 )
                  break;
                if ( v73 != v88 + 1 )
                  break;
              }
              ++*(_WORD *)(v72 + 240);
            }
            while ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v68 );
          }
          if ( byte_100D73A4[64 * v93]
            || (v76 = *(_DWORD *)(a1 + 56), v77 = *(_BYTE *)(*(_WORD *)(v76 + 240) + v76 + 69), v77 >= 0x30u)
            && v77 <= 0x39u )
          {
            v87 = 2;
          }
          else
          {
            *(_WORD *)(v76 + 240) = (char)v90;
            v87 = 0;
          }
          v78 = *(_WORD *)(a2 + 8) & 0x3F;
          if ( v78 != 46 && v78 != 47 && v78 != 52 && v78 != 48 && v78 != 54
            || (v79 = *(_DWORD *)(a1 + 56), *(_WORD *)(v79 + 240) != v88) )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
          }
          else
          {
            *(_BYTE *)(v79 + 242) = 2;
          }
        }
        else
        {
          if ( v20 != 84 && v20 != 0x2000 )
            return v87;
          v87 = sub_1005F0F0(a2, a1, v5, a5);
        }
        if ( v87 != 4 && v87 != 2 )
          return v87;
LABEL_127:
        if ( v89 < 0 )
          v89 = -v89;
        v57 = v91;
        sub_1005EC80(v91, (int)&v89, v89);
        v58 = *(_WORD *)(v57 + 8) & 0x3F;
        LOBYTE(v88) = 31;
        if ( v58 == 52 || v58 == 54 )
        {
          v59 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90);
          goto LABEL_187;
        }
        goto LABEL_192;
      }
      if ( v20 == 56 )
      {
        v90 = (signed int *)(2 * (*(_BYTE *)(a5 + 8) >= 0) - 1);
        if ( v18 >= v88 )
        {
          v43 = (const char *)(v17 + 69);
          v44 = strlen((const char *)(v17 + 69));
          v45 = strchr(v43, 58);
          v46 = (_BYTE)v45 + 1;
          do
            v47 = *v45++;
          while ( v47 );
          v48 = *(_DWORD *)(a1 + 56);
          if ( *(_WORD *)(v48 + 240) < (signed __int16)(char)(v44 - ((_BYTE)v45 - v46)) )
          {
            v49 = *(_WORD *)(a2 + 8) & 0x3F;
            if ( v49 == 46 || v49 == 47 || v49 == 52 || v49 == 48 || v49 == 54 )
            {
              v50 = v88;
              *(_WORD *)(v48 + 240) = v88;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 2;
              goto LABEL_100;
            }
            *(_BYTE *)(v48 + 242) = 1;
          }
        }
        v50 = v88;
LABEL_100:
        if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != v94 - 1
          || (v51 = *(_WORD *)(a2 + 8) & 0x3F, v51 != 52) && v51 != 54
          || sub_100702F0((void *)(v94 - 1)) != 1 )
        {
          v52 = *(_DWORD *)(a1 + 56);
          v53 = *(_WORD *)(v52 + 240);
          if ( v53 == v50 - 1 )
          {
            v87 = 2;
            *(_BYTE *)(v52 + 69) = 2 * (*(_BYTE *)(v52 + 69) != 45) + 43;
          }
          else
          {
            v54 = *(_WORD *)(a2 + 8) & 0x3F;
            if ( v54 != 46 && v54 != 47 && v54 != 52 && v54 != 48 && v54 != 54 || v53 != v50 )
            {
              v55 = *(_BYTE *)(v53 + v52 + 69);
              if ( v55 != 48 || v90 != (signed int *)-1 )
              {
                if ( *(_BYTE *)(*(_WORD *)(v52 + 240) + v52 + 69) < (unsigned __int8)*(&byte_100D7370[(v93 << 6) - v50]
                                                                                     + *(_WORD *)(v52 + 240))
                  || v90 != (signed int *)1 )
                {
                  v56 = *(_DWORD *)(a1 + 56);
                  *(_BYTE *)(*(_WORD *)(v56 + 240) + v56 + 69) = sub_10071500(v55, 0x10u, (char)v90);
                  v87 = 2;
                }
                else
                {
                  *(_BYTE *)(v53 + v52 + 69) = 48;
                  v87 = 2;
                }
              }
              else
              {
                *(_BYTE *)(*(_WORD *)(v52 + 240) + v52 + 69) = *(&byte_100D7370[(v93 << 6) - v50] + *(_WORD *)(v52 + 240));
                v87 = 2;
              }
            }
            else
            {
              sub_1005ECE0(a1, v50, v91, (int)v90);
              v87 = 2;
            }
          }
        }
        else
        {
          v87 = 2;
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) = (*(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) == -108) - 108;
        }
        goto LABEL_127;
      }
      v21 = v20 - 32;
      if ( !v21 )
        goto LABEL_34;
      v22 = v21 - 1;
      if ( v22 )
      {
        if ( v22 != 7 )
          return v87;
LABEL_34:
        v23 = v92;
        v24 = v91;
        *(_WORD *)(v17 + 240) = -128;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
        sub_1005FDE0(v90, (int)v23, a1, v24);
        return 6;
      }
      *(_WORD *)(v17 + 240) = -128;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
      sub_1006FBE0((int)v96, (_BYTE *)(*(_DWORD *)(a1 + 56) + 69), 21);
      v25 = v94;
      if ( (unsigned int)v94 >= 0x14 )
        v25 = 20;
      v96[v25] = 0;
      v26 = *(_WORD *)(a2 + 8) & 0x3F;
      BYTE3(v89) = 0;
      if ( v26 != 50 && v26 != 51 )
      {
        v27 = v88;
        BYTE2(v89) = 0;
        v29 = j__atol(&v96[v88]);
      }
      else
      {
        v27 = v88;
        BYTE2(v89) = j__atol(&v96[v88]);
        v29 = 0;
      }
      v30 = *(_WORD *)(a2 + 8) & 0x3F;
      LOWORD(v89) = v29;
      if ( v30 != 49
        && v30 != 48
        && v30 != 47
        && v30 != 50
        && v30 != 51
        && v30 != 46
        && v30 != 56
        && v30 != 53
        && sub_100702F0(v28) == 1 )
      {
        if ( !v29 )
        {
          v29 = 12;
LABEL_54:
          LOWORD(v89) = v29;
          goto LABEL_55;
        }
        if ( v29 > 12 )
        {
          v29 -= 12;
          goto LABEL_54;
        }
      }
LABEL_55:
      v31 = v27 + 3;
      if ( word_100D739C[32 * v93] <= 99 )
        v31 = v27 + 2;
      v32 = v94;
      if ( v31 < v94 )
      {
        while ( 1 )
        {
          v33 = v96[v31];
          if ( (unsigned __int8)v33 >= 0x30u && (unsigned __int8)v33 <= 0x39u )
            break;
          if ( ++v31 >= v94 )
            goto LABEL_67;
        }
        if ( v31 < v94 )
        {
          v34 = *(_WORD *)(v91 + 8) & 0x3F;
          if ( v34 != 50 && v34 != 51 )
            BYTE2(v89) = j__atol(&v96[v31]);
          else
            BYTE3(v89) = j__atol(&v96[v31]);
        }
      }
LABEL_67:
      v35 = v31 + 2;
      if ( v35 < v32 )
      {
        while ( 1 )
        {
          v36 = v96[v35];
          if ( (unsigned __int8)v36 >= 0x30u && (unsigned __int8)v36 <= 0x39u )
            break;
          if ( ++v35 >= v32 )
            goto LABEL_74;
        }
        if ( v35 < v32 )
          BYTE3(v89) = j__atol(&v96[v35]);
      }
LABEL_74:
      if ( sub_100702F0(v28) == 1 )
      {
        v37 = *(_WORD *)(v91 + 8) & 0x3F;
        if ( v37 == 52 || v37 == 54 )
        {
          v38 = *(_DWORD *)(a1 + 56);
          v39 = *(_BYTE *)(v38 + 90);
          *(_BYTE *)(v38 + 90) = -108;
          if ( v29 )
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) = v39;
          v40 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90);
          if ( v40 == -107 && v29 < 12 )
          {
            v29 += 12;
            LOWORD(v89) = v29;
          }
          if ( v40 == -108 && v29 == 12 )
            LOWORD(v89) = 0;
        }
      }
      sub_10075C80(&v95, v89);
      v41 = v95;
      v42 = v90;
      *v90 = v95;
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 69) == 45 )
        *v42 = -v41;
      sub_1005FDE0(v42, (int)v92, a1, v91);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v80 = *(_DWORD *)(a1 + 56), *(_WORD *)(v80 + 240) != -128) )
      {
        if ( v6 < 0 )
          v89 = -v6;
        v57 = v91;
        sub_1005EC80(v91, (int)&v89, v89);
        v58 = *(_WORD *)(v57 + 8) & 0x3F;
        LOBYTE(v88) = 31;
        if ( v58 != 52 && v58 != 54 )
        {
LABEL_192:
          if ( v58 == 56 )
            LOBYTE(v88) = 38;
        }
        else
        {
          v59 = *(_BYTE *)(v80 + 90);
LABEL_187:
          if ( v59 == -108 )
          {
            LOBYTE(v88) = 35;
          }
          else if ( v59 == -107 )
          {
            LOBYTE(v88) = 36;
          }
          else
          {
            sub_1005EC10((signed __int16 *)&v89, &v88);
          }
        }
        sprintf(v96, (const char *)(*(_DWORD *)(a1 + 56) + 69));
        v81 = v92;
        *(_WORD *)(a1 + 438) = *(_WORD *)v92;
        v82 = v88;
        *(_WORD *)(a1 + 436) = *((_WORD *)v81 + 1);
        v83 = sub_100793A0(v82);
        v84 = sub_1005EDA0(*(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
        v85 = *(_WORD *)(v57 + 10) - v84;
        if ( v84 > 0 )
          v85 -= *(_WORD *)(dword_1068B4C4[5 * ((*(_DWORD *)(v57 + 4) >> 10) & 0xF)] + 28);
        if ( !*(_WORD *)(v57 + 10) )
          v85 = sub_1005EBB0(*(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
        sub_1006DCF0(a1, v96, v83, v85, v84, *(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
      }
      else
      {
        sub_1005FDE0(v90, (int)v92, a1, v91);
      }
      return v87;
    default:
      return v87;
  }
}
// 100D739C: using guessed type __int16 word_100D739C[];
// 1068B4C4: using guessed type int dword_1068B4C4[];
// 1005FEA0: using guessed type char var_1C[24];

//----- (100609A0) --------------------------------------------------------
char __usercall sub_100609A0@<al>(signed int *a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  signed int v3; // eax@1
  signed int v4; // ecx@1
  const char *v5; // eax@3

  v3 = *a1;
  v4 = 0;
  if ( v3 < 0x7FFFFFFF )
    v4 = v3;
  v5 = "%+0*d";
  if ( !(*(_BYTE *)(a3 + 8) & 0x40) )
    v5 = "%0*d";
  sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), v5, *(_BYTE *)(a3 + 10), v4);
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = (char)(*(_BYTE *)(a3 + 10) - 1);
  return 4;
}

//----- (100609F0) --------------------------------------------------------
char __cdecl sub_100609F0(int a1)
{
  int v1; // ecx@0
  __int16 v2; // ax@1
  int v4; // [sp+0h] [bp-18h]@0
  char v5; // [sp+4h] [bp-14h]@1
  int v6; // [sp+8h] [bp-10h]@1
  __int16 v7; // [sp+Ch] [bp-Ch]@1
  char v8; // [sp+Eh] [bp-Ah]@1
  char v9; // [sp+Fh] [bp-9h]@1
  __int16 v10; // [sp+10h] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_WORD *)(a1 + 8);
  v2 = *(_WORD *)(a1 + 12);
  v8 = *(_BYTE *)(a1 + 10);
  v9 = 0;
  v10 = v2;
  return sub_10063F20(v1, (int)&v5, v4);
}

//----- (10060A50) --------------------------------------------------------
char __usercall sub_10060A50@<al>(float *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  return sub_10063FF0(a4, a2, a3, a1);
}

//----- (10060A70) --------------------------------------------------------
char __usercall sub_10060A70@<al>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // esi@1
  bool v4; // zf@1
  int v5; // edi@1
  char result; // al@1
  signed int v7; // ebp@1
  int v8; // ecx@4
  unsigned __int16 v9; // cx@8
  int v10; // ecx@10
  __int16 v11; // ax@10
  char v12; // al@13
  __int32 v13; // eax@19
  int v14; // eax@25
  int v15; // edx@30
  int v16; // edx@47
  int v17; // ecx@48
  int v18; // ecx@50
  char *v19; // [sp+Ch] [bp-8h]@1
  int v20; // [sp+10h] [bp-4h]@1

  v3 = a1;
  v4 = (*(_BYTE *)(a1 + 8) & 0x40) == 0;
  v5 = a2;
  result = 1;
  v7 = 1;
  v20 = 0;
  v19 = "%+0*d";
  if ( v4 )
    v19 = "%0*d";
  if ( *(_WORD *)(a3 + 10) == 84 )
  {
    v8 = *(_DWORD *)(a2 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 || *(_BYTE *)(v8 + 69) != 45 )
      *(_WORD *)(a3 + 14) = 45;
    else
      *(_WORD *)(a3 + 14) = 43;
  }
  v9 = *(_WORD *)(a3 + 14);
  if ( v9 < 0x30u || v9 > 0x39u )
  {
    if ( v9 == 43 || v9 == 45 )
    {
      v15 = *(_DWORD *)(v3 + 16);
      if ( v15 < 0 && (v9 == 45 || v15 < 0 && *(_DWORD *)(v3 + 20) > 0 && v9 == 43) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
          sub_100609A0(&v20, v5, v3);
        if ( *(_WORD *)(a3 + 14) == 45 && j__atol((const char *)(*(_DWORD *)(v5 + 56) + 69)) >= 0
          || *(_WORD *)(a3 + 14) == 43 && j__atol((const char *)(*(_DWORD *)(v5 + 56) + 69)) <= 0 )
        {
          if ( *(_BYTE *)(v3 + 8) & 0x40 )
          {
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
          }
          else if ( *(_WORD *)(a3 + 14) == 45 )
          {
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 45;
          }
          else
          {
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 48;
          }
        }
        result = 2;
      }
      v16 = *(_DWORD *)(v5 + 56);
      if ( !*(_WORD *)(v16 + 240) )
      {
        v17 = *(_DWORD *)(v5 + 56);
        if ( *(_BYTE *)(*(_WORD *)(v16 + 240) + v17 + 69) == 43 || *(_BYTE *)(*(_WORD *)(v17 + 240) + v17 + 69) == 45 )
        {
          ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
          v18 = *(_BYTE *)(v3 + 10) - 1;
          if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) < v18 )
            LOWORD(v18) = *(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
          *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)v18;
        }
      }
    }
  }
  else
  {
    v10 = *(_DWORD *)(v5 + 56);
    v11 = *(_WORD *)(v10 + 240);
    if ( v11 == -128 )
    {
      sub_100609A0(&v20, v5, v3);
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
      result = 2;
    }
    else if ( v11 == (char)(*(_BYTE *)(v3 + 10) - 1) )
    {
      v12 = *(_BYTE *)(v10 + 69);
      if ( v12 == 48 || (v12 == 43 || v12 == 45) && *(_BYTE *)(v10 + 70) == 48 )
      {
        if ( v12 == 45 )
        {
          *(_BYTE *)(v10 + 69) = 48;
          v7 = -1;
        }
        v13 = j__atol((const char *)(*(_DWORD *)(v5 + 56) + 69));
        sprintf((char *)(*(_DWORD *)(v5 + 56) + 69), v19, *(_BYTE *)(v3 + 10), 10 * v13);
        if ( v7 == -1 )
          *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 45;
      }
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
      result = 2;
    }
    else
    {
      if ( *(_BYTE *)(v3 + 8) & 0x40 && !v11 )
        *(_WORD *)(v10 + 240) = 1;
      *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v5 + 56) + 240))++ + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
      v14 = *(_BYTE *)(v3 + 10) - 1;
      if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) < v14 )
        LOWORD(v14) = *(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)v14;
      result = 2;
    }
  }
  return result;
}

//----- (10060D00) --------------------------------------------------------
char __cdecl sub_10060D00(int a1, int a2, int a3, float *a4, int a5)
{
  int v5; // ebp@1
  char v6; // bl@1
  char result; // al@6
  signed int v8; // ecx@7
  int v9; // ecx@9
  int v10; // ecx@10
  __int16 v11; // si@12
  int v12; // edx@13
  int v13; // edx@13
  int v14; // ecx@15
  int v15; // eax@15
  int v16; // eax@18
  int v17; // esi@25
  int v18; // eax@26
  float *v19; // esi@27
  signed int v20; // ecx@27
  int v21; // edi@27
  int v22; // edx@27
  int v23; // ebx@29
  int v24; // eax@32
  int v25; // edx@32
  int v26; // edx@34
  float v27; // eax@38
  int v28; // eax@43
  int v29; // esi@45
  int v30; // edx@48
  int v31; // eax@48
  __int32 v32; // eax@51
  int v33; // eax@54
  signed int v34; // eax@59
  char v35; // al@66
  char *v36; // [sp+18h] [bp+8h]@1

  v5 = a2;
  v6 = 1;
  v36 = sub_100793B0(*(_WORD *)(a2 + 8), 0);
  if ( *(_WORD *)a5 == 32802 )
    goto LABEL_4;
  if ( *(_WORD *)a5 != 32840 )
  {
    if ( *(_WORD *)a5 == 32888 )
    {
LABEL_4:
      if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128 )
      {
        sub_100609F0(v5);
        return 1;
      }
      sub_10060A50(a4, v5, a3, a1);
    }
    return v6;
  }
  v8 = *(_WORD *)(a5 + 10);
  if ( v8 > 57 )
  {
    if ( v8 == 84 || v8 == 0x2000 )
    {
      v35 = sub_10060A70(v5, a1, a5);
      v6 = v35;
      if ( v35 == 3 )
      {
        sub_10060A50(a4, v5, a3, a1);
        return v6;
      }
      if ( v35 == 2 )
      {
        sub_100609F0(v5);
        return 2;
      }
    }
    return v6;
  }
  if ( v8 == 57 )
    goto LABEL_74;
  v9 = v8 - 32;
  if ( !v9 )
  {
    v28 = *(_DWORD *)(a1 + 56);
    if ( *(_WORD *)(v28 + 240) != -128 )
    {
      *(_WORD *)(v28 + 240) = -128;
      sub_10060A50(a4, v5, a3, a1);
      return 3;
    }
    return v6;
  }
  v10 = v9 - 1;
  if ( v10 )
  {
    if ( v10 != 23 )
      return v6;
    v11 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
    if ( v11 == -128 )
    {
      v18 = *(_BYTE *)(a5 + 8);
      if ( *(_BYTE *)(v5 + 26) )
      {
        v19 = a4;
        v20 = *(_DWORD *)a4;
        v21 = v18 * *(_WORD *)(v5 + 24) + *(_DWORD *)a4;
        v22 = *(_DWORD *)(v5 + 20);
        if ( v21 <= v22 )
        {
          v23 = *(_DWORD *)(v5 + 16);
          if ( v21 >= v23 )
            *(_DWORD *)a4 = v21;
          else
            *(_DWORD *)a4 = v20 + v22 + *(_WORD *)(v5 + 24) * (v18 + 1) - v23;
        }
        else
        {
          *(_DWORD *)a4 = v20 + *(_DWORD *)(v5 + 16) + *(_WORD *)(v5 + 24) * (v18 - 1) - v22;
        }
      }
      else
      {
        v24 = *(_DWORD *)a4 + *(_WORD *)(v5 + 24) * v18;
        v25 = *(_DWORD *)(v5 + 20);
        if ( v24 <= v25 )
        {
          v26 = *(_DWORD *)(v5 + 16);
          if ( v24 >= v26 )
            *(_DWORD *)a4 = v24;
          else
            *(_DWORD *)a4 = v26;
        }
        else
        {
          *(_DWORD *)a4 = v25;
        }
        v19 = a4;
      }
      v27 = *v19;
      if ( *(_DWORD *)(v5 + 16) > *(_DWORD *)v19 )
        v27 = *(float *)(v5 + 16);
      *v19 = v27;
      if ( *(_DWORD *)(v5 + 20) < SLODWORD(v27) )
        v27 = *(float *)(v5 + 20);
      *v19 = v27;
      *(_DWORD *)v19 = sub_100A7330(SLODWORD(v27), *(_WORD *)(v5 + 24));
      sub_10060A50(v19, v5, a3, a1);
      result = 3;
    }
    else
    {
      v12 = *(_BYTE *)(a5 + 8) < 0;
      LOBYTE(v12) = *(_BYTE *)(a5 + 8) >= 0;
      v13 = 2 * v12 - 1;
      if ( !(*(_BYTE *)(v5 + 8) & 0x40) || v11 )
      {
        v16 = *(_DWORD *)(a1 + 56);
        if ( (*(_BYTE *)(*(_WORD *)(v16 + 240) + v16 + 69) != 48 || v13 >= 0)
          && (*(_BYTE *)(*(_WORD *)(v16 + 240) + v16 + 69) != 57 || v13 <= 0)
          || v11
          || *(_DWORD *)(v5 + 16) >= 0 )
        {
          v17 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v17 + 240) + v17 + 69) = sub_10071500(
                                                           *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240)
                                                                    + *(_DWORD *)(a1 + 56)
                                                                    + 69),
                                                           0x10u,
                                                           v13);
          sub_100609F0(v5);
          result = 2;
        }
        else
        {
          *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
          sub_100609F0(v5);
          result = 2;
        }
      }
      else
      {
        v14 = *(_DWORD *)(a1 + 56);
        v15 = *(_WORD *)(v14 + 240);
        if ( *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) == 45 )
        {
          *(_BYTE *)(v15 + v14 + 69) = 43;
          sub_100609F0(v5);
          result = 2;
        }
        else
        {
          *(_BYTE *)(v15 + v14 + 69) = 45;
          sub_100609F0(v5);
          result = 2;
        }
      }
    }
  }
  else
  {
LABEL_74:
    v29 = *(_DWORD *)(a1 + 56);
    if ( *(_WORD *)(v29 + 240) == -128 )
      return v6;
    if ( *(_WORD *)(a5 + 10) != 57 || *(_BYTE *)(v5 + 10) <= 1u )
    {
      *(_WORD *)(v29 + 240) = -128;
      v32 = j__atol((const char *)(*(_DWORD *)(a1 + 56) + 69));
      *(_DWORD *)a4 = v32;
      if ( !memcmp(v36, "", 2u) && !v32 || v32 == 360 )
      {
        v33 = *(_DWORD *)(v5 + 16);
        if ( *(_DWORD *)(v5 + 20) - v33 == 359 )
        {
          if ( !v33 )
            *(_DWORD *)a4 = 0;
          if ( *(_DWORD *)(v5 + 20) == 360 )
            *(_DWORD *)a4 = 360;
        }
      }
      v34 = *(_DWORD *)a4;
      if ( *(_DWORD *)(v5 + 16) > *(_DWORD *)a4 )
        v34 = *(_DWORD *)(v5 + 16);
      *(_DWORD *)a4 = v34;
      if ( *(_DWORD *)(v5 + 20) < v34 )
        v34 = *(_DWORD *)(v5 + 20);
      *(_DWORD *)a4 = v34;
      *(_DWORD *)a4 = sub_100A7330(v34, *(_WORD *)(v5 + 24));
      sub_10060A50(a4, v5, a3, a1);
      result = 3;
    }
    else
    {
      *(_WORD *)(v29 + 240) += *(_BYTE *)(a5 + 8);
      v30 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)(v30 <= 0 ? 0 : v30);
      v31 = *(_BYTE *)(v5 + 10) - 1;
      if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v31 )
        LOWORD(v31) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)v31;
      sub_100609F0(v5);
      result = 2;
    }
  }
  return result;
}

//----- (10061190) --------------------------------------------------------
double __cdecl sub_10061190(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 >= (double)a1 )
    result = a2;
  return result;
}

//----- (100611B0) --------------------------------------------------------
double __cdecl sub_100611B0(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 <= (double)a1 )
    result = a2;
  return result;
}

//----- (100611D0) --------------------------------------------------------
signed int __fastcall sub_100611D0(int a1)
{
  signed int result; // eax@1

  result = 1;
  if ( a1 > 0 )
  {
    do
    {
      result *= 10;
      --a1;
    }
    while ( a1 );
  }
  return result;
}

//----- (100611F0) --------------------------------------------------------
char __usercall sub_100611F0@<al>(int a1@<eax>, float *a2@<edi>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  const char *v5; // eax@7
  int v6; // eax@9
  char result; // al@10
  int v8; // [sp+14h] [bp+4h]@1

  v3 = a3;
  *(float *)&v8 = 0.0;
  v4 = a1;
  if ( *a2 < 1.0e25 && *a2 > -1.0e25 && 9.8999998e24 != *a2 )
    v8 = *(int *)a2;
  if ( (*(_WORD *)(a1 + 8) & 0x3F) != 16 )
    *(float *)&v8 = sub_10079840(v8, *(_WORD *)(a1 + 8));
  v5 = "%+0*.*f";
  if ( !(*(_BYTE *)(v4 + 8) & 0x40) )
    v5 = "%0*.*f";
  sprintf((char *)(*(_DWORD *)(v3 + 56) + 69), v5, *(_BYTE *)(v4 + 10), *(_BYTE *)(v4 + 11), v8);
  v6 = *(_DWORD *)(v3 + 56);
  if ( *(_BYTE *)(v4 + 11) )
  {
    *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = (char)(strlen((const char *)(v6 + 69))
                                                  - strlen(strchr((const char *)(v6 + 69), 46)))
                                           - 1;
    result = 4;
  }
  else
  {
    *(_WORD *)(v6 + 240) = (char)(*(_BYTE *)(v4 + 10) - 1);
    result = 4;
  }
  return result;
}

//----- (10061300) --------------------------------------------------------
char __cdecl sub_10061300(int a1)
{
  int v1; // ecx@0
  __int16 v2; // ax@1
  int v4; // [sp+0h] [bp-18h]@0
  char v5; // [sp+4h] [bp-14h]@1
  int v6; // [sp+8h] [bp-10h]@1
  __int16 v7; // [sp+Ch] [bp-Ch]@1
  char v8; // [sp+Eh] [bp-Ah]@1
  char v9; // [sp+Fh] [bp-9h]@1
  __int16 v10; // [sp+10h] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_WORD *)(a1 + 8) | 0x100;
  v8 = *(_BYTE *)(a1 + 10);
  v2 = *(_WORD *)(a1 + 12);
  v9 = *(_BYTE *)(a1 + 11);
  v10 = v2;
  return sub_10063F20(v1, (int)&v5, v4);
}

//----- (10061360) --------------------------------------------------------
char __usercall sub_10061360@<al>(int a1@<ecx>, float *a2@<edi>, int a3@<esi>, int a4)
{
  int v4; // edx@1
  __int16 v5; // ax@1
  double v7; // [sp+0h] [bp-1Ch]@1
  int v8; // [sp+8h] [bp-14h]@1
  int v9; // [sp+Ch] [bp-10h]@1
  __int16 v10; // [sp+10h] [bp-Ch]@1
  char v11; // [sp+12h] [bp-Ah]@1
  char v12; // [sp+13h] [bp-9h]@1
  __int16 v13; // [sp+14h] [bp-8h]@1

  v4 = *(_DWORD *)(a4 + 4);
  v7 = *a2;
  v9 = v4;
  v10 = *(_WORD *)(a4 + 8);
  v11 = *(_BYTE *)(a4 + 10);
  v5 = *(_WORD *)(a4 + 12);
  v12 = *(_BYTE *)(a4 + 11);
  v13 = v5;
  v8 = 89;
  return sub_10069E80(a1, (int)&v8, a3, &v7);
}

//----- (100613D0) --------------------------------------------------------
int __cdecl sub_100613D0(float a1)
{
  int v1; // ecx@0
  double v2; // ST04_8@1

  v2 = (double)sub_100611D0(v1) * a1;
  return (signed int)((double)sub_100A73F0(a1) * 0.5 + v2);
}

//----- (10061410) --------------------------------------------------------
char __usercall sub_10061410@<al>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ebp@1
  int v5; // esi@1
  int v6; // eax@4
  unsigned __int16 v7; // cx@8
  int v8; // ecx@10
  __int16 v9; // di@10
  bool v11; // zf@12
  const char *v12; // ecx@13
  char v13; // kr00_1@13
  char *v14; // eax@13
  char v15; // dl@13
  char v16; // cl@14
  char v17; // al@19
  bool v18; // sf@25
  char *v19; // eax@26
  int v20; // edi@26
  char v21; // dl@27
  char v22; // bl@28
  char *v23; // eax@28
  char v24; // dl@28
  char v25; // cl@29
  double v26; // st7@30
  int v27; // edx@34
  unsigned __int8 v28; // al@34
  const char *v29; // ecx@34
  char *v30; // eax@38
  char v31; // di@38
  char v32; // dl@39
  int v33; // edx@44
  int v34; // eax@44
  int v35; // ecx@67
  int v36; // edx@70
  int v37; // eax@70
  const char *v38; // ecx@77
  char *v39; // eax@77
  int v40; // edi@77
  char v41; // dl@78
  float v42; // [sp+18h] [bp-Ch]@1
  char *v43; // [sp+1Ch] [bp-8h]@1
  int v44; // [sp+20h] [bp-4h]@1
  char v45; // [sp+28h] [bp+4h]@1
  __int32 v46; // [sp+28h] [bp+4h]@25
  float v47; // [sp+28h] [bp+4h]@30

  v3 = a3;
  v42 = 0.0;
  v4 = a2;
  v11 = (*(_BYTE *)(a2 + 8) & 0x40) == 0;
  v5 = a1;
  v45 = 1;
  v44 = 1;
  v43 = "%+0*.*f";
  if ( v11 )
    v43 = "%0*.*f";
  if ( *(_WORD *)(a3 + 10) == 84 )
  {
    v6 = *(_DWORD *)(a1 + 56);
    if ( *(_WORD *)(v6 + 240) == -128 || *(_BYTE *)(v6 + 69) != 45 )
      *(_WORD *)(a3 + 14) = 45;
    else
      *(_WORD *)(a3 + 14) = 43;
  }
  v7 = *(_WORD *)(a3 + 14);
  if ( v7 >= 0x30u && v7 <= 0x39u )
  {
    v8 = *(_DWORD *)(v5 + 56);
    v9 = *(_WORD *)(v8 + 240);
    if ( v9 == -128 )
    {
      sub_100611F0(v4, &v42, v5);
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
      return 2;
    }
    v11 = *(_BYTE *)(v4 + 11) == 0;
    if ( *(_BYTE *)(v4 + 11) > 0 )
    {
      v12 = (const char *)(v8 + 69);
      v13 = strlen(v12);
      v14 = strchr(v12, 46);
      v15 = (_BYTE)v14 + 1;
      do
        v16 = *v14++;
      while ( v16 );
      v8 = *(_DWORD *)(v5 + 56);
      v9 = *(_WORD *)(v8 + 240);
      v3 = a3;
      if ( *(_WORD *)(v8 + 240) == (char)(v13 - ((_BYTE)v14 - v15)) - 1 )
        goto LABEL_19;
      v11 = *(_BYTE *)(v4 + 11) == 0;
    }
    if ( !v11 || v9 != (char)(*(_BYTE *)(v4 + 10) - 1) )
    {
      if ( *(_BYTE *)(v4 + 8) & 0x40 && !v9 )
        *(_WORD *)(v8 + 240) = 1;
      *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v5 + 56) + 240))++ + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(v3 + 14);
      v33 = *(_DWORD *)(v5 + 56);
      v34 = *(_BYTE *)(v4 + 10) - 1;
      if ( *(_WORD *)(v33 + 240) < v34 )
        LOWORD(v34) = *(_WORD *)(v33 + 240);
      *(_WORD *)(v33 + 240) = (char)v34;
      return 2;
    }
LABEL_19:
    v17 = *(_BYTE *)(v8 + 69);
    if ( v17 == 48 || (v17 == 43 || v17 == 45) && *(_BYTE *)(v8 + 70) == 48 )
    {
      if ( v17 == 45 )
      {
        *(_BYTE *)(v8 + 69) = 48;
        v44 = -1;
      }
      v46 = j__atol((const char *)(*(_DWORD *)(v5 + 56) + 69));
      v11 = *(_BYTE *)(v4 + 11) == 0;
      v18 = *(_BYTE *)(v4 + 11) < 0;
      v42 = (double)v46 * 10.0;
      if ( !v18 && !v11 )
      {
        v19 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        v20 = *(_DWORD *)(v5 + 56) + 70;
        do
          v21 = *v19++;
        while ( v21 );
        v22 = (_BYTE)v19 - v20;
        v23 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 46);
        v24 = (_BYTE)v23 + 1;
        do
          v25 = *v23++;
        while ( v25 );
        v26 = atof((const char *)((char)(v22 - ((_BYTE)v23 - v24)) + *(_DWORD *)(v5 + 56) + 69));
        v3 = a3;
        v47 = v26;
        v42 = v47 + v42;
      }
      sprintf((char *)(*(_DWORD *)(v5 + 56) + 69), v43, *(_BYTE *)(v4 + 10), *(_BYTE *)(v4 + 11), v42);
      if ( v44 == -1 )
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 45;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(v3 + 14);
    if ( *(_BYTE *)(v4 + 11) > 0 )
    {
      v27 = *(_DWORD *)(v5 + 56);
      v28 = *(_BYTE *)(v27 + 69);
      v29 = (const char *)(v27 + 69);
      if ( v28 > 0x30u || (v28 == 43 || v28 == 45) && *(_BYTE *)(v27 + 70) != 48 )
      {
        v30 = (char *)(v27 + 69);
        v31 = v27 + 70;
        do
          v32 = *v30++;
        while ( v32 );
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)((_BYTE)v30 - v31 - strlen(strchr(v29, 46))) + 1;
        return 2;
      }
    }
    return 2;
  }
  if ( v7 != 43 && v7 != 45 )
  {
    if ( v7 == 46 && *(_BYTE *)(v4 + 11) > 0 )
    {
      if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
        sub_100611F0(v4, &v42, v5);
      v38 = (const char *)(*(_DWORD *)(v5 + 56) + 69);
      v39 = (char *)(*(_DWORD *)(v5 + 56) + 69);
      v40 = *(_DWORD *)(v5 + 56) + 70;
      do
        v41 = *v39++;
      while ( v41 );
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)((_BYTE)v39 - v40 - strlen(strchr(v38, 46))) + 1;
    }
    return v45;
  }
  if ( *(float *)(v4 + 16) < 0.0 && v7 == 45 || *(float *)(v4 + 16) < 0.0 && *(float *)(v4 + 20) > 0.0 && v7 == 43 )
  {
    if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
      sub_100611F0(v4, &v42, v5);
    if ( *(_WORD *)(a3 + 14) == 45 && atof((const char *)(*(_DWORD *)(v5 + 56) + 69)) >= 0.0
      || *(_WORD *)(a3 + 14) == 43 && atof((const char *)(*(_DWORD *)(v5 + 56) + 69)) <= 0.0 )
    {
      if ( *(_BYTE *)(v4 + 8) & 0x40 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
        v45 = 2;
        goto LABEL_67;
      }
      if ( *(_WORD *)(a3 + 14) == 45 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 45;
        v45 = 2;
        goto LABEL_67;
      }
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 48;
    }
    v45 = 2;
  }
LABEL_67:
  v35 = *(_DWORD *)(v5 + 56);
  if ( *(_WORD *)(v35 + 240)
    || *(_BYTE *)(*(_WORD *)(v35 + 240) + v35 + 69) != 43
    && *(_BYTE *)(*(_WORD *)(v35 + 240) + *(_DWORD *)(v5 + 56) + 69) != 45 )
  {
    return v45;
  }
  ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
  v36 = *(_DWORD *)(v5 + 56);
  v37 = *(_BYTE *)(v4 + 10) - 1;
  if ( *(_WORD *)(v36 + 240) < v37 )
    LOWORD(v37) = *(_WORD *)(v36 + 240);
  *(_WORD *)(v36 + 240) = (char)v37;
  return v45;
}

//----- (100618E0) --------------------------------------------------------
char __cdecl sub_100618E0(int a1, int a2, int *a3, float *a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  int v7; // edi@1
  int v8; // ebp@1
  char result; // al@8
  float *v10; // edi@9
  signed int v11; // eax@9
  int v12; // eax@11
  int v13; // eax@12
  int v14; // ebp@14
  int v15; // eax@14
  __int16 v16; // cx@14
  double v17; // st7@16
  double v18; // st7@23
  int v19; // ebx@30
  int v20; // ecx@31
  int v21; // eax@31
  int v22; // ecx@31
  int v23; // eax@31
  int v24; // ecx@31
  int v25; // ebx@31
  int v26; // eax@31
  int v27; // ecx@31
  int v28; // eax@31
  double v29; // st7@34
  float v30; // ST0C_4@43
  double v31; // st7@43
  int v32; // ST08_4@44
  int v33; // ecx@44
  int v34; // eax@45
  int v35; // eax@47
  int v36; // edx@50
  int v37; // eax@50
  int v38; // eax@52
  float v39; // ST0C_4@55
  float v40; // [sp+4h] [bp-20h]@43
  float v41; // [sp+18h] [bp-Ch]@1
  float v42; // [sp+1Ch] [bp-8h]@1
  int v43; // [sp+20h] [bp-4h]@31
  char v44; // [sp+2Ch] [bp+8h]@1
  float v45; // [sp+2Ch] [bp+8h]@23
  float v46; // [sp+2Ch] [bp+8h]@31
  float v47; // [sp+2Ch] [bp+8h]@43
  float v48; // [sp+2Ch] [bp+8h]@43
  float v49; // [sp+2Ch] [bp+8h]@55
  float v50; // [sp+2Ch] [bp+8h]@55
  float v51; // [sp+2Ch] [bp+8h]@55
  int v52; // [sp+38h] [bp+14h]@31

  v5 = a2;
  v41 = sub_10079840(COERCE_INT(*(float *)(a2 + 16)), *(_WORD *)(a2 + 8));
  v42 = sub_10079840(COERCE_INT(*(float *)(v5 + 20)), *(_WORD *)(v5 + 8));
  v6 = *(_WORD *)(a2 + 12);
  v7 = 0;
  v44 = 1;
  v8 = v6;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      if ( !v6 )
        v8 = sub_10069E20(*(_DWORD *)(v5 + 4), *(_WORD *)(v5 + 8), *(_BYTE *)(v5 + 10), *(_BYTE *)(v5 + 11));
      if ( ~((unsigned int)*(_WORD *)(v5 + 8) >> 9) & 1 )
      {
        v7 = (signed __int16)sub_1006D690(*(_DWORD *)(v5 + 4), *(_WORD *)(v5 + 8), a4);
        if ( (*(_DWORD *)(v5 + 4) & 0xC000) != 0x4000 )
        {
          v8 -= v7;
          if ( v7 > 0 )
            v8 -= *(_WORD *)(dword_1068B4C4[5 * ((*(_DWORD *)(v5 + 4) >> 10) & 0xF)] + 28);
        }
      }
      sub_1006DB90(a1 + 276, *a3, *(_DWORD *)(v5 + 4), v8 + v7);
      return 2;
    case 0x8048:
      v10 = a4;
      v11 = *(_WORD *)(a5 + 10);
      if ( v11 > 57 )
      {
        if ( v11 != 84 && v11 != 0x2000 )
          return v44;
        v44 = sub_10061410(a1, v5, a5);
        if ( v44 != 3 )
        {
          if ( v44 == 2 )
          {
            sub_10061300(v5);
            return 2;
          }
          return v44;
        }
        v33 = a1;
        goto LABEL_66;
      }
      if ( v11 == 57 )
        goto LABEL_47;
      v12 = v11 - 32;
      if ( !v12 )
      {
        v34 = *(_DWORD *)(a1 + 56);
        if ( *(_WORD *)(v34 + 240) == -128 )
          return v44;
        *(_WORD *)(v34 + 240) = -128;
        v44 = 3;
        v33 = a1;
LABEL_66:
        sub_10061360(v33, v10, (int)a3, v5);
        return v44;
      }
      v13 = v12 - 1;
      if ( v13 )
      {
        if ( v13 != 23 )
          return v44;
        v14 = a1;
        v15 = *(_DWORD *)(a1 + 56);
        v16 = *(_WORD *)(v15 + 240);
        if ( v16 != -128 )
        {
          if ( *(_BYTE *)(a5 + 8) >= 0 )
            v17 = 1.0;
          else
            v17 = -1.0;
          if ( !(*(_BYTE *)(v5 + 8) & 0x40) || v16 )
          {
            v45 = v17;
            v18 = v45;
            if ( (*(_BYTE *)(*(_WORD *)(v15 + 240) + v15 + 69) != 48 || v18 >= 0.0)
              && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) != 57 || v18 <= 0.0)
              || v16
              || *(float *)(v5 + 16) >= 0.0 )
            {
              v19 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v19 + 240) + v19 + 69) = sub_10071500(
                                                               *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240)
                                                                        + *(_DWORD *)(a1 + 56)
                                                                        + 69),
                                                               0x10u,
                                                               (signed int)v18);
              sub_10061300(v5);
              result = 2;
            }
            else
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
              sub_10061300(v5);
              result = 2;
            }
          }
          else if ( *(_BYTE *)(*(_WORD *)(v15 + 240) + v15 + 69) == 45 )
          {
            *(_BYTE *)(*(_WORD *)(v15 + 240) + v15 + 69) = 43;
            sub_10061300(v5);
            result = 2;
          }
          else
          {
            *(_BYTE *)(*(_WORD *)(v15 + 240) + v15 + 69) = 45;
            sub_10061300(v5);
            result = 2;
          }
          return result;
        }
        *a4 = sub_10079840(COERCE_INT(*a4), *(_WORD *)(v5 + 8));
        v20 = *(_BYTE *)(v5 + 11);
        v46 = (double)*(_BYTE *)(a5 + 8) * *(float *)(v5 + 24);
        v21 = sub_100613D0(v46);
        v22 = *(_BYTE *)(v5 + 11);
        v52 = v21;
        v23 = sub_100613D0(*a4);
        v24 = *(_BYTE *)(v5 + 11);
        v25 = v23;
        v26 = sub_100613D0(v42);
        v27 = *(_BYTE *)(v5 + 11);
        v43 = v26;
        v28 = sub_100613D0(v41);
        if ( *(_BYTE *)(v5 + 28) )
        {
          if ( v25 + v52 > v43 )
          {
            if ( v25 != v43 )
            {
              v29 = *a4 + v46 - (v42 - v41);
              goto LABEL_43;
            }
LABEL_34:
            v29 = v41;
LABEL_43:
            *a4 = v29;
            v30 = sub_10061190(v41, *a4);
            v47 = sub_100611B0(v42, v30);
            *a4 = v47;
            v48 = sub_100A7380(v47, *(float *)(v5 + 24));
            v31 = v48;
            *a4 = v48;
            LODWORD(v40) = *(_WORD *)(v5 + 8);
LABEL_44:
            *(float *)&v32 = v31;
            *a4 = sub_10079E70(v32, LODWORD(v40));
            v44 = 3;
            v33 = v14;
            goto LABEL_66;
          }
          if ( v25 + v52 < v28 )
          {
            if ( v25 != v28 )
            {
              v29 = *a4 + v46 + v42 - v41;
              goto LABEL_43;
            }
            goto LABEL_38;
          }
        }
        else
        {
          if ( v25 + v52 > v43 )
          {
LABEL_38:
            v29 = v42;
            goto LABEL_43;
          }
          if ( v25 + v52 < v28 )
            goto LABEL_34;
        }
        v29 = *a4 + v46;
        goto LABEL_43;
      }
LABEL_47:
      v14 = a1;
      v35 = *(_DWORD *)(a1 + 56);
      if ( *(_WORD *)(v35 + 240) == -128 )
        return v44;
      if ( *(_WORD *)(a5 + 10) != 57 || *(_BYTE *)(v5 + 10) <= 1u )
      {
        *(_WORD *)(v35 + 240) = -128;
        v49 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
        v39 = sub_10061190(v41, v49);
        v50 = sub_100611B0(v42, v39);
        *a4 = v50;
        v51 = sub_100A7380(v50, *(float *)(v5 + 24));
        v31 = v51;
        *a4 = v51;
        LODWORD(v40) = *(_WORD *)(v5 + 8);
        goto LABEL_44;
      }
      *(_WORD *)(v35 + 240) += *(_BYTE *)(a5 + 8);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)((signed int)*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) <= 0 ? 0 : *(_WORD *)(*(_DWORD *)(a1 + 56) + 240));
      v36 = *(_DWORD *)(a1 + 56);
      v37 = *(_BYTE *)(v5 + 10) - 1;
      if ( *(_WORD *)(v36 + 240) < v37 )
        LOWORD(v37) = *(_WORD *)(v36 + 240);
      *(_WORD *)(v36 + 240) = (char)v37;
      v38 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(*(_WORD *)(v38 + 240) + v38 + 69) == 46 )
        *(_WORD *)(v38 + 240) += *(_BYTE *)(a5 + 8);
      sub_10061300(v5);
      return 2;
    case 0x8022:
    case 0x8078:
      v33 = a1;
      if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128 )
      {
        sub_10061300(v5);
        return 1;
      }
      v10 = a4;
      goto LABEL_66;
    default:
      return v44;
  }
}
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (10061F30) --------------------------------------------------------
int __usercall sub_10061F30@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // esi@1
  __int16 v5; // di@2
  __int16 v6; // cx@2
  signed __int16 v7; // ax@2
  int v8; // ebp@2
  int v9; // ebx@2
  __int16 v10; // ax@2
  __int16 v11; // cx@2
  int v12; // ebp@2
  signed __int16 v13; // bx@2
  int v14; // eax@2
  signed __int16 v15; // ax@2
  __int16 v16; // dx@4
  __int16 v17; // ax@4
  int v18; // eax@4
  int v19; // ebx@4
  __int16 v20; // ST7C_2@13
  int v21; // edx@13
  int v22; // ST70_4@13
  __int16 v23; // ax@14
  __int16 v24; // ax@17
  int result; // eax@19
  char v26; // [sp+Ah] [bp-72h]@1
  bool v27; // [sp+Bh] [bp-71h]@4
  int v28; // [sp+Ch] [bp-70h]@2
  __int16 v29; // [sp+Ch] [bp-70h]@4
  __int16 v30; // [sp+Ch] [bp-70h]@13
  __int16 v31; // [sp+14h] [bp-68h]@4
  signed __int16 v32; // [sp+18h] [bp-64h]@4
  __int16 v33; // [sp+18h] [bp-64h]@13
  __int16 v34; // [sp+1Ch] [bp-60h]@2
  int v35; // [sp+20h] [bp-5Ch]@2
  __int16 v36; // [sp+24h] [bp-58h]@2
  __int16 v37; // [sp+26h] [bp-56h]@2
  __int16 v38; // [sp+28h] [bp-54h]@2
  __int16 v39; // [sp+2Ah] [bp-52h]@2
  __int16 v40; // [sp+2Ch] [bp-50h]@2
  __int16 v41; // [sp+2Eh] [bp-4Eh]@2
  __int16 v42; // [sp+30h] [bp-4Ch]@2
  __int16 v43; // [sp+32h] [bp-4Ah]@2
  __int16 v44; // [sp+34h] [bp-48h]@2
  __int16 v45; // [sp+36h] [bp-46h]@2
  __int16 v46; // [sp+38h] [bp-44h]@2
  __int16 v47; // [sp+3Ah] [bp-42h]@2
  __int16 v48; // [sp+3Ch] [bp-40h]@2
  __int16 v49; // [sp+3Eh] [bp-3Eh]@2
  __int16 v50; // [sp+40h] [bp-3Ch]@2
  __int16 v51; // [sp+42h] [bp-3Ah]@2
  char v52; // [sp+44h] [bp-38h]@16

  v4 = a3;
  v26 = 0;
  if ( *(_WORD *)a4 <= *(_WORD *)(a4 + 2) )
  {
    *(_WORD *)(a3 + 440) = word_105728D8[15];
    *(_WORD *)(a3 + 442) = word_105728D8[15];
    result = sub_1009F8C0(a3 + 392, *(_WORD *)a1, *(_WORD *)(a1 + 2), *(_WORD *)(a2 + 4), *(_WORD *)(a2 + 6));
  }
  else
  {
    v5 = *(_WORD *)a1;
    v6 = *(_WORD *)(a1 + 2);
    v7 = *(_WORD *)(a2 + 4);
    v34 = v7;
    v8 = *(_WORD *)(a2 + 6);
    v9 = (unsigned __int16)((v7 + 1) / 2);
    v38 = v7 + v5 - 1;
    v10 = v5 + v7 / 2;
    v40 = v10;
    v48 = v10;
    v37 = v9 + v6 - 1;
    v39 = v9 + v6 - 1;
    v43 = v9 + v6 - 1;
    v45 = v6 + v8 - v9;
    v47 = v6 + v8 - v9;
    v51 = v6 + v8 - v9;
    v46 = v38;
    v49 = v6 + v8 - 1;
    v41 = v6;
    v11 = v9 + v6 + 1;
    v12 = -2 - 2 * v9 + v8;
    v13 = *(_WORD *)a4;
    v14 = (signed __int16)v12 - 2;
    v28 = v14;
    v35 = *(_WORD *)(a4 + 2);
    v15 = v35 * v14 / *(_WORD *)a4;
    v36 = v5;
    v42 = v5;
    v44 = v5;
    v50 = v5;
    if ( v15 <= 3 )
      v15 = 3;
    v32 = v15;
    v16 = v12 - v15 + v11 - 1;
    v17 = *(_WORD *)(a4 + 4);
    v31 = v17;
    v29 = (unsigned int)(v28 * v17 / (unsigned __int16)v13) + v11 + 1;
    v18 = v11 + 1;
    v27 = v29 == v18;
    v19 = (unsigned __int16)v13 - v35;
    if ( v31 >= v19 || v29 > v16 )
    {
      v29 = v16;
      v26 = 1;
    }
    if ( v31 >= v19 || v29 != v16 )
    {
      if ( v31 > 0 && v29 == v18 )
      {
        v29 = v11 + 2;
        v27 = 0;
      }
    }
    else
    {
      v29 = v16 - 1;
      v26 = 0;
    }
    v33 = v32 + 2;
    v20 = *(_WORD *)(v4 + 398);
    v21 = *(_DWORD *)(v4 + 452);
    v30 = v29 - 1;
    *(_WORD *)(v4 + 398) = 1;
    *(_DWORD *)(v4 + 452) = &unk_100C42E0;
    v22 = v21;
    *(_WORD *)(v4 + 440) = word_105728D8[15];
    *(_WORD *)(v4 + 442) = word_105728D8[14];
    sub_1009F8C0(v4 + 392, v5, v11, v34, v12);
    *(_WORD *)(v4 + 398) = v20;
    *(_DWORD *)(v4 + 452) = v22;
    if ( v27 )
      v23 = word_105728D8[0];
    else
      v23 = word_105728D8[14];
    *(_WORD *)(v4 + 440) = v23;
    *(_WORD *)(v4 + 442) = v23;
    *(_WORD *)(v4 + 428) = v23;
    *(_WORD *)(v4 + 430) = v23;
    sub_1009F430(v4 + 392, 4, (int)&v36, 0);
    sub_1009ED40(v4 + 392, 3, (int)&v36, 56, (int)&v52);
    if ( v26 )
      v24 = word_105728D8[0];
    else
      v24 = word_105728D8[14];
    *(_WORD *)(v4 + 440) = v24;
    *(_WORD *)(v4 + 442) = v24;
    *(_WORD *)(v4 + 428) = v24;
    *(_WORD *)(v4 + 430) = v24;
    sub_1009F430(v4 + 392, 4, (int)&v44, 0);
    sub_1009ED40(v4 + 392, 3, (int)&v44, 56, (int)&v52);
    *(_WORD *)(v4 + 428) = word_105728D8[0];
    *(_WORD *)(v4 + 430) = word_105728D8[1];
    sub_1009E590(v4 + 392, v5, v30, v34, v33, 2);
    *(_WORD *)(v4 + 428) = word_105728D8[15];
    *(_WORD *)(v4 + 430) = word_105728D8[0];
    *(_WORD *)(v4 + 440) = word_105728D8[14];
    *(_WORD *)(v4 + 442) = word_105728D8[14];
    result = sub_1009E590(v4 + 392, v5 + 1, v30 + 1, v34 - 2, v33 - 2, 3);
  }
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10062310) --------------------------------------------------------
char __cdecl sub_10062310(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    sub_10061F30(a3, a2, a1, a4);
    result = 2;
  }
  return result;
}

//----- (10062350) --------------------------------------------------------
char __usercall sub_10062350@<al>(unsigned __int8 a1@<al>, unsigned __int8 a2, int a3)
{
  char *v3; // eax@1
  char result; // al@3

  v3 = strchr((&off_100D8DE0)[4 * a2], a1);
  if ( a3 == 1 )
  {
    if ( !v3 || (result = v3[1]) == 0 )
      result = *(&off_100D8DE0)[4 * a2];
  }
  else if ( v3 && *v3 != *(&off_100D8DE0)[4 * a2] )
  {
    result = *(v3 - 1);
  }
  else
  {
    result = (&off_100D8DE0)[4 * a2][strlen((&off_100D8DE0)[4 * a2]) - 1];
  }
  return result;
}

//----- (100623D0) --------------------------------------------------------
char *__usercall sub_100623D0@<eax>(int a1@<ecx>, int a2@<esi>, int a3)
{
  int v3; // eax@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = a1;
  strncpy((char *)&v5, (const char *)(*(_WORD *)(*(_DWORD *)(a2 + 56) + 240) + *(_DWORD *)(a2 + 56) + 69), 2u);
  BYTE2(v5) = 0;
  v3 = a3 + (unsigned __int8)j__atol((const char *)&v5);
  if ( v3 <= 18 )
  {
    if ( v3 < 0 )
      v3 = 18;
  }
  else
  {
    v3 = 0;
  }
  sprintf((char *)&v5, "%02u", v3);
  return strncpy((char *)(*(_WORD *)(*(_DWORD *)(a2 + 56) + 240) + *(_DWORD *)(a2 + 56) + 69), (const char *)&v5, 2u);
}

//----- (10062450) --------------------------------------------------------
char __usercall sub_10062450@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // edx@1
  int v5; // ecx@1
  char v6; // bl@1
  int v7; // eax@1
  char v8; // dl@1
  unsigned __int16 v9; // cx@6
  bool v10; // zf@11
  int v11; // ecx@13
  __int16 v12; // cx@19
  char *v13; // eax@20
  int v14; // ecx@26
  int v15; // eax@26
  int v16; // ecx@32
  int v17; // eax@32
  int v18; // eax@37
  int v19; // ecx@37
  __int16 v20; // di@40
  int v21; // ebx@40
  int v22; // ecx@41
  int v23; // eax@47
  int v24; // esi@54
  __int16 v25; // ax@54
  char v27; // [sp+13h] [bp-5h]@1
  char v28; // [sp+14h] [bp-4h]@1
  char v29; // [sp+15h] [bp-3h]@1
  unsigned __int8 v30; // [sp+16h] [bp-2h]@1
  char v31; // [sp+17h] [bp-1h]@1

  v2 = a1;
  v3 = a2;
  v4 = *(_WORD *)(*(_DWORD *)(a2 + 56) + 240);
  v5 = (int)*(&off_100DD5AC + 10 * (unsigned __int8)byte_105728D4);
  v6 = word_100DD5CC[20 * (unsigned __int8)byte_105728D4];
  v7 = 20 * (unsigned __int8)byte_105728D4;
  v30 = *(_BYTE *)(v4 + v5);
  v31 = word_100DD5C8[v7];
  v27 = 1;
  v8 = LOBYTE(word_100DD5CA[v7]) + LOBYTE(word_100DD5CE[v7]) - 1;
  v28 = 0;
  v29 = LOBYTE(word_100DD5CA[v7]) + LOBYTE(word_100DD5CE[v7]) - 1;
  if ( *(_BYTE *)(v5 + v8) == 11 )
  {
    v8 = LOBYTE(word_100DD5CA[v7]) + LOBYTE(word_100DD5CE[v7]) - 2;
    v29 = LOBYTE(word_100DD5CA[v7]) + LOBYTE(word_100DD5CE[v7]) - 2;
  }
  if ( *(_BYTE *)(v2 + 14) == 32 )
    *(_WORD *)(v2 + 14) = 95;
  if ( (unsigned __int8)byte_105728D4 > 1u )
  {
    if ( !strchr((&off_100D8DE0)[4 * v30], *(_BYTE *)(v2 + 14)) )
      return v27;
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240) + *(_DWORD *)(v3 + 56) + 69) = *(_BYTE *)(v2 + 14);
    v8 = v29;
    v27 = 2;
    goto LABEL_47;
  }
  v9 = *(_WORD *)(v2 + 14);
  if ( v9 >= 0x41u && v9 <= 0x5Au || v9 == 32 )
  {
    if ( strchr("NS", *(_BYTE *)(v2 + 14)) && *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) < (signed __int16)v6 )
    {
      *(_BYTE *)(v31 + *(_DWORD *)(v3 + 56) + 69) = *(_BYTE *)(v2 + 14);
      v10 = *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) == v31;
      goto LABEL_15;
    }
    if ( strchr("EW", *(_BYTE *)(v2 + 14)) )
    {
      v11 = *(_DWORD *)(v3 + 56);
      if ( *(_WORD *)(v11 + 240) >= (signed __int16)v6 )
      {
        *(_BYTE *)(v6 + v11 + 69) = *(_BYTE *)(v2 + 14);
        v10 = *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) == v6;
LABEL_15:
        if ( v10 )
          v28 = 1;
        goto LABEL_36;
      }
    }
LABEL_36:
    v8 = v29;
    v27 = 2;
    goto LABEL_37;
  }
  if ( v9 >= 0x30u && v9 <= 0x39u )
  {
    v12 = *(_WORD *)(*(_DWORD *)(v3 + 56) + 240);
    if ( v12 <= 0 || (v13 = *(char **)((char *)&off_100DD5AC + v7 * 2) + v12, *v13 != 5) && *(v13 - 1) != 5 )
    {
      if ( strchr((&off_100D8DE0)[4 * v30], *(_BYTE *)(v2 + 14)) )
      {
        *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240) + *(_DWORD *)(v3 + 56) + 69) = *(_BYTE *)(v2 + 14);
        v16 = 20 * (unsigned __int8)byte_105728D4;
        v17 = *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) + 1;
        v28 = 1;
        if ( v17 < word_100DD5CA[20 * (unsigned __int8)byte_105728D4] )
        {
          do
          {
            if ( (*(_BYTE **)((char *)&off_100DD5AC + v16 * 2))[v17] != 11 )
              *(_BYTE *)(*(_DWORD *)(v3 + 56) + v17 + 69) = 48;
            ++v17;
          }
          while ( v17 < word_100DD5CA[v16] );
        }
      }
      goto LABEL_36;
    }
    if ( v30 == 5 )
    {
      if ( !strchr("01", *(_BYTE *)(v2 + 14)) )
        goto LABEL_36;
    }
    else if ( !strchr("0123456789", *(_BYTE *)(v2 + 14)) )
    {
      goto LABEL_36;
    }
    *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v3 + 56) + 240))++ + *(_DWORD *)(v3 + 56) + 69) = *(_BYTE *)(v2 + 14);
    *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242) = 1;
    v14 = 20 * (unsigned __int8)byte_105728D4;
    v15 = *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) + 1;
    if ( v15 < word_100DD5CE[20 * (unsigned __int8)byte_105728D4] + word_100DD5CC[20 * (unsigned __int8)byte_105728D4] )
    {
      do
      {
        if ( (*(_BYTE **)((char *)&off_100DD5AC + v14 * 2))[v15] != 11 )
          *(_BYTE *)(*(_DWORD *)(v3 + 56) + v15 + 69) = 48;
        ++v15;
      }
      while ( v15 < word_100DD5CE[v14] + word_100DD5CC[v14] );
    }
    goto LABEL_36;
  }
LABEL_37:
  v18 = 20 * (unsigned __int8)byte_105728D4;
  v19 = *(_DWORD *)(v3 + 56) + word_100DD5CC[20 * (unsigned __int8)byte_105728D4];
  if ( *(_BYTE *)(v19 + 70) == 49 )
  {
    if ( *(_BYTE *)(v19 + 71) == 57 )
      *(_BYTE *)(v19 + 71) = 48;
    v20 = word_100DD5CC[v18];
    v21 = word_100DD5CC[v18];
    if ( *(_BYTE *)(v21 + *(_DWORD *)(v3 + 56) + 71) == 56 )
    {
      v22 = v21 + 3;
      if ( v21 + 3 < v21 + word_100DD5CE[v18] )
      {
        do
        {
          if ( (*(_BYTE **)((char *)&off_100DD5AC + v18 * 2))[v22] != 11 )
          {
            *(_BYTE *)(*(_DWORD *)(v3 + 56) + v22 + 69) = 48;
            v20 = word_100DD5CC[v18];
            if ( *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) >= v20 )
              v28 = 0;
          }
          ++v22;
        }
        while ( v22 < word_100DD5CE[v18] + v20 );
      }
    }
  }
  if ( v28 == 1 )
  {
LABEL_47:
    *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242) = 1;
    v23 = 20 * (unsigned __int8)byte_105728D4;
    if ( *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) == word_100DD5CA[20 * (unsigned __int8)byte_105728D4] - 1 )
      *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = LOBYTE(word_100DD5CC[v23]);
    else
      ++*(_WORD *)(*(_DWORD *)(v3 + 56) + 240);
    if ( (*(_BYTE **)((char *)&off_100DD5AC + v23 * 2))[*(_WORD *)(*(_DWORD *)(v3 + 56) + 240)] == 11 )
      ++*(_WORD *)(*(_DWORD *)(v3 + 56) + 240);
    v24 = *(_DWORD *)(v3 + 56);
    LOBYTE(v25) = v8;
    if ( *(_WORD *)(v24 + 240) < (signed int)v8 )
      v25 = *(_WORD *)(v24 + 240);
    *(_WORD *)(v24 + 240) = (char)v25;
  }
  return v27;
}
// 100DD5AC: using guessed type void *off_100DD5AC;
// 100DD5C8: using guessed type __int16 word_100DD5C8[];
// 100DD5CA: using guessed type __int16 word_100DD5CA[];
// 100DD5CC: using guessed type __int16 word_100DD5CC[];
// 100DD5CE: using guessed type __int16 word_100DD5CE[];
// 105728D4: using guessed type char byte_105728D4;

//----- (100628B0) --------------------------------------------------------
int __usercall sub_100628B0@<eax>(char a1@<dl>, int a2@<esi>, const char *a3, int *a4)
{
  int v4; // ecx@1
  __int16 v5; // di@1
  int v6; // ebx@1
  int v7; // edi@3
  __int16 v8; // ax@3
  int v9; // edx@14
  bool v10; // zf@15
  int v11; // ecx@17
  int v12; // edx@21
  int v13; // eax@26
  int result; // eax@31
  int v15; // edx@31
  char v16; // [sp+1h] [bp-1h]@1

  v4 = *(_DWORD *)(a2 + 56);
  v5 = *(_WORD *)(v4 + 240);
  v16 = *(_BYTE *)(a2 + 3);
  v6 = v5;
  if ( !v16 || v5 == -128 )
    goto LABEL_31;
  v7 = word_100DD5CC[20 * (unsigned __int8)byte_105728D4];
  v8 = word_100DD5CA[20 * (unsigned __int8)byte_105728D4];
  *(_BYTE *)(a2 + 3) = 0;
  *(_WORD *)(v4 + 240) = -128;
  if ( v6 < v7 )
  {
    if ( !a1 )
    {
      v11 = *(_DWORD *)(a2 + 56);
      *(_BYTE *)(a2 + 3) = 1;
      *(_WORD *)(v11 + 240) = (char)v6;
      goto LABEL_31;
    }
    if ( a1 != 6 )
    {
      if ( v6 )
      {
        if ( v6 <= 0 )
          goto LABEL_31;
        if ( a1 != 3 )
        {
          v10 = a1 == 2;
          goto LABEL_29;
        }
        v13 = *(_DWORD *)(a2 + 56);
        *(_BYTE *)(a2 + 3) = 1;
        *(_WORD *)(v13 + 240) = (char)(v6 - 2);
LABEL_27:
        ++*(_WORD *)(a2 + 438);
        goto LABEL_31;
      }
      if ( a1 == 2 )
      {
        v12 = *(_DWORD *)(a2 + 56);
        *(_BYTE *)(a2 + 3) = 1;
        *(_WORD *)(v12 + 240) = 0;
        goto LABEL_31;
      }
      if ( a1 != 3 )
        goto LABEL_31;
    }
    ++*(_WORD *)(a2 + 438);
    goto LABEL_31;
  }
  if ( a1 == 1 )
  {
    *(_BYTE *)(a2 + 3) = 1;
    *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = (char)(v6 - v8);
    goto LABEL_31;
  }
  if ( a1 == 7 )
    goto LABEL_27;
  if ( v6 == v7 )
  {
    if ( a1 == 4 )
    {
      *(_BYTE *)(a2 + 3) = 1;
      *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = 0;
    }
    else if ( a1 == 5 )
    {
      ++*(_WORD *)(a2 + 438);
    }
    goto LABEL_31;
  }
  if ( v6 <= v7 )
    goto LABEL_31;
  if ( a1 == 5 )
  {
    v9 = *(_DWORD *)(a2 + 56);
    *(_BYTE *)(a2 + 3) = 1;
    *(_WORD *)(v9 + 240) = (char)(v6 - v8 - 1);
    ++*(_WORD *)(a2 + 438);
    goto LABEL_31;
  }
  v10 = a1 == 4;
LABEL_29:
  if ( v10 )
    --*(_WORD *)(a2 + 438);
LABEL_31:
  sub_1006D8E0(a2, a3, a4);
  LOBYTE(result) = v16;
  v15 = *(_DWORD *)(a2 + 56);
  *(_BYTE *)(a2 + 3) = v16;
  *(_WORD *)(v15 + 240) = (char)v6;
  return result;
}
// 100DD5CA: using guessed type __int16 word_100DD5CA[];
// 100DD5CC: using guessed type __int16 word_100DD5CC[];
// 105728D4: using guessed type char byte_105728D4;

//----- (10062A50) --------------------------------------------------------
int __usercall sub_10062A50@<eax>(int a1@<edx>, char *a2@<ecx>, char *a3, unsigned int a4, __int16 a5)
{
  int v5; // esi@1
  int v6; // ebx@1
  void *v7; // ecx@1
  int v8; // edi@4
  int v9; // eax@4
  __int16 v10; // ax@4
  int v11; // ebp@4
  int v12; // ebp@4
  int v13; // eax@4
  signed int v14; // ecx@8
  __int16 v15; // bp@12
  int v16; // eax@12
  unsigned int v17; // edi@18
  __int16 v18; // cx@18
  bool v19; // zf@18
  __int16 v20; // bx@28
  const char *v21; // ecx@28
  int v23; // [sp+10h] [bp-58h]@4
  int v24; // [sp+10h] [bp-58h]@15
  int v25; // [sp+14h] [bp-54h]@4
  int v26; // [sp+18h] [bp-50h]@4
  int v27; // [sp+18h] [bp-50h]@5
  int v28; // [sp+1Ch] [bp-4Ch]@2
  unsigned int v29; // [sp+20h] [bp-48h]@18
  int v30; // [sp+24h] [bp-44h]@22
  unsigned int v31; // [sp+28h] [bp-40h]@18
  int v32; // [sp+2Ch] [bp-3Ch]@20
  __int16 v33; // [sp+30h] [bp-38h]@22
  int v34; // [sp+32h] [bp-36h]@1
  int v35; // [sp+38h] [bp-30h]@4
  int v36; // [sp+3Ch] [bp-2Ch]@4
  int v37; // [sp+40h] [bp-28h]@4
  char *v38; // [sp+48h] [bp-20h]@1
  char *v39; // [sp+4Ch] [bp-1Ch]@1
  int v40; // [sp+50h] [bp-18h]@22
  char v41; // [sp+54h] [bp-14h]@4
  char v42; // [sp+5Ch] [bp-Ch]@4

  v5 = a1;
  v39 = a3;
  v38 = a2;
  v34 = sub_1006CFD0(a4);
  v6 = sub_1006D000(a4)[1];
  if ( sub_10079360(v7) )
    v28 = sub_1006D000(0x826u)[1];
  else
    v28 = sub_1006D000(0x426u)[1];
  v8 = sub_1006D040(a4);
  v9 = sub_1006D920(a4, 1);
  v25 = v9;
  v36 = BYTE1(v9);
  sub_100683C0((int)&v42, (int)&v41, byte_105728D4);
  v10 = *(_WORD *)(v5 + 436);
  LOWORD(v37) = *(_WORD *)(v5 + 438);
  HIWORD(v37) = v10;
  v35 = sub_1006D070(a4);
  v23 = sub_1009DA50(v6, v39, v8);
  v26 = sub_1009DA50(v6, v38, v8);
  v11 = sub_1009DA50(v28, word_100D2B44, v8);
  v12 = sub_1009DA50(v28, &v41, v8) + v11;
  v13 = v26 + v12 + *(_WORD *)(v28 + 28);
  if ( v23 <= v13 )
  {
    v27 = v26 + v12 + *(_WORD *)(v28 + 28);
  }
  else
  {
    v13 = v23;
    v27 = v23;
  }
  if ( a5 <= v13 )
    v14 = 0;
  else
    v14 = a5 - v13;
  if ( (v8 & 3) == 1 )
  {
    v15 = (v13 - 1) / 2;
    v16 = v14 / 2;
    v14 -= v14 / 2;
  }
  else
  {
    if ( (v8 & 3) != 2 )
    {
      v15 = 0;
      v16 = v14;
LABEL_17:
      v24 = 0;
      goto LABEL_18;
    }
    v15 = v13 - 1;
    v16 = 0;
  }
  v24 = v14;
  if ( v14 )
  {
    v24 = v14 - v36;
    if ( v14 - v36 <= 0 )
      goto LABEL_17;
  }
LABEL_18:
  v29 = v8 & 0xFFFFFFFE | 2;
  v17 = v8 & 0xFFFFFFFC;
  v18 = *(_WORD *)(v6 + 24) + (v25 >> 24) + BYTE2(v25) - *(_WORD *)(v6 + 26);
  *(_WORD *)(v5 + 438) += v15;
  v19 = *(_BYTE *)(v5 + 3) == 0;
  v36 = (unsigned __int16)(v18 + 2);
  v31 = v17;
  if ( v19 || *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
    v32 = v25 + 0x2000000;
  else
    v32 = v25;
  v40 = v27 + v16;
  v33 = v27 + v16;
  v30 = v6;
  sub_100628B0(0, v5, v39, &v30);
  if ( v24 )
  {
    v19 = *(_BYTE *)(v5 + 3) == 0;
    v31 = v29;
    if ( v19 || *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
      v32 = v25 + 0x2000000;
    else
      v32 = v25;
    v33 = v24;
    sub_100628B0(6, v5, (const char *)&unk_100C4192, &v30);
  }
  v20 = v36 + HIWORD(v37);
  v21 = v38;
  *(_WORD *)(v5 + 438) = v37 + v15;
  v31 = v17;
  v33 = v40;
  *(_WORD *)(v5 + 436) = v20;
  v32 = v25;
  sub_100628B0(1, v5, v21, &v30);
  if ( v24 )
  {
    v33 = v24;
    v31 = v29;
    v32 = v25;
    sub_100628B0(7, v5, (const char *)&unk_100C4192, &v30);
  }
  *(_WORD *)(v5 + 438) = v37 + v15 - v27 + 1;
  v31 = v29;
  *(_WORD *)(v5 + 436) = v20;
  v32 = v25;
  v30 = v28;
  v33 = 0;
  return sub_100628B0(8, v5, &v41, &v30);
}
// 105728D4: using guessed type char byte_105728D4;

//----- (10062DA0) --------------------------------------------------------
int __usercall sub_10062DA0@<eax>(int a1@<eax>, int a2, void *a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // ecx@1
  __int16 v9; // dx@1
  __int16 v10; // ax@1
  signed int v11; // eax@1
  char v12; // dl@1
  char *v13; // eax@1
  char v14; // dl@2
  char *v15; // eax@3
  char v16; // dl@4
  int *v17; // eax@5
  int v18; // ebp@5
  int v19; // eax@5
  signed int v20; // eax@5
  signed int v21; // ecx@8
  int v22; // ebp@10
  unsigned int v23; // edi@16
  unsigned int v24; // ebx@16
  bool v25; // zf@16
  int v26; // ecx@28
  int v27; // eax@28
  char v29; // [sp+10h] [bp-3Ch]@1
  char v30; // [sp+11h] [bp-3Bh]@1
  char v31; // [sp+14h] [bp-38h]@3
  char v32; // [sp+15h] [bp-37h]@3
  int v33; // [sp+18h] [bp-34h]@1
  int v34; // [sp+1Ch] [bp-30h]@12
  int v35; // [sp+20h] [bp-2Ch]@5
  char *v36; // [sp+24h] [bp-28h]@1
  int v37; // [sp+28h] [bp-24h]@1
  int v38; // [sp+2Ch] [bp-20h]@1
  int v39; // [sp+34h] [bp-18h]@1
  unsigned int v40; // [sp+38h] [bp-14h]@16
  int v41; // [sp+3Ch] [bp-10h]@18
  __int16 v42; // [sp+40h] [bp-Ch]@23
  int v43; // [sp+42h] [bp-Ah]@1
  int v44; // [sp+48h] [bp-4h]@1
  int v45; // [sp+5Ch] [bp+10h]@12

  v5 = a1;
  v6 = sub_1006D040(a4);
  v33 = sub_1006D920(a4, 1);
  v7 = v6 | (*((_BYTE *)sub_1006D000(a4) + 16) << 22);
  v37 = BYTE1(v33);
  v43 = sub_1006CFD0(a4);
  v8 = sub_1006D000(a4)[1];
  v9 = *(_WORD *)(v5 + 438);
  v10 = *(_WORD *)(v5 + 436);
  v39 = v8;
  LOWORD(v38) = v9;
  HIWORD(v38) = v10;
  v11 = sub_1006D070(a4);
  v12 = *(_BYTE *)a2;
  v44 = v11;
  v13 = (char *)a2;
  v29 = v12;
  v30 = 0;
  v36 = (char *)(a2 + 1);
  do
    v14 = *v13++;
  while ( v14 );
  memcpy_0((void *)a2, (const void *)(a2 + 2), v13 - v36 - 1);
  v15 = (char *)a3;
  v31 = *(_BYTE *)a3;
  v32 = 0;
  v36 = (char *)a3 + 1;
  do
    v16 = *v15++;
  while ( v16 );
  memcpy_0(a3, (char *)a3 + 1, v15 - v36);
  v35 = sub_1009DA50(v39, (_BYTE *)a2, v6);
  v36 = (char *)sub_1009DA50(v39, &v29, v7);
  v17 = sub_1006D000(a4);
  v18 = (int)&v36[*((_BYTE *)v17 + 17) + 1];
  v36 = (char *)sub_1009DA50(v39, a3, v6);
  v19 = sub_1009DA50(v39, &v31, v7);
  v20 = (signed int)&v36[v19];
  if ( v18 + v35 > v20 )
    v20 = v18 + v35;
  if ( (signed __int16)a5 <= v20 )
    v21 = 0;
  else
    v21 = (signed __int16)a5 - v20;
  v22 = 0;
  if ( v6 & 3 )
  {
    if ( (v6 & 3) == 1 )
    {
      v34 = v20 / 2;
      v22 = v21 / 2;
      v21 = v21 - v21 / 2 - 1;
      v45 = v21;
    }
    else
    {
      v34 = 0;
      v45 = v21;
    }
    if ( !v21 )
      goto LABEL_16;
    v45 = v21 - v37;
    if ( v21 - v37 > 0 )
      goto LABEL_16;
  }
  else
  {
    v34 = v20;
    v22 = v21;
  }
  v45 = 0;
LABEL_16:
  *(_WORD *)(v5 + 438) -= v22 + v34;
  v23 = v7 & 0xFFFFFFFE | 2;
  v24 = v6 & 0xFFFFFFFE | 2;
  v25 = *(_BYTE *)(v5 + 3) == 0;
  v40 = v23;
  if ( v25 || *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
    v41 = v33 + 0x2000000;
  else
    v41 = v33;
  if ( v22 )
  {
    v42 = v22;
    sub_100628B0(8, v5, (const char *)&unk_100C4192, &v39);
  }
  v25 = *(_BYTE *)(v5 + 3) == 0;
  v42 = 0;
  if ( v25 || *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
    v41 = v33 + 0x2000000;
  else
    v41 = v33;
  sub_100628B0(2, v5, &v29, &v39);
  v40 = v24;
  v42 = *((_BYTE *)sub_1006D000(a4) + 17);
  sub_100628B0(8, v5, (const char *)&unk_100C4192, &v39);
  v42 = v45 + v35;
  sub_100628B0(3, v5, (const char *)a2, &v39);
  v26 = v33;
  v27 = *(_WORD *)(v39 + 24) + BYTE2(v33) - *(_WORD *)(v39 + 26) + (v33 >> 24) + 2;
  *(_WORD *)(v5 + 438) = v38 - v34 - v22;
  *(_WORD *)(v5 + 436) = HIWORD(v38) + v27;
  v40 = v23;
  v41 = v26;
  if ( v22 )
  {
    v42 = v22;
    sub_100628B0(8, v5, (const char *)&unk_100C4192, &v39);
  }
  v42 = 0;
  sub_100628B0(4, v5, &v31, &v39);
  v41 = v33;
  v42 = v45 + (_WORD)v36;
  v40 = v24;
  return sub_100628B0(5, v5, (const char *)a3, &v39);
}

//----- (10063100) --------------------------------------------------------
int __usercall sub_10063100@<eax>(void *a1@<ecx>, char *a2@<ebx>, int a3)
{
  int result; // eax@2
  unsigned int v4; // [sp+0h] [bp-8h]@0
  int v5; // [sp+4h] [bp-4h]@0

  if ( (unsigned __int8)byte_105728D4 > 1u )
    result = sub_10062A50(a3, (char *)a1, a2, v4, v5);
  else
    result = sub_10062DA0(a3, (int)a2, a1, v4, v5);
  return result;
}
// 105728D4: using guessed type char byte_105728D4;

//----- (10063130) --------------------------------------------------------
int __usercall sub_10063130@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, char *a5, char *a6)
{
  int v6; // edi@1
  int v7; // esi@1
  float v8; // ST1C_4@1
  float v9; // ST18_4@1
  float v10; // ST14_4@1
  int v11; // edi@1
  int v12; // ST00_4@1
  float v14; // [sp+20h] [bp-30h]@1
  float v15; // [sp+24h] [bp-2Ch]@1
  float v16; // [sp+28h] [bp-28h]@1

  v6 = a2;
  v7 = a1;
  sub_1006E530(&v14);
  v8 = v15;
  v9 = v16;
  v10 = v14;
  sub_10068420(a5, a6, a4, byte_105728D4, SLOBYTE(v10), SLOBYTE(v9), SLOBYTE(v8));
  *(_WORD *)(v7 + 438) = *(_WORD *)v6;
  *(_WORD *)(v7 + 436) = *(_WORD *)(v6 + 2);
  v11 = *(_DWORD *)(a3 + 4);
  v12 = v7;
  LOWORD(v7) = *(_WORD *)(a3 + 8);
  return sub_10063100(a6, a5, v12);
}
// 105728D4: using guessed type char byte_105728D4;

//----- (100631D0) --------------------------------------------------------
char __usercall sub_100631D0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // edi@1
  int v7; // edx@1
  signed __int16 v8; // cx@1
  signed int v9; // eax@1
  char v10; // bl@1
  float v11; // ST28_4@4
  float v12; // ST24_4@4
  float v13; // ST20_4@4
  char *v14; // edx@4
  _BYTE *v15; // eax@4
  char v16; // cl@5
  char v17; // bl@6
  int v18; // edi@6
  char *v19; // ecx@6
  _BYTE *v20; // edx@6
  char v21; // al@7
  unsigned __int16 v22; // ax@9
  char result; // al@19
  int v24; // eax@23
  int v25; // eax@24
  int v26; // edi@27
  int v27; // eax@27
  int v28; // ecx@35
  int v29; // edx@39
  int v30; // ecx@39
  size_t v31; // ST1C_4@39
  char v32; // bl@39
  float v33; // ST28_4@41
  float v34; // ST24_4@41
  float v35; // ST20_4@41
  char v36; // dl@43
  int v37; // ecx@46
  unsigned int v38; // eax@46
  int v39; // ecx@48
  int v40; // ecx@48
  int v41; // edx@49
  int v42; // edx@51
  int v43; // eax@51
  int v44; // ebx@55
  __int16 v45; // dx@55
  int v46; // edi@55
  int v47; // eax@60
  int v48; // ecx@60
  unsigned __int16 v49; // ax@70
  unsigned __int16 v50; // ax@76
  int v51; // edi@84
  int v52; // eax@84
  int v53; // ecx@86
  signed __int16 v54; // di@87
  int v55; // ecx@93
  __int16 v56; // dx@94
  char *v57; // eax@95
  int v58; // esi@97
  char v59; // al@100
  int v60; // eax@101
  int v61; // ecx@104
  int v62; // eax@110
  int v63; // ecx@115
  int v64; // [sp+1Ch] [bp-54h]@1
  float v65; // [sp+20h] [bp-50h]@4
  float v66; // [sp+24h] [bp-4Ch]@4
  float v67; // [sp+28h] [bp-48h]@4
  char v68[16]; // [sp+4Ch] [bp-24h]@4
  char v69[16]; // [sp+5Ch] [bp-14h]@4

  v5 = a2;
  v6 = a1;
  v7 = *(_DWORD *)(a2 + 56);
  v8 = *(_WORD *)(v7 + 240);
  v9 = *(_WORD *)(v6 + 10);
  v64 = v6;
  v10 = 1;
  if ( v8 == -128 )
  {
    if ( v9 == 56 || v9 == 0x2000 )
    {
      sub_1006E530(&v65);
      v11 = v66;
      v12 = v67;
      v13 = v65;
      sub_10068420(v69, v68, a5, byte_105728D4, SLOBYTE(v13), SLOBYTE(v12), SLOBYTE(v11));
      v14 = v69;
      v15 = (_BYTE *)(*(_DWORD *)(v5 + 56) + 69);
      do
      {
        v16 = *v14;
        *v15++ = *v14++;
      }
      while ( v16 );
      v17 = byte_105728D4;
      v18 = 20 * (unsigned __int8)byte_105728D4;
      v19 = v68;
      v20 = (_BYTE *)(word_100DD5CA[20 * (unsigned __int8)byte_105728D4] + *(_DWORD *)(v5 + 56) + 69);
      do
      {
        v21 = *v19;
        *v20++ = *v19++;
      }
      while ( v21 );
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = LOBYTE(word_100DD5C8[v18]);
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
      if ( *(_WORD *)(v64 + 10) != 0x2000
        || ((v22 = *(_WORD *)(v64 + 14), v22 < 0x41u) || v22 > 0x5Au) && v22 != 32 && (v22 < 0x30u || v22 > 0x39u) )
      {
        result = 4;
      }
      else
      {
        if ( v22 >= 0x30u && v22 <= 0x39u && (!v17 || v17 == 1) )
          *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = 2;
        result = sub_10062450(v64, v5);
      }
      return result;
    }
    return v10;
  }
  if ( v9 > 56 )
  {
    if ( v9 != 57 )
    {
      if ( v9 == 0x2000 )
      {
        v49 = *(_WORD *)(v6 + 14);
        if ( v49 >= 0x30u
          && v49 <= 0x39u
          && (!byte_105728D4 || byte_105728D4 == 1)
          && v8 == word_100DD5CC[20 * (unsigned __int8)byte_105728D4] )
        {
          *(_WORD *)(v7 + 240) = LOBYTE(word_100DD5CC[20 * (unsigned __int8)byte_105728D4]) + 1;
        }
        v50 = *(_WORD *)(v6 + 14);
        if ( v50 >= 0x41u && v50 <= 0x5Au )
          return sub_10062450(v6, v5);
        if ( v50 == 32 || v50 >= 0x30u && v50 <= 0x39u )
          return sub_10062450(v6, v5);
      }
      return v10;
    }
    if ( byte_105728D4 && byte_105728D4 != 1
      || (v51 = word_100DD5CC[20 * (unsigned __int8)byte_105728D4],
          v52 = 20 * (unsigned __int8)byte_105728D4,
          *(_BYTE *)(v51 + v7 + 70) != 49)
      || *(_BYTE *)(v51 + v7 + 71) != 56
      || (v53 = v51 + 3, v51 + 3 >= v51 + word_100DD5CE[v52]) )
    {
      v54 = 1;
    }
    else
    {
      v54 = 1;
      do
      {
        if ( (*(_BYTE **)((char *)&off_100DD5AC + v52 * 2))[v53] != 11 )
          *(_BYTE *)(v53 + *(_DWORD *)(v5 + 56) + 69) = 48;
        ++v53;
      }
      while ( v53 < word_100DD5CC[v52] + word_100DD5CE[v52] );
    }
    v55 = *(_DWORD *)(v5 + 56);
    if ( *(_BYTE *)(v55 + 242) == 1 )
    {
      v56 = *(_WORD *)(v55 + 240);
      if ( v56 > 0 )
      {
        v57 = (char *)*(&off_100DD5AC + 10 * (unsigned __int8)byte_105728D4) + v56;
        if ( *v57 == 5 || *(v57 - 1) == 5 )
        {
          v58 = *(_DWORD *)(v5 + 56);
          if ( *(_BYTE *)(v64 + 8) >= 0 )
          {
            *(_WORD *)(v58 + 240) += v54;
            result = 2;
          }
          else
          {
            --*(_WORD *)(v58 + 240);
            result = 2;
          }
          return result;
        }
      }
    }
    v59 = *(_BYTE *)(v64 + 8);
    if ( v59 >= 0 )
    {
      if ( v59 <= 0 )
        return v10;
      v62 = 20 * (unsigned __int8)byte_105728D4;
      if ( *(_WORD *)(v55 + 240) == word_100DD5CA[20 * (unsigned __int8)byte_105728D4] - 1 )
        *(_WORD *)(v55 + 240) = LOBYTE(word_100DD5CC[v62]);
      else
        ++*(_WORD *)(v55 + 240);
      if ( (*(_BYTE **)((char *)&off_100DD5AC + v62 * 2))[*(_WORD *)(*(_DWORD *)(v5 + 56) + 240)] == 11 )
        ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
      v63 = *(_DWORD *)(v5 + 56);
      if ( *(_WORD *)(v63 + 240) > word_100DD5CE[v62] + word_100DD5CA[v62] - 1 )
        *(_WORD *)(v63 + 240) = LOBYTE(word_100DD5C8[v62]);
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = ((*(_BYTE **)((char *)&off_100DD5AC + v62 * 2))[*(_WORD *)(*(_DWORD *)(v5 + 56) + 240)] == 5)
                                             + 1;
    }
    else
    {
      v60 = 20 * (unsigned __int8)byte_105728D4;
      if ( *(_WORD *)(v55 + 240) == word_100DD5CC[v60] )
        *(_WORD *)(v55 + 240) = LOBYTE(word_100DD5CA[v60]) - v54;
      else
        --*(_WORD *)(v55 + 240);
      v61 = *(_DWORD *)(v5 + 56);
      if ( *(_WORD *)(v61 + 240) < word_100DD5C8[v60] )
        *(_WORD *)(v61 + 240) = LOBYTE(word_100DD5CA[v60]) + LOBYTE(word_100DD5CE[v60]) - v54;
      if ( (*(_BYTE **)((char *)&off_100DD5AC + v60 * 2))[*(_WORD *)(*(_DWORD *)(v5 + 56) + 240)] == 11 )
        --*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = ((*(_BYTE **)((char *)&off_100DD5AC + v60 * 2))[*(_WORD *)(*(_DWORD *)(v5 + 56) + 240)] == 5)
                                             + 1;
    }
    return 2;
  }
  if ( v9 == 56 )
  {
    v36 = byte_105728D4;
    if ( v8 > 0 && *((char *)*(&off_100DD5AC + 10 * (unsigned __int8)byte_105728D4) + v8 - 1) == 5 )
    {
      --*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
    }
    v37 = *(_DWORD *)(v5 + 56);
    v38 = 40 * (unsigned __int8)v36;
    if ( *((_BYTE *)*(&off_100DD5AC + 10 * (unsigned __int8)v36) + *(_WORD *)(v37 + 240)) == 5 )
      *(_BYTE *)(v37 + 242) = 2;
    v39 = *(_BYTE *)(v6 + 8) < 0;
    LOBYTE(v39) = *(_BYTE *)(v6 + 8) >= 0;
    v40 = 2 * v39 - 1;
    if ( (unsigned __int8)v36 > 1u )
    {
      v44 = *(_DWORD *)(v5 + 56);
      v45 = *(_WORD *)(v44 + 240);
      LOWORD(v46) = word_100DD5C8[v38 / 2];
      if ( v45 == (_WORD)v46 )
      {
        if ( (*(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69) != 48 || v40 != -1)
          && (*(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69) != 53 || v40 != 1) )
        {
          *(_BYTE *)(word_100DD5C8[20 * (unsigned __int8)byte_105728D4] + *(_DWORD *)(v5 + 56) + 69) = sub_10062350(*(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69), (*(_BYTE **)((char *)&off_100DD5AC + v38))[*(_WORD *)(v44 + 240)], v40);
        }
        else
        {
          *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69) = 54;
          v47 = word_100DD5C8[v38 / 2];
          v48 = *(_DWORD *)(v5 + 56);
          if ( *(_BYTE *)(v47 + v48 + 70) != 95 )
            *(_BYTE *)(v47 + v48 + 70) = 48;
        }
      }
      else
      {
        v46 = (signed __int16)v46;
        if ( v45 == (signed __int16)v46 + 1 )
        {
          if ( *(_BYTE *)(v46 + v44 + 69) >= 0x36u )
            *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69) = 48;
          else
            *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69) = sub_10062350(
                                                             *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69),
                                                             (*(_BYTE **)((char *)&off_100DD5AC + v38))[*(_WORD *)(v44 + 240)],
                                                             v40);
        }
        else
        {
          *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69) = sub_10062350(
                                                           *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 69),
                                                           (*(_BYTE **)((char *)&off_100DD5AC + v38))[*(_WORD *)(v44 + 240)],
                                                           v40);
        }
      }
    }
    else
    {
      v41 = *(_DWORD *)(v5 + 56);
      if ( *(_BYTE *)(v41 + 242) == 2 )
      {
        sub_100623D0(v40, v5, v40);
      }
      else
      {
        *(_BYTE *)(*(_WORD *)(v41 + 240) + v41 + 69) = sub_10062350(
                                                         *(_BYTE *)(*(_WORD *)(v41 + 240) + v41 + 69),
                                                         (*(_BYTE **)((char *)&off_100DD5AC + v38))[*(_WORD *)(v41 + 240)],
                                                         v40);
        v42 = *(_DWORD *)(v5 + 56);
        v43 = word_100DD5CC[20 * (unsigned __int8)byte_105728D4];
        if ( *(_BYTE *)(v43 + v42 + 70) == 49
          && *(_BYTE *)(v43 + v42 + 71) == 56
          && *(_WORD *)(v42 + 240) > word_100DD5CC[20 * (unsigned __int8)byte_105728D4] )
        {
          *(_BYTE *)(*(_WORD *)(v42 + 240) + v42 + 69) = 48;
        }
      }
    }
    return 2;
  }
  v24 = v9 - 32;
  if ( !v24 )
    goto LABEL_26;
  v25 = v24 - 1;
  if ( v25 )
  {
    if ( v25 != 7 )
      return v10;
LABEL_26:
    *(_WORD *)(v7 + 240) = -128;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
    sub_10063130(v5, a4, a3, a5, v69, v68);
    return 6;
  }
  LOWORD(v26) = word_100DD5CC[20 * (unsigned __int8)byte_105728D4];
  v27 = 20 * (unsigned __int8)byte_105728D4;
  if ( v8 < (signed __int16)v26 && (!byte_105728D4 || byte_105728D4 == 1) )
  {
    *(_WORD *)(v7 + 240) = LOBYTE(word_100DD5CC[v27]);
    return 2;
  }
  if ( !byte_105728D4 || byte_105728D4 == 1 )
  {
    v26 = (signed __int16)v26;
    if ( *(_BYTE *)((signed __int16)v26 + v7 + 70) == 49 && *(_BYTE *)(v26 + v7 + 71) == 56 )
    {
      v28 = v26 + 3;
      if ( v26 + 3 < v26 + word_100DD5CE[v27] )
      {
        do
        {
          if ( (*(_BYTE **)((char *)&off_100DD5AC + v27 * 2))[v28] != 11 )
            *(_BYTE *)(v28 + *(_DWORD *)(v5 + 56) + 69) = 48;
          ++v28;
        }
        while ( v28 < word_100DD5CC[v27] + word_100DD5CE[v27] );
      }
    }
  }
  strncpy(v69, (const char *)(*(_DWORD *)(v5 + 56) + 69), word_100DD5CA[v27]);
  v29 = *(_DWORD *)(v5 + 56);
  v30 = word_100DD5CA[20 * (unsigned __int8)byte_105728D4];
  v31 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
  v69[v30] = 0;
  strncpy(v68, (const char *)(v30 + v29 + 69), v31);
  v68[word_100DD5CE[20 * (unsigned __int8)byte_105728D4]] = 0;
  v32 = 0;
  if ( !strpbrk(v69, "_") && !strpbrk(v68, "_") )
  {
    sub_1006E530(&v65);
    v33 = v66;
    v34 = v67;
    v35 = v65;
    sub_10068A70((int)v69, (int)v68, a5, byte_105728D4, SLOBYTE(v35), SLOBYTE(v34), SLOBYTE(v33));
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = -128;
    v32 = 3;
    sub_10063130(v5, a4, a3, a5, v69, v68);
  }
  result = v32;
  *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
  return result;
}
// 100DD5AC: using guessed type void *off_100DD5AC;
// 100DD5C8: using guessed type __int16 word_100DD5C8[];
// 100DD5CA: using guessed type __int16 word_100DD5CA[];
// 100DD5CC: using guessed type __int16 word_100DD5CC[];
// 100DD5CE: using guessed type __int16 word_100DD5CE[];
// 105728D4: using guessed type char byte_105728D4;
// 100631D0: using guessed type char var_24[16];
// 100631D0: using guessed type char var_14[16];

//----- (10063AD0) --------------------------------------------------------
char __usercall sub_10063AD0@<al>(_WORD *a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  signed int v5; // eax@2
  int *v6; // ebx@2
  int v7; // edx@4
  char v8; // al@8
  char v9; // cl@10
  int v10; // edx@10
  char v11; // ST4B_1@10
  int v12; // edx@10
  int v13; // ecx@10
  size_t v14; // ST28_4@10
  int v15; // eax@10
  __int16 v16; // si@10
  int v17; // edi@10
  int v18; // ecx@10
  int v19; // eax@10
  size_t v20; // ST0C_4@10
  int v21; // ecx@10
  __int16 v22; // ax@10
  int v23; // edx@12
  int v24; // ecx@13
  int v25; // eax@13
  size_t v26; // ST28_4@13
  int v27; // ecx@13
  __int16 v28; // si@13
  int v29; // edi@13
  int v30; // ecx@13
  int v31; // eax@13
  size_t v32; // ST0C_4@13
  __int16 v33; // si@14
  int v34; // edi@14
  char v36; // [sp+Eh] [bp-2Eh]@1
  char v37[16]; // [sp+18h] [bp-24h]@10
  char v38[16]; // [sp+28h] [bp-14h]@10

  v36 = 1;
  switch ( *a1 )
  {
    case 0x8040:
      v5 = word_100DD5CA[20 * (unsigned __int8)byte_105728D4];
      v6 = &dword_1068B4C0[5 * ((*(_DWORD *)(a4 + 4) >> 10) & 0xF)];
      if ( v5 <= word_100DD5CE[20 * (unsigned __int8)byte_105728D4] )
        v5 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
      LOWORD(v7) = *(_WORD *)(a4 + 8);
      if ( (_WORD)v7 )
        v7 = (signed __int16)v7;
      else
        v7 = v5 * *((_BYTE *)v6 + 17) + (v5 - 1) * *(_WORD *)(v6[1] + 28);
      sub_1006DB90(a3 + 276, *(_DWORD *)a5, *(_DWORD *)(a4 + 4), v7);
      *(_WORD *)(a3 + 282) += *(_WORD *)(v6[1] + 24) + 1;
      v36 = 2;
      break;
    case 0x8048:
      v8 = sub_100631D0((int)a1, a3, a4, a5, a2);
      v36 = v8;
      if ( v8 == 4 || v8 == 2 )
      {
        v9 = *(_BYTE *)(a3 + 3);
        v10 = 5 * (unsigned __int8)byte_105728D4;
        *(_BYTE *)(a3 + 3) = 0;
        v11 = v9;
        strncpy(v38, (const char *)(*(_DWORD *)(a3 + 56) + 69), word_100DD5CA[4 * v10]);
        v12 = *(_DWORD *)(a3 + 56);
        v13 = word_100DD5CA[20 * (unsigned __int8)byte_105728D4];
        v14 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
        v38[v13] = 0;
        strncpy(v37, (const char *)(v12 + v13 + 69), v14);
        v15 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
        *(_WORD *)(a3 + 438) = *(_WORD *)a5;
        *(_WORD *)(a3 + 436) = *(_WORD *)(a5 + 2);
        v16 = *(_WORD *)(a4 + 8);
        v17 = *(_DWORD *)(a4 + 4);
        v37[v15] = 0;
        sub_10063100(v37, v38, a3);
        *(_BYTE *)(a3 + 3) = v11;
        strncpy(v38, (const char *)(*(_DWORD *)(a3 + 56) + 69), word_100DD5CA[20 * (unsigned __int8)byte_105728D4]);
        v18 = word_100DD5CA[20 * (unsigned __int8)byte_105728D4];
        v19 = *(_DWORD *)(a3 + 56);
        v20 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
        v38[v18] = 0;
        strncpy(v37, (const char *)(v19 + v18 + 69), v20);
        v21 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
        *(_WORD *)(a3 + 438) = *(_WORD *)a5;
        v22 = *(_WORD *)(a5 + 2);
        goto LABEL_14;
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a3 + 3) && (v23 = *(_DWORD *)(a3 + 56), *(_WORD *)(v23 + 240) != -128) )
      {
        strncpy(v38, (const char *)(v23 + 69), word_100DD5CA[20 * (unsigned __int8)byte_105728D4]);
        v24 = word_100DD5CA[20 * (unsigned __int8)byte_105728D4];
        v25 = *(_DWORD *)(a3 + 56);
        v26 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
        v38[v24] = 0;
        strncpy(v37, (const char *)(v25 + v24 + 69), v26);
        v27 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
        *(_BYTE *)(a3 + 3) = 0;
        *(_WORD *)(a3 + 438) = *(_WORD *)a5;
        *(_WORD *)(a3 + 436) = *(_WORD *)(a5 + 2);
        v28 = *(_WORD *)(a4 + 8);
        v29 = *(_DWORD *)(a4 + 4);
        v37[v27] = 0;
        sub_10063100(v37, v38, a3);
        strncpy(v38, (const char *)(*(_DWORD *)(a3 + 56) + 69), word_100DD5CA[20 * (unsigned __int8)byte_105728D4]);
        v30 = word_100DD5CA[20 * (unsigned __int8)byte_105728D4];
        v31 = *(_DWORD *)(a3 + 56);
        v32 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
        v38[v30] = 0;
        strncpy(v37, (const char *)(v31 + v30 + 69), v32);
        v21 = word_100DD5CE[20 * (unsigned __int8)byte_105728D4];
        *(_BYTE *)(a3 + 3) = 1;
        *(_WORD *)(a3 + 438) = *(_WORD *)a5;
        v22 = *(_WORD *)(a5 + 2);
LABEL_14:
        *(_WORD *)(a3 + 436) = v22;
        v33 = *(_WORD *)(a4 + 8);
        v34 = *(_DWORD *)(a4 + 4);
        v37[v21] = 0;
        sub_10063100(v37, v38, a3);
      }
      else
      {
        sub_10063130(a3, a5, a4, a2, v38, v37);
      }
      break;
    default:
      return v36;
  }
  return v36;
}
// 100DD5CA: using guessed type __int16 word_100DD5CA[];
// 100DD5CE: using guessed type __int16 word_100DD5CE[];
// 105728D4: using guessed type char byte_105728D4;
// 1068B4C0: using guessed type int dword_1068B4C0[];
// 10063AD0: using guessed type char var_14[16];
// 10063AD0: using guessed type char var_24[16];

//----- (10063EF0) --------------------------------------------------------
char __cdecl sub_10063EF0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // ecx@0

  byte_105728D4 = sub_10070120(v5);
  return sub_10063AD0(a5, a4, a1, a2, a3);
}
// 105728D4: using guessed type char byte_105728D4;

//----- (10063F20) --------------------------------------------------------
char __cdecl sub_10063F20(int a1, int a2, int a3)
{
  __int16 v3; // ax@1
  unsigned int v4; // ecx@1
  int v5; // ebp@1
  __int16 v6; // ax@1
  char *v8; // [sp+1Ch] [bp+Ch]@1

  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v8 = sub_100793B0(*(_WORD *)(a2 + 8), 0);
  v3 = sub_1006D690(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), 0);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  v6 = *(_WORD *)(a2 + 12);
  if ( (*(_DWORD *)(a2 + 4) & 0xC000) != 0x4000 )
  {
    v6 -= v5;
    if ( v5 > 0 )
      v6 -= *(_WORD *)(dword_1068B4C4[5 * ((v4 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a2 + 12) )
    v6 = sub_10069E20(v4, *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
  return sub_1006DCF0(a1, (char *)(*(_DWORD *)(a1 + 56) + 69), v8, v6, v5, *(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
}
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (10063FF0) --------------------------------------------------------
char __cdecl sub_10063FF0(int a1, int a2, int a3, float *a4)
{
  bool v4; // sf@1
  unsigned __int8 v5; // of@1
  __int16 v6; // ax@1
  __int16 v7; // dx@1
  bool v8; // cl@3
  __int16 v9; // ax@5
  char *v10; // edi@12
  char v11; // cl@13
  char *v12; // edi@15
  char v13; // al@16
  char v14; // al@18
  int v15; // eax@21
  size_t v16; // edi@24
  char *v17; // ebx@25
  __int16 v18; // ax@25
  unsigned int v19; // ecx@25
  int v20; // ebp@25
  __int16 v21; // ax@25
  __int16 v23; // [sp+Ch] [bp-24h]@1
  int v24; // [sp+10h] [bp-20h]@1
  char v25[2]; // [sp+14h] [bp-1Ch]@10
  char v26[12]; // [sp+20h] [bp-10h]@23

  v5 = __OFSUB__(*(_DWORD *)a4, 0x7FFFFFFF);
  v4 = *(_DWORD *)a4 - 0x7FFFFFFF < 0;
  v6 = *(_WORD *)(a2 + 8);
  v7 = *(_WORD *)(a2 + 8);
  v24 = a1;
  v23 = v7;
  v8 = v4 ^ v5 || (v6 & 0x3F) == 8;
  v9 = v6 & 0x3F;
  if ( v9 == 4 )
  {
    v7 &= 0xFDFFu;
    v23 = v7;
  }
  if ( !v8 )
    goto LABEL_33;
  if ( *(_DWORD *)a4 || !(v7 & 0x8000) )
  {
    strcpy(v25, "%");
    if ( v7 & 0x40 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 43;
    }
  }
  else
  {
    strcpy(v25, "-%");
  }
  v12 = (char *)&v24 + 3;
  if ( v9 == 8 )
  {
    do
      v13 = (v12++)[1];
    while ( v13 );
    *(_DWORD *)v12 = 5777968;
  }
  else
  {
    do
      v14 = (v12++)[1];
    while ( v14 );
    *(_DWORD *)v12 = 6564400;
  }
  v15 = v7 & 0x100 ? *(_BYTE *)(a2 + 10) : 0;
  if ( sprintf(v26, v25, v15, *(_DWORD *)a4) > *(_BYTE *)(a2 + 10) )
  {
LABEL_33:
    v16 = *(_BYTE *)(a2 + 10);
    memset(v26, 95, v16);
    v26[v16] = 0;
  }
  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v17 = sub_100793B0(*(_WORD *)(a2 + 8), a4);
  v18 = sub_1006D690(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
  v19 = *(_DWORD *)(a2 + 4);
  v20 = v18;
  v21 = *(_WORD *)(a2 + 12);
  if ( (*(_DWORD *)(a2 + 4) & 0xC000) != 0x4000 )
  {
    v21 -= v20;
    if ( v20 > 0 )
      v21 -= *(_WORD *)(dword_1068B4C4[5 * ((v19 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a2 + 12) )
    v21 = sub_10069E20(v19, *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), 0);
  return sub_1006DCF0(v24, v26, v17, v21, v20, *(_DWORD *)(a2 + 4), v23);
}
// 1068B4C4: using guessed type int dword_1068B4C4[];
// 10063FF0: using guessed type char var_10[12];

//----- (100641E0) --------------------------------------------------------
char __usercall sub_100641E0@<al>(_DWORD *a1@<eax>, int a2@<ebx>, int a3@<esi>)
{
  const char *v3; // edi@1
  signed int v4; // eax@1
  int v5; // eax@3
  int v6; // ecx@3

  v3 = "%+0*d";
  v4 = *a1 >= 0x7FFFFFFF ? 0 : *a1;
  if ( !(*(_BYTE *)(a3 + 8) & 0x40) )
    v3 = "%0*d";
  v5 = sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), v3, *(_BYTE *)(a3 + 10), v4);
  v6 = *(_BYTE *)(a3 + 10);
  if ( v5 > v6 )
    sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), v3, v6, 0);
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = 0;
  return 4;
}

//----- (10064250) --------------------------------------------------------
char __usercall sub_10064250@<al>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  bool v5; // zf@1
  int v6; // edi@1
  signed int v7; // ebx@1
  int v8; // eax@4
  unsigned __int16 v9; // ax@7
  int v10; // eax@9
  __int16 v11; // cx@9
  char result; // al@10
  char v13; // cl@12
  __int32 v14; // eax@18
  int v15; // eax@21
  int v16; // edx@39
  int v17; // eax@42
  char *v18; // [sp+10h] [bp-8h]@1
  int v19; // [sp+14h] [bp-4h]@1
  char v20; // [sp+1Ch] [bp+4h]@1

  v3 = a3;
  v4 = a1;
  v5 = (*(_BYTE *)(a1 + 8) & 0x40) == 0;
  v6 = a2;
  v20 = 1;
  v7 = 1;
  v19 = 0;
  v18 = "%+0*d";
  if ( v5 )
    v18 = "%0*d";
  if ( *(_WORD *)(v3 + 10) == 84 )
  {
    v8 = *(_DWORD *)(a2 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
      *(_WORD *)(v3 + 14) = 45;
    else
      *(_WORD *)(v3 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
  }
  v9 = *(_WORD *)(v3 + 14);
  if ( v9 < 0x30u || v9 > 0x39u )
  {
    if ( v9 != 43 && v9 != 45 )
    {
      result = 1;
    }
    else if ( sub_10079370(*(_WORD *)(v4 + 8)) || *(_BYTE *)(v4 + 8) & 0x40 )
    {
      if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) == -128 )
      {
        sub_100641E0(&v19, v6, v4);
        *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)(*(_BYTE *)(v4 + 10) - 1);
      }
      if ( *(_WORD *)(v3 + 14) == 45 && j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69)) >= 0
        || *(_WORD *)(v3 + 14) == 43 && j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69)) <= 0 )
      {
        if ( *(_BYTE *)(v4 + 8) & 0x40 || *(_WORD *)(v3 + 14) == 45 )
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
        else
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = 48;
        v20 = 2;
      }
      v16 = *(_DWORD *)(v6 + 56);
      if ( !*(_WORD *)(v16 + 240)
        && (*(_BYTE *)(*(_WORD *)(v16 + 240) + v16 + 69) == 43
         || *(_BYTE *)(*(_WORD *)(v16 + 240) + *(_DWORD *)(v6 + 56) + 69) == 45) )
      {
        ++*(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
        v17 = *(_BYTE *)(v4 + 10) - 1;
        if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) < v17 )
          LOWORD(v17) = *(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
        *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)v17;
      }
      result = v20;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    v10 = *(_DWORD *)(a2 + 56);
    v11 = *(_WORD *)(v10 + 240);
    if ( v11 == -128 )
    {
      sub_100641E0(&v19, v6, v4);
      *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)(*(_BYTE *)(v4 + 10) - 1);
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v6 + 56) + 240) + *(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
      result = 2;
    }
    else if ( v11 == (unsigned __int8)(*(_BYTE *)(v4 + 10) - 1) )
    {
      v13 = *(_BYTE *)(v10 + 69);
      if ( v13 == 48 || (v13 == 43 || v13 == 45) && *(_BYTE *)(v10 + 70) == 48 )
      {
        if ( v13 == 45 )
        {
          *(_BYTE *)(v10 + 69) = 48;
          v7 = -1;
        }
        v14 = j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69));
        sprintf((char *)(*(_DWORD *)(v6 + 56) + 69), v18, *(_BYTE *)(v4 + 10), 10 * v14);
        if ( v7 == -1 )
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = 45;
      }
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v6 + 56) + 240) + *(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
      result = 2;
    }
    else
    {
      *(_BYTE *)(*(_WORD *)(v10 + 240) + v10 + 69) = *(_BYTE *)(v3 + 14);
      ++*(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
      v15 = *(_BYTE *)(v4 + 10) - 1;
      if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) < v15 )
        LOWORD(v15) = *(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)v15;
      result = 2;
    }
  }
  return result;
}

//----- (10064510) --------------------------------------------------------
char __cdecl sub_10064510(int a1, int a2)
{
  int v2; // ecx@0
  __int16 v3; // ax@1
  char v5; // [sp+0h] [bp-14h]@1
  int v6; // [sp+4h] [bp-10h]@1
  __int16 v7; // [sp+8h] [bp-Ch]@1
  char v8; // [sp+Ah] [bp-Ah]@1
  char v9; // [sp+Bh] [bp-9h]@1
  __int16 v10; // [sp+Ch] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_WORD *)(a1 + 8);
  v3 = *(_WORD *)(a1 + 12);
  v8 = *(_BYTE *)(a1 + 10);
  v10 = v3;
  v9 = 0;
  return sub_10063F20(v2, (int)&v5, a2);
}

//----- (10064570) --------------------------------------------------------
char __cdecl sub_10064570(int a1, int a2, int *a3, float *a4, int a5)
{
  char v5; // bl@1
  __int16 v6; // ax@2
  _WORD *v7; // ebx@2
  int v8; // eax@3
  int v9; // edx@5
  __int16 v10; // ax@9
  int v11; // eax@10
  __int16 v12; // cx@10
  char result; // al@11
  int v14; // eax@12
  __int16 v15; // bp@12
  signed int v16; // eax@13
  char v17; // al@19
  __int16 v18; // cx@21
  __int16 v19; // ax@25
  signed int v20; // edx@28
  int v21; // edx@30
  int v22; // edx@31
  char v23; // cl@33
  int v24; // ebx@34
  int v25; // ebx@39
  int v26; // edx@42
  __int16 v27; // ax@42

  v5 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v6 = *(_WORD *)(a2 + 12);
      v7 = (_WORD *)(a1 + 276);
      if ( v6 )
      {
        sub_1006DB90(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v6);
      }
      else
      {
        v8 = sub_10069E20(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), 0);
        sub_1006DB90((int)v7, *a3, *(_DWORD *)(a2 + 4), v8);
      }
      v9 = (signed __int16)sub_1006D690(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v9 > 0 )
      {
        v10 = *(_WORD *)(dword_1068B4C4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v9 + v10;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v11 = (v10 + v9 + 1) / 2;
          v12 = *(_WORD *)(a1 + 280) - v11;
          *v7 -= v11;
          *(_WORD *)(a1 + 280) = v12;
        }
      }
      return 2;
    case 0x8048:
      v14 = *(_DWORD *)(a1 + 56);
      v15 = *(_WORD *)(v14 + 240);
      if ( v15 == -128 )
      {
        v16 = *(_WORD *)(a5 + 10);
        if ( v16 > 84 )
        {
          if ( v16 != 0x2000 )
            return v5;
        }
        else if ( v16 != 84 )
        {
          if ( v16 == 32 )
          {
            if ( !*(_DWORD *)a4 )
              return v5;
            v18 = *(_WORD *)(a2 + 8);
            if ( *(_WORD *)(a2 + 8) & 0x400 || (v18 & 0x3F) == 27 )
              return v5;
            v5 = sub_100641E0(a4, a1, a2);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, *(_BYTE *)(a2 + 10));
            goto LABEL_50;
          }
          if ( v16 != 56 || *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 )
            return v5;
          v17 = sub_100641E0(a4, a1, a2);
LABEL_49:
          v5 = v17;
LABEL_50:
          if ( v5 != 4 && v5 != 2 )
            return v5;
LABEL_52:
          sub_10064510(a2, (int)a3);
          return v5;
        }
        v19 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v19 & 0x3F) == 27 )
          return v5;
LABEL_48:
        v17 = sub_10064250(a2, a1, a5);
        goto LABEL_49;
      }
      v20 = *(_WORD *)(a5 + 10);
      if ( v20 > 57 )
      {
        if ( v20 != 84 && v20 != 0x2000 )
          return v5;
        goto LABEL_48;
      }
      if ( v20 == 57 )
      {
        *(_WORD *)(v14 + 240) += *(_BYTE *)(a5 + 8);
        v26 = *(_DWORD *)(a1 + 56);
        v27 = *(_WORD *)(v26 + 240);
        v5 = 2;
        if ( v27 < 0 )
        {
          *(_WORD *)(v26 + 240) = 0;
          sub_10064510(a2, (int)a3);
          return 2;
        }
        if ( v27 > *(_BYTE *)(a2 + 10) - 1 )
        {
          *(_WORD *)(v26 + 240) = (char)(*(_BYTE *)(a2 + 10) - 1);
          sub_10064510(a2, (int)a3);
          return 2;
        }
        goto LABEL_52;
      }
      v21 = v20 - 32;
      if ( v21 )
      {
        v22 = v21 - 1;
        if ( v22 )
        {
          if ( v22 != 23 )
            return v5;
          v23 = *(_BYTE *)(a5 + 8);
          if ( v23 >= 0 )
          {
            if ( v23 <= 0 )
              return v5;
            if ( !(*(_BYTE *)(a2 + 8) & 0x40) || v15 )
            {
              v25 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v25 + 240) + v25 + 69) = sub_10071500(*(_BYTE *)(v15 + v14 + 69), 0x10u, 1);
              sub_10064510(a2, (int)a3);
              result = 2;
            }
            else
            {
              *(_BYTE *)(v14 + 69) = 2 * (*(_BYTE *)(v14 + 69) != 45) + 43;
              sub_10064510(a2, (int)a3);
              result = 2;
            }
          }
          else
          {
            v24 = *(_DWORD *)(a1 + 56);
            *(_BYTE *)(*(_WORD *)(v24 + 240) + v24 + 69) = sub_10071500(*(_BYTE *)(v15 + v24 + 69), 0x10u, -1);
            sub_10064510(a2, (int)a3);
            result = 2;
          }
        }
        else
        {
          *(_WORD *)(v14 + 240) = -128;
          *(_DWORD *)a4 = j__atol((const char *)(*(_DWORD *)(a1 + 56) + 69));
          sub_10063FF0(a1, a2, (int)a3, a4);
          result = 3;
        }
      }
      else
      {
        *(_WORD *)(v14 + 240) = -128;
        sub_10063FF0(a1, a2, (int)a3, a4);
        result = 6;
      }
      return result;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_10063FF0(a1, a2, (int)a3, a4);
        return v5;
      }
      sub_10064510(a2, (int)a3);
      return 1;
    default:
      return v5;
  }
}
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (10064A20) --------------------------------------------------------
char __usercall sub_10064A20@<al>(_WORD *a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, _WORD *a5)
{
  char v5; // bl@1
  _WORD *v6; // ST10_4@7
  int v7; // ecx@7
  unsigned __int16 *v8; // ST0C_4@7
  char result; // al@7
  _WORD *v10; // ST10_4@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Bh] [bp-1Dh]@1
  int v14; // [sp+Ch] [bp-1Ch]@8
  int v15; // [sp+10h] [bp-18h]@8
  __int16 v16; // [sp+14h] [bp-14h]@8
  __int16 v17; // [sp+16h] [bp-12h]@8
  int v18; // [sp+18h] [bp-10h]@7
  int v19; // [sp+1Ch] [bp-Ch]@7
  __int16 v20; // [sp+20h] [bp-8h]@7

  v5 = *(_BYTE *)(a3 + 3);
  v13 = byte_10658E06;
  if ( *(_BYTE *)(a3 + 9) || *(_BYTE *)(*(_DWORD *)(a3 + 56) + 237) && v5 )
  {
    *(_BYTE *)(a3 + 3) = 1;
    byte_10658E06 = 1;
  }
  if ( *(_BYTE *)(a4 + 8) & 1 )
  {
    if ( (*(_BYTE *)(a4 + 8) & 1) == 1 )
    {
      v6 = a1;
      v7 = *a5;
      v19 = *(_DWORD *)(a4 + 4);
      v20 = *(_WORD *)(a4 + 10);
      v8 = (unsigned __int16 *)(*(_DWORD *)(a4 + 16) + 2 * v7);
      v18 = 107;
      result = sub_10068E70(a3, (int)&v18, a2, v8, v6);
      byte_10658E06 = v13;
      *(_BYTE *)(a3 + 3) = v5;
    }
    else
    {
      result = v13;
      byte_10658E06 = v13;
      *(_BYTE *)(a3 + 3) = v5;
    }
  }
  else
  {
    v10 = a1;
    v11 = *a5;
    v15 = *(_DWORD *)(a4 + 4);
    v16 = *(_WORD *)(a4 + 10);
    v12 = *(_DWORD *)(a4 + 16);
    v14 = 105;
    v17 = 0;
    result = sub_100698B0(a3, (int)&v14, a2, *(char **)(v12 + 4 * v11), (int)v10);
    byte_10658E06 = v13;
    *(_BYTE *)(a3 + 3) = v5;
  }
  return result;
}
// 10658E06: using guessed type char byte_10658E06;

//----- (10064B50) --------------------------------------------------------
char __cdecl sub_10064B50(int a1, int a2, int a3, _WORD *a4, int a5)
{
  int v5; // ecx@5
  int v6; // eax@5
  int v7; // edx@5
  int v8; // ecx@5
  char v9; // ST3F_1@5
  unsigned __int16 v10; // ax@6
  int v11; // eax@8
  __int16 v12; // cx@11
  int v13; // eax@11
  char v15; // [sp+13h] [bp-39h]@1
  __int16 v16; // [sp+14h] [bp-38h]@5
  int v17; // [sp+18h] [bp-34h]@5
  int v18; // [sp+1Ch] [bp-30h]@5
  _WORD *v19; // [sp+20h] [bp-2Ch]@5
  int v20; // [sp+24h] [bp-28h]@5
  int v21; // [sp+28h] [bp-24h]@5
  int v22; // [sp+2Ch] [bp-20h]@5
  int v23; // [sp+30h] [bp-1Ch]@5
  int v24; // [sp+34h] [bp-18h]@7
  int v25; // [sp+38h] [bp-14h]@7
  __int16 v26; // [sp+3Ch] [bp-10h]@7
  __int16 v27; // [sp+3Eh] [bp-Eh]@7
  char v28; // [sp+40h] [bp-Ch]@7

  v15 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      sub_10064A20((_WORD *)a5, a3, a1, a2, a4);
      v15 = 2;
      break;
    case 0x8048:
      if ( *(_WORD *)(a2 + 12) && *(_WORD *)(a5 + 10) == 56 )
      {
        v5 = *(_DWORD *)(a1 + 56);
        v17 = 0;
        v16 = -32688;
        v18 = a2;
        v19 = a4;
        v22 = 83;
        v23 = *(_DWORD *)(v5 + 8);
        sub_10064A20(&unk_100E4624, a3, a1, a2, a4);
        v6 = *(_DWORD *)(a1 + 276);
        v7 = *(_DWORD *)(a1 + 56);
        v8 = *(_DWORD *)(a1 + 280);
        v20 = v6;
        v21 = v8;
        HIWORD(v20) = *(_WORD *)(v7 + 30) + HIWORD(v6);
        HIWORD(v21) = *(_WORD *)(v7 + 30) + HIWORD(v8);
        LOWORD(v20) = *(_WORD *)(v7 + 28) + v6;
        LOBYTE(v6) = *(_BYTE *)(a1 + 3);
        LOWORD(v21) = *(_WORD *)(v7 + 28) + v8;
        *(_BYTE *)(v7 + 237) = 1;
        v9 = v6;
        *(_BYTE *)(a1 + 3) = 1;
        sub_10064A20(&unk_100E461C, a3, a1, a2, a4);
        *(_BYTE *)(a1 + 3) = v9;
        sub_10002670(a1, (int)&v16, 32);
        sub_1006E380(a1, 0, (int (__cdecl *)(int))sub_10005A20, 0);
        v15 = 2;
      }
      break;
    case 0x8022:
    case 0x8078:
      v10 = *(_WORD *)(a2 + 12);
      if ( v10 )
      {
        v11 = v10 - 1;
        if ( *a4 < v11 )
          LOWORD(v11) = *a4;
        *a4 = (signed __int16)v11 <= 0 ? 0 : (unsigned __int16)v11;
        sub_10064A20((_WORD *)a5, a3, a1, a2, a4);
        v15 = 2;
      }
      else
      {
        v25 = *(_DWORD *)(a2 + 4);
        v24 = 105;
        v26 = 0;
        v27 = 4;
        strcpy(&v28, "NONE");
        sub_10069460(a1, (int)&v24, a3, &v28);
        v15 = 2;
      }
      break;
    case 0x8051:
      v12 = *(_WORD *)(a5 + 10);
      *a4 = v12;
      v13 = *(_WORD *)(a2 + 12) - 1;
      v15 = 3;
      if ( v12 < v13 )
        LOWORD(v13) = v12;
      *a4 = (signed __int16)v13 <= 0 ? 0 : (unsigned __int16)v13;
      sub_10064A20(&unk_100E461C, a3, a1, a2, a4);
      break;
    default:
      return v15;
  }
  return v15;
}

//----- (10064DE0) --------------------------------------------------------
char __cdecl sub_10064DE0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char v5; // al@3
  __int16 v6; // dx@4
  __int16 v7; // ax@6
  signed __int16 v8; // cx@6
  __int16 v9; // dx@8
  __int16 v10; // bx@8
  __int16 v11; // bp@8
  __int16 v12; // ST2C_2@8
  int v13; // edx@8
  int v14; // ST28_4@8
  __int16 v16; // [sp+0h] [bp-10h]@6
  __int16 v17; // [sp+4h] [bp-Ch]@4

  if ( *a5 == -32734 || *a5 == -32648 )
  {
    v5 = *(_BYTE *)(a2 + 8);
    if ( v5 & 0x20 )
    {
      v6 = *(_WORD *)(a2 + 6);
      v17 = *(_WORD *)(a2 + 4);
    }
    else
    {
      v17 = *(_WORD *)a3 + *(_WORD *)(a2 + 4);
      v6 = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6);
    }
    v16 = v6;
    v7 = word_105728D8[(unsigned __int8)sub_1007A590(v5 & 0x1F)];
    v8 = 2;
    if ( (*(_BYTE *)(a2 + 8) & 0xC0) != 64 )
      v8 = 1;
    v9 = *(_WORD *)(a1 + 396);
    v10 = *(_WORD *)(a1 + 426);
    v11 = *(_WORD *)(a1 + 424);
    *(_WORD *)(a1 + 426) = v8;
    v12 = v9;
    v13 = *(_DWORD *)(a1 + 428);
    *(_WORD *)(a1 + 424) = v8;
    *(_WORD *)(a1 + 428) = v7;
    *(_WORD *)(a1 + 430) = v7;
    v14 = v13;
    *(_WORD *)(a1 + 396) = 2;
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_1009E7F0(a1 + 392, v17, v16, 2);
    *(_WORD *)(a1 + 426) = v10;
    *(_WORD *)(a1 + 424) = v11;
    *(_WORD *)(a1 + 396) = v12;
    *(_WORD *)(a1 + 428) = v14;
    *(_WORD *)(a1 + 430) = HIWORD(v14);
  }
  return 1;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10064F30) --------------------------------------------------------
char __usercall sub_10064F30@<al>(int a1@<edx>, int a2@<esi>, int a3, int *a4, int a5)
{
  char v5; // bl@1
  int v6; // ecx@5
  int v7; // eax@5
  char result; // al@8
  char v9; // [sp+7h] [bp-15h]@1
  int v10; // [sp+8h] [bp-14h]@5
  char v11; // [sp+Ch] [bp-10h]@5
  char v12; // [sp+Dh] [bp-Fh]@5
  __int16 v13; // [sp+Eh] [bp-Eh]@5
  __int16 v14; // [sp+10h] [bp-Ch]@5
  int v15; // [sp+14h] [bp-8h]@6
  int v16; // [sp+18h] [bp-4h]@5

  v9 = byte_10658E06;
  v5 = *(_BYTE *)(a2 + 3);
  if ( *(_BYTE *)(a2 + 9) || *(_BYTE *)(*(_DWORD *)(a2 + 56) + 237) && v5 )
  {
    *(_BYTE *)(a2 + 3) = 1;
    byte_10658E06 = 1;
  }
  v6 = *(_DWORD *)(a1 + 8);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v7 = 4 * *(_WORD *)(a1 + 2);
  v10 = 75;
  v16 = *(_DWORD *)(v7 + v6);
  if ( (*(_BYTE *)(a3 + 4) & 1) == 1 )
    v15 = *(_DWORD *)(a1 + 4);
  else
    v15 = *(_DWORD *)(v7 + *(_DWORD *)(a1 + 4));
  sub_1006C4E0(a2, (int)&v10, a4, (int)&v11, a5);
  result = v9;
  byte_10658E06 = v9;
  *(_BYTE *)(a2 + 3) = v5;
  return result;
}
// 10658E06: using guessed type char byte_10658E06;

//----- (10064FE0) --------------------------------------------------------
char __cdecl sub_10064FE0(unsigned int a1, int a2, int *a3, int a4, int a5)
{
  char v5; // bl@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // edx@3
  int v9; // ecx@3
  char result; // al@5
  int v11; // eax@6
  __int16 v12; // cx@9
  int v13; // eax@9
  int v14; // eax@9
  int v15; // [sp+8h] [bp-18h]@3
  int v16; // [sp+Ch] [bp-14h]@3
  int v17; // [sp+10h] [bp-10h]@3
  int v18; // [sp+14h] [bp-Ch]@3
  int v19; // [sp+18h] [bp-8h]@3
  int v20; // [sp+1Ch] [bp-4h]@3
  char v21; // [sp+34h] [bp+14h]@3

  v5 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) != 56 )
        goto LABEL_12;
      v6 = *(_DWORD *)(a1 + 56);
      v15 = a2;
      v16 = a4;
      v19 = 76;
      v20 = *(_DWORD *)(v6 + 8);
      sub_10064F30(a4, a1, a2, a3, (int)&unk_100E4624);
      v7 = *(_DWORD *)(a1 + 276);
      v8 = *(_DWORD *)(a1 + 56);
      v9 = *(_DWORD *)(a1 + 280);
      v17 = v7;
      v18 = v9;
      HIWORD(v17) = *(_WORD *)(v8 + 30) + HIWORD(v7);
      HIWORD(v18) = *(_WORD *)(v8 + 30) + HIWORD(v9);
      LOWORD(v17) = *(_WORD *)(v8 + 28) + v7;
      LOBYTE(v7) = *(_BYTE *)(a1 + 3);
      LOWORD(v18) = *(_WORD *)(v8 + 28) + v9;
      *(_BYTE *)(v8 + 237) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      v21 = v7;
      if ( !(*(_BYTE *)(a2 + 4) & 0x10) )
      {
        sub_10064F30(a4, a1, a2, a3, (int)&unk_100E461C);
        *(_BYTE *)(a1 + 3) = v21;
      }
      sub_1006DFD0(a1, 0, (int (__cdecl *)(int))sub_100048C0, 0, (int)&v15);
      result = 2;
      break;
    case 0x8022:
    case 0x8040:
    case 0x8078:
      v11 = *(_WORD *)a4 - 1;
      if ( *(_WORD *)(a4 + 2) < v11 )
        LOWORD(v11) = *(_WORD *)(a4 + 2);
      *(_WORD *)(a4 + 2) = (signed __int16)v11 <= 0 ? 0 : (unsigned __int16)v11;
      sub_10064F30(a4, a1, a2, a3, a5);
      result = 2;
      break;
    case 0x8051:
      v12 = *(_WORD *)(a5 + 10);
      v13 = *(_WORD *)a4;
      *(_WORD *)(a4 + 2) = v12;
      v14 = v13 - 1;
      v5 = 3;
      if ( v12 < v14 )
        LOWORD(v14) = v12;
      *(_WORD *)(a4 + 2) = (signed __int16)v14 <= 0 ? 0 : v14;
      sub_10064F30(a4, a1, a2, a3, (int)&unk_100E461C);
      goto LABEL_12;
    default:
LABEL_12:
      result = v5;
      break;
  }
  return result;
}

//----- (100651F0) --------------------------------------------------------
int __cdecl sub_100651F0(unsigned int a1, unsigned __int8 a2)
{
  int v2; // edx@1
  int v3; // esi@1

  v2 = (unsigned __int8)byte_100DAAAD[28 * a2];
  v3 = (unsigned __int8)byte_100DAAAC[28 * a2];
  return v2 * LOBYTE(dword_1068B4C0[5 * ((a1 >> 10) & 0xF) + 4])
       + v3 * BYTE1(dword_1068B4C0[5 * ((a1 >> 10) & 0xF) + 4])
       + *(_WORD *)(dword_1068B4C4[5 * ((a1 >> 10) & 0xF)] + 28) * (v3 + v2 - 1);
}
// 1068B4C0: using guessed type int dword_1068B4C0[];
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (10065250) --------------------------------------------------------
int __cdecl sub_10065250(int a1, char *a2, char a3)
{
  int v3; // ST10_4@1
  char *v4; // eax@1

  v3 = *(_WORD *)(a1 + 2) % 100;
  v4 = sub_10070850(*((_WORD *)&dbl_100DD6C0 + *(_BYTE *)a1 + 3));
  return sprintf(a2, (&off_100DAAA4)[28 * (unsigned __int8)a3], *(_BYTE *)(a1 + 1), v4, v3);
}
// 100DD6C0: using guessed type double dbl_100DD6C0;

//----- (100652B0) --------------------------------------------------------
int __usercall sub_100652B0@<eax>(int a1@<eax>, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1
  int result; // eax@1

  v2 = *(_DWORD *)(a2 + 56);
  v3 = *(_WORD *)(v2 + 240);
  result = 7 * *(_BYTE *)(a1 + 8);
  if ( v3 == dword_100DAAB0[result] )
    *(_BYTE *)(v2 + 242) = 3;
  else
    *(_BYTE *)(v2 + 242) = (v3 == dword_100DAAB4[result]) + 1;
  return result * 4;
}
// 100DAAB0: using guessed type int dword_100DAAB0[];
// 100DAAB4: using guessed type int dword_100DAAB4[];

//----- (10065300) --------------------------------------------------------
char *__usercall sub_10065300@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int v4; // eax@1
  int v6; // [sp+0h] [bp-4h]@1

  v6 = a1;
  strncpy((char *)&v6, (const char *)(dword_100DAAB4[7 * *(_BYTE *)(a3 + 8)] + *(_DWORD *)(a2 + 56) + 69), 2u);
  BYTE2(v6) = 0;
  v4 = a4 + (unsigned __int8)j__atol((const char *)&v6);
  if ( v4 <= 31 )
  {
    if ( v4 <= 0 )
      v4 = 31;
  }
  else
  {
    v4 = 1;
  }
  sprintf((char *)&v6, "%02u", v4);
  return strncpy((char *)(dword_100DAAB4[7 * *(_BYTE *)(a3 + 8)] + *(_DWORD *)(a2 + 56) + 69), (const char *)&v6, 2u);
}
// 100DAAB4: using guessed type int dword_100DAAB4[];

//----- (100653A0) --------------------------------------------------------
char *__usercall sub_100653A0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  signed int v4; // esi@1
  int v5; // esi@4
  char *v6; // eax@8
  int v8; // [sp+0h] [bp-4h]@1

  v8 = a1;
  strncpy((char *)&v8, (const char *)(dword_100DAAB0[7 * *(_BYTE *)(a3 + 8)] + *(_DWORD *)(a2 + 56) + 69), 3u);
  BYTE3(v8) = 0;
  v4 = 0;
  do
  {
    if ( !strcmp((const char *)&v8, sub_10070850(word_100DD6C8[v4])) )
      break;
    ++v4;
  }
  while ( v4 < 11 );
  v5 = a4 + v4;
  if ( v5 <= 11 )
  {
    if ( v5 < 0 )
      v5 = 11;
  }
  else
  {
    v5 = 0;
  }
  v6 = sub_10070850(word_100DD6C8[v5]);
  return strncpy((char *)(dword_100DAAB0[7 * *(_BYTE *)(a3 + 8)] + *(_DWORD *)(a2 + 56) + 69), v6, 3u);
}
// 100DAAB0: using guessed type int dword_100DAAB0[];
// 100DD6C8: using guessed type __int16 word_100DD6C8[];

//----- (10065480) --------------------------------------------------------
char __usercall sub_10065480@<al>(int a1@<eax>, int a2@<edi>, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  int v5; // ecx@2
  int v6; // ebp@2
  int v7; // eax@2
  int v8; // edx@7
  int v9; // eax@7
  unsigned __int16 *v10; // ebp@8
  char *v11; // eax@10
  bool v12; // zf@12
  bool v13; // sf@12
  unsigned __int8 v14; // of@12
  int v16; // ecx@14
  unsigned __int16 *v17; // ebp@15
  char *v18; // eax@18
  unsigned __int16 *v19; // ebp@25
  char *v20; // eax@29

  v3 = a1;
  v4 = 0;
  if ( *(_BYTE *)(a3 + 14) != 32 )
  {
    v5 = dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)];
    v6 = *(_DWORD *)(a1 + 56);
    v7 = *(_WORD *)(v6 + 240);
    if ( v7 != v5 )
    {
      if ( v7 != v5 + 1 && v7 != v5 + 2 )
        *(_WORD *)(v6 + 240) = dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)];
      v4 = 0;
    }
    *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242) = 1;
    v8 = *(_DWORD *)(v3 + 56);
    v9 = dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)];
    if ( *(_WORD *)(v8 + 240) == v9 )
    {
      v10 = (unsigned __int16 *)&unk_100DD6DE;
      do
      {
        if ( *(_WORD *)(a3 + 14) == (unsigned __int8)*sub_10070850(*v10) )
        {
          v11 = sub_10070850(*v10);
          strncpy((char *)(dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69), v11, 3u);
          ++v4;
        }
        --v10;
      }
      while ( (signed int)v10 >= (signed int)word_100DD6C8 );
      v14 = __OFSUB__(v4, 1);
      v12 = v4 == 1;
      v13 = v4 - 1 < 0;
      if ( v4 == 1 )
      {
        *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = dword_100DAAB8[7 * *(_BYTE *)(a2 + 8)];
        return 2;
      }
    }
    else
    {
      v16 = *(_WORD *)(v8 + 240);
      if ( v16 != v9 + 1 )
      {
        if ( v16 == v9 + 2 )
        {
          v19 = (unsigned __int16 *)&unk_100DD6DE;
          do
          {
            if ( *(_BYTE *)(dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69) == *sub_10070850(*v19)
              && *(_BYTE *)(dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 70) == sub_10070850(*v19)[1]
              && *(_WORD *)(a3 + 14) == (unsigned __int8)sub_10070850(*v19)[2] )
            {
              v20 = sub_10070850(*v19);
              strncpy((char *)(dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69), v20, 3u);
              ++v4;
            }
            --v19;
          }
          while ( (signed int)v19 >= (signed int)word_100DD6C8 );
          if ( v4 == 1 )
            *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = dword_100DAAB8[7 * *(_BYTE *)(a2 + 8)];
        }
        return 2;
      }
      v17 = (unsigned __int16 *)&unk_100DD6DE;
      do
      {
        if ( *(_BYTE *)(dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69) == *sub_10070850(*v17)
          && *(_WORD *)(a3 + 14) == (unsigned __int8)sub_10070850(*v17)[1] )
        {
          v18 = sub_10070850(*v17);
          strncpy((char *)(dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69), v18, 3u);
          ++v4;
        }
        --v17;
      }
      while ( (signed int)v17 >= (signed int)word_100DD6C8 );
      v14 = __OFSUB__(v4, 1);
      v12 = v4 == 1;
      v13 = v4 - 1 < 0;
      if ( v4 == 1 )
      {
        *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = dword_100DAAB8[7 * *(_BYTE *)(a2 + 8)];
        return 2;
      }
    }
    if ( !((unsigned __int8)(v13 ^ v14) | v12) )
    {
      ++*(_WORD *)(*(_DWORD *)(v3 + 56) + 240);
      return 2;
    }
  }
  return 2;
}
// 100DAAB0: using guessed type int dword_100DAAB0[];
// 100DAAB8: using guessed type int dword_100DAAB8[];
// 100DD6C8: using guessed type __int16 word_100DD6C8[];

//----- (10065790) --------------------------------------------------------
char __usercall sub_10065790@<al>(int a1@<edi>, int a2@<esi>, int a3)
{
  int v3; // ebx@1
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // ebp@1
  char result; // al@1
  int v8; // ecx@3
  int v9; // ecx@6
  __int32 v10; // eax@11
  char v11[2]; // [sp+8h] [bp-4h]@10
  char v12; // [sp+Ah] [bp-2h]@10

  v3 = *(_DWORD *)(a2 + 56);
  v4 = *(_WORD *)(v3 + 240);
  v5 = 7 * *(_BYTE *)(a1 + 8);
  v6 = dword_100DAAB8[v5];
  result = 1;
  if ( v4 != v6 && v4 != v6 + 1 )
  {
    v9 = dword_100DAAB4[v5];
    if ( v4 == v9 || v4 == v9 + 1 )
    {
      if ( *(_BYTE *)(v3 + 242) == 2 )
      {
        *(_WORD *)(v9 + v3 + 69) = 12336;
        *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = LOWORD(dword_100DAAB4[7 * *(_BYTE *)(a1 + 8)]) + 1;
        *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 1;
      }
      strncpy(v11, (const char *)(dword_100DAAB4[7 * *(_BYTE *)(a1 + 8)] + *(_DWORD *)(a2 + 56) + 69), 2u);
      v12 = 0;
      if ( v11[0] == 48 )
      {
        v10 = j__atol(v11);
        sprintf(v11, "%02i", 10 * v10);
      }
      v11[*(_WORD *)(*(_DWORD *)(a2 + 56) + 240) - dword_100DAAB4[7 * *(_BYTE *)(a1 + 8)]] = *(_BYTE *)(a3 + 14);
      if ( j__atol(v11) > 31 )
        *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a2 + 56) + 240) + *(_DWORD *)(a2 + 56) + 69) = *(_BYTE *)(a3 + 14);
      else
        *(_WORD *)(dword_100DAAB4[7 * *(_BYTE *)(a1 + 8)] + *(_DWORD *)(a2 + 56) + 69) = *(_WORD *)v11;
      strncpy(v11, (const char *)(dword_100DAAB4[7 * *(_BYTE *)(a1 + 8)] + *(_DWORD *)(a2 + 56) + 69), 2u);
      if ( 10 * j__atol(v11) > 31 )
      {
        *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = dword_100DAAB0[7 * *(_BYTE *)(a1 + 8)];
        *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 3;
      }
      result = 2;
    }
  }
  else
  {
    *(_BYTE *)(*(_WORD *)(v3 + 240) + v3 + 69) = *(_BYTE *)(a3 + 14);
    v8 = *(_DWORD *)(a2 + 56);
    if ( *(_WORD *)(v8 + 240) == dword_100DAAB8[7 * *(_BYTE *)(a1 + 8)] )
      ++*(_WORD *)(v8 + 240);
    *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 1;
    result = 2;
  }
  return result;
}
// 100DAAB0: using guessed type int dword_100DAAB0[];
// 100DAAB4: using guessed type int dword_100DAAB4[];
// 100DAAB8: using guessed type int dword_100DAAB8[];

//----- (100659A0) --------------------------------------------------------
char __usercall sub_100659A0@<al>(int a1@<edi>, int a2@<esi>, int a3, unsigned int *a4)
{
  unsigned int v4; // ecx@1
  bool v5; // zf@1
  char *v6; // eax@7
  char *v7; // edx@7
  char v8; // cl@8
  int *v9; // eax@13
  int v10; // ST1C_4@13
  signed int v11; // eax@13
  unsigned int v12; // ST14_4@13
  int v13; // eax@13
  int v14; // ST0C_4@13
  signed int v15; // eax@13
  int v17; // [sp+8h] [bp-2Ch]@1
  int v18; // [sp+Ch] [bp-28h]@13
  int v19; // [sp+10h] [bp-24h]@13
  int v20; // [sp+14h] [bp-20h]@13
  __int16 v21; // [sp+18h] [bp-1Ch]@11
  int v22; // [sp+1Ah] [bp-1Ah]@13
  int v23; // [sp+20h] [bp-14h]@13
  char v24[12]; // [sp+24h] [bp-10h]@7

  v4 = *a4;
  v5 = byte_100DAABC[28 * *(_BYTE *)(a2 + 8)] == 0;
  LOBYTE(v17) = 13;
  if ( v5 )
  {
    if ( v4 == -1 )
      goto LABEL_7;
    sub_10075A10((int)&v17, v4);
  }
  else if ( !sub_10075D60((int)&v17) )
  {
    LOBYTE(v17) = 13;
    goto LABEL_7;
  }
  if ( (unsigned __int8)v17 <= 0xCu )
  {
    sub_10065250((int)&v17, v24, *(_BYTE *)(a2 + 8));
    goto LABEL_11;
  }
LABEL_7:
  v6 = (&off_100DAAA8)[28 * *(_BYTE *)(a2 + 8)];
  v7 = (char *)(v24 - v6);
  do
  {
    v8 = *v6;
    v6[(_DWORD)v7] = *v6;
    ++v6;
  }
  while ( v8 );
LABEL_11:
  v21 = *(_WORD *)(a2 + 10);
  if ( !v21 )
    v21 = sub_100651F0(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 8));
  v9 = sub_1006D000(*(_DWORD *)(a2 + 4));
  v10 = *(_DWORD *)(a2 + 4);
  v18 = v9[1];
  v11 = sub_1006D040(v10);
  v12 = *(_DWORD *)(a2 + 4);
  v19 = v11;
  v20 = sub_1006D920(v12, 0);
  v13 = sub_1006CFD0(*(_DWORD *)(a2 + 4));
  v14 = *(_DWORD *)(a2 + 4);
  v22 = v13;
  v15 = sub_1006D070(v14);
  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  v23 = v15;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  return sub_1006D8E0(a1, v24, &v18);
}
// 100DAAA8: using guessed type char *off_100DAAA8;
// 100659A0: using guessed type char var_10[12];

//----- (10065B00) --------------------------------------------------------
char __cdecl sub_10065B00(int a1, int a2, int a3, unsigned int *a4, int a5)
{
  int v5; // esi@1
  char v6; // bl@1
  __int16 v7; // cx@2
  unsigned int v8; // esi@3
  int v9; // eax@3
  char result; // al@3
  int v11; // ecx@5
  __int16 v12; // di@5
  signed int v13; // eax@5
  unsigned __int16 v14; // ax@8
  int v15; // edi@11
  char v16; // al@11
  int v17; // eax@18
  int v18; // eax@19
  int v19; // eax@22
  signed int v20; // ebx@23
  int v21; // eax@28
  int v22; // eax@31
  signed __int16 v23; // ax@32
  int v24; // edx@32
  int v25; // ebx@43
  int v26; // esi@43
  int v27; // eax@43
  int v28; // ebx@43
  int v29; // esi@47
  int v30; // esi@50
  unsigned __int16 v31; // ax@53
  int *v32; // eax@61
  int v33; // ST1C_4@61
  signed int v34; // eax@61
  unsigned int v35; // ST14_4@61
  int v36; // eax@61
  unsigned int v37; // ST10_4@61
  const char *v38; // ST04_4@61
  char v39; // al@65
  __int16 j; // bx@66
  int v41; // edx@67
  int v42; // ecx@67
  int v43; // eax@67
  int v44; // eax@69
  int v45; // eax@72
  char *v46; // eax@76
  char v47; // dl@77
  int v48; // esi@78
  char i; // bl@78
  int v50; // edx@79
  int v51; // ecx@79
  int v52; // eax@79
  int v53; // eax@81
  int v54; // eax@84
  unsigned int v55; // ST20_4@88
  int *v56; // eax@88
  int v57; // ST1C_4@88
  int v58; // eax@88
  unsigned int v59; // ST10_4@88
  int v60; // eax@88
  int v61; // ST0C_4@88
  const char *v62; // ST04_4@88
  char v63; // [sp+Ch] [bp-28h]@32
  char v64; // [sp+Eh] [bp-26h]@32
  int v65; // [sp+10h] [bp-24h]@11
  char v66; // [sp+14h] [bp-20h]@23
  char v67; // [sp+17h] [bp-1Dh]@23
  int v68; // [sp+1Ch] [bp-18h]@61
  int v69; // [sp+20h] [bp-14h]@61
  int v70; // [sp+24h] [bp-10h]@61
  __int16 v71; // [sp+28h] [bp-Ch]@59
  int v72; // [sp+2Ah] [bp-Ah]@61
  int v73; // [sp+30h] [bp-4h]@61

  v5 = a5;
  v6 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 10);
      if ( v7 )
      {
        sub_1006DB90(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v7);
        result = 2;
      }
      else
      {
        v8 = *(_DWORD *)(a2 + 4);
        v9 = sub_100651F0(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 8));
        sub_1006DB90(a1 + 276, *(_DWORD *)a3, v8, v9);
        result = 2;
      }
      return result;
    case 0x8048:
      v11 = *(_DWORD *)(a1 + 56);
      v12 = *(_WORD *)(v11 + 240);
      v13 = *(_WORD *)(a5 + 10);
      if ( v12 == -128 )
      {
        if ( v13 != 56 )
        {
          if ( v13 != 0x2000 )
            return v6;
          v14 = *(_WORD *)(a5 + 14);
          if ( (v14 < 0x41u || v14 > 0x5Au) && v14 != 32 )
          {
            if ( v14 < 0x30u || v14 > 0x39u )
              return v6;
            sub_10075A10((int)&v65, *a4);
            v15 = a2;
            sub_10065250((int)&v65, (char *)(*(_DWORD *)(a1 + 56) + 69), *(_BYTE *)(a2 + 8));
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = dword_100DAAB4[7 * *(_BYTE *)(a2 + 8)];
            sub_100652B0(a2, a1);
            v16 = sub_10065790(a2, a1, v5);
          }
          else
          {
            sub_10075A10((int)&v65, *a4);
            v15 = a2;
            sub_10065250((int)&v65, (char *)(*(_DWORD *)(a1 + 56) + 69), *(_BYTE *)(a2 + 8));
            v16 = sub_10065480(a1, a2, v5);
          }
LABEL_57:
          v6 = v16;
          if ( v16 != 4 && v16 != 2 )
            return v6;
          goto LABEL_59;
        }
        sub_10075A10((int)&v65, *a4);
        sub_10065250((int)&v65, (char *)(*(_DWORD *)(a1 + 56) + 69), *(_BYTE *)(a2 + 8));
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
        sub_100652B0(a2, a1);
        v6 = 4;
        v15 = a2;
LABEL_59:
        v71 = *(_WORD *)(v15 + 10);
        if ( !v71 )
          v71 = sub_100651F0(*(_DWORD *)(v15 + 4), *(_BYTE *)(v15 + 8));
        v32 = sub_1006D000(*(_DWORD *)(v15 + 4));
        v33 = *(_DWORD *)(v15 + 4);
        v68 = v32[1];
        v34 = sub_1006D040(v33);
        v35 = *(_DWORD *)(v15 + 4);
        v69 = v34;
        v36 = sub_1006D920(v35, 0);
        v37 = *(_DWORD *)(v15 + 4);
        v70 = v36;
        v72 = sub_1006CFD0(v37);
        v73 = sub_1006D070(*(_DWORD *)(v15 + 4));
        *(_WORD *)(a1 + 438) = *(_WORD *)a3;
        v38 = (const char *)(*(_DWORD *)(a1 + 56) + 69);
        *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
        sub_1006D8E0(a1, v38, &v68);
        return v6;
      }
      if ( v13 > 56 )
      {
        if ( v13 == 57 )
        {
          v39 = *(_BYTE *)(a5 + 8);
          if ( v39 >= 0 )
          {
            if ( v39 <= 0 )
              return v6;
            v46 = (char *)(v11 + 69);
            do
              v47 = *v46++;
            while ( v47 );
            v48 = (int)&v46[-v11 - 70];
            for ( i = (*(_WORD *)(v11 + 240))++; *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v48; ++*(_WORD *)(v50 + 240) )
            {
              v50 = *(_DWORD *)(a1 + 56);
              v51 = *(_WORD *)(v50 + 240);
              v52 = 7 * *(_BYTE *)(a2 + 8);
              if ( v51 == dword_100DAAB0[v52] )
                break;
              if ( v51 == dword_100DAAB4[v52] )
                break;
              v53 = dword_100DAAB8[v52];
              if ( v51 == v53 )
                break;
              if ( v51 == v53 + 1 )
                break;
            }
            v54 = *(_DWORD *)(a1 + 56);
            if ( *(_WORD *)(v54 + 240) >= v48 )
            {
              *(_WORD *)(v54 + 240) = i;
              return 0;
            }
          }
          else
          {
            for ( j = (*(_WORD *)(v11 + 240))--; *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) >= 0; --*(_WORD *)(v41 + 240) )
            {
              v41 = *(_DWORD *)(a1 + 56);
              v42 = *(_WORD *)(v41 + 240);
              v43 = 7 * *(_BYTE *)(a2 + 8);
              if ( v42 == dword_100DAAB0[v43] )
                break;
              if ( v42 == dword_100DAAB4[v43] )
                break;
              v44 = dword_100DAAB8[v43];
              if ( v42 == v44 )
                break;
              if ( v42 == v44 + 1 )
                break;
            }
            v45 = *(_DWORD *)(a1 + 56);
            if ( *(_WORD *)(v45 + 240) < 0 )
            {
              *(_WORD *)(v45 + 240) = (char)j;
              return 0;
            }
          }
          sub_100652B0(a2, a1);
          v15 = a2;
          v6 = 2;
          goto LABEL_59;
        }
        if ( v13 != 0x2000 )
          return v6;
        v31 = *(_WORD *)(a5 + 14);
        if ( (v31 < 0x41u || v31 > 0x5Au) && v31 != 32 )
        {
          if ( v31 < 0x30u || v31 > 0x39u )
            return v6;
          v15 = a2;
          v16 = sub_10065790(a2, a1, a5);
        }
        else
        {
          v15 = a2;
          v16 = sub_10065480(a1, a2, a5);
        }
        goto LABEL_57;
      }
      if ( v13 == 56 )
      {
        v25 = *(_BYTE *)(a5 + 8) < 0;
        LOBYTE(v25) = *(_BYTE *)(a5 + 8) >= 0;
        v26 = dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)];
        v27 = 7 * *(_BYTE *)(a2 + 8);
        v28 = 2 * v25 - 1;
        if ( v12 != v26 && v12 != v26 + 1 && v12 != v26 + 2 )
        {
          v29 = dword_100DAAB4[v27];
          if ( v12 != v29 && v12 != v29 + 1 )
          {
            *(_BYTE *)(v11 + 242) = 1;
            v30 = *(_DWORD *)(a1 + 56);
            v15 = a2;
            *(_BYTE *)(*(_WORD *)(v30 + 240) + v30 + 69) = sub_10071500(
                                                             *(_BYTE *)(*(_WORD *)(v30 + 240) + v30 + 69),
                                                             0x10u,
                                                             v28);
            v6 = 2;
          }
          else
          {
            *(_WORD *)(v11 + 240) = dword_100DAAB4[v27];
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 2;
            sub_10065300(v11, a1, a2, v28);
            v6 = 2;
            v15 = a2;
          }
        }
        else
        {
          v15 = a2;
          *(_WORD *)(v11 + 240) = dword_100DAAB0[v27];
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 3;
          sub_100653A0(v11, a1, a2, v28);
          v6 = 2;
        }
        goto LABEL_59;
      }
      v17 = v13 - 32;
      if ( !v17 )
        goto LABEL_21;
      v18 = v17 - 1;
      if ( v18 )
      {
        if ( v18 != 7 )
          return v6;
LABEL_21:
        *(_WORD *)(v11 + 240) = -128;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
        sub_100659A0(a1, a2, a3, a4);
        return 6;
      }
      *(_WORD *)(v11 + 240) = -128;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
      v19 = dword_100DAAB0[7 * *(_BYTE *)(a2 + 8)];
      v65 = 130416897;
      if ( v19 != -1 )
      {
        strncpy(&v66, (const char *)(v19 + *(_DWORD *)(a1 + 56) + 69), 3u);
        v67 = 0;
        v20 = 11;
        do
        {
          if ( !strcmp(&v66, sub_10070850(word_100DD6C8[v20])) )
            break;
          --v20;
        }
        while ( v20 >= 0 );
        LOBYTE(v65) = 13;
        if ( v20 >= 0 )
          LOBYTE(v65) = v20 + 1;
      }
      v21 = dword_100DAAB4[7 * *(_BYTE *)(a2 + 8)];
      if ( v21 != -1 )
      {
        strncpy((char *)&a5, (const char *)(v21 + *(_DWORD *)(a1 + 56) + 69), 2u);
        BYTE2(a5) = 0;
        BYTE1(v65) = j__atol((const char *)&a5);
        if ( !BYTE1(v65) )
          BYTE1(v65) = 1;
      }
      v22 = dword_100DAAB8[7 * *(_BYTE *)(a2 + 8)];
      if ( v22 == -1 )
      {
        LOWORD(v24) = HIWORD(v65);
      }
      else
      {
        strncpy(&v63, (const char *)(v22 + *(_DWORD *)(a1 + 56) + 69), 2u);
        v64 = 0;
        v23 = j__atol(&v63);
        v24 = (unsigned __int16)v23 % 100 + 1900;
        HIWORD(v65) = (unsigned __int16)v23 % 100 + 1900;
        if ( (unsigned __int16)v24 < 0x7C6u )
        {
          LOWORD(v24) = (unsigned __int16)v23 % 100 + 2000;
          HIWORD(v65) = (unsigned __int16)v23 % 100 + 2000;
        }
      }
      if ( (unsigned __int8)(v65 - 1) > 0xBu
        || (unsigned __int8)(BYTE1(v65) - 1) > 0x1Eu
        || BYTE1(v65) > (unsigned __int8)byte_100F2FA7[(unsigned __int8)v65]
        && (BYTE1(v65) != 29 || (_BYTE)v65 != 2 || (unsigned __int16)v24 % 4) )
      {
        sub_100659A0(a1, a2, a3, a4);
        result = 0;
      }
      else
      {
        sub_10075B40((int *)a4, v65);
        sub_100659A0(a1, a2, a3, a4);
        result = 3;
      }
      return result;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_100659A0(a1, a2, a3, a4);
        return v6;
      }
      v55 = *(_DWORD *)(a2 + 4);
      v71 = 0;
      v56 = sub_1006D000(v55);
      v57 = *(_DWORD *)(a2 + 4);
      v68 = v56[1];
      v69 = sub_1006D040(v57);
      v58 = sub_1006D920(*(_DWORD *)(a2 + 4), 0);
      v59 = *(_DWORD *)(a2 + 4);
      v70 = v58;
      v60 = sub_1006CFD0(v59);
      v61 = *(_DWORD *)(a2 + 4);
      v72 = v60;
      v73 = sub_1006D070(v61);
      *(_WORD *)(a1 + 438) = *(_WORD *)a3;
      v62 = (const char *)(*(_DWORD *)(a1 + 56) + 69);
      *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
      sub_1006D8E0(a1, v62, &v68);
      return 1;
    default:
      return v6;
  }
}
// 100DAAB0: using guessed type int dword_100DAAB0[];
// 100DAAB4: using guessed type int dword_100DAAB4[];
// 100DAAB8: using guessed type int dword_100DAAB8[];
// 100DD6C8: using guessed type __int16 word_100DD6C8[];

//----- (100663E0) --------------------------------------------------------
char __usercall sub_100663E0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, _WORD *a5)
{
  int v5; // esi@1
  int v6; // ST20_4@1
  __int16 v7; // dx@1
  __int16 v8; // ax@1
  __int16 v9; // ax@1
  char v10; // cl@1
  __int16 v11; // bp@6
  signed __int16 v12; // dx@6
  int v13; // esi@6
  _WORD *v14; // esi@10
  __int16 v15; // cx@10
  char v17; // [sp+Bh] [bp-5Dh]@1
  __int16 v18; // [sp+Ch] [bp-5Ch]@10
  __int16 v19; // [sp+Eh] [bp-5Ah]@10
  char v20; // [sp+10h] [bp-58h]@10
  __int16 v21; // [sp+12h] [bp-56h]@10
  __int16 v22; // [sp+14h] [bp-54h]@10
  int v23; // [sp+18h] [bp-50h]@10
  _WORD *v24; // [sp+1Ch] [bp-4Ch]@1
  int v25; // [sp+20h] [bp-48h]@6
  int v26; // [sp+24h] [bp-44h]@1
  int v27; // [sp+28h] [bp-40h]@1
  __int16 v28; // [sp+2Ch] [bp-3Ch]@1
  __int16 v29; // [sp+2Eh] [bp-3Ah]@1
  char v30; // [sp+30h] [bp-38h]@1

  v5 = a1;
  v6 = *(_WORD *)(a4 + 2);
  v24 = a5;
  (*(void (__cdecl **)(int, int, char *))(a1 + 12))(a3, v6, &v30);
  v7 = *(_WORD *)(v5 + 8);
  v8 = *(_WORD *)(v5 + 10);
  v27 = *(_DWORD *)(v5 + 4) | 0x400000;
  v28 = v7;
  v26 = 105;
  v29 = v8;
  sub_10069460(a3, (int)&v26, a2, &v30);
  v9 = *(_WORD *)(a4 + 2);
  v10 = 5;
  v17 = 5;
  if ( !v9 )
    v10 = 0;
  if ( v9 == *(_WORD *)a4 - 1 || !*(_WORD *)a4 )
    v17 = 0;
  v11 = *(_WORD *)a2;
  v12 = *(_WORD *)(v5 + 8) - 1;
  v13 = *(_DWORD *)(v5 + 4) & 0xC000;
  v25 = (unsigned __int16)v12;
  if ( v13 == 0x4000 )
  {
    v11 -= v12;
  }
  else if ( v13 == 0x8000 )
  {
    v11 += v12 / -2;
  }
  v14 = v24;
  v20 = v10 | 0x80;
  v15 = *(_WORD *)(a2 + 2);
  v21 = 0;
  v22 = 0;
  v18 = v11 - 5;
  v19 = v15 + 1;
  v23 = 58;
  sub_10066B70(a3, (int)&v23, (int)&v18, &v20, v24);
  v20 = v17;
  v18 = v25 + v11 + 5;
  return sub_10066B70(a3, (int)&v23, (int)&v18, &v20, v14);
}

//----- (10066540) --------------------------------------------------------
char __cdecl sub_10066540(int a1, int a2, int *a3, int a4, int a5)
{
  char result; // al@1
  int v6; // eax@4
  __int16 v7; // cx@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // eax@4
  __int16 v11; // ax@6
  __int16 v12; // [sp+10h] [bp-D4h]@4
  __int16 v13; // [sp+14h] [bp-D0h]@7
  int v14; // [sp+18h] [bp-CCh]@7
  __int16 v15; // [sp+1Ch] [bp-C8h]@7

  result = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      sub_1006DB90(a1 + 276, *a3, *(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
      goto LABEL_9;
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) != 56 )
        return result;
      v12 = *(_WORD *)(a4 + 2);
      v6 = (signed __int16)(*(_WORD *)(a4 + 2) + *(_BYTE *)(a5 + 8));
      v7 = v6 < 0;
      LOBYTE(v7) = v6 <= 0;
      v8 = v6 & (v7 - 1);
      v9 = *(_WORD *)a4;
      *(_WORD *)(a4 + 2) = v8;
      v10 = v9 - 1;
      if ( v8 < v10 )
        LOWORD(v10) = v8;
      *(_WORD *)(a4 + 2) = v10;
      sub_100663E0(a2, (int)a3, a1, a4, (_WORD *)a5);
      v11 = *(_WORD *)(a4 + 2);
      if ( v12 != v11 )
      {
        v14 = 0;
        v13 = -32738;
        v15 = v11;
        sub_10002670(a1, (int)&v13, 204);
      }
      goto LABEL_9;
    case 0x8022:
    case 0x8078:
      sub_100663E0(a2, (int)a3, a1, a4, (_WORD *)a5);
LABEL_9:
      result = 2;
      break;
    default:
      return result;
  }
  return result;
}

//----- (100666E0) --------------------------------------------------------
char __cdecl sub_100666E0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( !(*(_WORD *)(a2 + 6) & 0x400) )
    {
      *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
      *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
      sub_100A1150(a1 + 392, *(_WORD *)a3, *(_WORD *)(a3 + 2), *(_WORD *)(a2 + 4), 1);
    }
    *(_WORD *)(a1 + 428) = *(_WORD *)a4;
    *(_WORD *)(a1 + 430) = *(_WORD *)a4;
    sub_100A1150(a1 + 392, *(_WORD *)a3, *(_WORD *)(a3 + 2), *(_WORD *)(a2 + 4), 0);
    result = 2;
  }
  return result;
}

//----- (10066790) --------------------------------------------------------
char __cdecl sub_10066790(int a1, int a2, int a3, _WORD *a4, _WORD *a5)
{
  bool v5; // zf@1
  int v6; // edx@1
  unsigned int v7; // eax@2
  __int16 v8; // dx@4
  __int16 v9; // ax@4
  int v11; // [sp+0h] [bp-8h]@1
  int v12; // [sp+4h] [bp-4h]@1

  v5 = *(_WORD *)(a2 + 6) == -1;
  v6 = *(_DWORD *)(a2 + 4);
  v11 = *(_DWORD *)a2;
  v12 = v6;
  if ( v5 )
  {
    HIWORD(v12) = *a4;
    v7 = HIWORD(v12);
  }
  else
  {
    v7 = *(_WORD *)(a2 + 6);
  }
  v8 = word_105728D8[v7 & 0x1F];
  v9 = word_105728D8[(v7 >> 5) & 0x1F];
  LOWORD(a2) = v8;
  HIWORD(a2) = v9;
  return sub_100666E0(a1, (int)&v11, a3, (int)&a2, a5);
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10066810) --------------------------------------------------------
char __cdecl sub_10066810(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // eax@3
  __int16 v6; // dx@6
  bool v7; // zf@6
  char v8; // bl@7
  __int16 v9; // dx@7
  int v10; // eax@7
  char result; // al@7
  __int16 v12; // [sp+10h] [bp-20h]@6
  __int16 v13; // [sp+12h] [bp-1Eh]@6
  int v14; // [sp+14h] [bp-1Ch]@3
  int v15; // [sp+18h] [bp-18h]@6
  int v16; // [sp+1Ch] [bp-14h]@7
  int v17; // [sp+20h] [bp-10h]@7
  __int16 v18; // [sp+24h] [bp-Ch]@7
  __int16 v19; // [sp+26h] [bp-Ah]@7
  __int16 v20; // [sp+28h] [bp-8h]@7

  if ( *(_BYTE *)a4 )
  {
    if ( *(_BYTE *)(a2 + 4) & 1 )
    {
      v14 = 56;
      v5 = BMP_get_bm_def(56);
    }
    else
    {
      v14 = 55;
      v5 = BMP_get_bm_def(55);
    }
  }
  else
  {
    v14 = 57;
    v5 = BMP_get_bm_def(57);
  }
  v6 = *(_WORD *)a3;
  v7 = (*(_BYTE *)(a2 + 4) & 2) == 0;
  v13 = *(_WORD *)(a3 + 2) - *(_WORD *)(v5 + 4);
  v12 = v6;
  v15 = 63;
  if ( v7 )
  {
    sub_1006CC90(a1, (int)&v15, (int)&v12, (unsigned __int16 *)&v14, a5);
    result = 1;
  }
  else
  {
    v8 = *(_BYTE *)(a1 + 3);
    *(_BYTE *)(a1 + 3) = 0;
    sub_1006CC90(a1, (int)&v15, (int)&v12, (unsigned __int16 *)&v14, a5);
    v13 -= 8;
    v12 -= 5;
    *(_BYTE *)(a1 + 3) = v8;
    v9 = *(_WORD *)(a4 + 4);
    v10 = *(_WORD *)(a4 + 6);
    v18 = *(_WORD *)(a4 + 2);
    v19 = v9;
    v16 = v10;
    v17 = 96;
    v20 = -1;
    sub_10069D40(a1, (int)&v17, (int)&v12, &v16, a5);
    result = 1;
  }
  return result;
}
// 1009B1F0: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10066940) --------------------------------------------------------
char __usercall sub_10066940@<al>(unsigned __int16 *a1@<eax>, int a2@<ebx>, int a3@<edi>, unsigned int a4@<esi>, int a5)
{
  char *v5; // ebp@1
  int *v6; // eax@1
  __int16 v7; // cx@1
  signed int v8; // eax@1
  __int16 v9; // dx@1
  int v10; // ecx@1
  int v12; // [sp+4h] [bp-18h]@1
  int v13; // [sp+8h] [bp-14h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  __int16 v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+12h] [bp-Ah]@1
  int v17; // [sp+18h] [bp-4h]@1

  v5 = sub_10070850(*a1);
  v13 = sub_1006D040(a4);
  v14 = sub_1006D920(a4, 0);
  v16 = sub_1006CFD0(a4);
  v6 = sub_1006D000(a4);
  v7 = *(_WORD *)(a5 + 8);
  v12 = *v6;
  v15 = v7;
  v8 = sub_1006D070(a4);
  v9 = *(_WORD *)a2;
  v10 = v12;
  v17 = v8;
  *(_WORD *)(a3 + 438) = v9;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a2 + 2);
  return sub_1006D980(a3, v5, &v12, *(_WORD *)(v10 + 30));
}

//----- (100669D0) --------------------------------------------------------
char __cdecl sub_100669D0(int a1, int a2, int *a3, int a4, _WORD *a5)
{
  int v5; // ebp@1
  char v6; // cl@1
  char v7; // dl@1
  unsigned int v8; // esi@1
  char result; // al@1
  int v10; // edi@2
  int v11; // ecx@3
  int v12; // edx@3
  int v13; // esi@7
  char v14; // bl@9
  char v15; // [sp+14h] [bp+8h]@1

  v5 = a2;
  v6 = (*(_DWORD *)(a2 + 4) >> 5) & 0x1F;
  v7 = *(_BYTE *)(a2 + 4) & 0x1F;
  v8 = *(_DWORD *)(a2 + 4) & 0xFFFFFC00;
  v15 = (*(_DWORD *)(a2 + 4) >> 5) & 0x1F;
  result = 1;
  switch ( *a5 )
  {
    case 0x8015:
      v10 = a4;
      if ( *(_BYTE *)(a4 + 2) )
        return 2;
      v11 = v6 & 0x1F;
      v12 = v7 & 0x1F;
      if ( *(_BYTE *)(a4 + 3) != 1 )
        goto LABEL_14;
      goto LABEL_16;
    case 0x8016:
      v10 = a4;
      if ( !*(_BYTE *)(a4 + 2) )
        goto LABEL_6;
      return 2;
    case 0x8040:
      sub_1006DB90(a1 + 276, *a3, *(_DWORD *)(v5 + 4), *(_WORD *)(v5 + 8));
      return 2;
    case 0x8022:
    case 0x8078:
      v10 = a4;
      v14 = *(_BYTE *)(a4 + 2);
      if ( v14 == 2 )
      {
        v13 = v6 & 0x1F | 32 * (v7 & 0x1F) | v8;
        goto LABEL_17;
      }
      if ( v14 == 1 )
        goto LABEL_15;
      if ( byte_10658E06 )
      {
        v11 = v6 & 0x1F;
        v12 = v7 & 0x1F;
        if ( *(_BYTE *)(a4 + 3) != 1 )
        {
LABEL_14:
          v13 = v11 | 32 * v12 | v8;
          goto LABEL_17;
        }
      }
      else
      {
LABEL_6:
        if ( *(_BYTE *)(v10 + 3) == 1 )
        {
          v13 = v15 & 0x1F | 32 * (v15 & 0x1F) | v8;
          goto LABEL_17;
        }
LABEL_15:
        v11 = v6 & 0x1F;
        v12 = v7 & 0x1F;
      }
LABEL_16:
      v13 = v12 | 32 * v11 | v8;
LABEL_17:
      sub_10066940((unsigned __int16 *)v10, (int)a3, a1, v13, v5);
      return 2;
    default:
      return result;
  }
}
// 10658E06: using guessed type char byte_10658E06;

//----- (10066B70) --------------------------------------------------------
char __cdecl sub_10066B70(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  _BYTE *v5; // ebp@1
  __int16 v6; // ax@1
  __int16 v7; // si@1
  __int16 v8; // di@1
  char result; // al@1
  int v10; // eax@3
  __int16 v11; // ax@6
  __int16 v12; // cx@10
  __int16 v13; // di@16
  char v14; // [sp+Fh] [bp-15h]@1
  __int16 v15; // [sp+10h] [bp-14h]@1
  __int16 v16; // [sp+14h] [bp-10h]@3
  __int16 v17; // [sp+16h] [bp-Eh]@3
  __int16 v18; // [sp+18h] [bp-Ch]@3
  __int16 v19; // [sp+1Ah] [bp-Ah]@3
  __int16 v20; // [sp+1Ch] [bp-8h]@3
  __int16 v21; // [sp+1Eh] [bp-6h]@3
  __int16 v22; // [sp+20h] [bp-4h]@3
  __int16 v23; // [sp+22h] [bp-2h]@3
  int v24; // [sp+30h] [bp+Ch]@13
  bool v25; // [sp+34h] [bp+10h]@1
  unsigned int v26; // [sp+38h] [bp+14h]@3

  v5 = a4;
  v6 = word_105728D8[*a4 & 0x1F];
  v14 = *a4 & 0x60;
  v7 = *(_WORD *)(a3 + 2);
  v25 = (*a4 & 0x80) == -128;
  v8 = *(_WORD *)a3;
  v15 = v6;
  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v10 = sub_100034E0(a1, 56);
    *(_WORD *)(a1 + 428) = v15;
    *(_WORD *)(a1 + 430) = v15;
    *(_WORD *)(a1 + 440) = v15;
    *(_WORD *)(a1 + 442) = v15;
    v19 = v7 - 14;
    v21 = v7 - 7;
    v26 = v10;
    *(_WORD *)(a1 + 396) = 3;
    v17 = v7;
    v23 = v7;
    v16 = v8;
    v18 = v8;
    v20 = v8 + 7 * (2 * (v25 == 0) - 1);
    v22 = v8;
    sub_1009ED40(a1 + 392, 4, (int)&v16, 56, v10);
    if ( v14 == 32 || v14 == 64 )
    {
      v11 = v25 ? v8 : v8 - *((_WORD *)v5 + 1) + 2;
      sub_1009E590(a1 + 392, v11, v7 - 9, *((_WORD *)v5 + 1) - 2, 5, 3);
      if ( v14 == 64 )
      {
        if ( v25 )
          v12 = v8 + *((_WORD *)v5 + 1) - 5;
        else
          v12 = v8 - *((_WORD *)v5 + 1);
        sub_1009E590(a1 + 392, v12, v7 - *((_WORD *)v5 + 2) + 2, 5, *((_WORD *)v5 + 2) - 8, 3);
        sub_1009E590(a1 + 392, v8 - *((_WORD *)v5 + 1) + 2, v7 - *((_WORD *)v5 + 2), *((_WORD *)v5 + 1) + 5, 5, 3);
        if ( v25 )
          v24 = (unsigned __int16)(v8 + *((_WORD *)v5 + 1) - 2);
        else
          v24 = (unsigned __int16)(v8 - *((_WORD *)v5 + 1) + 1);
        sub_100A1BD0(a1 + 392, v24, v7 - 6);
        sub_100A1BD0(a1 + 392, v24, v7 - *((_WORD *)v5 + 2) + 1);
        if ( v25 )
          v13 = v8 + *((_WORD *)v5 + 1) - 6;
        else
          v13 = v8 - *((_WORD *)v5 + 1) + 5;
        sub_100A1BD0(a1 + 392, v13, v7 - 10);
        sub_100A1BD0(a1 + 392, v13, v7 - *((_WORD *)v5 + 2) + 5);
      }
    }
    sub_10003450(a1, v26);
    result = 2;
  }
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10066DF0) --------------------------------------------------------
int __usercall sub_10066DF0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int result; // eax@2

  if ( dword_100DCCD8[4 * ((*(_BYTE *)(a1 + 8) & 0x3F) - 38)] != 360
    || (result = *(_DWORD *)(a2 + 56), *(_WORD *)(result + 240)) )
  {
    result = *(_DWORD *)(a2 + 56);
    *(_BYTE *)(result + 242) = 1;
  }
  else
  {
    *(_BYTE *)(result + 242) = 2;
  }
  return result;
}
// 100DCCD8: using guessed type int dword_100DCCD8[];

//----- (10066E30) --------------------------------------------------------
char *__usercall sub_10066E30@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebx@1
  __int16 v4; // bp@1
  signed int v5; // edi@1
  int v6; // esi@1
  __int32 v7; // ecx@1
  __int32 v8; // eax@2
  __int32 v9; // ebp@2
  char v11; // [sp+10h] [bp-8h]@1
  char v12; // [sp+11h] [bp-7h]@1
  char v13[4]; // [sp+14h] [bp-4h]@1
  __int32 v14; // [sp+1Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_BYTE *)(a1 + 8) & 0x3F;
  v5 = 10 * (signed int)flt_100DCCDC[4 * ((*(_BYTE *)(a1 + 8) & 0x3F) - 38)];
  strncpy(
    v13,
    (const char *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240) + *(_DWORD *)(v3 + 56) + 69),
    *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242));
  v13[*(_BYTE *)(*(_DWORD *)(v3 + 56) + 242)] = 0;
  v6 = a3 + (unsigned __int16)j__atol(v13);
  v11 = *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240)
                 + *(_DWORD *)(v3 + 56)
                 + *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242)
                 + 69);
  v12 = 0;
  v7 = j__atol(&v11);
  v14 = v7;
  if ( v4 == 41 )
  {
    v11 = *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240)
                   + *(_DWORD *)(v3 + 56)
                   + *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242)
                   + 71);
    v8 = j__atol(&v11);
    v7 = v14;
    v9 = v8;
  }
  else
  {
    v9 = 0;
  }
  if ( 100 * v6 > v5 || v9 + 10 * (v7 + 10 * v6) > v5 )
  {
    v6 = 0;
  }
  else if ( v6 < 0 )
  {
    v6 = v5 / 100;
    if ( v9 + 10 * (v7 + 10 * (v5 / 100)) > v5 )
      --v6;
  }
  sprintf(v13, "%0*u", *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242), v6);
  return strncpy(
           (char *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240) + *(_DWORD *)(v3 + 56) + 69),
           v13,
           *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242));
}
// 100DCCDC: using guessed type float flt_100DCCDC[];
// 10066E30: using guessed type char var_4[4];

//----- (10066FA0) --------------------------------------------------------
int __fastcall sub_10066FA0(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1

  v2 = 5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF);
  v3 = (unsigned __int8)byte_100DCCE1[16 * ((*(_BYTE *)(a2 + 8) & 0x3F) - 38)];
  return v3 * BYTE1(dword_1068B4C0[v2 + 4]) + (v3 - 1) * *(_WORD *)(dword_1068B4C4[v2] + 28);
}
// 1068B4C0: using guessed type int dword_1068B4C0[];
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (10066FF0) --------------------------------------------------------
char __usercall sub_10066FF0@<al>(int a1@<eax>, int a2@<ecx>)
{
  unsigned __int16 v2; // ax@1

  v2 = *(_BYTE *)(a1 + 8) & 0x3F;
  if ( dword_100DCCD8[4 * (v2 - 38)] != 360 || *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) != 1 )
  {
    if ( v2 == 41 )
    {
      if ( *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) != 3 )
        return 1;
    }
    else if ( v2 != 42 || *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) != 3 )
    {
      return 1;
    }
  }
  return 0;
}
// 100DCCD8: using guessed type int dword_100DCCD8[];

//----- (10067050) --------------------------------------------------------
char __usercall sub_10067050@<al>(int a1@<esi>, int a2, int a3)
{
  __int16 v3; // bx@1
  int v4; // ecx@1
  char *v5; // edi@1
  int v6; // eax@1
  int v7; // edx@1
  bool v8; // zf@3
  int v9; // ecx@3
  const char *v10; // ebp@4
  int v11; // eax@4
  __int32 v12; // eax@8
  float v13; // ST24_4@9
  float v14; // ST2C_4@9
  float v15; // ST24_4@9
  int v16; // eax@13
  int i; // edi@16
  int v19; // ecx@20
  signed int v20; // eax@20
  int v21; // [sp+4h] [bp-20h]@8
  char v22; // [sp+17h] [bp-Dh]@1
  signed int v23; // [sp+1Ch] [bp-8h]@3

  v3 = *(_BYTE *)(a2 + 8) & 0x3F;
  v4 = *(_BYTE *)(a2 + 8) & 0x3F;
  v5 = &byte_100DCCE1[16 * (v4 - 38)];
  v6 = (unsigned __int8)*v5;
  v22 = 0;
  v7 = v6 + 1;
  if ( v3 != 42 )
    v7 = v6 - 1;
  v8 = v4 == 41;
  v9 = *(_DWORD *)(a1 + 56);
  v23 = v7;
  if ( v8 )
  {
    v10 = "%0*.1f";
    v11 = v6 - 3;
  }
  else
  {
    v10 = "%0*d";
    v11 = v6 - 1;
  }
  if ( *(_WORD *)(v9 + 240) == v11 && *(_BYTE *)(v9 + 69) == 48 )
  {
    v22 = 1;
    v12 = j__atol((const char *)(v9 + 69));
    if ( v3 == 41 )
    {
      v13 = (double)v12 * 10.0;
      v14 = atof((const char *)(*(_DWORD *)(a1 + 56) + 72));
      v15 = v14 + v13;
      sprintf((char *)(*(_DWORD *)(a1 + 56) + 69), v10, (unsigned __int8)*v5, v15);
    }
    else
    {
      sprintf((char *)(*(_DWORD *)(a1 + 56) + 69), v10, (unsigned __int8)*v5, 10 * v12, v21);
    }
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = *(_BYTE *)(a3 + 14);
  if ( !v22 )
    goto LABEL_16;
  if ( v3 == 39 )
  {
    v16 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(v16 + 70) == 48 )
    {
      *(_BYTE *)(v16 + 242) = 1;
      return 2;
    }
    goto LABEL_16;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 69) != 48 )
  {
LABEL_16:
    ++*(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
    for ( i = *(_DWORD *)(a1 + 56); *(_WORD *)(i + 240) < v23; i = *(_DWORD *)(a1 + 56) )
    {
      if ( sub_10066FF0(a2, a1) )
        break;
      if ( *(_BYTE *)(i + 242) == 2 )
        break;
      ++*(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
    }
    v19 = *(_DWORD *)(a1 + 56);
    v20 = *(_WORD *)(v19 + 240);
    if ( v20 >= v23 )
      LOBYTE(v20) = v23;
    *(_WORD *)(v19 + 240) = (char)v20;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
  return 2;
}

//----- (100671E0) --------------------------------------------------------
char __thiscall sub_100671E0(int this)
{
  char result; // al@1

  result = *(_BYTE *)(this + 1);
  if ( result == 69 )
  {
    *(_BYTE *)(this + 1) = 87;
  }
  else if ( result == 87 )
  {
    *(_BYTE *)(this + 1) = 69;
  }
  return result;
}

//----- (10067200) --------------------------------------------------------
int __usercall sub_10067200@<eax>(int a1@<ecx>, int *a2@<ebx>, int a3@<edi>, int *a4@<esi>, _BYTE *a5, char a6)
{
  int *v6; // eax@3
  int result; // eax@4

  if ( a6 )
  {
    *a4 = 0;
  }
  else
  {
    v6 = sub_1006D000(*(_DWORD *)(a3 + 4));
    *a4 = sub_1009DA50(v6[1], a5, 0);
  }
  result = *(_WORD *)(a3 + 10) - *a4;
  *a2 = result;
  if ( *a4 > 0 )
  {
    a1 = dword_1068B4C4[5 * ((*(_DWORD *)(a3 + 4) >> 10) & 0xF)];
    result -= *(_WORD *)(a1 + 28);
    *a2 = result;
  }
  if ( !*(_WORD *)(a3 + 10) )
  {
    result = sub_10066FA0(a1, a3);
    *a2 = result;
  }
  return result;
}
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (10067270) --------------------------------------------------------
int __usercall sub_10067270@<eax>(_WORD *a1@<edx>, int a2@<ecx>, int a3, char a4, char *a5, int a6, int a7, int a8)
{
  double v8; // st7@1
  __int16 v9; // ax@1
  double v10; // st7@1
  bool v11; // c0@1
  unsigned __int16 v12; // bp@1
  _WORD *v13; // edi@1
  int *v14; // esi@1
  float v15; // ST10_4@3
  double v16; // st7@3
  double v17; // st7@8
  __int16 v18; // cx@11
  char *v19; // edi@13
  char v20; // al@14
  char *v21; // eax@18
  char v22; // cl@19
  char *v23; // edi@25
  char v24; // al@26
  int v25; // ecx@27
  char *v26; // eax@29
  char v27; // cl@30
  char *v28; // edi@33
  char v29; // al@34
  unsigned int v30; // eax@48
  unsigned __int8 v31; // al@51
  char *v32; // eax@43
  int v33; // ecx@43
  _BYTE *v34; // esi@56
  _BYTE *v35; // edx@56
  char v36; // cl@57
  int *v37; // ebx@58
  int result; // eax@58
  const char *v39; // ebp@61
  unsigned int v40; // eax@61
  char *v41; // edi@61
  char v42; // cl@62
  int *v43; // eax@63
  char v44; // [sp+1Bh] [bp-39h]@1
  signed int v45; // [sp+1Ch] [bp-38h]@8
  char v46; // [sp+1Ch] [bp-38h]@43
  bool v47; // [sp+23h] [bp-31h]@1
  int v48; // [sp+24h] [bp-30h]@1
  _WORD *v49; // [sp+28h] [bp-2Ch]@1
  int v50; // [sp+2Ch] [bp-28h]@1
  int *v51; // [sp+30h] [bp-24h]@1
  int *v52; // [sp+34h] [bp-20h]@1
  char *v53; // [sp+38h] [bp-1Ch]@1
  char v54[8]; // [sp+3Ch] [bp-18h]@1
  char v55[2]; // [sp+44h] [bp-10h]@11

  v8 = *(float *)a3;
  v9 = *(_WORD *)(a2 + 8);
  v50 = a2;
  *(float *)&v48 = v8;
  v10 = *(float *)&v48;
  v11 = *(float *)&v48 < -3.141592741012573;
  *(_DWORD *)v54 = a1;
  v52 = (int *)a6;
  v12 = v9 & 0x3F;
  v51 = (int *)a7;
  v13 = (_WORD *)a8;
  *(_WORD *)a8 = v9;
  v14 = &dword_100DCCD8[4 * ((v9 & 0x3F) - 38)];
  v53 = a5;
  v49 = (_WORD *)a8;
  v47 = 0;
  v44 = 0;
  if ( v11 || v10 >= 3.141592741012573 )
  {
    if ( v12 == 41 )
      strncpy(a5, "___._", *((_BYTE *)v14 + 9));
    else
      strncpy(a5, "____", *((_BYTE *)v14 + 9));
    a5[*((_BYTE *)v14 + 9)] = 0;
    v47 = 1;
    goto LABEL_40;
  }
  v15 = v10;
  sub_1007A5E0((int)&v48, v15);
  v16 = *(float *)&v48;
  if ( *(float *)&v48 > 180.0 )
  {
    if ( v12 == 42 || v12 == 43 )
    {
      v44 = 1;
      *(float *)&v48 = 360.0 - v16;
      v16 = *(float *)&v48;
    }
    else if ( v12 == 39 )
    {
      *(float *)&v48 = v16 - 360.0 - 1.0;
      v16 = *(float *)&v48;
LABEL_8:
      v17 = v16 + 0.5;
      v45 = (signed int)v17;
      if ( !*((_BYTE *)v14 + 8) && !(signed int)v17 )
        v45 = 360;
      goto LABEL_11;
    }
  }
  if ( v12 != 41 )
    goto LABEL_8;
  *(float *)&v45 = v16;
  if ( v16 < 0.1000000014901161 )
    *(float *)&v45 = 360.0;
LABEL_11:
  v18 = *(_WORD *)a8;
  strcpy(v55, "%");
  if ( v18 & 0x40 && v12 == 39 )
  {
    v19 = &v54[7];
    do
      v20 = (v19++)[1];
    while ( v20 );
    *(_WORD *)v19 = 43;
  }
  if ( v18 & 0x100 )
  {
    if ( v12 != 41 )
    {
      v23 = &v54[7];
      do
        v24 = (v23++)[1];
      while ( v24 );
      v25 = *((_BYTE *)v14 + 9);
      *(_DWORD *)v23 = 6564400;
      sprintf(a5, v55, v25, v45);
      goto LABEL_36;
    }
    v21 = &v54[7];
    do
      v22 = (v21++)[1];
    while ( v22 );
    *(_DWORD *)v21 = 825109040;
    *((_WORD *)v21 + 2) = 102;
  }
  else
  {
    if ( v12 != 41 )
    {
      v28 = &v54[7];
      do
        v29 = (v28++)[1];
      while ( v29 );
      *(_WORD *)v28 = 100;
      sprintf(a5, v55, v45);
      goto LABEL_36;
    }
    v26 = &v54[7];
    do
      v27 = (v26++)[1];
    while ( v27 );
    *(_DWORD *)v26 = 1714499114;
    v26[4] = 0;
  }
  sprintf(a5, v55, *((_BYTE *)v14 + 9), v45);
LABEL_36:
  if ( *(float *)&v45 == 0.0 || v45 == 180 )
    v47 = v12 != 42;
  v13 = v49;
LABEL_40:
  if ( a4 && v47 && (unsigned int)v12 - 42 <= 1 )
  {
    v46 = 5;
    v32 = sub_100793A0(5u);
  }
  else
  {
    v30 = *v13;
    if ( v30 & 0x200 )
    {
      v46 = 31;
      v32 = sub_100793A0(0x1Fu);
    }
    else
    {
      if ( v12 == 42 )
      {
        v31 = v44 != 0 ? 9 : 6;
      }
      else if ( v12 == 43 )
      {
        v31 = (v44 == 0) + 7;
      }
      else
      {
        v31 = sub_10079420(v30, 0);
      }
      v46 = v31;
      v32 = sub_100793A0(v31);
    }
  }
  v34 = *(_BYTE **)v54;
  v35 = *(_BYTE **)v54;
  do
  {
    v36 = *v32;
    *v35++ = *v32++;
  }
  while ( v36 );
  v37 = v52;
  LOBYTE(v33) = (*v13 & 0x200) == 512;
  result = sub_10067200(v33, v52, v50, v51, v34, v33);
  if ( v12 == 43 && v46 == 7 && !(*v49 & 0x200) )
  {
    v39 = v53;
    **(_WORD **)v54 = 145;
    strcpy(v54, "");
    v40 = strlen(v39) + 1;
    v41 = (char *)&v53 + 3;
    do
      v42 = (v41++)[1];
    while ( v42 );
    qmemcpy(v41, v39, v40);
    strcpy((char *)v39, v54);
    v43 = sub_1006D000(*(_DWORD *)(v50 + 4));
    result = sub_1009DA50(v43[1], "", 0);
    *v51 -= result;
    *v37 += result;
  }
  return result;
}
// 100DCCD8: using guessed type int dword_100DCCD8[];

//----- (100676A0) --------------------------------------------------------
char __usercall sub_100676A0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  __int16 v4; // dx@1
  __int16 v5; // ST18_2@1
  __int16 v6; // dx@1
  char v8; // [sp+0h] [bp-1Ch]@1
  int v9; // [sp+4h] [bp-18h]@1
  int v10; // [sp+8h] [bp-14h]@1
  int v11; // [sp+Ch] [bp-10h]@1
  char v12; // [sp+10h] [bp-Ch]@1

  sub_10067270(&v8, a2, a4, 1, &v12, (int)&v10, (int)&v9, (int)&v11);
  v4 = v11;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  v5 = v4;
  v6 = v10;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  return sub_1006DCF0(a3, &v12, &v8, v6, v9, *(_DWORD *)(a2 + 4), v5);
}

//----- (10067720) --------------------------------------------------------
char __cdecl sub_10067720(int a1, int a2, _WORD *a3, int *a4, int a5)
{
  int v5; // eax@1
  __int16 v6; // ax@2
  int v7; // edx@2
  int v8; // edx@6
  __int16 v9; // ax@7
  int v10; // eax@8
  __int16 v11; // cx@8
  int v12; // ecx@10
  int v13; // eax@10
  int v14; // esi@10
  __int16 v15; // cx@10
  int v16; // esi@10
  unsigned __int16 v17; // cx@12
  int v18; // esi@14
  int v19; // ecx@15
  int v20; // edx@15
  int v21; // ecx@15
  int v22; // esi@19
  int v23; // edx@23
  int v24; // ecx@23
  int v25; // edx@26
  int v26; // ecx@26
  int v27; // ecx@28
  int v28; // eax@30
  int v29; // edx@30
  int v30; // ecx@30
  int v31; // esi@36
  int v32; // edx@37
  int v33; // eax@37
  signed int v34; // edx@41
  int v35; // edx@43
  int v36; // esi@45
  _WORD *v37; // ebx@55
  char v38; // al@58
  int v39; // eax@59
  int v40; // esi@61
  int v41; // esi@63
  int v42; // esi@67
  int v43; // esi@70
  char v44; // al@70
  unsigned __int16 v45; // cx@75
  _WORD *v46; // eax@80
  _BYTE *v47; // ST1C_4@80
  char v48; // dl@90
  int v49; // esi@97
  int v50; // esi@98
  int v51; // ecx@106
  char v53; // [sp+17h] [bp-31h]@1
  int v54; // [sp+18h] [bp-30h]@2
  int v55; // [sp+1Ch] [bp-2Ch]@10
  int v56; // [sp+20h] [bp-28h]@2
  int v57; // [sp+24h] [bp-24h]@15
  int v58; // [sp+28h] [bp-20h]@15
  int v59; // [sp+2Ch] [bp-1Ch]@15
  int v60; // [sp+30h] [bp-18h]@2
  int v61; // [sp+34h] [bp-14h]@10
  _WORD *v62; // [sp+38h] [bp-10h]@1
  char v63; // [sp+3Ch] [bp-Ch]@2

  v5 = *(_WORD *)a5;
  v62 = a3;
  v53 = 1;
  switch ( v5 )
  {
    case 32832:
      sub_10067270(&v63, a2, (int)a4, 0, &v63, (int)&v54, (int)&v56, (int)&v60);
      v6 = *(_WORD *)(a2 + 10);
      v7 = v54;
      if ( v6 )
        v7 = v6;
      sub_1006DB90(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v7);
      if ( !*(_WORD *)(a2 + 10) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000 )
      {
        v8 = v56;
        if ( v56 > 0 )
        {
          v9 = *(_WORD *)(dword_1068B4C4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
          *(_WORD *)(a1 + 280) += v56 + v9;
          if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
          {
            v10 = (v9 + v8 + 1) / 2;
            v11 = *(_WORD *)(a1 + 280) - v10;
            *(_WORD *)(a1 + 276) -= v10;
            *(_WORD *)(a1 + 280) = v11;
          }
        }
      }
      return 2;
    case 32840:
      v12 = *(_WORD *)(a2 + 8) & 0x3F;
      v60 = *(_WORD *)(a2 + 8) & 0xFDFF;
      v13 = *(_DWORD *)(a1 + 56);
      v14 = (unsigned __int16)v12;
      v61 = v12;
      v15 = *(_WORD *)(v13 + 240);
      v16 = v14 - 38;
      v55 = v16;
      if ( v15 == -128 )
      {
        if ( *(_WORD *)(a5 + 10) == 0x2000 )
        {
          v17 = *(_WORD *)(a5 + 14);
          if ( v17 >= 0x30u && v17 <= 0x39u && (v18 = 16 * v16, byte_100DCCE2[v18]) )
          {
            v19 = *(_DWORD *)(a2 + 4);
            v57 = *(_DWORD *)a2;
            v20 = *(_DWORD *)(a2 + 8);
            v58 = v19;
            v59 = v20;
            LOWORD(v59) = v20 | 0x100;
            sub_10067270(
              (_WORD *)(v13 + 75),
              (int)&v57,
              (int)a4,
              0,
              (char *)(v13 + 69),
              (int)&v54,
              (int)&v56,
              (int)&v60);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, (unsigned __int8)byte_100DCCE1[v18]);
            v21 = *(_DWORD *)(a1 + 56);
            if ( (_WORD)v61 == 41 )
            {
              *(_BYTE *)(v21 + 72) = 46;
              *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 2;
            }
            else
            {
              *(_WORD *)(v21 + 240) = (unsigned __int8)byte_100DCCE1[v18] - 1;
            }
            v53 = sub_10067050(a1, a2, a5);
          }
          else
          {
            v22 = 16 * v55;
            if ( byte_100DCCE2[16 * v55] && (_WORD)v61 == 42 && (v17 == 69 || v17 == 87) )
            {
              v23 = *(_DWORD *)(a2 + 4);
              v57 = *(_DWORD *)a2;
              v24 = *(_DWORD *)(a2 + 8);
              v58 = v23;
              v59 = v24;
              LOWORD(v59) = v24 | 0x100;
              sub_10067270(
                (_WORD *)(v13 + 75),
                (int)&v57,
                (int)a4,
                0,
                (char *)(v13 + 69),
                (int)&v54,
                (int)&v56,
                (int)&v60);
              memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, (unsigned __int8)byte_100DCCE1[v22]);
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) = *(_BYTE *)(a5 + 14);
              *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (unsigned __int8)byte_100DCCE1[v22] - 1;
            }
            else if ( v17 == 46 && (_WORD)v61 == 41 )
            {
              v25 = *(_DWORD *)(a2 + 4);
              v57 = *(_DWORD *)a2;
              v26 = *(_DWORD *)(a2 + 8);
              v58 = v25;
              v59 = v26;
              LOWORD(v59) = v26 | 0x100;
              sub_10067270(
                (_WORD *)(v13 + 75),
                (int)&v57,
                (int)a4,
                0,
                (char *)(v13 + 69),
                (int)&v54,
                (int)&v56,
                (int)&v60);
              memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, (unsigned __int8)byte_100DCCE1[v22]);
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 72) = 46;
              *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 4;
            }
          }
          v16 = v55;
        }
        HIWORD(v27) = HIWORD(a5);
        if ( *(_WORD *)(a5 + 10) == 56 )
        {
          if ( byte_100DCCE2[16 * v16] )
          {
            v28 = *(_DWORD *)a2;
            v29 = *(_DWORD *)(a2 + 8);
            v55 = *a4;
            v30 = *(_DWORD *)(a2 + 4);
            v57 = v28;
            v59 = v29;
            LOWORD(v59) = v29 | 0x100;
            v58 = v30;
            if ( *(float *)&v55 == 6.283185482025146 || 9.8999998e24 == *(float *)&v55 )
              *(float *)&v55 = 0.0;
            sub_10067270(
              (_WORD *)(*(_DWORD *)(a1 + 56) + 75),
              (int)&v57,
              (int)&v55,
              0,
              (char *)(*(_DWORD *)(a1 + 56) + 69),
              (int)&v54,
              (int)&v56,
              (int)&v60);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
            sub_10066DF0(a2, a1);
            v53 = 4;
          }
          else
          {
            v53 = 0;
          }
        }
        if ( *(_WORD *)(a5 + 10) == 32 )
        {
          v31 = 16 * v16;
          if ( byte_100DCCE2[v31] )
          {
            v32 = *(_DWORD *)(a2 + 8);
            v33 = *(_DWORD *)a2;
            v58 = *(_DWORD *)(a2 + 4);
            v59 = v32;
            LOWORD(v59) = v32 | 0x100;
            v57 = v33;
            sub_10067270(
              (_WORD *)(*(_DWORD *)(a1 + 56) + 75),
              (int)&v57,
              (int)a4,
              0,
              (char *)(*(_DWORD *)(a1 + 56) + 69),
              (int)&v54,
              (int)&v56,
              (int)&v60);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, (unsigned __int8)byte_100DCCE1[v31]);
            if ( (_WORD)v61 == 41 )
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 72) = 46;
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
            sub_10066DF0(a2, a1);
            sub_100676A0((int)v62, a2, a1, (int)a4);
            v53 = 4;
            goto LABEL_80;
          }
          return 0;
        }
        goto LABEL_78;
      }
      v34 = *(_WORD *)(a5 + 10);
      if ( v34 <= 56 )
      {
        if ( v34 != 56 )
        {
          v35 = v34 - 32;
          if ( v35 )
          {
            if ( v35 == 1 )
            {
              *(_WORD *)(v13 + 240) = -128;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
              *(float *)&v54 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
              v36 = 4 * ((*(_BYTE *)(a2 + 8) & 0x3F) - 38);
              v55 = SLODWORD(flt_100DCCDC[v36]);
              if ( *(float *)&v55 <= (double)*(float *)&v54 )
                v54 = v55;
              if ( 0.0 == *(float *)&v54 && !byte_100DCCE0[v36 * 4] )
                v54 = SLODWORD(flt_100DCCDC[v36]);
              if ( *(float *)&v54 >= 360.0 )
                *(float *)&v54 = 0.0;
              sub_1007A610((int)a4, *(float *)&v54);
              if ( !strcmp((const char *)(*(_DWORD *)(a1 + 56) + 75), &byte_100DCCE3[v36 * 4]) )
                *(float *)a4 = *(float *)a4 * -1.0;
              *(float *)a4 = sub_100A72C0(*(float *)a4);
              sub_100676A0((int)v62, a2, a1, (int)a4);
              v53 = 3;
            }
          }
          else
          {
            *(_WORD *)(v13 + 240) = -128;
            v37 = v62;
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
            sub_100676A0((int)v37, a2, a1, (int)a4);
            v53 = 6;
          }
          return v53;
        }
        if ( v15 == 1 )
          v15 = 0;
        *(_WORD *)(v13 + 240) = v15;
        sub_10066DF0(a2, a1);
        v38 = *(_BYTE *)(a5 + 8);
        if ( v38 >= 0 )
        {
          if ( v38 <= 0 )
            goto LABEL_72;
          v39 = *(_DWORD *)(a1 + 56);
          if ( *(_BYTE *)(v39 + 242) > 1 )
          {
            sub_10066E30(a2, v27, 1);
            v53 = 2;
            goto LABEL_80;
          }
          v42 = 4 * v16;
          if ( *(_WORD *)(v39 + 240) < (signed __int16)(unsigned __int8)byte_100DCCE1[v42 * 4] )
          {
            *(float *)&v55 = COERCE_FLOAT(j__atol((const char *)(v39 + 69)));
            if ( flt_100DCCDC[v42] == (double)v55 )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 48;
              v53 = 2;
            }
            else
            {
              v43 = *(_DWORD *)(a1 + 56);
              v44 = sub_10071500(*(_BYTE *)(*(_WORD *)(v43 + 240) + v43 + 69), 0x10u, 1);
              v27 = *(_WORD *)(v43 + 240);
              *(_BYTE *)(v27 + v43 + 69) = v44;
              v53 = 2;
            }
            goto LABEL_80;
          }
        }
        else
        {
          v39 = *(_DWORD *)(a1 + 56);
          if ( *(_BYTE *)(v39 + 242) > 1 )
          {
            sub_10066E30(a2, v27, -1);
            v53 = 2;
            goto LABEL_80;
          }
          v40 = 4 * v16;
          if ( *(_WORD *)(v39 + 240) < (signed __int16)(unsigned __int8)byte_100DCCE1[v40 * 4] )
          {
            *(float *)&v55 = COERCE_FLOAT(j__atol((const char *)(v39 + 69)));
            if ( flt_100DCCDC[v40] != (double)v55 )
            {
              v41 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v41 + 240) + v41 + 69) = sub_10071500(
                                                               *(_BYTE *)(*(_WORD *)(v41 + 240) + v41 + 69),
                                                               0x10u,
                                                               -1);
              v53 = 2;
              goto LABEL_80;
            }
LABEL_72:
            v53 = 2;
            goto LABEL_80;
          }
        }
        sub_100671E0(v39 + 75);
        goto LABEL_72;
      }
      if ( v34 == 57 )
      {
        if ( v15 != 1 )
        {
          v48 = *(_BYTE *)(a5 + 8);
          if ( v48 < 0 )
          {
            if ( v15 )
            {
              --*(_WORD *)(v13 + 240);
              for ( ; *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) >= 0; --*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) )
              {
                if ( sub_10066FF0(a2, a1) )
                  break;
              }
            }
            v53 = 2;
            sub_10066DF0(a2, a1);
            goto LABEL_80;
          }
          if ( v48 <= 0 )
            return v53;
          v49 = (unsigned __int8)byte_100DCCE1[16 * v16];
          if ( (_WORD)v61 == 42 )
            v50 = v49 + 1;
          else
            v50 = v49 - 1;
          if ( v15 < v50 )
          {
            ++*(_WORD *)(v13 + 240);
            for ( ; *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v50; ++*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) )
            {
              if ( sub_10066FF0(a2, a1) )
                break;
            }
            sub_10066DF0(a2, a1);
            v53 = 2;
            goto LABEL_80;
          }
          return 0;
        }
        *(_WORD *)(v13 + 240) = *(_BYTE *)(a5 + 8) < 0 ? 0 : 2;
        sub_10066DF0(a2, a1);
        v53 = 2;
LABEL_80:
        v46 = v62;
        LOWORD(v27) = *v62;
        *(_WORD *)(a1 + 438) = *v62;
        v47 = (_BYTE *)(*(_DWORD *)(a1 + 56) + 75);
        *(_WORD *)(a1 + 436) = v46[1];
        sub_10067200(v27, &v54, a2, &v56, v47, 0);
        sub_1006DCF0(
          a1,
          (char *)(*(_DWORD *)(a1 + 56) + 69),
          (const char *)(*(_DWORD *)(a1 + 56) + 75),
          v54,
          v56,
          *(_DWORD *)(a2 + 4),
          v60);
        return v53;
      }
      if ( v34 != 0x2000 )
        return v53;
      v45 = *(_WORD *)(a5 + 14);
      if ( v45 < 0x30u || v45 > 0x39u )
      {
        if ( (_WORD)v61 != 42 || v45 != 69 && v45 != 87 )
        {
          if ( v45 == 46 && (_WORD)v61 == 41 )
            *(_WORD *)(v13 + 240) = 4;
        }
        else
        {
          *(_BYTE *)(v13 + 76) = *(_BYTE *)(a5 + 14);
        }
        return v53;
      }
      v53 = sub_10067050(a1, a2, a5);
LABEL_78:
      if ( v53 == 4 || v53 == 2 )
        goto LABEL_80;
      return v53;
    case 32802:
    case 32888:
      if ( *(_BYTE *)(a1 + 3) && (v51 = *(_DWORD *)(a1 + 56), *(_WORD *)(v51 + 240) != -128) )
      {
        *(_WORD *)(a1 + 438) = *a3;
        *(_WORD *)(a1 + 436) = a3[1];
        sub_10067200(v51 + 75, &v54, a2, &v56, (_BYTE *)(v51 + 75), 0);
        sub_1006DCF0(
          a1,
          (char *)(*(_DWORD *)(a1 + 56) + 69),
          (const char *)(*(_DWORD *)(a1 + 56) + 75),
          v54,
          v56,
          *(_DWORD *)(a2 + 4),
          *(_WORD *)(a2 + 8));
      }
      else
      {
        sub_100676A0((int)a3, a2, a1, (int)a4);
      }
      return v53;
    default:
      return v53;
  }
}
// 100DCCDC: using guessed type float flt_100DCCDC[];
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (10068190) --------------------------------------------------------
int __cdecl sub_10068190(int a1, int a2)
{
  int v2; // eax@1
  void (__cdecl *v3)(int, _DWORD, signed int, signed int); // ecx@1
  int v4; // eax@3
  int v5; // eax@3
  void (__cdecl *v6)(int, _DWORD, signed int, _DWORD); // ecx@3
  int result; // eax@5

  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(void (__cdecl **)(int, _DWORD, signed int, signed int))(v2 + 232);
  if ( v3 )
    v3(a1, *(_BYTE *)(v2 + 230), 255, 1);
  v4 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 3) = 0;
  *(_BYTE *)(a1 + 5) = 1;
  sub_10070710(
    a1,
    (int)&unk_100E461C,
    *(char **)(*(_DWORD *)(v4 + 56) + 4 * a2),
    *(_DWORD *)(*(_DWORD *)(v4 + 60) + 4 * a2));
  v5 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 5) = 0;
  v6 = *(void (__cdecl **)(int, _DWORD, signed int, _DWORD))(v5 + 232);
  if ( v6 )
    v6(a1, *(_BYTE *)(v5 + 230), 255, 0);
  result = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(result + 231) = *(_BYTE *)(result + 230);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  return result;
}

//----- (10068230) --------------------------------------------------------
int __usercall sub_10068230@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int result; // eax@1
  void (__cdecl *v4)(int, int, int, signed int); // eax@2
  int v5; // eax@5
  int v6; // eax@6
  int v7; // edx@6

  *(_WORD *)(*(_DWORD *)(a3 + 56) + 240) = -128;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 242) = 1;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 230) = a1;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 231) = *(_BYTE *)(*(_DWORD *)(a3 + 56) + 230);
  result = *(_DWORD *)(a3 + 56);
  if ( result == *(_DWORD *)(a3 + 48) )
  {
    v4 = *(void (__cdecl **)(int, int, int, signed int))(result + 232);
    if ( v4 )
      v4(a3, a2, a1, 1);
    if ( a2 != 255 )
    {
      v5 = *(_DWORD *)(a3 + 56);
      *(_BYTE *)(a3 + 3) = 0;
      *(_BYTE *)(a3 + 5) = 1;
      sub_10070710(
        a3,
        (int)&unk_100E461C,
        *(char **)(*(_DWORD *)(v5 + 56) + 4 * a2),
        *(_DWORD *)(*(_DWORD *)(v5 + 60) + 4 * a2));
    }
    v6 = *(_DWORD *)(a3 + 56);
    *(_BYTE *)(a3 + 3) = 1;
    *(_BYTE *)(a3 + 5) = 0;
    sub_10070710(
      a3,
      (int)&unk_100E461C,
      *(char **)(*(_DWORD *)(v6 + 56) + 4 * a1),
      *(_DWORD *)(*(_DWORD *)(v6 + 60) + 4 * a1));
    v7 = *(_DWORD *)(a3 + 56);
    *(_BYTE *)(a3 + 3) = 0;
    result = *(_DWORD *)(v7 + 232);
    if ( result )
      result = ((int (__cdecl *)(int, int, int, _DWORD))result)(a3, a2, a1, 0);
  }
  return result;
}

//----- (100682F0) --------------------------------------------------------
char __cdecl sub_100682F0(int a1, int a2, int a3)
{
  signed int v3; // ebx@1
  int v4; // ebp@2
  unsigned __int8 v5; // dl@2
  int v6; // eax@4
  int v7; // edi@5
  unsigned __int8 v8; // cl@5
  int v9; // edi@15
  signed int v10; // eax@15
  bool v11; // zf@15
  char result; // al@21
  unsigned __int8 v13; // [sp+10h] [bp+8h]@3

  v3 = a2;
  if ( a2 == 255 )
    return 0;
  v4 = *(_DWORD *)(a1 + 56);
  v5 = *(_BYTE *)(v4 + 68);
  if ( !v5 )
    return 0;
  v13 = *(_BYTE *)(v4 + 230);
  if ( *(_BYTE *)(v4 + 68) > 1u )
  {
    v6 = a3;
    if ( a3 )
    {
      v7 = 2 * (a3 >= 0) - 1;
      v8 = *(_BYTE *)(v4 + 230);
      while ( 1 )
      {
        v3 += v7;
        if ( v3 < 0 || v3 >= v5 )
          break;
        if ( *(_BYTE *)(v3 + *(_DWORD *)(v4 + 64)) & 1 )
        {
          v8 = v3;
          v6 -= v7;
        }
        if ( !v6 )
          goto LABEL_20;
      }
      v3 = v8;
      goto LABEL_20;
    }
    goto LABEL_14;
  }
  if ( !a3 )
  {
LABEL_14:
    if ( *(_BYTE *)(v4 + 230) == -1 )
    {
      v9 = *(_DWORD *)(v4 + 64);
      v10 = v3;
      v11 = (*(_BYTE *)(v9 + v3) & 1) == 0;
      v3 = 255;
      if ( v11 )
      {
        do
        {
          if ( v10 >= v5 )
            break;
          ++v10;
        }
        while ( !(*(_BYTE *)(v9 + v10) & 1) );
      }
      if ( v10 < v5 )
        v3 = v10;
    }
  }
LABEL_20:
  if ( v3 == v13 )
  {
    result = 1;
  }
  else
  {
    sub_10068230(v3, v13, a1);
    result = 2;
  }
  return result;
}

//----- (100683C0) --------------------------------------------------------
void __cdecl sub_100683C0(int a1, int a2, unsigned __int8 a3)
{
  int v3; // esi@3
  unsigned __int8 v4; // kr00_1@3
  char *v5; // ecx@3
  char v6; // dl@4
  char *v7; // eax@5
  char v8; // cl@6

  if ( a1 && a2 )
  {
    v3 = (int)*(&off_100DD5A8 + 10 * a3);
    v4 = strlen((const char *)*(&off_100DD5A8 + 10 * a3));
    v5 = (char *)*(&off_100DD5A8 + 10 * a3);
    do
    {
      v6 = *v5;
      v5[a1 - v3] = *v5;
      ++v5;
    }
    while ( v6 );
    v7 = (char *)(v4 + v3 + 1);
    do
    {
      v8 = *v7;
      v7[a2 - v4 - v3 - 1] = *v7;
      ++v7;
    }
    while ( v8 );
  }
}
// 100DD5A8: using guessed type void *off_100DD5A8;

//----- (10068420) --------------------------------------------------------
void __cdecl sub_10068420(char *a1, char *a2, int a3, char a4, char a5, char a6, char a7)
{
  int v7; // eax@4
  bool v8; // zf@9
  bool v9; // sf@9
  unsigned __int8 v10; // of@9
  int v11; // eax@9
  signed int v12; // edi@17
  int v13; // eax@19
  int v14; // edx@23
  double v15; // st7@23
  double v16; // st6@23
  double v17; // st5@24
  int v18; // ecx@27
  int v19; // edx@31
  signed int v20; // ST64_4@34
  double v21; // ST7C_8@34
  double v22; // st5@34
  char *v23; // ecx@39
  char *v24; // edx@39
  char v25; // al@40
  char *v26; // ecx@41
  char *v27; // edx@41
  char v28; // al@42
  char v29; // [sp+36h] [bp-52h]@6
  char v30; // [sp+37h] [bp-51h]@11
  signed int v31; // [sp+38h] [bp-50h]@4
  int v32; // [sp+3Ch] [bp-4Ch]@9
  char v33; // [sp+40h] [bp-48h]@4
  signed int v34; // [sp+44h] [bp-44h]@0
  double v35; // [sp+48h] [bp-40h]@0
  double v36; // [sp+50h] [bp-38h]@0
  int v37; // [sp+58h] [bp-30h]@23
  int v38; // [sp+5Ch] [bp-2Ch]@23
  unsigned __int8 v39; // [sp+60h] [bp-28h]@21
  unsigned __int8 v40; // [sp+61h] [bp-27h]@36
  char v41; // [sp+62h] [bp-26h]@36
  unsigned __int8 v42; // [sp+63h] [bp-25h]@36
  float v43; // [sp+64h] [bp-24h]@23
  float v44; // [sp+68h] [bp-20h]@24
  double v45; // [sp+6Ch] [bp-1Ch]@21
  float v46; // [sp+74h] [bp-14h]@32
  double v47; // [sp+78h] [bp-10h]@19
  double v48; // [sp+80h] [bp-8h]@23

  if ( a1 && a2 && a3 )
  {
    v33 = sub_10068E60();
    v7 = *(_DWORD *)a3;
    v31 = *(_DWORD *)a3;
    if ( *(_DWORD *)a3 >= 0 )
    {
      v29 = 78;
    }
    else if ( v7 == 0x80000000 )
    {
      v7 = 0x7FFFFFFF;
      v31 = 0x7FFFFFFF;
      v29 = 83;
    }
    else
    {
      v7 = -v7;
      v31 = v7;
      v29 = 83;
    }
    v10 = __OFSUB__(v7, 0x40000000);
    v8 = v7 == 0x40000000;
    v9 = v7 - 0x40000000 < 0;
    v11 = *(_DWORD *)(a3 + 4);
    v32 = *(_DWORD *)(a3 + 4);
    if ( v11 >= 0 )
    {
      v30 = 69;
    }
    else if ( v11 == 0x80000000 )
    {
      v32 = 0x7FFFFFFF;
      v30 = 87;
    }
    else
    {
      v32 = -v11;
      v30 = 87;
    }
    if ( (unsigned __int8)(v9 ^ v10) | v8 )
    {
      switch ( a4 )
      {
        case 0:
        case 1:
          v35 = (double)v31 * 0.00000008381903171539307;
          v36 = 0.00000008381903171539307 * (double)v32;
          goto LABEL_17;
        case 2:
        case 3:
          v13 = *(_DWORD *)(a3 + 4);
          sub_1007A640((int)&v47, *(_QWORD *)a3, *(_QWORD *)a3 >> 32);
          if ( v47 > 1.46607657167524 || v47 < -1.396263401595467 )
          {
            sub_1006E570(&v47, (int)&v45);
            sub_1006ED30((int)&v45, (int)&v39);
          }
          else
          {
            sub_1006E6F0(&v47, (int)&v45, (float *)&a5, (float *)&a6, (float *)&a7);
            sub_1006F0F0((int)&v45, (int)&v39);
          }
          v14 = *(_DWORD *)a3;
          v38 = *(_DWORD *)(a3 + 4);
          v37 = v14;
          sub_1007A660((int)&v37, v47, v48);
          v15 = 9.9999996e24;
          v16 = v43;
          if ( v43 == 9.9999996e24 )
            goto LABEL_38;
          v17 = v44;
          goto LABEL_25;
        case 4:
          v18 = *(_DWORD *)(a3 + 4);
          sub_1007A640((int)&v47, *(_QWORD *)a3, *(_QWORD *)a3 >> 32);
          if ( v47 > 1.46607657167524 || v47 < -1.396263401595467 )
            sub_1006E570(&v47, (int)&v45);
          else
            sub_1006E6F0(&v47, (int)&v45, (float *)&a5, (float *)&a6, (float *)&a7);
          v19 = *(_DWORD *)a3;
          v38 = *(_DWORD *)(a3 + 4);
          v37 = v19;
          sub_1007A660((int)&v37, v47, v48);
          v15 = 9.9999996e24;
          v16 = *((float *)&v45 + 1);
          if ( *((float *)&v45 + 1) == 9.9999996e24 )
            goto LABEL_38;
          v17 = v46;
LABEL_25:
          if ( v17 == v15 )
            goto LABEL_38;
          v12 = (signed int)(v16 + 0.5);
          v31 = (signed int)(v17 + 0.5);
          break;
        default:
LABEL_17:
          v12 = v34;
          break;
      }
      switch ( a4 )
      {
        case 0:
          sprintf(
            a1,
            "%c %02d@%05.2lf'",
            (unsigned __int8)v29,
            (signed int)(v35 + 0.00008333333333333333),
            (double)(signed int)((v35 + 0.00008333333333333333 - (double)(signed int)(v35 + 0.00008333333333333333))
                               * 6000.0)
          / 100.0);
          sprintf(
            a2,
            "%c%03d@%05.2lf'",
            (unsigned __int8)v30,
            (signed int)(v36 + 0.00008333333333333333),
            (double)(signed int)((v36 + 0.00008333333333333333 - (double)(signed int)(v36 + 0.00008333333333333333))
                               * 6000.0)
          / 100.0);
          sub_1006FB90(a1, 64, v33);
          sub_1006FB90(a2, 64, v33);
          break;
        case 1:
          v20 = (signed int)(v36 + 0.00001388888888888889);
          v21 = (v36 + 0.00001388888888888889 - (double)v20) * 60.0;
          v22 = (v35 + 0.00001388888888888889 - (double)(signed int)(v35 + 0.00001388888888888889)) * 60.0;
          sprintf(
            a1,
            "%c %02d@%02d'%04.1lf\"",
            (unsigned __int8)v29,
            (signed int)(v35 + 0.00001388888888888889),
            (signed int)v22,
            (double)(signed int)((v22 - (double)(signed int)v22) * 600.0) / 10.0);
          sprintf(
            a2,
            "%c%03d@%02d'%04.1lf\"",
            (unsigned __int8)v30,
            v20,
            (signed int)v21,
            (double)(signed int)((v21 - (double)(signed int)v21) * 600.0) / 10.0);
          sub_1006FB90(a1, 64, v33);
          sub_1006FB90(a2, 64, v33);
          break;
        case 4:
          sprintf(a1, "%02d %c %07d", SBYTE2(v45), BYTE3(v45), v12);
          sprintf(a2, "%07d", v31);
          break;
        case 2:
          sprintf(a1, "%02d %c %c%c %05d", v41, v42, v39, v40, v12);
          sprintf(a2, "%05d", v31);
          break;
        case 3:
          sprintf(a1, "%02d %c %c%c %04d", v41, v42, v39, v40, v12 / 10);
          sprintf(a2, "%04d", v31 / 10);
          break;
        default:
          return;
      }
    }
    else
    {
LABEL_38:
      if ( (unsigned __int8)a4 < 5u )
      {
        v23 = off_100DD5C0[10 * (unsigned __int8)a4];
        v24 = a1;
        do
        {
          v25 = *v23;
          *v24++ = *v23++;
        }
        while ( v25 );
        v26 = (&off_100DD5C4)[40 * (unsigned __int8)a4];
        v27 = a2;
        do
        {
          v28 = *v26;
          *v27++ = *v26++;
        }
        while ( v28 );
        sub_1006FB90(a1, 64, v33);
        sub_1006FB90(a2, 64, v33);
      }
    }
  }
}
// 100DD5C0: using guessed type char *off_100DD5C0[2];
// 100DD5C4: using guessed type char *off_100DD5C4;

//----- (10068A10) --------------------------------------------------------
void __usercall sub_10068A10(double *a1@<eax>, char a2@<dl>, double *a3@<ecx>, char a4)
{
  double v4; // st7@4

  if ( a4 == 83 )
    *a1 = *a1 * -1.0;
  if ( a2 == 87 )
  {
    v4 = -1.0 * *a3;
    *a3 = v4;
    if ( 0.0 == v4 )
      *a3 = v4 - 0.000002777777808660176;
  }
  else if ( a2 == 69 && 180.0 == *a3 )
  {
    *a3 = *a3 - 0.000002777777808660176;
  }
}

//----- (10068A70) --------------------------------------------------------
void __cdecl sub_10068A70(int a1, int a2, int a3, char a4, char a5, char a6, char a7)
{
  double v7; // st7@7
  double v8; // st7@13
  unsigned int v9; // eax@14
  unsigned int v10; // eax@19
  double v11; // [sp+Ch] [bp-6Ch]@5
  int v12; // [sp+14h] [bp-64h]@7
  int v13; // [sp+18h] [bp-60h]@7
  int v14; // [sp+1Ch] [bp-5Ch]@5
  int v15; // [sp+20h] [bp-58h]@5
  int v16; // [sp+24h] [bp-54h]@5
  int v17; // [sp+28h] [bp-50h]@6
  int v18; // [sp+2Ch] [bp-4Ch]@6
  double v19; // [sp+30h] [bp-48h]@5
  double v20; // [sp+38h] [bp-40h]@5
  double v21; // [sp+44h] [bp-34h]@7
  int v22; // [sp+4Ch] [bp-2Ch]@11
  double v23; // [sp+50h] [bp-28h]@16
  int v24; // [sp+58h] [bp-20h]@19
  double v25; // [sp+5Ch] [bp-1Ch]@14
  int v26; // [sp+64h] [bp-14h]@14
  double v27; // [sp+68h] [bp-10h]@16
  double v28; // [sp+70h] [bp-8h]@18

  if ( a1 && a2 && a3 )
  {
    switch ( a4 )
    {
      case 0:
        sub_100AA9F8(a1, (int)"%c%*c%2d%*c%6lf%*c", (unsigned int)&v16);
        sub_100AA9F8(a2, (int)"%c%3d%*c%6lf%*c", (unsigned int)&v11 + 1);
        v19 = v19 / 60.0 + (double)v14;
        v20 = v20 / 60.0 + (double)v15;
        sub_10068A10(&v19, SBYTE1(v11), &v20, v16);
        goto LABEL_12;
      case 1:
        sub_100AA9F8(a1, (int)"%c%*c%2d%*c%2d%*c%4lf%*c", (unsigned int)&v16);
        sub_100AA9F8(a2, (int)"%c%3d%*c%2d%*c%4lf%*c", (unsigned int)&v11 + 1);
        v19 = v19 / 3600.0 + (double)v17 / 60.0 + (double)v14;
        v20 = v20 / 3600.0 + (double)v18 / 60.0 + (double)v15;
        sub_10068A10(&v19, SBYTE1(v11), &v20, v16);
        goto LABEL_12;
      case 4:
        sub_100AA9F8(a1, (int)"%2d%*c%c%*c%7d", (unsigned int)&v11 + 4);
        sub_100AA9F8(a2, (int)"%7d", (unsigned int)&v13);
        *((float *)&v21 + 1) = (double)v12;
        v7 = (double)v13;
        BYTE2(v21) = BYTE4(v11);
        BYTE3(v21) = LOBYTE(v11);
        goto LABEL_11;
      case 2:
        sub_100AA9F8(a1, (int)"%2d%*c%c%*c%c%c%*c%5d", (unsigned int)&v11 + 4);
        sub_100AA9F8(a2, (int)"%5d", (unsigned int)&v13);
        *((float *)&v21 + 1) = (double)v12;
        v7 = (double)v13;
        goto LABEL_10;
      case 3:
        sub_100AA9F8(a1, (int)"%2d%*c%c%*c%c%c%*c%4d", (unsigned int)&v11 + 4);
        sub_100AA9F8(a2, (int)"%4d", (unsigned int)&v13);
        *((float *)&v21 + 1) = ((double)v12 + 0.5) * 10.0;
        v7 = 10.0 * ((double)v13 + 0.5);
LABEL_10:
        *(_WORD *)((char *)&v21 + 1) = *(_WORD *)((char *)&v11 + 3);
        LOBYTE(v21) = BYTE2(v11);
        BYTE3(v21) = LOBYTE(v11);
LABEL_11:
        *(float *)&v22 = v7;
LABEL_12:
        switch ( a4 )
        {
          case 0:
          case 1:
            v8 = 11930464.71111111 * v20;
            *(_DWORD *)a3 = (signed int)(v19 * 11930464.71111111);
            *(_DWORD *)(a3 + 4) = (signed int)v8;
            break;
          case 2:
          case 3:
            v25 = v21;
            v9 = LODWORD(v21) >> 24;
            v26 = v22;
            if ( BYTE3(v21) < 0x43u || (unsigned __int8)v9 > 0x58u )
            {
              sub_1006E9E0((int)&v25, (int)&v23);
              sub_1006EC20((int)&v23, (int)&v27);
            }
            else
            {
              sub_1006EB10((int)&v25, (int)&v23);
              sub_1006EE10((int)&v23, (int)&v27, (float *)&a5, (float *)&a6, (float *)&a7);
            }
            sub_1007A660(a3, v27, v28);
            break;
          case 4:
            v23 = v21;
            v10 = LODWORD(v21) >> 24;
            v24 = v22;
            if ( BYTE3(v21) < 0x43u || (unsigned __int8)v10 > 0x58u )
              sub_1006EC20((int)&v23, (int)&v27);
            else
              sub_1006EE10((int)&v23, (int)&v27, (float *)&a5, (float *)&a6, (float *)&a7);
            sub_1007A660(a3, v27, v28);
            break;
          default:
            return;
        }
        break;
      default:
        return;
    }
  }
}
// 100DD6C0: using guessed type double dbl_100DD6C0;

//----- (10068E60) --------------------------------------------------------
char sub_10068E60()
{
  return -111;
}

//----- (10068E70) --------------------------------------------------------
char __cdecl sub_10068E70(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  char *v6; // edi@4
  signed int v7; // eax@4
  unsigned int v8; // ST1C_4@4
  int v9; // eax@4
  unsigned int v10; // ST18_4@4
  int *v11; // eax@4
  __int16 v12; // dx@4
  int v13; // ST10_4@4
  signed int v14; // eax@4
  __int16 v15; // dx@4
  int v16; // edx@4
  int v17; // eax@6
  int v18; // edi@7
  int v19; // ebx@7
  char *v20; // eax@7
  int v21; // [sp+8h] [bp-18h]@4
  int v22; // [sp+Ch] [bp-14h]@4
  int v23; // [sp+10h] [bp-10h]@4
  __int16 v24; // [sp+14h] [bp-Ch]@4
  int v25; // [sp+16h] [bp-Ah]@4
  int v26; // [sp+1Ch] [bp-4h]@4

  result = 1;
  if ( *a5 == 32802 )
  {
LABEL_4:
    v6 = sub_10070850(*a4);
    v7 = sub_1006D040(*(_DWORD *)(a2 + 4));
    v8 = *(_DWORD *)(a2 + 4);
    v22 = v7;
    v9 = sub_1006D920(v8, 0);
    v10 = *(_DWORD *)(a2 + 4);
    v23 = v9;
    v25 = sub_1006CFD0(v10);
    v11 = sub_1006D000(*(_DWORD *)(a2 + 4));
    v12 = *(_WORD *)(a2 + 8);
    v13 = *(_DWORD *)(a2 + 4);
    v21 = *v11;
    v24 = v12;
    v14 = sub_1006D070(v13);
    v15 = *(_WORD *)a3;
    v26 = v14;
    *(_WORD *)(a1 + 438) = v15;
    v16 = v21;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_1006D980(a1, v6, &v21, *(_WORD *)(v16 + 30));
    return 2;
  }
  if ( *a5 != 32832 )
  {
    if ( *a5 != 32888 )
      return result;
    goto LABEL_4;
  }
  LOWORD(v17) = *(_WORD *)(a2 + 8);
  if ( (_WORD)v17 )
  {
    v17 = (signed __int16)v17;
  }
  else
  {
    v18 = sub_1006D040(*(_DWORD *)(a2 + 4));
    v19 = *sub_1006D000(*(_DWORD *)(a2 + 4));
    v20 = sub_10070850(*a4);
    v17 = sub_1009DA50(v19, v20, v18);
  }
  sub_1006DB90(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v17);
  return 2;
}

//----- (10068FA0) --------------------------------------------------------
void *__cdecl sub_10068FA0(int a1, __int16 a2)
{
  void *result; // eax@1

  result = memset((void *)(*(_DWORD *)(a1 + 56) + 69), 95, a2);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + a2 + 69) = 0;
  return result;
}

//----- (10068FD0) --------------------------------------------------------
char __cdecl sub_10068FD0(int a1, int a2, char *a3)
{
  char *v3; // edx@1
  _BYTE *v4; // eax@1
  char v5; // cl@2

  v3 = a3;
  v4 = (_BYTE *)(*(_DWORD *)(a1 + 56) + 69);
  do
  {
    v5 = *v3;
    *v4++ = *v3++;
  }
  while ( v5 );
  sub_1006FB90((const char *)(*(_DWORD *)(a1 + 56) + 69), 32, 95);
  sub_1006FB40((const char *)(*(_DWORD *)(a1 + 56) + 69), *(_WORD *)(a2 + 10), 95);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
  return 4;
}

//----- (10069030) --------------------------------------------------------
int __cdecl sub_10069030(int a1, int a2, int a3, signed int a4, int a5)
{
  int v5; // edi@1
  unsigned int v6; // ecx@1
  char v7; // al@6
  int v8; // eax@8
  __int16 v9; // dx@8
  __int64 v10; // rax@9
  float v11; // ST10_4@9

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 4) & 0xC000 )
  {
    if ( (*(_DWORD *)(a1 + 4) & 0xC000) == 0x4000 )
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8);
    else
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8) / 2;
  }
  else
  {
    LOWORD(a1) = *(_WORD *)a2;
  }
  v7 = *(_BYTE *)(v5 + 15);
  if ( *(_BYTE *)(v5 + 15) & 6 )
  {
    if ( (*(_BYTE *)(v5 + 15) & 6) == 2 )
    {
      v10 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
      v11 = 0.5 * (double)(a5 + 1);
      HIWORD(a1) = (signed int)((double)(*(_WORD *)(v5 + 12) / 2
                                       + (((signed int)v10 - HIDWORD(v10)) >> 1)
                                       + *(_WORD *)(a2 + 2)
                                       - 1)
                              + 0.5
                              + (1.0 - v11) * (double)a4);
      return a1;
    }
    v8 = sub_1006D920(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) + *(_WORD *)(v5 + 12) - a4 * a5 - *(_WORD *)(a3 + 26);
  }
  else
  {
    v8 = sub_1006D920(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
  }
  HIWORD(a1) = BYTE2(v8) + *(_WORD *)(a2 + 2) + v9 - 1;
  return a1;
}

//----- (10069180) --------------------------------------------------------
char __usercall sub_10069180@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // eax@3
  int v5; // ecx@3
  char result; // al@4
  int v7; // eax@5
  int v8; // eax@7

  if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) == -128 )
  {
    sub_10068FD0(a4, a3, a1);
    sub_10068FA0(a4, *(_WORD *)(a3 + 10));
  }
  v4 = *(_DWORD *)(a4 + 56);
  v5 = *(_WORD *)(v4 + 240);
  if ( *(_WORD *)(a2 + 10) == 0x2000 )
  {
    *(_BYTE *)(v5 + v4 + 69) = *(_BYTE *)(a2 + 14);
    v7 = *(_DWORD *)(a4 + 56);
    if ( *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) == 32 )
      *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) = 95;
    ++*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    v8 = *(_WORD *)(a3 + 10) - 1;
    if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) < v8 )
      LOWORD(v8) = *(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) = v8;
    result = 2;
  }
  else
  {
    *(_BYTE *)(v5 + v4 + 69) = 95;
    --*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a4 + 56) + 240) <= 0) - 1;
    result = 2;
  }
  return result;
}

//----- (10069240) --------------------------------------------------------
char __usercall sub_10069240@<al>(unsigned __int16 a1@<di>, int a2)
{
  char v2; // bl@1
  char v3; // al@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@2

  v2 = 0;
  v3 = sub_10071500(0, a1, 1);
  v4 = (unsigned __int8)v3;
  v5 = (unsigned __int8)sub_10071500(v3, a1, 1);
  if ( v4 == a2 )
  {
    result = 1;
  }
  else
  {
    if ( v5 != v4 )
    {
      do
      {
        if ( v5 == a2 )
          v2 = 1;
        v5 = (unsigned __int8)sub_10071500(v5, a1, 1);
      }
      while ( (unsigned __int8)v5 != v4 );
    }
    result = v2;
  }
  return result;
}

//----- (100692A0) --------------------------------------------------------
signed int __usercall sub_100692A0@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3)
{
  char v3; // bl@8
  signed int result; // eax@8
  char v5; // [sp+4h] [bp-4h]@0

  if ( (signed int)a2 <= 177 )
  {
    if ( a2 != 177 )
    {
      switch ( a2 )
      {
        case 0x51u:
        case 0x91u:
          goto LABEL_8;
        case 0x10u:
        case 0x14u:
          goto LABEL_9;
        case 0x92u:
          goto LABEL_11;
        default:
          goto LABEL_12;
      }
      goto LABEL_12;
    }
LABEL_8:
    v3 = 65;
    LOBYTE(result) = sub_10071500(65, a2, -1);
    goto LABEL_13;
  }
  if ( (signed int)a2 > 528 )
  {
    if ( a2 != 1043 )
      goto LABEL_12;
LABEL_11:
    v3 = 97;
    LOBYTE(result) = sub_10071500(97, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 528 )
  {
LABEL_9:
    v3 = 48;
    LOBYTE(result) = sub_10071500(48, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 178 )
    goto LABEL_11;
  if ( a2 == 273 )
    goto LABEL_8;
LABEL_12:
  v3 = v5;
  LOBYTE(result) = sub_10071500(v5, a2, -1);
LABEL_13:
  if ( a3 == 95 )
  {
    if ( a1 > 0 )
      return (unsigned __int8)v3;
  }
  else
  {
    if ( a3 == (unsigned __int8)v3 && a1 < 0 || a3 == (unsigned __int8)result && a1 > 0 )
      return 95;
    do
    {
      LOBYTE(result) = sub_10071500(a3, a2, a1);
      LOBYTE(a3) = result;
    }
    while ( (_BYTE)result == 95 );
  }
  return (unsigned __int8)result;
}

//----- (10069400) --------------------------------------------------------
signed int __cdecl sub_10069400(int a1, int a2, signed int a3)
{
  __int16 v3; // si@1
  signed int result; // eax@1
  int v5; // edi@1
  int v6; // ebx@2
  bool v7; // zf@2

  v3 = sub_10070640(*(_DWORD *)(a2 + 4));
  result = a3;
  v5 = 2 * (a3 >= 0) - 1;
  if ( a3 )
  {
    do
    {
      v6 = *(_DWORD *)(a1 + 56);
      result = sub_100692A0(v5, v3, *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69));
      v7 = a3 == v5;
      a3 -= v5;
      *(_BYTE *)(*(_WORD *)(v6 + 240) + v6 + 69) = result;
    }
    while ( !v7 );
  }
  return result;
}

//----- (10069460) --------------------------------------------------------
char __cdecl sub_10069460(int a1, int a2, int a3, char *a4)
{
  int v4; // esi@1
  char v5; // bl@1
  bool v6; // zf@1
  signed int v7; // eax@3
  unsigned int v8; // ST24_4@3
  int v9; // eax@3
  int v10; // ST1C_4@3
  __int16 v11; // ax@3
  int v12; // eax@6
  int v13; // eax@6
  char *v14; // ebx@6
  bool v15; // al@9
  int v16; // eax@11
  int v17; // eax@13
  int v18; // eax@13
  int v19; // ST1C_4@18
  int v21; // [sp+10h] [bp-28h]@1
  int v22; // [sp+14h] [bp-24h]@1
  int v23; // [sp+18h] [bp-20h]@1
  int v24; // [sp+1Ch] [bp-1Ch]@6
  int v25; // [sp+20h] [bp-18h]@3
  int v26; // [sp+24h] [bp-14h]@3
  int v27; // [sp+28h] [bp-10h]@3
  __int16 v28; // [sp+2Ch] [bp-Ch]@5
  int v29; // [sp+2Eh] [bp-Ah]@3
  int v30; // [sp+34h] [bp-4h]@3
  int v31; // [sp+40h] [bp+8h]@13

  v4 = a2;
  v5 = 0;
  v6 = *(_BYTE *)a2 == 124;
  LOBYTE(v23) = 0;
  v21 = 0;
  v22 = 0;
  if ( v6 )
  {
    v5 = *(_BYTE *)(a2 + 14);
    LOBYTE(v23) = (*(_BYTE *)(a2 + 15) & 1) == 1;
  }
  v25 = sub_1006D020(*(_DWORD *)(a2 + 4));
  v7 = sub_1006D040(*(_DWORD *)(a2 + 4));
  v8 = *(_DWORD *)(a2 + 4);
  v26 = v7;
  v27 = sub_1006D920(v8, v23);
  v9 = sub_1006CFD0(*(_DWORD *)(a2 + 4));
  v10 = *(_DWORD *)(a2 + 4);
  v29 = v9;
  v30 = sub_1006D070(v10);
  v11 = *(_WORD *)(a2 + 8);
  if ( !v11 )
    v11 = sub_1009DA50(v25, a4, v26);
  v6 = *(_BYTE *)a2 == 124;
  v28 = v11;
  if ( v6 )
  {
    sub_1006DC60(a4, *(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 14), (int)&v24, (int)&v22);
    v23 = v5;
    v12 = sub_1006F1A0(a4, v25, v27, *(_WORD *)(a2 + 12), v5, &v21);
    v13 = sub_100034E0(a1, v12);
    v14 = (char *)v13;
    if ( v21 > 0 )
    {
      v15 = !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128;
      v16 = sub_1006F210((int)a4, v25, 0, *(_WORD *)(a2 + 8), v21, v15, v14);
      v22 = v16;
      if ( v16 == -1 )
      {
        v16 = v21;
        v22 = v21;
      }
      v17 = sub_10069030(a2, a3, v25, v24, v16);
      v6 = *(_BYTE *)(a1 + 3) == 0;
      v31 = v17;
      v18 = v29;
      *(_WORD *)(a1 + 396) = 3;
      if ( !v6 && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_10658E06 || byte_1068B020) )
      {
        *(_WORD *)(a1 + 428) = HIWORD(v18);
        *(_WORD *)(a1 + 430) = v29;
        v18 = *(_DWORD *)(a1 + 428);
      }
      *(_WORD *)(a1 + 440) = v18;
      *(_WORD *)(a1 + 442) = v18;
      sub_1009F8C0(a1 + 392, *(_WORD *)a3 - 1, *(_WORD *)(a3 + 2), *(_WORD *)(v4 + 8) + 2, *(_WORD *)(v4 + 12));
      v19 = v23;
      *(_WORD *)(a1 + 438) = v31;
      *(_WORD *)(a1 + 436) = HIWORD(v31);
      LOBYTE(v13) = sub_1006D980(a1, v14, &v25, v19);
    }
    if ( v14 )
      LOBYTE(v13) = sub_10003450(a1, (unsigned int)v14);
  }
  else
  {
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    LOBYTE(v13) = sub_1006D8E0(a1, a4, &v25);
  }
  return v13;
}
// 10658E06: using guessed type char byte_10658E06;
// 1068B020: using guessed type char byte_1068B020;

//----- (100696C0) --------------------------------------------------------
char __cdecl sub_100696C0(int a1, int a2, int a3, char *a4)
{
  int v4; // ebp@1
  signed __int16 v5; // di@1
  int v6; // ecx@1
  int v7; // eax@1
  int v8; // ecx@4
  char v9; // bl@4
  char result; // al@10
  char v11; // bl@11
  char v12; // al@13
  int v13; // eax@18
  int v14; // eax@19
  int v15; // eax@24
  int v16; // [sp+18h] [bp+8h]@1

  v4 = a2;
  LOWORD(v7) = sub_10070640(*(_DWORD *)(a2 + 4));
  v5 = *(_WORD *)(a3 + 14);
  v6 = (unsigned __int16)v7;
  LOWORD(v7) = *(_WORD *)(a3 + 10);
  v16 = v6;
  if ( (_WORD)v7 == 0x2000 && v5 == 32 )
    v5 = 95;
  v8 = *(_DWORD *)(a1 + 56);
  v9 = 1;
  if ( *(_WORD *)(v8 + 240) == -128 )
  {
    if ( !(*(_DWORD *)(v4 + 4) & 0x200000) )
    {
      v7 = (unsigned __int16)v7;
      if ( (signed int)(unsigned __int16)v7 <= 73 )
      {
        if ( (unsigned __int16)v7 != 73 )
        {
          if ( v7 == 32 )
          {
            v11 = sub_10068FD0(a1, v4, a4);
            sub_10068FA0(a1, *(_WORD *)(v4 + 10));
            return v11;
          }
          if ( v7 == 56 )
            return sub_10068FD0(a1, v4, a4);
          return v9;
        }
        return sub_10069180(a4, a3, v4, a1);
      }
      if ( v7 == 0x2000 )
      {
        v12 = sub_10069240(v16, (unsigned __int16)v5);
        goto LABEL_14;
      }
    }
    return v9;
  }
  v7 = (unsigned __int16)v7;
  if ( (signed int)(unsigned __int16)v7 > 57 )
  {
    if ( v7 == 73 )
      return sub_10069180(a4, a3, v4, a1);
    if ( v7 == 0x2000 )
    {
      v12 = sub_10069240(v16, (unsigned __int16)v5);
LABEL_14:
      if ( v12 )
        return sub_10069180(a4, a3, v4, a1);
    }
    return v9;
  }
  if ( (unsigned __int16)v7 != 57 )
  {
    v13 = v7 - 32;
    if ( !v13 )
    {
      result = 6;
      *(_WORD *)(v8 + 240) = -128;
      return result;
    }
    v14 = v13 - 1;
    if ( !v14 )
    {
      *(_WORD *)(v8 + 240) = -128;
      sub_1006FB90((const char *)(*(_DWORD *)(a1 + 56) + 69), 95, 32);
      sub_1006FDE0(*(_DWORD *)(a1 + 56) + 69, 0);
      return 3;
    }
    if ( v14 == 23 )
    {
      sub_10069400(a1, v4, *(_BYTE *)(a3 + 8));
      return 2;
    }
    return v9;
  }
  *(_WORD *)(v8 + 240) += *(_BYTE *)(a3 + 8);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) <= 0) - 1;
  v15 = *(_WORD *)(v4 + 10) - 1;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v15 )
    LOWORD(v15) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = v15;
  return 2;
}

//----- (100698B0) --------------------------------------------------------
char __cdecl sub_100698B0(int a1, int a2, int a3, char *a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  char *v7; // edi@1
  __int16 v8; // bx@3
  int v9; // ebp@3
  __int16 v10; // di@5
  int v11; // eax@5
  char result; // al@5
  char *v13; // eax@10
  char *v14; // edx@10
  char v15; // cl@11
  int v16; // ecx@14
  char v17; // [sp+13h] [bp-5h]@1
  int v18; // [sp+14h] [bp-4h]@5

  v5 = a2;
  v6 = *(_WORD *)(a2 + 8);
  v7 = a4;
  v17 = 1;
  if ( !v6 )
    v6 = sub_1006D630(a4, *(_DWORD *)(a2 + 4));
  v8 = v6;
  v9 = *sub_1006D000(*(_DWORD *)(v5 + 4));
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      if ( *(_BYTE *)v5 == 124 )
      {
        v10 = sub_1006DC60(v7, *(_DWORD *)(v5 + 4), *(_BYTE *)(v5 + 14), (int)&v18, (int)&a2);
        v11 = sub_10069030(v5, a3, v9, v18, a2);
        sub_1006DB90(a1 + 276, v11, *(_DWORD *)(v5 + 4), v8);
        *(_WORD *)(a1 + 282) = v10 + *(_WORD *)(a1 + 278);
        result = 2;
      }
      else
      {
        sub_1006DB90(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(v5 + 4), v8);
        result = 2;
      }
      break;
    case 0x8048:
      v17 = sub_100696C0(a1, v5, a5, v7);
      switch ( v17 )
      {
        case 2:
        case 4:
          sub_10069460(a1, v5, a3, (char *)(*(_DWORD *)(a1 + 56) + 69));
          result = v17;
          break;
        case 6:
          sub_10069460(a1, v5, a3, v7);
          result = v17;
          break;
        case 3:
          v13 = (char *)(*(_DWORD *)(a1 + 56) + 69);
          v14 = v7;
          do
          {
            v15 = *v13;
            *v14++ = *v13++;
          }
          while ( v15 );
          sub_10069460(a1, v5, a3, v7);
          result = v17;
          break;
        default:
          goto LABEL_18;
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v16 = *(_DWORD *)(a1 + 56), *(_WORD *)(v16 + 240) != -128) )
        sub_10069460(a1, v5, a3, (char *)(v16 + 69));
      else
        sub_10069460(a1, v5, a3, v7);
      v17 = 2;
      goto LABEL_18;
    default:
LABEL_18:
      result = v17;
      break;
  }
  return result;
}

//----- (10069B10) --------------------------------------------------------
char __cdecl sub_10069B10(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // cx@4
  unsigned int v7; // eax@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // ecx@8
  __int16 v11; // bp@8
  __int16 *v12; // ebx@9
  char v13; // dl@10
  __int16 v14; // ax@14
  __int16 v15; // cx@16
  int v16; // [sp+4h] [bp-14h]@9
  __int16 v17; // [sp+8h] [bp-10h]@4
  __int16 v18; // [sp+Ch] [bp-Ch]@4
  __int16 v19; // [sp+Eh] [bp-Ah]@4
  __int16 v20; // [sp+10h] [bp-8h]@4
  __int16 v21; // [sp+12h] [bp-6h]@4
  __int16 v22; // [sp+14h] [bp-4h]@4
  __int16 v23; // [sp+16h] [bp-2h]@4
  int v24; // [sp+2Ch] [bp+14h]@9

  result = 1;
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return result;
  }
  v18 = word_105728D8[1];
  v19 = word_105728D8[0];
  v20 = word_105728D8[0];
  v21 = word_105728D8[0];
  v22 = word_105728D8[0];
  v6 = word_105728D8[(unsigned __int8)sub_1007A590(15)];
  v7 = *(_WORD *)(a2 + 8);
  v23 = v6;
  v8 = v7;
  v9 = ((v7 >> 12) & 3) + 1;
  *(_WORD *)(a1 + 426) = v9;
  *(_WORD *)(a1 + 424) = v9;
  v17 = v8 & 0xC00;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) == -32768 )
  {
    *(_WORD *)(a1 + 398) = 1;
    *(_DWORD *)(a1 + 452) = &unk_100C42E0;
    *(_WORD *)(a1 + 440) = 0;
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 398) = 3;
  }
  v10 = 3 - v9;
  v11 = 0;
  if ( 3 - v9 < 3 )
  {
    v24 = v10 + 1;
    v12 = &v18 + 2 * v10;
    v16 = 3 - v10;
    do
    {
      v13 = 2;
      if ( v24 >= 3 && (*(_WORD *)(a2 + 8) & 0xC000) != 0x4000 )
        v13 = 3;
      if ( v17 == 2048 )
      {
        *(_WORD *)(a1 + 428) = *(_WORD *)a4;
        v14 = *(_WORD *)a4;
      }
      else
      {
        if ( v17 )
        {
          v15 = v12[1];
          v14 = *v12;
        }
        else
        {
          v15 = *v12;
          v14 = v12[1];
        }
        *(_WORD *)(a1 + 428) = v15;
      }
      *(_WORD *)(a1 + 430) = v14;
      sub_1009E590(
        a1 + 392,
        v11 + *(_WORD *)a3,
        v11 + *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 4) - 2 * v11,
        *(_WORD *)(a2 + 6) - 2 * v11,
        v13);
      ++v24;
      v12 += 2;
      ++v11;
      --v16;
    }
    while ( v16 );
  }
  return 2;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10069D40) --------------------------------------------------------
char __cdecl sub_10069D40(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // ST10_1@2
  __int16 v8; // cx@2
  __int16 v9; // ax@2
  __int16 v11; // [sp+10h] [bp-14h]@4
  __int16 v12; // [sp+12h] [bp-12h]@4
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@1
  int v15; // [sp+1Ch] [bp-8h]@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v14 = v6;
  v15 = v5;
  if ( (_WORD)v5 == -1 )
  {
    v7 = *a4 & 0x1F;
    LOWORD(v15) = *(_WORD *)a4;
    v8 = word_105728D8[(unsigned __int8)sub_1007A590(v7)];
    v9 = word_105728D8[((unsigned int)*(_WORD *)a4 >> 5) & 0x1F];
  }
  else
  {
    v8 = word_105728D8[(unsigned __int8)sub_1007A590(v5 & 0x1F)];
    v9 = word_105728D8[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  }
  v11 = v8;
  v12 = v9;
  return sub_10069B10(a1, (int)&v13, a3, (int)&v11, a5);
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (10069E20) --------------------------------------------------------
int __cdecl sub_10069E20(unsigned int a1, char a2, int a3, int a4)
{
  int result; // eax@1

  result = a3 * byte_1068B4D1[20 * ((a1 >> 10) & 0xF)]
         + (a3 - 1) * *(_WORD *)(dword_1068B4C4[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a2 & 0x80 )
      result += BYTE3(dword_1068B4C0[5 * ((a1 >> 10) & 0xF) + 3]) - byte_1068B4D1[20 * ((a1 >> 10) & 0xF)];
  }
  return result;
}
// 1068B4C0: using guessed type int dword_1068B4C0[];
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (10069E80) --------------------------------------------------------
char __cdecl sub_10069E80(int a1, int a2, int a3, double *a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  unsigned int v6; // ecx@1
  int v7; // eax@1
  __int16 v8; // bx@1
  double v9; // st7@3
  __int16 v10; // cx@5
  __int16 v11; // cx@5
  int v12; // ebx@8
  size_t v13; // edi@9
  int v14; // eax@9
  int v15; // edx@14
  __int16 v16; // ax@14
  float v17; // ST4C_4@20
  char *v18; // edi@27
  char v19; // al@28
  char *v20; // edi@30
  char v21; // al@31
  char v22; // al@33
  char *v23; // eax@35
  char v24; // cl@36
  signed int v25; // ecx@37
  char v26; // cl@38
  int v27; // ecx@40
  int v28; // edi@43
  int i; // eax@47
  char v30; // dl@50
  signed int v31; // ecx@52
  char v32; // al@53
  int v33; // eax@63
  signed int v34; // ebx@69
  signed int v35; // eax@69
  unsigned int v36; // ST18_4@71
  int *v37; // eax@71
  int v38; // edi@80
  unsigned int v39; // ebx@80
  __int16 v40; // ax@80
  bool v42; // [sp+2Fh] [bp-59h]@21
  int v43; // [sp+30h] [bp-58h]@1
  int v44; // [sp+30h] [bp-58h]@14
  int v45; // [sp+34h] [bp-54h]@1
  char *v46; // [sp+38h] [bp-50h]@14
  char v47; // [sp+3Ch] [bp-4Ch]@71
  char v48; // [sp+3Dh] [bp-4Bh]@71
  char v49; // [sp+3Eh] [bp-4Ah]@71
  int v50; // [sp+40h] [bp-48h]@3
  int v51; // [sp+44h] [bp-44h]@1
  int v52; // [sp+48h] [bp-40h]@1
  int v53; // [sp+4Ch] [bp-3Ch]@1
  double v54; // [sp+50h] [bp-38h]@5
  char v55[2]; // [sp+58h] [bp-30h]@21
  char v56; // [sp+63h] [bp-25h]@12
  char v57; // [sp+64h] [bp-24h]@9
  char v58; // [sp+65h] [bp-23h]@64

  v4 = a2;
  v5 = *(_BYTE *)a2 == 89;
  v45 = *(_BYTE *)(a2 + 10);
  v6 = *(_WORD *)(a2 + 8);
  v53 = a1;
  v7 = *(_BYTE *)(a2 + 11);
  v8 = v6;
  v52 = a2;
  v51 = (unsigned __int16)v6;
  v43 = v7;
  if ( v5 && 9.899999762399947e24 != *a4 )
  {
    *(float *)&v50 = *a4;
    v9 = sub_10079840(v50, v6);
  }
  else
  {
    *(float *)&v50 = 9.8999998e24;
    v9 = *a4;
  }
  v10 = *(_WORD *)(a2 + 8);
  v54 = v9;
  v11 = v10 & 0x3F;
  if ( v11 == 28 )
  {
    if ( v9 > 1.0 || v9 < 0.0 )
    {
LABEL_8:
      v12 = v53;
LABEL_9:
      v13 = *(_BYTE *)(v4 + 10);
      memset(&v57, 95, v13);
      v14 = v43;
      if ( v43 > 0 )
      {
        if ( (signed int)(v13 - v43) <= 1 )
          v14 = v13 - 2;
        *(&v56 + v13 - v14) = 46;
      }
      *(&v57 + v13) = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( v9 >= 1.0e25 )
      goto LABEL_8;
    if ( v9 <= -1.0e25 )
      goto LABEL_8;
    if ( 9.899999762399947e24 == v9 )
      goto LABEL_8;
    v17 = v9;
    if ( v17 == 9.8999998e24 )
      goto LABEL_8;
  }
  v42 = 1;
  strcpy(v55, "%");
  if ( v8 & 0x800 || v8 & 0x40 || v11 == 27 || v11 == 28 )
  {
    ++v45;
    v18 = (char *)&v54 + 7;
    do
      v19 = (v18++)[1];
    while ( v19 );
    *(_WORD *)v18 = 43;
  }
  else if ( v11 == 7 )
  {
    ++v45;
  }
  v20 = (char *)&v54 + 7;
  if ( v8 & 0x100 )
  {
    do
      v21 = (v20++)[1];
    while ( v21 );
    *(_WORD *)v20 = 48;
  }
  else
  {
    do
      v22 = (v20++)[1];
    while ( v22 );
    *(_WORD *)v20 = 45;
  }
  v23 = (char *)&v54 + 7;
  if ( v11 == 7 )
  {
    do
      v24 = (v23++)[1];
    while ( v24 );
    v25 = 1697263146;
  }
  else
  {
    do
      v26 = (v23++)[1];
    while ( v26 );
    v25 = 1714040362;
  }
  *(_DWORD *)v23 = v25;
  v27 = *(_BYTE *)(a2 + 10);
  v23[4] = 0;
  v12 = _snprintf(&v57, 0x1Eu, v55, v27, *(_BYTE *)(a2 + 11), LODWORD(v9), (_DWORD)(*(unsigned __int64 *)&v9 >> 32));
  if ( v12 > v45 )
  {
    v42 = 0;
    if ( !(v51 & 0x80) && v43 > 0 )
    {
      v28 = v43;
      do
      {
        if ( v42 )
          break;
        v12 = sprintf(&v57, v55, *(_BYTE *)(a2 + 10), --v28, v54);
        v42 = v12 <= v45;
      }
      while ( v28 > 0 );
      v43 = v28;
    }
  }
  for ( i = v12 - 1; i >= 0; --i )
  {
    if ( *(&v57 + i) != 32 )
      break;
    *(&v57 + i) = 0;
    --v12;
  }
  v30 = 1;
  if ( v57 == 45 || v57 == 43 )
  {
    v31 = 1;
    if ( v12 <= 1 )
      goto LABEL_89;
    do
    {
      v32 = *(&v57 + v31);
      if ( v32 != 46 && v32 != 48 && v32 != 101 && v32 != 43 )
      {
        v30 = 0;
        v31 = v12;
      }
      ++v31;
    }
    while ( v31 < v12 );
    if ( v30 )
    {
LABEL_89:
      if ( (*(_WORD *)(a2 + 8) & 0x3F) == 17 && *(_WORD *)(a2 + 8) & 0x40 )
      {
        v57 = 43;
      }
      else
      {
        --v12;
        v33 = 0;
        if ( v12 > 0 )
        {
          qmemcpy(&v57, &v58, v12);
          v4 = v52;
          v33 = v12;
        }
        *(&v57 + v33) = 0;
      }
    }
  }
  if ( !v42 )
    goto LABEL_9;
LABEL_14:
  v46 = sub_100793B0(*(_WORD *)(v4 + 8), (float *)&v50);
  v15 = (signed __int16)sub_1006D690(*(_DWORD *)(v4 + 4), *(_WORD *)(v4 + 8), (float *)&v50);
  v16 = *(_WORD *)(v4 + 8) & 0x3F;
  v44 = v15;
  if ( v16 == 27 )
  {
    if ( v57 == 45 )
    {
      v57 = -100;
    }
    else if ( v57 == 43 )
    {
      --v45;
      v34 = v12 - 1;
      v35 = 0;
      if ( v34 > 0 )
      {
        qmemcpy(&v57, &v58, v34);
        v4 = v52;
        v35 = v34;
      }
      *(&v57 + v35) = 0;
      v36 = *(_DWORD *)(v4 + 4);
      v47 = *v46;
      v48 = -99;
      v49 = 0;
      v46 = &v47;
      v37 = sub_1006D000(v36);
      v44 += sub_1009DA50(v37[1], "", 0);
    }
  }
  else if ( v16 == 28 && !strncmp(&v57, "+0.", 3u) )
  {
    strncpy(&v57, "M ", 2u);
  }
  if ( v51 & 0x800 )
  {
    if ( v57 == 45 )
    {
      v57 = -92;
    }
    else if ( v57 == 43 )
    {
      v57 = -93;
    }
  }
  v38 = v53;
  *(_WORD *)(v53 + 438) = *(_WORD *)a3;
  *(_WORD *)(v38 + 436) = *(_WORD *)(a3 + 2);
  v39 = *(_DWORD *)(v4 + 4);
  v40 = *(_WORD *)(v4 + 12);
  if ( (*(_DWORD *)(v4 + 4) & 0xC000) != 0x4000 )
  {
    if ( ~(unsigned __int8)(*(_WORD *)(v4 + 8) >> 9) & 1 )
    {
      v40 -= v44;
      if ( v44 > 0 )
        v40 -= *(_WORD *)(dword_1068B4C4[5 * ((v39 >> 10) & 0xF)] + 28);
    }
  }
  if ( !*(_WORD *)(v4 + 12) )
    v40 = sub_10069E20(v39, *(_WORD *)(v4 + 8), v45, *(_BYTE *)(v4 + 11));
  return sub_1006DCF0(v38, &v57, v46, v40, v44, v39, v51);
}
// 100D1C0C: using guessed type __int16 word_100D1C0C;
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (1006A380) --------------------------------------------------------
char __usercall sub_1006A380@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  int v4; // ebp@1
  double v5; // st7@4
  double v6; // st7@6
  __int16 v7; // ax@6
  const char *v8; // esi@8
  int v10; // [sp+14h] [bp+4h]@6
  float v11; // [sp+14h] [bp+4h]@12

  v4 = a4;
  if ( *a1 >= 1.0e25 || *a1 <= -1.0e25 || 9.8999998e24 == *a1 )
    v5 = 0.0;
  else
    v5 = *a1;
  *(float *)&v10 = v5;
  v6 = sub_10079840(v10, *(_WORD *)(a2 + 8));
  v7 = *(_WORD *)(a2 + 8);
  if ( v7 & 0x40 )
  {
    if ( (v7 & 0x3F) == 7 )
      v8 = "%+0*.*e";
    else
      v8 = "%+0*.*f";
  }
  else
  {
    v8 = "%0*.*e";
    if ( (v7 & 0x3F) != 7 )
      v8 = "%0*.*f";
  }
  v11 = v6;
  if ( sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), v11) > a3 )
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), 0.0);
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = 0;
  return 4;
}

//----- (1006A460) --------------------------------------------------------
char __usercall sub_1006A460@<al>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi@1
  __int16 v5; // ax@1
  int v6; // edi@1
  __int16 v7; // ax@2
  int v8; // ecx@8
  const char *v9; // ecx@11
  char v10; // bl@11
  char *v11; // eax@11
  char v12; // dl@11
  char v13; // cl@12
  const char *v14; // edx@14
  char *v15; // eax@14
  char v16; // di@14
  char v17; // cl@15
  char v18; // bl@16
  char *v19; // eax@16
  char v20; // dl@16
  char v21; // cl@17
  unsigned __int16 v22; // ax@20
  int v23; // ecx@22
  signed __int16 v24; // di@22
  char *v25; // eax@25
  char v26; // dl@26
  char v27; // bl@27
  char *v28; // eax@27
  char v29; // dl@27
  char v30; // cl@28
  int v31; // ecx@32
  unsigned __int8 v32; // al@32
  char *v33; // eax@36
  char v34; // dl@37
  char v35; // bl@38
  char *v36; // eax@38
  char v37; // dl@38
  char v38; // cl@39
  const char *v39; // ecx@42
  char v40; // bl@42
  char *v41; // eax@42
  char v42; // dl@42
  char v43; // cl@43
  int v44; // eax@47
  unsigned __int16 v45; // ax@53
  const char *v46; // ecx@59
  char v47; // bl@59
  char *v48; // eax@59
  char v49; // dl@59
  char v50; // cl@60
  int v51; // edx@62
  char v52; // al@64
  int v53; // ebp@64
  bool v54; // zf@71
  bool v55; // sf@71
  char *v56; // eax@72
  int v57; // edi@72
  char v58; // dl@73
  char v59; // bl@74
  char *v60; // eax@74
  char v61; // dl@74
  char v62; // cl@75
  int v63; // ecx@81
  unsigned __int8 v64; // al@81
  char *v65; // eax@85
  char v66; // dl@86
  char v67; // bl@87
  char *v68; // eax@87
  char v69; // dl@87
  char v70; // cl@88
  const char *v71; // ecx@93
  char v72; // kr00_1@93
  char *v73; // eax@93
  char v74; // dl@93
  char v75; // cl@94
  signed int v76; // eax@96
  char *v77; // eax@104
  int v78; // edi@104
  char v79; // dl@105
  char v80; // bl@106
  char *v81; // eax@106
  char v82; // dl@106
  char v83; // cl@107
  char *v84; // eax@116
  int v85; // edi@116
  char v86; // dl@117
  char v87; // bl@118
  char *v88; // eax@118
  char v89; // dl@118
  char v90; // cl@119
  char *v91; // eax@122
  int v92; // edi@122
  char v93; // dl@123
  char v94; // bl@124
  char *v95; // eax@124
  char v96; // dl@124
  char v97; // cl@125
  int v98; // ecx@126
  const char *v99; // edx@127
  char *v100; // eax@127
  char v101; // di@127
  char v102; // cl@128
  char v103; // bl@129
  char *v104; // eax@129
  char v105; // di@129
  char v106; // cl@130
  char *v107; // eax@131
  int v108; // ecx@131
  char v109; // dl@132
  char v110; // bl@133
  char *v111; // eax@133
  char v112; // dl@133
  char v113; // cl@134
  int v114; // ebp@142
  int v115; // ecx@147
  const char *v116; // edx@152
  char *v117; // eax@152
  char v118; // di@152
  char v119; // cl@153
  char v120; // bl@154
  char *v121; // eax@154
  char v122; // dl@154
  char v123; // cl@155
  int v124; // edx@158
  signed int v125; // eax@158
  char *v126; // eax@165
  int v127; // edi@165
  char v128; // dl@166
  char v129; // bl@167
  char *v130; // eax@167
  char v131; // dl@167
  char v132; // cl@168
  int v133; // eax@170
  char v135; // [sp+1Bh] [bp-Dh]@1
  float v136; // [sp+1Ch] [bp-Ch]@1
  char *v137; // [sp+20h] [bp-8h]@3
  int v138; // [sp+24h] [bp-4h]@1
  __int32 v139; // [sp+2Ch] [bp+4h]@71
  float v140; // [sp+2Ch] [bp+4h]@76

  v4 = a1;
  v136 = 0.0;
  v5 = *(_WORD *)(a2 + 8);
  v6 = a4;
  v135 = 1;
  v138 = 1;
  if ( v5 & 0x40 )
  {
    v7 = v5 & 0x3F;
    if ( v7 == 7 )
      v137 = "%+0*.*e";
    else
      v137 = "%+0*.*f";
  }
  else
  {
    v7 = v5 & 0x3F;
    v137 = "%0*.*e";
    if ( v7 != 7 )
      v137 = "%0*.*f";
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
  {
    v8 = *(_DWORD *)(v4 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
    {
      *(_WORD *)(a4 + 14) = 45;
    }
    else
    {
      if ( v7 != 7 )
        goto LABEL_176;
      v9 = (const char *)(v8 + 69);
      v10 = strlen(v9);
      v11 = strchr(v9, 101);
      v12 = (_BYTE)v11 + 1;
      do
        v13 = *v11++;
      while ( v13 );
      v8 = *(_DWORD *)(v4 + 56);
      if ( *(_WORD *)(v8 + 240) <= (signed __int16)(char)(v10 - ((_BYTE)v11 - v12)) )
      {
LABEL_176:
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
      }
      else
      {
        v14 = (const char *)(v8 + 69);
        v15 = (char *)(v8 + 69);
        v16 = v8 + 70;
        do
          v17 = *v15++;
        while ( v17 );
        v18 = (_BYTE)v15 - v16;
        v19 = strchr(v14, 101);
        v20 = (_BYTE)v19 + 1;
        do
          v21 = *v19++;
        while ( v21 );
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)((char)(v18 - ((_BYTE)v19 - v20)) + *(_DWORD *)(v4 + 56) + 70) == 43) + 43;
      }
    }
  }
  v22 = *(_WORD *)(v6 + 14);
  if ( v22 < 0x30u || v22 > 0x39u )
  {
    if ( (*(_WORD *)(a2 + 8) & 0x3F) != 7 || v22 != 69 )
    {
      if ( (v22 == 43 || v22 == 45) && (sub_10079370(*(_WORD *)(a2 + 8)) || *(_BYTE *)(a2 + 8) & 0x40) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        {
          sub_1006A380(&v136, a2, a3, v4);
          if ( *(_BYTE *)(a2 + 11) )
          {
            v84 = (char *)(*(_DWORD *)(v4 + 56) + 69);
            v85 = *(_DWORD *)(v4 + 56) + 70;
            do
              v86 = *v84++;
            while ( v86 );
            v87 = (_BYTE)v84 - v85;
            v88 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
            v89 = (_BYTE)v88 + 1;
            do
              v90 = *v88++;
            while ( v90 );
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v87 - ((_BYTE)v88 - v89)) - 1;
          }
          else
          {
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
          }
        }
        if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 )
          goto LABEL_177;
        v91 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v92 = *(_DWORD *)(v4 + 56) + 70;
        do
          v93 = *v91++;
        while ( v93 );
        v94 = (_BYTE)v91 - v92;
        v95 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
        v96 = (_BYTE)v95 + 1;
        do
          v97 = *v95++;
        while ( v97 );
        v98 = *(_DWORD *)(v4 + 56);
        if ( *(_WORD *)(v98 + 240) <= (signed __int16)(char)(v94 - ((_BYTE)v95 - v96)) )
        {
LABEL_177:
          if ( (*(_WORD *)(a4 + 14) != 45 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) < 0.0)
            && (*(_WORD *)(a4 + 14) != 43 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) > 0.0) )
          {
            v114 = a2;
          }
          else
          {
            v114 = a2;
            if ( *(_BYTE *)(a2 + 8) & 0x40 || *(_WORD *)(a4 + 14) == 45 )
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
            }
            else
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 48;
              v135 = 2;
            }
          }
          v115 = *(_DWORD *)(v4 + 56);
          if ( !*(_WORD *)(v115 + 240)
            && (*(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 43
             || *(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 45
             || (*(_BYTE *)(v114 + 8) & 0x3F) == 7) )
          {
            if ( (*(_BYTE *)(v114 + 8) & 0x3F) == 7 )
            {
              v116 = (const char *)(v115 + 69);
              v117 = (char *)(v115 + 69);
              v118 = v115 + 70;
              do
                v119 = *v117++;
              while ( v119 );
              v120 = (_BYTE)v117 - v118;
              v121 = strchr(v116, 46);
              v122 = (_BYTE)v121 + 1;
              do
                v123 = *v121++;
              while ( v123 );
              *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v120 - ((_BYTE)v121 - v122)) - 1;
            }
            else
            {
              ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
            }
            v124 = *(_DWORD *)(v4 + 56);
            v125 = a3 - (((unsigned int)*(_WORD *)(v114 + 8) >> 13) & 3) - 1;
            if ( *(_WORD *)(v124 + 240) < v125 )
              LOWORD(v125) = *(_WORD *)(v124 + 240);
            *(_WORD *)(v124 + 240) = (char)v125;
          }
        }
        else
        {
          v99 = (const char *)(v98 + 69);
          v100 = (char *)(v98 + 69);
          v101 = v98 + 70;
          do
            v102 = *v100++;
          while ( v102 );
          v103 = (_BYTE)v100 - v101;
          v104 = strchr(v99, 101);
          v105 = (_BYTE)v104 + 1;
          do
            v106 = *v104++;
          while ( v106 );
          *(_BYTE *)((char)(v103 - ((_BYTE)v104 - v105)) + *(_DWORD *)(v4 + 56) + 70) = *(_BYTE *)(a4 + 14);
          v107 = (char *)(*(_DWORD *)(v4 + 56) + 69);
          v108 = *(_DWORD *)(v4 + 56) + 70;
          do
            v109 = *v107++;
          while ( v109 );
          v110 = (_BYTE)v107 - v108;
          v111 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
          v112 = (_BYTE)v111 + 1;
          do
            v113 = *v111++;
          while ( v113 );
          if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == (char)(v110 - ((_BYTE)v111 - v112)) + 1 )
            ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
          v135 = 2;
        }
      }
      else if ( *(_WORD *)(v6 + 14) == 46 && *(_BYTE *)(a2 + 11) > 0 )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
          sub_1006A380(&v136, a2, a3, v4);
        v126 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v127 = *(_DWORD *)(v4 + 56) + 70;
        do
          v128 = *v126++;
        while ( v128 );
        v129 = (_BYTE)v126 - v127;
        v130 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v131 = (_BYTE)v130 + 1;
        do
          v132 = *v130++;
        while ( v132 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v129 - ((_BYTE)v130 - v131)) + 1;
      }
    }
    else
    {
      if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        sub_1006A380(&v136, a2, a3, v4);
      v77 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v78 = *(_DWORD *)(v4 + 56) + 70;
      do
        v79 = *v77++;
      while ( v79 );
      v80 = (_BYTE)v77 - v78;
      v81 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
      v82 = (_BYTE)v81 + 1;
      do
        v83 = *v81++;
      while ( v83 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v80 - ((_BYTE)v81 - v82)) + 1;
      v135 = 2;
    }
    goto LABEL_170;
  }
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( v24 == -128 )
  {
    sub_1006A380(&v136, a2, a3, v4);
    if ( *(_BYTE *)(a2 + 11) )
    {
      v25 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      do
        v26 = *v25++;
      while ( v26 );
      v27 = (_BYTE)v25 - (*(_BYTE *)(v4 + 56) + 70);
      v28 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v29 = (_BYTE)v28 + 1;
      do
        v30 = *v28++;
      while ( v30 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v27 - ((_BYTE)v28 - v29)) - 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_BYTE *)(a2 + 11) > 0 )
    {
      if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7
        || (v31 = *(_DWORD *)(v4 + 56), v32 = *(_BYTE *)(v31 + 69), v32 > 0x30u)
        || (v32 == 43 || v32 == 45) && *(_BYTE *)(v31 + 70) != 48 )
      {
        v33 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        do
          v34 = *v33++;
        while ( v34 );
        v35 = (_BYTE)v33 - (*(_BYTE *)(v4 + 56) + 70);
        v36 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v37 = (_BYTE)v36 + 1;
        do
          v38 = *v36++;
        while ( v38 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v35 - ((_BYTE)v36 - v37)) + 1;
        v135 = 2;
        goto LABEL_170;
      }
    }
LABEL_99:
    v135 = 2;
    goto LABEL_170;
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
  {
    v39 = (const char *)(v23 + 69);
    v40 = strlen(v39);
    v41 = strchr(v39, 101);
    v42 = (_BYTE)v41 + 1;
    do
      v43 = *v41++;
    while ( v43 );
    v23 = *(_DWORD *)(v4 + 56);
    v24 = *(_WORD *)(v23 + 240);
    if ( v24 > (char)(v40 - ((_BYTE)v41 - v42)) )
    {
      if ( a3 - v24 != 2 )
      {
        if ( a3 - v24 != 3 )
        {
          v44 = *(_DWORD *)(v4 + 56);
          if ( a3 - v24 != 4 )
          {
            if ( *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 68) < 0x33u || *(_WORD *)(a4 + 14) < 0x38u )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
              goto LABEL_170;
            }
            goto LABEL_99;
          }
          ++*(_WORD *)(v44 + 240);
        }
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
      }
      v45 = *(_WORD *)(a4 + 14);
      if ( v45 >= 0x30u
        && v45 <= 0x33u
        && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 70) < 0x38u || v45 < 0x33u) )
      {
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
        v135 = 2;
        goto LABEL_170;
      }
      goto LABEL_99;
    }
  }
  if ( *(_BYTE *)(a2 + 11) <= 0 )
    goto LABEL_178;
  v46 = (const char *)(v23 + 69);
  v47 = strlen(v46);
  v48 = strchr(v46, 46);
  v49 = (_BYTE)v48 + 1;
  do
    v50 = *v48++;
  while ( v50 );
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( *(_WORD *)(v23 + 240) != (char)(v47 - ((_BYTE)v48 - v49)) - 1 )
  {
LABEL_178:
    v51 = a2;
    if ( !*(_BYTE *)(a2 + 11) )
    {
      if ( v24 == a3 - (((unsigned int)*(_WORD *)(a2 + 8) >> 13) & 3) - 1 )
        goto LABEL_64;
      v51 = a2;
    }
    if ( (*(_BYTE *)(v51 + 8) & 0x3F) == 7 && !v24 )
    {
      v71 = (const char *)(v23 + 69);
      v72 = strlen(v71);
      v73 = strchr(v71, 46);
      v74 = (_BYTE)v73 + 1;
      do
        v75 = *v73++;
      while ( v75 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v72 - ((_BYTE)v73 - v74)) - 1;
      v51 = a2;
    }
    *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    v76 = a3 - (((unsigned int)*(_WORD *)(v51 + 8) >> 13) & 3) - 1;
    if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) < v76 )
      LOWORD(v76) = *(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)v76;
    goto LABEL_99;
  }
LABEL_64:
  v52 = *(_BYTE *)(v23 + 69);
  v53 = a2;
  if ( v52 == 48 && (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || (v52 == 43 || v52 == 45) && *(_BYTE *)(v23 + 70) == 48 )
  {
    if ( v52 == 45 )
    {
      *(_BYTE *)(v23 + 69) = 48;
      v138 = -1;
    }
    v139 = j__atol((const char *)(*(_DWORD *)(v4 + 56) + 69));
    v54 = *(_BYTE *)(v53 + 11) == 0;
    v55 = *(_BYTE *)(v53 + 11) < 0;
    v136 = (double)v139 * 10.0;
    if ( !v55 && !v54 )
    {
      v56 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v57 = *(_DWORD *)(v4 + 56) + 70;
      do
        v58 = *v56++;
      while ( v58 );
      v59 = (_BYTE)v56 - v57;
      v60 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v61 = (_BYTE)v60 + 1;
      do
        v62 = *v60++;
      while ( v62 );
      v140 = atof((const char *)((char)(v59 - ((_BYTE)v60 - v61)) + *(_DWORD *)(v4 + 56) + 69));
      v136 = v140 + v136;
    }
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v137, a3, *(_BYTE *)(v53 + 11), v136);
    if ( v138 == -1 )
      *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 45;
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
  if ( *(_BYTE *)(v53 + 11) <= 0 )
    goto LABEL_99;
  if ( (*(_BYTE *)(v53 + 8) & 0x3F) != 7 )
  {
    v63 = *(_DWORD *)(v4 + 56);
    v64 = *(_BYTE *)(v63 + 69);
    if ( v64 <= 0x30u && (v64 != 43 && v64 != 45 || *(_BYTE *)(v63 + 70) == 48) )
      goto LABEL_99;
  }
  v65 = (char *)(*(_DWORD *)(v4 + 56) + 69);
  do
    v66 = *v65++;
  while ( v66 );
  v67 = (_BYTE)v65 - (*(_BYTE *)(v4 + 56) + 70);
  v68 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) + 1;
  v135 = 2;
LABEL_170:
  v133 = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 101 || *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return v135;
}

//----- (1006AF30) --------------------------------------------------------
char __usercall sub_1006AF30@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5)
{
  float *v5; // edi@1
  __int16 v6; // ax@1
  unsigned int v7; // edi@1
  int v8; // ebp@1
  __int16 v9; // ax@1
  char *v11; // [sp+8h] [bp-4h]@1

  v5 = a2;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  v11 = sub_100793B0(*(_WORD *)(a4 + 8), a2);
  v6 = sub_1006D690(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8), v5);
  v7 = *(_DWORD *)(a4 + 4);
  v8 = v6;
  v9 = *(_WORD *)(a4 + 12);
  if ( (*(_DWORD *)(a4 + 4) & 0xC000) != 0x4000 )
  {
    v9 -= v8;
    if ( v8 > 0 )
      v9 -= *(_WORD *)(dword_1068B4C4[5 * ((v7 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a4 + 12) )
    v9 = sub_10069E20(v7, *(_WORD *)(a4 + 8), a5, *(_BYTE *)(a4 + 11));
  return sub_1006DCF0(a3, (char *)(*(_DWORD *)(a3 + 56) + 69), v11, v9, v8, v7, *(_WORD *)(a4 + 8));
}
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (1006AFF0) --------------------------------------------------------
char __usercall sub_1006AFF0@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4)
{
  double v4; // st7@2
  double v6; // [sp+0h] [bp-8h]@4

  if ( 9.8999998e24 == *a2 )
    v4 = 9.899999762399947e24;
  else
    v4 = *a2;
  v6 = v4;
  return sub_10069E80(a3, a1, a4, &v6);
}

//----- (1006B030) --------------------------------------------------------
char __cdecl sub_1006B030(int a1, int a2, int *a3, float *a4, int a5)
{
  __int16 v5; // cx@2
  __int16 v6; // cx@4
  __int16 v7; // ax@9
  _WORD *v8; // esi@9
  unsigned int v9; // ebp@10
  int v10; // eax@10
  int v11; // edx@12
  __int16 v12; // ax@16
  int v13; // eax@17
  __int16 v14; // cx@17
  int v16; // eax@19
  signed __int16 v17; // si@19
  signed int v18; // eax@20
  char v19; // al@27
  char v20; // al@33
  __int16 v21; // ax@36
  signed int v22; // ecx@40
  int v23; // ecx@42
  int v24; // ecx@43
  int v25; // ecx@45
  int v26; // ecx@47
  int v27; // edi@49
  const char *v28; // eax@50
  char v29; // ST38_1@50
  bool v30; // zf@58
  bool v31; // sf@58
  int v32; // esi@65
  char v33; // dl@68
  bool v34; // zf@73
  bool v35; // sf@73
  bool v36; // zf@80
  bool v37; // sf@80
  char v38; // al@87
  int v39; // esi@94
  double v40; // st7@96
  int v41; // esi@101
  unsigned int v42; // edx@101
  __int16 v43; // bx@101
  unsigned __int8 v44; // cl@103
  int v45; // ecx@109
  _WORD *v46; // eax@109
  char v47; // dl@109
  char *v48; // eax@114
  int v49; // esi@114
  char v50; // dl@115
  char v51; // bl@116
  char *v52; // eax@116
  char v53; // dl@116
  char v54; // cl@117
  char v55; // cl@118
  int v56; // eax@118
  int v57; // edx@118
  char *v58; // eax@120
  int v59; // esi@120
  char v60; // dl@121
  char v61; // bl@122
  char *v62; // eax@122
  char v63; // dl@122
  char v64; // cl@123
  char v65; // cl@124
  int v66; // eax@124
  int v67; // edx@124
  char v68; // [sp-4h] [bp-2Ch]@64
  unsigned __int16 v69; // [sp+0h] [bp-28h]@64
  char v70; // [sp+4h] [bp-24h]@64
  char v71; // [sp+1Bh] [bp-Dh]@1
  size_t v72; // [sp+1Ch] [bp-Ch]@2
  unsigned int v73; // [sp+3Ch] [bp+14h]@50
  int v74; // [sp+3Ch] [bp+14h]@99

  v71 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v72 = 0;
  }
  else
  {
    v72 = *(_BYTE *)(a2 + 10);
    v5 = *(_WORD *)(a2 + 8);
    if ( v5 & 0x40 || *(_WORD *)(a2 + 8) & 0x800 || (v6 = v5 & 0x3F, v6 == 7) || v6 == 28 )
      ++v72;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 12);
      v8 = (_WORD *)(a1 + 276);
      if ( v7 )
      {
        sub_1006DB90(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v7);
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 4);
        v10 = sub_10069E20(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
        sub_1006DB90((int)v8, *a3, v9, v10);
      }
      v11 = (signed __int16)sub_1006D690(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v11 > 0 )
      {
        v12 = *(_WORD *)(dword_1068B4C4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v11 + v12;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v13 = (v12 + v11 + 1) / 2;
          v14 = *(_WORD *)(a1 + 280) - v13;
          *v8 -= v13;
          *(_WORD *)(a1 + 280) = v14;
        }
      }
      return 2;
    case 0x8048:
      v16 = *(_DWORD *)(a1 + 56);
      v17 = *(_WORD *)(v16 + 240);
      if ( v17 == -128 )
      {
        v18 = *(_WORD *)(a5 + 10);
        if ( v18 > 84 )
        {
          if ( v18 != 0x2000 )
            return v71;
        }
        else if ( v18 != 84 )
        {
          if ( v18 == 32 )
          {
            if ( *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
              return v71;
            v71 = sub_1006A380(a4, a2, v72, a1);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, v72);
            if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
            {
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 71) = 46;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 64) = 101;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 65) = 43;
            }
            else
            {
              v20 = *(_BYTE *)(a2 + 11);
              if ( v20 > 0 )
                *(_BYTE *)(*(_DWORD *)(a1 + 56) - v20 + v72 + 68) = 46;
            }
            goto LABEL_132;
          }
          if ( v18 != 56
            || *(_WORD *)(a2 + 8) & 0x400
            || (*(_WORD *)(a2 + 8) & 0x3F) == 27
            || *(_WORD *)(a2 + 8) & 0x800 )
          {
            return v71;
          }
          v19 = sub_1006A380(a4, a2, v72, a1);
LABEL_131:
          v71 = v19;
LABEL_132:
          if ( v71 != 4 && v71 != 2 )
            return v71;
          goto LABEL_134;
        }
        v21 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v21 & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
          return v71;
        v19 = sub_1006A460(a1, a2, v72, a5);
        goto LABEL_131;
      }
      v22 = *(_WORD *)(a5 + 10);
      if ( v22 > 57 )
      {
        if ( v22 != 84 && v22 != 0x2000 )
          return v71;
        v19 = sub_1006A460(a1, a2, v72, a5);
        goto LABEL_131;
      }
      if ( v22 == 57 )
      {
        *(_WORD *)(v16 + 240) += *(_BYTE *)(a5 + 8);
        v41 = *(_DWORD *)(a1 + 56);
        v42 = *(_WORD *)(a2 + 8);
        v43 = *(_WORD *)(v41 + 240);
        v71 = 2;
        if ( v43 >= 0 )
        {
          v44 = *(_BYTE *)(a2 + 10);
          if ( v43 <= (signed int)(v44 - ((v42 >> 13) & 3) - 1) || v42 & 0x40 || (v42 & 0x3F) == 7 )
          {
            if ( v43 <= (signed int)v44 )
            {
              while ( 1 )
              {
                v45 = *(_DWORD *)(a1 + 56);
                v46 = (_WORD *)(v45 + 240);
                v47 = *(_BYTE *)(*(_WORD *)(v45 + 240) + v45 + 69);
                if ( v47 != 46 && v47 != 101 )
                {
                  if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || *(_WORD *)(v45 + 240) <= 0 )
                    break;
                  if ( !strchr((const char *)(v45 + 69), 46) )
                    goto LABEL_142;
                  v48 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                  v49 = *(_DWORD *)(a1 + 56) + 70;
                  do
                    v50 = *v48++;
                  while ( v50 );
                  v51 = (_BYTE)v48 - v49;
                  v52 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46);
                  v53 = (_BYTE)v52 + 1;
                  do
                    v54 = *v52++;
                  while ( v54 );
                  v55 = (_BYTE)v52 - v53;
                  v56 = *(_DWORD *)(a1 + 56);
                  v57 = *(_WORD *)(v56 + 240);
                  v46 = (_WORD *)(v56 + 240);
                  if ( v57 >= (char)(v51 - v55) - 1 )
                  {
LABEL_142:
                    if ( strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46) )
                      break;
                    v58 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                    v59 = *(_DWORD *)(a1 + 56) + 70;
                    do
                      v60 = *v58++;
                    while ( v60 );
                    v61 = (_BYTE)v58 - v59;
                    v62 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 101);
                    v63 = (_BYTE)v62 + 1;
                    do
                      v64 = *v62++;
                    while ( v64 );
                    v65 = (_BYTE)v62 - v63;
                    v66 = *(_DWORD *)(a1 + 56);
                    v67 = *(_WORD *)(v66 + 240);
                    v46 = (_WORD *)(v66 + 240);
                    if ( v67 >= (char)(v61 - v65) - 1 )
                      break;
                  }
                }
                if ( *(_BYTE *)(a5 + 8) <= 0 )
                  --*v46;
                else
                  ++*v46;
              }
            }
            else
            {
              *(_WORD *)(v41 + 240) = (char)v44;
            }
          }
          else
          {
            *(_WORD *)(v41 + 240) = (char)(v44 - ((v42 >> 13) & 3) - 1);
          }
        }
        else
        {
          *(_WORD *)(v41 + 240) = 0;
        }
        goto LABEL_134;
      }
      v23 = v22 - 32;
      if ( !v23 )
      {
        *(_WORD *)(v16 + 240) = -128;
        sub_1006AFF0(a2, a4, a1, (int)a3);
        return 6;
      }
      v24 = v23 - 1;
      if ( v24 )
      {
        if ( v24 != 23 )
          return v71;
        v25 = *(_WORD *)(a2 + 8);
        if ( v25 & 0x40 && !v17 )
        {
          LOBYTE(v25) = *(_BYTE *)(v16 + 69) != 45;
          v26 = 2 * v25 + 43;
LABEL_48:
          *(_BYTE *)(v16 + 69) = v26;
          v71 = 2;
LABEL_134:
          sub_1006AF30((int)a3, a4, a1, a2, v72);
          return v71;
        }
        v27 = 2 * (*(_BYTE *)(a5 + 8) >= 0) - 1;
        if ( (v25 & 0x3F) != 7
          || (v28 = (const char *)(v16 + 69),
              v73 = strlen(v28),
              v29 = strlen(strchr(v28, 101)),
              v16 = *(_DWORD *)(a1 + 56),
              v17 = *(_WORD *)(v16 + 240),
              v17 <= (char)(v73 - v29))
          && v17 )
        {
          v38 = *(_BYTE *)(v17 + v16 + 69);
          if ( (v38 == 48 && v27 < 0 || v38 == 57 && v27 > 0) && !v17 && sub_10079370(*(_WORD *)(a2 + 8)) )
          {
            *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
          v39 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69) = sub_10071500(
                                                           *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69),
                                                           0x10u,
                                                           v27);
        }
        else
        {
          if ( !v17 )
          {
            v71 = 2;
            *(_BYTE *)(v16 + 69) = *(_BYTE *)(v16 + 69) != 45 ? 45 : 48;
            goto LABEL_134;
          }
          if ( v72 - v17 == 2 )
          {
            v16 += v17;
            if ( *(_BYTE *)(v16 + 70) > 0x37u )
            {
              v34 = v27 == 0;
              v35 = v27 < 0;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 50;
                  v71 = 2;
                  goto LABEL_134;
                }
                v34 = v27 == 0;
                v35 = v27 < 0;
              }
              if ( !v35 && !v34 && *(_BYTE *)(v16 + 69) >= 0x32u )
              {
                *(_BYTE *)(v16 + 69) = 48;
                v71 = 2;
                goto LABEL_134;
              }
LABEL_64:
              v70 = v27;
              v69 = 16;
              v68 = *(_BYTE *)(v16 + 69);
LABEL_65:
              v32 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v32 + 240) + v32 + 69) = sub_10071500(v68, v69, v70);
              v71 = 2;
              goto LABEL_134;
            }
            v36 = v27 == 0;
            v37 = v27 < 0;
            if ( v27 < 0 )
            {
              if ( *(_BYTE *)(v16 + 69) == 48 )
              {
                *(_BYTE *)(v16 + 69) = 51;
                v71 = 2;
                goto LABEL_134;
              }
              v36 = v27 == 0;
              v37 = v27 < 0;
            }
            if ( !v37 && !v36 && *(_BYTE *)(v16 + 69) >= 0x33u )
            {
              *(_BYTE *)(v16 + 69) = 48;
              v71 = 2;
              goto LABEL_134;
            }
LABEL_66:
            v70 = v27;
            v69 = 16;
            v68 = *(_BYTE *)(v16 + 69);
            goto LABEL_65;
          }
          if ( v72 - v17 != 3 )
          {
            if ( v72 - v17 == 4 )
            {
              v71 = 2;
              *(_BYTE *)(v17 + v16 + 69) = 2 * (*(_BYTE *)(v17 + v16 + 69) != 45) + 43;
              goto LABEL_134;
            }
            v16 += v17;
            if ( *(_BYTE *)(v16 + 68) >= 0x33u )
            {
              v30 = v27 == 0;
              v31 = v27 < 0;
              LOBYTE(v26) = 48;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 55;
                  v71 = 2;
                  goto LABEL_134;
                }
                v30 = v27 == 0;
                v31 = v27 < 0;
              }
              if ( !v31 && !v30 && *(_BYTE *)(v16 + 69) >= 0x37u )
                goto LABEL_48;
              goto LABEL_64;
            }
            goto LABEL_66;
          }
          v33 = *(_BYTE *)(v17 + v16 + 69);
          if ( v33 == 45 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 43;
            v71 = 2;
            goto LABEL_134;
          }
          if ( v33 == 43 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
        }
        v71 = 2;
        goto LABEL_134;
      }
      *(_WORD *)(v16 + 240) = -128;
      v40 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
      if ( v40 > 1.0e25 || v40 < -1.0e25 )
        v40 = 9.899999762399947e24;
      *(float *)&v74 = v40;
      *a4 = sub_10079E70(v74, *(_WORD *)(a2 + 8));
      sub_1006AFF0(a2, a4, a1, (int)a3);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_1006AFF0(a2, a4, a1, (int)a3);
        return v71;
      }
      sub_1006AF30((int)a3, a4, a1, a2, v72);
      return 1;
    default:
      return v71;
  }
}
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (1006B920) --------------------------------------------------------
void *__usercall sub_1006B920@<eax>(int a1@<ecx>, int a2@<esi>, unsigned int *a3)
{
  unsigned int v3; // eax@1
  int v4; // edi@1
  unsigned int v5; // ebx@2
  void *result; // eax@2
  char v7; // [sp+4h] [bp-44h]@2
  char v8[32]; // [sp+24h] [bp-24h]@2

  v3 = *a3;
  v4 = 3 - ((*(_BYTE *)(a1 + 8) & 0x3F) != 44);
  if ( *a3 == 0xFFFF )
  {
    result = memset((void *)a2, 95, v4 + 4);
    *(_BYTE *)(a2 + 3) = 46;
    *(_BYTE *)(a2 + v4 + 4) = 0;
  }
  else
  {
    v5 = v3 % 0x3E8;
    sprintf(&v7, "%0*i", 3, v3 / 0x3E8);
    sprintf(v8, "%03i", v5);
    v8[v4] = 0;
    strncat(&v7, word_100CC1C0, 0x1Bu);
    strncat(&v7, v8, 0x1Au);
    result = strncpy((char *)a2, &v7, 0x1Eu);
  }
  return result;
}
// 1006B920: using guessed type char var_24[32];

//----- (1006B9F0) --------------------------------------------------------
int __usercall sub_1006B9F0@<eax>(unsigned int a1@<eax>, int a2@<esi>, char a3, int a4)
{
  int v4; // edx@1
  int *v5; // ecx@1
  int result; // eax@1

  v4 = byte_1068B4D1[20 * ((a1 >> 10) & 0xF)];
  v5 = &dword_1068B4C0[5 * ((a1 >> 10) & 0xF)];
  result = a2 * v4 + (a2 - 1) * *(_WORD *)(dword_1068B4C4[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a3 & 0x80 )
      result += *((_BYTE *)v5 + 15) - v4;
  }
  return result;
}
// 1068B4C0: using guessed type int dword_1068B4C0[];
// 1068B4C4: using guessed type int dword_1068B4C4[];

//----- (1006BA40) --------------------------------------------------------
signed int __usercall sub_1006BA40@<eax>(int a1@<eax>, void *a2@<ecx>, unsigned int *a3, int a4)
{
  unsigned int *v4; // ebp@1
  signed int v5; // edi@1
  unsigned int v6; // ebx@4
  signed int v7; // esi@4
  unsigned int v8; // edx@6
  int v9; // eax@9
  int v10; // edx@9
  unsigned int v11; // edx@10
  int v12; // ebx@17
  signed int result; // eax@17
  signed int v14; // [sp+10h] [bp-4h]@2
  signed int v15; // [sp+18h] [bp+4h]@2

  v4 = a3;
  v5 = (signed int)a2;
  LOWORD(a2) = *(_WORD *)(a1 + 8) & 0x3F;
  if ( (_WORD)a2 == 45 )
  {
    v15 = 108;
    v14 = 117;
  }
  else
  {
    v15 = 118;
    v14 = 136;
  }
  v6 = *v4 / 0x3E8;
  v7 = *v4 % 0x3E8;
  if ( v5 )
  {
    if ( (_WORD)a2 == 45 )
    {
      v8 = (signed int)((unsigned __int64)(1374389535i64 * (50 * v5 + v7)) >> 32) >> 4;
      v7 = 50 * (v8 + (v8 >> 31));
    }
    else if ( sub_1007A560(a2) == 1 )
    {
      v7 = 25 * ((25 * v5 + v7) / 25);
    }
    else
    {
      v9 = v5 % 4 + v7 % 25 / 5;
      v10 = 0;
      if ( v5 >= 0 )
      {
        v11 = v9 < 4 ? 0 : 5;
      }
      else
      {
        LOBYTE(v10) = v9 >= 0;
        v11 = (v10 - 1) & 0xFFFFFFFB;
      }
      v7 = 5
         * (((signed int)((unsigned __int64)(1717986919i64 * (signed int)(v5 % 4 + v11 + 4 * (v5 % 4) + v7)) >> 32) >> 1)
          + 5 * (v5 / 4)
          + ((unsigned int)((unsigned __int64)(1717986919i64 * (signed int)(v5 % 4 + v11 + 4 * (v5 % 4) + v7)) >> 32) >> 31));
    }
    if ( v7 >= 0 )
    {
      if ( v7 >= 1000 )
        v7 -= 1000;
    }
    else
    {
      v7 += 1000;
    }
  }
  v12 = a4 + v6;
  result = v14;
  if ( v12 <= v14 )
  {
    if ( v12 < v15 )
      v12 = v14;
    *v4 = v7 + 1000 * v12;
  }
  else
  {
    *v4 = v7 + 1000 * v15;
  }
  return result;
}

//----- (1006BBC0) --------------------------------------------------------
unsigned int __usercall sub_1006BBC0@<eax>(int a1@<ebx>, int a2, unsigned int *a3)
{
  unsigned int v3; // esi@1
  char v4; // cl@1
  unsigned int v5; // edi@2
  unsigned int v6; // ecx@2
  unsigned int v7; // edx@2
  unsigned int v8; // eax@2
  unsigned int result; // eax@10
  float v10; // ST04_4@15
  float v11; // ST00_4@15
  double v12; // st7@15
  unsigned int v13; // ecx@15
  signed int v14; // edx@18

  v3 = *a3;
  v4 = *(_BYTE *)(a1 + 8) & 0x3F;
  if ( v4 == 45 )
  {
    v5 = 50;
    v6 = 117950;
    v7 = 108000;
    v8 = 117000;
  }
  else
  {
    if ( sub_1007A560((void *)v4) == 1 )
    {
      v5 = 25;
      v6 = 136975;
    }
    else
    {
      v5 = 5;
      v6 = 136990;
    }
    v8 = 1000 * ((unsigned int)(v6 * (unsigned __int64)(unsigned int)&unk_10624DD3 >> 32) >> 6);
    v7 = 118000;
  }
  if ( *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) == 2 )
  {
    if ( v3 < v7 || v3 > v6 )
      return -1;
    goto LABEL_13;
  }
  if ( v3 <= v6 )
  {
LABEL_13:
    if ( v3 < v7 )
      v3 = v7;
    goto LABEL_15;
  }
  v3 = v8;
LABEL_15:
  v10 = (double)v5;
  v11 = (double)v3;
  v12 = sub_100A7380(v11, v10);
  v13 = (signed __int64)v12;
  if ( (*(_BYTE *)(a1 + 8) & 0x3F) != 44 || v5 != 5 || v13 % 0x19 / 5 != 4 )
  {
    result = (signed __int64)v12;
  }
  else
  {
    v14 = *a3 % 0xA != 0 ? -1 : 1;
    result = v14 + v13 + 4 * v14;
  }
  return result;
}

//----- (1006BD10) --------------------------------------------------------
char __usercall sub_1006BD10@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // ax@1

  v3 = *(_WORD *)(a3 + 12);
  *(_WORD *)(a2 + 438) = *(_WORD *)a1;
  *(_WORD *)(a2 + 436) = *(_WORD *)(a1 + 2);
  if ( !*(_WORD *)(a3 + 12) )
    v3 = sub_1006B9F0(*(_DWORD *)(a3 + 4), *(_BYTE *)(a3 + 10), *(_WORD *)(a3 + 8), *(_BYTE *)(a3 + 11));
  return sub_1006DCF0(
           a2,
           (char *)(*(_DWORD *)(a2 + 56) + 69),
           (const char *)&unk_100C4192,
           v3,
           0,
           *(_DWORD *)(a3 + 4),
           *(_WORD *)(a3 + 8));
}

//----- (1006BD70) --------------------------------------------------------
char __usercall sub_1006BD70@<al>(int a1@<ebx>, int a2@<edi>, int a3, unsigned int *a4)
{
  __int16 v4; // ax@1
  char v6; // [sp+8h] [bp-24h]@1

  sub_1006B920(a2, (int)&v6, a4);
  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v4 = *(_WORD *)(a2 + 12);
  if ( !v4 )
    v4 = sub_1006B9F0(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 10), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 11));
  return sub_1006DCF0(a1, &v6, (const char *)&unk_100C4192, v4, 0, *(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
}

//----- (1006BE10) --------------------------------------------------------
char __usercall sub_1006BE10@<al>(unsigned int *a1@<edx>, int a2@<ecx>, int a3@<edi>)
{
  size_t v3; // ebp@1
  char *v4; // eax@1
  int v5; // esi@1
  char v6; // dl@2
  char v7; // bl@3
  char *v8; // eax@3
  char v9; // dl@3
  char v10; // cl@4

  v3 = 3 - ((*(_BYTE *)(a2 + 8) & 0x3F) != 44);
  sub_1006B920(a2, *(_DWORD *)(a3 + 56) + 69, a1);
  v4 = (char *)(*(_DWORD *)(a3 + 56) + 69);
  v5 = *(_DWORD *)(a3 + 56) + 70;
  do
    v6 = *v4++;
  while ( v6 );
  v7 = (_BYTE)v4 - v5;
  v8 = strchr((const char *)(*(_DWORD *)(a3 + 56) + 69), 46);
  v9 = (_BYTE)v8 + 1;
  do
    v10 = *v8++;
  while ( v10 );
  memset((void *)((char)(v7 - ((_BYTE)v8 - v9)) + *(_DWORD *)(a3 + 56) + 70), 48, v3);
  *(_WORD *)(*(_DWORD *)(a3 + 56) + 240) = 0;
  return 4;
}

//----- (1006BEA0) --------------------------------------------------------
int __usercall sub_1006BEA0@<eax>(int a1@<eax>, void *a2@<ecx>, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  double v6; // st7@1
  int v7; // eax@1
  unsigned __int8 v8; // bl@1
  char *v9; // eax@3
  char v10; // dl@4
  double v11; // st7@10
  int v12; // eax@10
  int v13; // esi@10
  int v14; // edx@11
  int v15; // eax@11
  int result; // eax@15
  int v17; // [sp+18h] [bp-4h]@1

  v4 = a1;
  v5 = (unsigned __int8)sub_1007A560(a2);
  v6 = atof((const char *)(*(_DWORD *)(v4 + 56) + 69));
  v7 = sub_100A7300(v6 * 1000.0);
  v8 = *(_BYTE *)(a4 + 14);
  v17 = v7;
  if ( v8 != 46 || *(_BYTE *)(a3 + 11) <= 0 )
  {
    if ( (*(_BYTE *)(a3 + 8) & 0x3F) == 45 && strchr((&off_100DF3C0)[4 * *(_WORD *)(*(_DWORD *)(v4 + 56) + 240)], v8)
      || (*(_BYTE *)(a3 + 8) & 0x3F) == 44 && strchr((*off_100DF3B8[v5])[*(_WORD *)(*(_DWORD *)(v4 + 56) + 240)], v8) )
    {
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = v8;
      v11 = atof((const char *)(*(_DWORD *)(v4 + 56) + 69));
      a4 = sub_100A7300(v11 * 1000.0);
      v12 = sub_1006BBC0(a3, v4, (unsigned int *)&a4);
      v13 = *(_DWORD *)(v4 + 56) + 69;
      a4 = v12;
      if ( v12 == -1 )
      {
        sub_1006B920(a3, v13, (unsigned int *)&v17);
      }
      else
      {
        sub_1006B920(a3, v13, (unsigned int *)&a4);
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
        v14 = *(_DWORD *)(v4 + 56);
        v15 = *(_BYTE *)(a3 + 10) - 1;
        if ( *(_WORD *)(v14 + 240) < v15 )
          LOWORD(v15) = *(_WORD *)(v14 + 240);
        *(_WORD *)(v14 + 240) = (char)v15;
      }
    }
  }
  else
  {
    v9 = (char *)(*(_DWORD *)(v4 + 56) + 69);
    do
      v10 = *v9++;
    while ( v10 );
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)((_BYTE)v9
                                                  - (*(_BYTE *)(v4 + 56)
                                                   + 70)
                                                  - strlen(strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46)))
                                           + 1;
  }
  result = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(result + 240) + result + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return result;
}
// 100DF3B8: using guessed type char *(*off_100DF3B8[2])[3];

//----- (1006C060) --------------------------------------------------------
char __cdecl sub_1006C060(int a1, int a2, __int64 a3, int a4)
{
  __int16 v4; // cx@2
  unsigned int v5; // edi@3
  int v6; // eax@3
  char result; // al@3
  unsigned __int16 v8; // cx@6
  unsigned __int16 v9; // ax@6
  int v10; // ecx@12
  int v11; // eax@12
  int v12; // eax@14
  void *v13; // ecx@17
  double v14; // st7@28
  unsigned __int16 v15; // ax@36
  void *v16; // ecx@39
  char v17; // [sp+1Bh] [bp-1h]@1

  v17 = 1;
  switch ( *(_WORD *)a4 )
  {
    case 0x8040:
      v4 = *(_WORD *)(a2 + 12);
      if ( v4 )
      {
        sub_1006DB90(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v4);
        result = 2;
      }
      else
      {
        v5 = *(_DWORD *)(a2 + 4);
        v6 = sub_1006B9F0(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 10), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 11));
        sub_1006DB90(a1 + 276, *(_DWORD *)a3, v5, v6);
        result = 2;
      }
      return result;
    case 0x8048:
      if ( ~((unsigned int)*(_WORD *)(a2 + 8) >> 10) & 1 )
      {
        v8 = *(_WORD *)(a2 + 14);
        v9 = *(_WORD *)(a4 + 10);
        if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
        {
          if ( v9 == v8 )
          {
            sub_1006BA40(a2, (void *)*(_BYTE *)(a4 + 8), (unsigned int *)HIDWORD(a3), 0);
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == v8 + 1 )
          {
            sub_1006BA40(a2, 0, (unsigned int *)HIDWORD(a3), *(_BYTE *)(a4 + 8));
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 33 )
          {
            sub_1006F7A0(*(_DWORD *)HIDWORD(a3));
            return 1;
          }
          if ( v9 != 0x2000 )
            return v17;
          v15 = *(_WORD *)(a4 + 14);
          if ( (v15 < 0x30u || v15 > 0x39u) && v15 != 46 )
            return v17;
          v17 = sub_1006BE10((unsigned int *)HIDWORD(a3), a2, a1);
          sub_1006BEA0(a1, v16, a2, a4);
          if ( v17 != 4 )
          {
            if ( v17 != 3 )
              return v17;
            goto LABEL_44;
          }
        }
        else
        {
          v17 = 4;
          if ( v9 == v8 )
          {
            sub_1006BA40(a2, (void *)*(_BYTE *)(a4 + 8), (unsigned int *)HIDWORD(a3), 0);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
LABEL_44:
            sub_1006BD70(a1, a2, a3, (unsigned int *)HIDWORD(a3));
            return v17;
          }
          if ( v9 == v8 + 1 )
          {
            sub_1006BA40(a2, 0, (unsigned int *)HIDWORD(a3), *(_BYTE *)(a4 + 8));
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 73 )
          {
            v10 = --*(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)(v10 <= 0 ? 0 : v10);
            v11 = *(_BYTE *)(a2 + 10) - 1;
            if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v11 )
              LOWORD(v11) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)v11;
            v12 = *(_DWORD *)(a1 + 56);
            if ( *(_BYTE *)(*(_WORD *)(v12 + 240) + v12 + 69) == 46 )
            {
              --*(_WORD *)(v12 + 240);
              sub_1006BD10(a3, a1, a2);
              return 4;
            }
            goto LABEL_40;
          }
          if ( v9 == 0x2000 )
          {
            if ( (v13 = (void *)*(_WORD *)(a4 + 14), (unsigned __int16)v13 >= 0x30u) && (unsigned __int16)v13 <= 0x39u
              || (_WORD)v13 == 46 )
            {
              sub_1006BEA0(a1, v13, a2, a4);
              sub_1006BD10(a3, a1, a2);
              return 4;
            }
          }
          if ( v9 == 33 || v9 == ((*(_WORD *)(a2 + 8) & 0x3F) != 44 ? 27 : 2) || v9 == 82 )
          {
            v14 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
            *(_DWORD *)HIDWORD(a3) = sub_100A7300(v14 * 1000.0);
LABEL_27:
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 37 || v9 == 34 || v9 == 32 )
            goto LABEL_27;
        }
LABEL_40:
        sub_1006BD10(a3, a1, a2);
        return v17;
      }
      if ( *(_WORD *)(a4 + 10) != 33 )
        return v17;
      sub_1006F7A0(*(_DWORD *)HIDWORD(a3));
      return 1;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_1006BD70(a1, a2, a3, (unsigned int *)HIDWORD(a3));
        return 2;
      }
      sub_1006BD10(a3, a1, a2);
      return 2;
    default:
      return v17;
  }
}

//----- (1006C4E0) --------------------------------------------------------
char __cdecl sub_1006C4E0(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_1068B040[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1006C550) --------------------------------------------------------
int __usercall sub_1006C550@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    do
    {
      sub_1009E590(
        v5 + 392,
        v3,
        v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * v3,
        0);
      ++v3;
    }
    while ( v3 < a3 );
  }
  *(_WORD *)(v5 + 428) = word_105728D8[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 430) = word_105728D8[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 440) = word_105728D8[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 442) = word_105728D8[*(_BYTE *)(v4 + 4) & 0x1F];
  return sub_1009E590(
           v5 + 392,
           a3,
           a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * a3,
           1);
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1006C630) --------------------------------------------------------
char __cdecl sub_1006C630(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // bx@5
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // ebp@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@17
  char v15; // al@19
  bool v16; // zf@19
  int v17; // eax@23
  int v18; // eax@28
  int v19; // esi@28

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( *(_DWORD *)(a1 + 64) == 9 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 248) = 1;
    v6 = word_105728D8[(unsigned __int8)sub_1007A590(*(_BYTE *)(a2 + 4) & 0x1F)];
    v7 = *(_BYTE *)(a2 + 4) & 0xE0;
    if ( !(*(_BYTE *)(a2 + 4) & 0xE0) )
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = v6;
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v17 + 25)
        && (*(_WORD *)(v17 + 40) || *(_WORD *)(v17 + 42) || *(_WORD *)(v17 + 44) || *(_WORD *)(v17 + 46)) )
      {
        sub_1009E590(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 42), 1);
        sub_1009E590(
          a1 + 392,
          0,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v18 = *(_DWORD *)(a1 + 56);
        sub_1009E590(
          a1 + 392,
          *(_WORD *)(v18 + 44) + *(_WORD *)(v18 + 40),
          *(_WORD *)(v18 + 42),
          *(_WORD *)(v18 + 32) - *(_WORD *)(v18 + 40) - *(_WORD *)(v18 + 44),
          *(_WORD *)(v18 + 46),
          1);
        v19 = *(_DWORD *)(a1 + 56);
        sub_1009E590(
          a1 + 392,
          0,
          *(_WORD *)(v19 + 46) + *(_WORD *)(v19 + 42),
          *(_WORD *)(v19 + 32),
          *(_WORD *)(v19 + 34) - *(_WORD *)(v19 + 42) - *(_WORD *)(v19 + 46),
          1);
        return 2;
      }
      sub_1009E590(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 34), 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      return 2;
    }
    if ( v7 == 32 )
    {
      *(_WORD *)(a1 + 428) = word_105728D8[(unsigned __int8)sub_1007A590(15)];
      *(_WORD *)(a1 + 430) = word_105728D8[(unsigned __int8)sub_1007A590(15)];
      *(_WORD *)(a1 + 440) = word_105728D8[(unsigned __int8)sub_1007A590(15)];
      *(_WORD *)(a1 + 442) = word_105728D8[(unsigned __int8)sub_1007A590(15)];
      sub_1006C550(a2, a1, 2u);
      return 2;
    }
    if ( v7 != 96 )
    {
      *(_WORD *)(a1 + 428) = word_105728D8[1];
      *(_WORD *)(a1 + 430) = word_105728D8[1];
      *(_WORD *)(a1 + 440) = word_105728D8[1];
      v8 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 442) = word_105728D8[1];
      sub_1009E590(a1 + 392, 0, 0, *(_WORD *)(v8 + 32), *(_WORD *)(v8 + 34), 1);
      *(_WORD *)(a1 + 428) = word_105728D8[15];
      *(_WORD *)(a1 + 430) = word_105728D8[14];
      sub_1009E590(a1 + 392, 0, 3, *(_WORD *)(*(_DWORD *)(a1 + 56) + 32), *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 6, 2);
      *(_WORD *)(a1 + 428) = word_105728D8[13];
      *(_WORD *)(a1 + 430) = word_105728D8[1];
      sub_1009E590(
        a1 + 392,
        1,
        4,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 8,
        2);
      *(_WORD *)(a1 + 428) = word_105728D8[14];
      *(_WORD *)(a1 + 430) = word_105728D8[12];
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      v9 = 2;
      do
      {
        sub_1009E590(
          a1 + 392,
          v9,
          v9 + 3,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2 * v9,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 2 * (v9 + 3),
          2);
        ++v9;
      }
      while ( v9 < 6 );
      v10 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v10 + 25)
        && (*(_WORD *)(v10 + 40) || *(_WORD *)(v10 + 42) || *(_WORD *)(v10 + 44) || *(_WORD *)(v10 + 46)) )
      {
        sub_1009E590(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 2);
        v11 = *(_DWORD *)(a1 + 56);
        *(_WORD *)(a1 + 428) = v6;
        *(_WORD *)(a1 + 430) = v6;
        sub_1009E590(a1 + 392, 6, 9, *(_WORD *)(v11 + 32) - 12, *(_WORD *)(v11 + 42) - 9, 1);
        sub_1009E590(
          a1 + 392,
          6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) - 6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v12 = *(_DWORD *)(a1 + 56);
        sub_1009E590(
          a1 + 392,
          *(_WORD *)(v12 + 44) + *(_WORD *)(v12 + 40),
          *(_WORD *)(v12 + 42),
          *(_WORD *)(v12 + 32) - *(_WORD *)(v12 + 40) - *(_WORD *)(v12 + 44) - 6,
          *(_WORD *)(v12 + 46),
          1);
        v13 = *(_DWORD *)(a1 + 56);
        sub_1009E590(
          a1 + 392,
          6,
          *(_WORD *)(v13 + 46) + *(_WORD *)(v13 + 42),
          *(_WORD *)(v13 + 32) - 12,
          *(_WORD *)(v13 + 34) - *(_WORD *)(v13 + 42) - *(_WORD *)(v13 + 46) - 9,
          1);
      }
      else
      {
        sub_1009E590(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 3);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      }
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 247) )
      {
        *(_WORD *)(a1 + 428) = word_105728D8[15];
        *(_WORD *)(a1 + 430) = word_105728D8[15];
        *(_WORD *)(a1 + 440) = word_105728D8[1];
        *(_WORD *)(a1 + 442) = word_105728D8[1];
        sub_1009E590(a1 + 392, 10, 13, *(_WORD *)(v14 + 32) - 20, *(_WORD *)(v14 + 34) - 26, 3);
        return 2;
      }
      return 2;
    }
    *(_WORD *)(a1 + 428) = word_105728D8[(unsigned __int8)sub_1007A590(15)];
    *(_WORD *)(a1 + 430) = word_105728D8[(unsigned __int8)sub_1007A590(15)];
    *(_WORD *)(a1 + 440) = word_105728D8[(unsigned __int8)sub_1007A590(15)];
    v15 = sub_1007A590(15);
    v16 = (*(_BYTE *)(a1 + 22) & 0x1E) == 0;
    *(_WORD *)(a1 + 442) = word_105728D8[(unsigned __int8)v15];
    if ( v16 )
    {
      sub_1006C550(a2, a1, 2u);
      result = 2;
    }
    else
    {
      sub_1006C550(a2, a1, 5u);
      result = 2;
    }
  }
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1006CBE0) --------------------------------------------------------
unsigned int *__usercall sub_1006CBE0@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3)
{
  int v3; // edi@1
  int v4; // ST38_4@1
  int v5; // eax@1
  __int16 v6; // cx@1
  unsigned int *result; // eax@1
  char v8; // [sp+Ch] [bp-204h]@1

  v3 = BMP_get_bm_def(*a3);
  v4 = *(_DWORD *)(a2 + 460);
  v5 = sub_1006E3E0(*a3, *(_BYTE *)(a2 + 3), (int)&v8);
  v6 = *(_WORD *)(a2 + 432);
  *(_DWORD *)(a2 + 460) = v5;
  result = sub_1009CD40(
             a2 + 392,
             v3,
             0,
             0,
             *(_WORD *)a1 + *(_WORD *)(a2 + 434),
             *(_WORD *)(a1 + 2) + v6,
             *(_WORD *)(v3 + 6),
             *(_WORD *)(v3 + 4));
  *(_DWORD *)(a2 + 460) = v4;
  return result;
}
// 1009B1F0: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (1006CC90) --------------------------------------------------------
char __cdecl sub_1006CC90(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  int v6; // eax@8
  __int16 v7; // dx@8
  __int16 v8; // si@8

  result = 1;
  if ( *a5 == 32802 )
    goto LABEL_11;
  if ( *a5 == 32832 )
  {
    v6 = BMP_get_bm_def(*a4);
    v7 = *(_WORD *)(v6 + 6);
    v8 = *(_WORD *)(v6 + 4);
    *(_WORD *)(a1 + 276) = *(_WORD *)a3;
    *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v7 + *(_WORD *)a3 - 1;
    *(_WORD *)(a1 + 282) = v8 + *(_WORD *)(a3 + 2) - 1;
    return 2;
  }
  if ( *a5 == 32888 )
  {
LABEL_11:
    if ( *a4 != -1 )
      sub_1006CBE0(a3, a1, a4);
    result = 2;
  }
  return result;
}
// 1009B1F0: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (1006CD30) --------------------------------------------------------
_DWORD *__cdecl sub_1006CD30(int a1, char *a2, int a3, _DWORD *a4)
{
  char *v4; // edi@1
  void (__cdecl *v5)(int, char *, char *, int, void *); // ebx@1
  char *v6; // eax@1
  int v7; // ST0C_4@1
  _DWORD *result; // eax@1

  v4 = a2;
  v5 = (void (__cdecl *)(int, char *, char *, int, void *))dword_1068B040[2 * (*(_DWORD *)a2 & 0xFF)];
  sub_10070660(a2, (int *)&a2, 0);
  v6 = a2;
  *(_WORD *)(a1 + 276) = *(_WORD *)a2;
  *(_WORD *)(a1 + 278) = *((_WORD *)v6 + 1);
  *(_WORD *)(a1 + 280) = *(_WORD *)v6;
  v7 = a3;
  *(_WORD *)(a1 + 282) = *((_WORD *)v6 + 1);
  v5(a1, v4, v6, v7, &unk_100E4624);
  result = a4;
  *a4 = *(_DWORD *)(a1 + 276);
  result[1] = *(_DWORD *)(a1 + 280);
  return result;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1006CDB0) --------------------------------------------------------
char __cdecl sub_1006CDB0(int a1, _WORD *a2, char **a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  char result; // al@1
  char **v8; // ebp@1
  int v9; // esi@1
  int v10; // ebx@1
  bool v11; // al@7
  bool v12; // al@11
  int v13; // [sp+10h] [bp-4h]@5
  int v14; // [sp+18h] [bp+4h]@2

  v6 = a1;
  result = sub_10001B10(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = *(_DWORD *)*a3 & 0xFF;
  v10 = 0;
  if ( v9 == 141 )
  {
    *(_BYTE *)(a1 + 3) = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      if ( *v8 )
      {
        result = sub_100705E0(v6, a5, v10);
        if ( result )
        {
          sub_10070660(*v8, &v13, 0);
          v11 = v10 == a6 && sub_10070610(v6, a2, *(_DWORD *)(v6 + 56));
          *(_BYTE *)(v6 + 3) = v11;
          v12 = v10 == a6 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
          *(_BYTE *)(v6 + 9) = v12;
          result = ((int (__cdecl *)(int, char *, int, _DWORD, _WORD *))dword_1068B040[2 * v9])(
                     v6,
                     *v8,
                     v13,
                     *(_DWORD *)(v14 + a4),
                     a2);
        }
      }
      v14 = 4 * ++v10;
      v8 = &a3[v10];
      v9 = *(_DWORD *)a3[v10] & 0xFF;
    }
    while ( v9 != 141 );
    *(_BYTE *)(v6 + 3) = 0;
  }
  return result;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1006CED0) --------------------------------------------------------
bool __cdecl sub_1006CED0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  char *v7; // ebp@1
  int v8; // edi@1
  bool result; // al@1
  _WORD *v10; // ebx@2
  int v11; // eax@4
  bool v12; // al@6
  bool v13; // zf@8
  bool v14; // al@10
  char *v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a1;
  sub_10001B10(a1, *(_DWORD *)(a1 + 56));
  v7 = a3;
  v8 = 0;
  result = sub_10070660(a3, &v16, &v15);
  if ( result )
  {
    v10 = a2;
    do
    {
      if ( sub_100705E0(v6, a5, v8) )
      {
        v11 = *(_DWORD *)(v6 + 56);
        LOWORD(a1) = *(_WORD *)v16 + *(_WORD *)(v11 + 36);
        HIWORD(a1) = *(_WORD *)(v16 + 2) + *(_WORD *)(v11 + 38);
        v12 = v8 == a6 && sub_10070610(v6, v10, v11);
        v13 = v8 == a6;
        *(_BYTE *)(v6 + 3) = v12;
        v14 = v13 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
        *(_BYTE *)(v6 + 9) = v14;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_1068B040[2 * (*(_DWORD *)v7 & 0xFF)])(
          v6,
          v7,
          &a1,
          *(_DWORD *)(a4 + 4 * v8),
          v10);
      }
      v7 = v15;
      ++v8;
      result = sub_10070660(v15, &v16, &v15);
    }
    while ( result );
  }
  *(_BYTE *)(v6 + 3) = 0;
  return result;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (1006CFD0) --------------------------------------------------------
int __cdecl sub_1006CFD0(unsigned int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+4h] [bp+4h]@1

  v1 = word_105728D8[(a1 >> 5) & 0x1F];
  HIWORD(v3) = word_105728D8[a1 & 0x1F];
  LOWORD(v3) = v1;
  return v3;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1006D000) --------------------------------------------------------
int *__cdecl sub_1006D000(unsigned int a1)
{
  return &dword_1068B4C0[5 * ((a1 >> 10) & 0xF)];
}
// 1068B4C0: using guessed type int dword_1068B4C0[];

//----- (1006D020) --------------------------------------------------------
int __cdecl sub_1006D020(unsigned int a1)
{
  int *v1; // eax@1
  char v2; // cl@1
  int result; // eax@2

  v1 = sub_1006D000(a1);
  if ( v2 & 1 )
    result = v1[2];
  else
    result = v1[1];
  return result;
}

//----- (1006D040) --------------------------------------------------------
signed int __cdecl sub_1006D040(__int16 a1)
{
  signed int result; // eax@1

  result = 1073741828;
  if ( a1 & 0xC000 )
  {
    if ( (a1 & 0xC000) == 0x8000 )
      result = 1073741829;
  }
  else
  {
    result = 1073741830;
  }
  return result;
}

//----- (1006D070) --------------------------------------------------------
signed int __cdecl sub_1006D070(int a1)
{
  int v1; // eax@1
  signed int result; // eax@3

  v1 = a1 & 0xC00000;
  if ( a1 & 0xC00000 )
  {
    if ( v1 == 0x400000 )
      result = 1;
    else
      result = v1 != 0x800000 ? 0 : 2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006D0A0) --------------------------------------------------------
void *sub_1006D0A0()
{
  void *result; // eax@1

  result = (void *)dword_10583274;
  if ( !dword_10583274 )
    result = &unk_100E0A88;
  return result;
}
// 10583274: using guessed type int dword_10583274;

//----- (1006D0B0) --------------------------------------------------------
_BYTE *__usercall sub_1006D0B0@<eax>(_BYTE *a1@<eax>)
{
  _BYTE *result; // eax@5

  if ( !*a1 )
    goto LABEL_9;
  do
  {
    if ( *a1 == 10 )
      break;
    ++a1;
  }
  while ( *a1 );
  if ( *a1 )
  {
    *a1 = 0;
    result = a1 + 1;
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (1006D0E0) --------------------------------------------------------
char __usercall sub_1006D0E0@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_1009DA50(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (1006D130) --------------------------------------------------------
char __usercall sub_1006D130@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7)
{
  unsigned int v7; // ecx@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ecx@1
  char *v11; // eax@4
  char v12; // cl@6
  signed __int16 v13; // dx@9
  int v14; // eax@25
  unsigned int v15; // ebx@29
  unsigned __int8 v16; // al@29
  __int16 v17; // dx@37
  __int16 v18; // cx@37
  unsigned int v19; // edi@42
  signed int v20; // ecx@44
  int v21; // edi@46
  unsigned int v22; // edi@52
  __int16 v23; // ax@52
  __int16 v24; // dx@55
  __int16 v25; // cx@55
  int v26; // eax@58
  char result; // al@63
  int v28; // [sp+0h] [bp-6Ch]@0
  int v29; // [sp+Ch] [bp-60h]@1
  char *v30; // [sp+10h] [bp-5Ch]@6
  signed int v31; // [sp+14h] [bp-58h]@1
  int v32; // [sp+18h] [bp-54h]@1
  int v33; // [sp+1Ch] [bp-50h]@1
  int v34; // [sp+20h] [bp-4Ch]@1
  int v35; // [sp+24h] [bp-48h]@1
  int v36; // [sp+28h] [bp-44h]@1
  int v37; // [sp+2Ch] [bp-40h]@1
  int v38; // [sp+30h] [bp-3Ch]@1
  __int16 v39; // [sp+30h] [bp-3Ch]@29
  __int16 v40; // [sp+32h] [bp-3Ah]@29
  int v41; // [sp+34h] [bp-38h]@1
  size_t v42; // [sp+3Ch] [bp-30h]@1
  signed int v43; // [sp+40h] [bp-2Ch]@9
  int v44; // [sp+44h] [bp-28h]@21
  int v45; // [sp+48h] [bp-24h]@15
  unsigned int v46; // [sp+4Ch] [bp-20h]@29
  signed int v47; // [sp+50h] [bp-1Ch]@1
  char v48; // [sp+54h] [bp-18h]@4

  v31 = a2;
  v42 = a1;
  v7 = strlen(a4);
  v34 = a5[2];
  v8 = a5[1];
  v35 = a5[3];
  v9 = v7;
  v36 = a5[4];
  v47 = v7;
  v32 = *a5;
  v33 = v8;
  v37 = a5[5];
  v29 = 0;
  v41 = *(_WORD *)(*a5 + 28);
  v10 = sub_1009DA50(*a5, a4, v8);
  v38 = v10;
  if ( (signed __int16)v35 <= 0 )
    LOWORD(v35) = v10;
  if ( (unsigned int)v9 >= 0x14 )
    v11 = (char *)sub_100034E0(a3, v9 + 1);
  else
    v11 = &v48;
  v12 = *(_BYTE *)(a3 + 3);
  v30 = v11;
  if ( v12 && a6 && v31 > 0 )
  {
    v13 = 1;
    v43 = 1;
  }
  else
  {
    v43 = 0;
    v13 = 1;
  }
  v45 = v12 && (!a6 || v31 >= 0 && v31 + 1 <= v9);
  v44 = *(_BYTE *)(a3 + 3) && a6 && (v31 < 0 || (signed int)(v31 + v42) < v9);
  if ( (v8 & 3) != 2 )
  {
    if ( v8 & 3 )
    {
      *(_WORD *)(a3 + 438) += (signed __int16)v35 / -2;
      v14 = ((signed __int16)v35 - v38) / 2;
    }
    else
    {
      *(_WORD *)(a3 + 438) += v13 - v35;
      v14 = (signed __int16)v35 - v38;
    }
    v8 = v8 & 0xFFFFFFFE | 2;
    v33 = v8;
    if ( v14 > 0 )
      v29 = v14;
  }
  v15 = v8 & 0xFFFFFFF7 | 4;
  v39 = v35 + v41 + *(_WORD *)(a3 + 438);
  v16 = v34;
  v40 = *(_WORD *)(a3 + 436);
  v46 = v8 & 0xFFFFFFF7 | 4;
  if ( !v43 && !v45 && v44 )
    v16 = 0;
  if ( *(_BYTE *)(a3 + 3) && !a6 && (byte_10658E06 || byte_1068B020) )
  {
    v17 = v36;
    v18 = HIWORD(v35);
  }
  else
  {
    v17 = HIWORD(v35);
    v18 = v36;
  }
  *(_WORD *)(a3 + 428) = v17;
  *(_WORD *)(a3 + 430) = v18;
  sub_1009DAB0(a3 + 392, v32, &unk_100C4192, v35, v8 & 0xFFFFFFF7 | 4, v16, v28);
  *(_WORD *)(a3 + 438) += v29;
  if ( *(_BYTE *)(a3 + 3) )
  {
    if ( v43 )
    {
      v19 = v8 & 0xFFFFFFF3;
      if ( a7 )
        --*(_WORD *)(a3 + 438);
      strncpy(v30, a4, v31);
      v20 = v31;
      if ( v31 >= v47 )
        v20 = v47;
      v30[v20] = 0;
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      v21 = sub_1009DAB0(a3 + 392, v32, v30, v35 - v29, v19 | 0x80000000, 0, v37) + v29;
      if ( a7 )
        *(_WORD *)(a3 + 438) += v41 + 1;
      else
        *(_WORD *)(a3 + 438) += v41;
      v15 = v46;
      v29 = v41 + v21;
      v8 = v33;
    }
    if ( v45 )
    {
      if ( a6 )
      {
        v22 = v34 & 0xFFFF0001 | 1;
        strncpy(v30, &a4[v31], v42);
        v30[v42] = 0;
        v23 = 0;
      }
      else
      {
        LOWORD(v22) = (unsigned __int8)v34;
        strcpy(v30, a4);
        v23 = v35 - v29;
      }
      if ( byte_10658E06 || byte_1068B020 )
      {
        v24 = v36;
        v25 = HIWORD(v35);
      }
      else
      {
        v24 = HIWORD(v35);
        v25 = v36;
      }
      *(_WORD *)(a3 + 428) = v24;
      *(_WORD *)(a3 + 430) = v25;
      v26 = sub_1009DAB0(a3 + 392, v32, v30, v23, v15 | 0x80000000, v22, v37);
      v8 = v33;
      *(_WORD *)(a3 + 438) += v41;
      v29 += v41 + v26;
    }
    if ( v44 )
    {
      if ( a7 )
        ++*(_WORD *)(a3 + 438);
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      sub_1009DAB0(
        a3 + 392,
        v32,
        &a4[((v42 + v31) & 0x80000000) != 0 ? 0 : v42 + v31],
        v35 - v29,
        v8 & 0xFFFFFFF3 | 0x80000000,
        0,
        v37);
    }
  }
  else
  {
    *(_WORD *)(a3 + 428) = HIWORD(v35);
    *(_WORD *)(a3 + 430) = v36;
    sub_1009DAB0(a3 + 392, v32, a4, v35 - v29, v8 | 0x80000000, v34, v37);
  }
  *(_WORD *)(a3 + 436) = v40;
  result = (char)v30;
  *(_WORD *)(a3 + 438) = v39;
  if ( v30 != &v48 )
    result = sub_10003450(a3, (unsigned int)v30);
  return result;
}
// 10658E06: using guessed type char byte_10658E06;
// 1068B020: using guessed type char byte_1068B020;

//----- (1006D630) --------------------------------------------------------
__int16 __cdecl sub_1006D630(_BYTE *a1, unsigned int a2)
{
  int v2; // edi@1
  __int16 result; // ax@2
  int v4; // ebx@3
  _BYTE *v5; // edx@3
  int v6; // ebp@3
  _BYTE *v7; // esi@4
  _BYTE *v8; // edx@4
  int v9; // eax@4

  v2 = 0;
  if ( *a1 )
  {
    v4 = sub_1006D040(a2);
    v6 = sub_1006D000(a2)[1];
    do
    {
      v7 = sub_1006D0B0(v5);
      v9 = sub_1009DA50(v6, v8, v4);
      if ( v2 <= v9 )
        v2 = v9;
      v5 = v7;
    }
    while ( v7 );
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006D690) --------------------------------------------------------
int __cdecl sub_1006D690(unsigned int a1, unsigned int a2, float *a3)
{
  int v3; // esi@1
  char *v4; // eax@1

  v3 = sub_1006D000(a1)[1];
  v4 = sub_100793B0(a2, a3);
  return sub_1009DA50(v3, v4, 0);
}

//----- (1006D6C0) --------------------------------------------------------
int sub_1006D6C0()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  int *v2; // esi@2
  unsigned __int8 v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  unsigned __int8 v9; // al@2
  int result; // eax@2

  v0 = &unk_100E0A94;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = &dword_1068B4C0[5 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF)];
    *((_BYTE *)v2 + 12) = *(_BYTE *)v0;
    *v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    *((_BYTE *)v2 + 13) = v3;
    v4 = FNT_get_fnt_hdr(v3);
    v2[1] = v4;
    v5 = sub_1009DA50(v4, word_100CC1C0, 0);
    v6 = v2[1];
    *((_BYTE *)v2 + 15) = v5;
    v7 = sub_1006D0E0(0x20u, v6, 0x5Fu);
    v8 = v2[1];
    *((_BYTE *)v2 + 16) = v7;
    *((_BYTE *)v2 + 17) = sub_1006D0E0(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    *((_BYTE *)v2 + 14) = v9;
    result = FNT_get_fnt_hdr(v9);
    v0 = (char *)v0 + 8;
    v2[2] = result;
  }
  while ( (signed int)v0 < (signed int)"ib\\adl\\cdp_fld_2d_utl.c" );
  return result;
}
// 1009B1EA: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);
// 1068B4C0: using guessed type int dword_1068B4C0[];

//----- (1006D760) --------------------------------------------------------
int __cdecl sub_1006D760(int a1, int a2, int a3, unsigned __int8 a4)
{
  _WORD *v4; // eax@1
  int v5; // esi@1
  __int16 v6; // cx@1
  __int16 v7; // dx@1
  _WORD *v8; // edi@1
  int v9; // edx@1
  int result; // eax@3
  int v11; // [sp+10h] [bp-8h]@1
  __int16 v12; // [sp+14h] [bp-4h]@1
  __int16 v13; // [sp+1Ch] [bp+4h]@1
  __int16 v14; // [sp+1Eh] [bp+6h]@1

  v4 = sub_1006D0A0();
  v5 = a1;
  v6 = *(_WORD *)(a1 + 426);
  v7 = *(_WORD *)(a1 + 424);
  v8 = v4;
  LOWORD(v4) = *(_WORD *)(a1 + 396);
  *(_WORD *)(a1 + 396) = 2;
  v12 = (signed __int16)v4;
  v13 = v6;
  *(_WORD *)(v5 + 426) = v8[3];
  v14 = v7;
  v9 = *(_DWORD *)(v5 + 428);
  *(_WORD *)(v5 + 424) = v8[3];
  v11 = v9;
  if ( a4 >= 2u )
    sub_10070AD0("..\\lib\\adl\\cdp_fld_2d_utl.c", 982, 1, 0);
  *(_WORD *)(v5 + 428) = word_105728D8[*((_BYTE *)v8 + a4)];
  *(_WORD *)(v5 + 430) = word_105728D8[*((_BYTE *)v8 + a4 + 2)];
  *(_WORD *)(v5 + 438) = *(_WORD *)a2 + v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_1009E7F0(v5 + 392, *(_WORD *)a3 - v8[3], *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 438) = *(_WORD *)a3 - v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_1009E7F0(v5 + 392, v8[3] + *(_WORD *)a2, *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 426) = v13;
  *(_WORD *)(v5 + 424) = v14;
  result = HIWORD(v11);
  *(_WORD *)(v5 + 396) = v12;
  *(_WORD *)(v5 + 428) = v11;
  *(_WORD *)(v5 + 430) = HIWORD(v11);
  return result;
}
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1006D8E0) --------------------------------------------------------
char __cdecl sub_1006D8E0(int a1, const char *a2, int *a3)
{
  return sub_1006D130(
           *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240),
           a1,
           a2,
           a3,
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
           1);
}

//----- (1006D920) --------------------------------------------------------
int __cdecl sub_1006D920(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // edx@1
  char v4; // si@1
  signed int v5; // eax@4

  v2 = sub_1006D000(a1)[1];
  v3 = 1;
  v4 = 1;
  if ( !a2 )
  {
    if ( *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24) > 1 )
      v3 = *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24);
    v5 = *(_WORD *)(v2 + 26);
    if ( v5 > 1 )
      v4 = v5;
  }
  return (((v3 << 8) | (unsigned __int8)v4) << 16) | 0x101;
}

//----- (1006D980) --------------------------------------------------------
char __cdecl sub_1006D980(int a1, const char *a2, int *a3, int a4)
{
  int v4; // eax@1
  unsigned int v5; // edi@1
  unsigned int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  char *v9; // edi@1
  int v10; // ecx@2
  char *v11; // ebp@2
  int v12; // ecx@6
  char v14; // [sp+13h] [bp-11h]@1
  char *v15; // [sp+14h] [bp-10h]@1
  unsigned int v16; // [sp+18h] [bp-Ch]@1
  unsigned int v17; // [sp+1Ch] [bp-8h]@1
  __int16 v18; // [sp+20h] [bp-4h]@1
  signed int v19; // [sp+28h] [bp+4h]@1
  __int16 v20; // [sp+2Ch] [bp+8h]@1
  __int16 v21; // [sp+2Eh] [bp+Ah]@1

  v4 = a3[2];
  v5 = (unsigned int)a3[2] >> 24;
  v6 = ((unsigned int)a3[2] >> 16) & 0xFF;
  v16 = v4 & 0xFFFF0001 | 1;
  v14 = 1;
  v17 = (v4 & 0xFFFFFF ^ ((v5 + a4) << 24)) & 0xFFFF0001 | 1;
  v7 = a1;
  v15 = (char *)sub_100034E0(a1, strlen(a2) + 1);
  strcpy(v15, a2);
  v21 = *(_WORD *)(a1 + 436);
  v19 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  v20 = *(_WORD *)(v7 + 438);
  v8 = v5 + v6 + *(_WORD *)(*a3 + 24) - *(_WORD *)(*a3 + 26);
  v9 = v15;
  v18 = a4 + v8;
  do
  {
    v11 = sub_1006D0B0(v9);
    *(_WORD *)(v7 + 438) = v20;
    *(_WORD *)(v7 + 436) = v21;
    if ( v11 )
      *(_DWORD *)(v10 + 8) = v17;
    else
      *(_DWORD *)(v10 + 8) = v16;
    if ( *(_BYTE *)(v7 + 3) && (v12 = *(_DWORD *)(v7 + 56), *(_WORD *)(v12 + 240) != -128) )
    {
      if ( v19 >= (signed int)strlen(v9) || v19 < 0 )
      {
        *(_BYTE *)(v7 + 3) = 0;
        sub_1006D130(*(_BYTE *)(v12 + 242), -128, v7, v9, a3, 0, 0);
        *(_BYTE *)(v7 + 3) = 1;
      }
      else
      {
        sub_1006D130(*(_BYTE *)(v12 + 242), v19, v7, v9, a3, 1, 0);
      }
      v19 -= strlen(v9);
    }
    else
    {
      if ( !v14 )
      {
        LOBYTE(a4) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v7 + 3) = 0;
      }
      sub_1006D130(
        *(_BYTE *)(*(_DWORD *)(v7 + 56) + 242),
        v19,
        v7,
        v9,
        a3,
        *(_WORD *)(*(_DWORD *)(v7 + 56) + 240) != -128,
        1);
      if ( !v14 )
        *(_BYTE *)(v7 + 3) = a4;
    }
    v21 += v18;
    v9 = v11;
    v14 = 0;
  }
  while ( v11 );
  return sub_10003450(v7, (unsigned int)v15);
}

//----- (1006DB90) --------------------------------------------------------
int __cdecl sub_1006DB90(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // edi@1
  int v5; // eax@1
  unsigned int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@3
  int result; // eax@3
  int v10; // [sp+18h] [bp+Ch]@1

  v4 = a3;
  v10 = sub_1006D920(a3, 0);
  v5 = sub_1006D000(v4)[1];
  *(_WORD *)(a1 + 2) = HIWORD(a2) + *(_WORD *)(v5 + 26) - BYTE2(v10) - *(_WORD *)(v5 + 24) + 1;
  v7 = v4 & 0xC000;
  *(_WORD *)(a1 + 6) = HIWORD(a2) + *(_WORD *)(v5 + 22) + (v6 >> 24) - *(_WORD *)(v5 + 24) - 1;
  if ( v7 )
  {
    if ( v7 == 0x4000 )
    {
      *(_WORD *)(a1 + 4) = a2 + 1;
      result = a2 + 1 - a4 - 1;
      *(_WORD *)a1 = result;
    }
    else
    {
      v8 = a2 - (a4 + 2) / 2 - 1;
      *(_WORD *)a1 = v8;
      result = v8 + a4 + 2 - 1;
      *(_WORD *)(a1 + 4) = result;
    }
  }
  else
  {
    result = a2 - 1;
    *(_WORD *)(a1 + 4) = a2 - 1 + a4 + 1;
    *(_WORD *)a1 = a2 - 1;
  }
  return result;
}

//----- (1006DC60) --------------------------------------------------------
__int16 __cdecl sub_1006DC60(char *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax@1
  unsigned int v6; // edi@1
  int v7; // ebp@1
  int v8; // ebx@1
  char *v9; // eax@1
  int v10; // edx@3

  v5 = sub_1006D920(a2, 0);
  v6 = v5 >> 24;
  v7 = (v5 >> 16) & 0xFF;
  v8 = sub_1006D000(a2)[1];
  v9 = strchr(a1, 10);
  for ( *(_DWORD *)a5 = 1; v9; ++*(_DWORD *)a5 )
    v9 = strchr(v9 + 1, 10);
  v10 = a3 + v6 + v7 + *(_WORD *)(v8 + 24) - *(_WORD *)(v8 + 26);
  *(_DWORD *)a4 = v10;
  return *(_WORD *)a5 * v10 - a3;
}

//----- (1006DCF0) --------------------------------------------------------
char __cdecl sub_1006DCF0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7)
{
  int *v7; // eax@1
  int v8; // ebx@1
  signed int v9; // edi@1
  signed int v10; // eax@4
  int v11; // ebp@4
  unsigned int v12; // ebx@4
  int v13; // eax@4
  __int16 v14; // cx@4
  int v15; // edx@4
  int v16; // edi@9
  signed int v17; // ecx@12
  __int64 v18; // rax@12
  __int16 v19; // dx@15
  __int16 v20; // dx@15
  int v21; // eax@17
  signed int v22; // edi@17
  int v24; // [sp+10h] [bp-30h]@1
  unsigned int v25; // [sp+14h] [bp-2Ch]@1
  unsigned int v26; // [sp+18h] [bp-28h]@1
  __int16 v27; // [sp+1Ch] [bp-24h]@2
  int v28; // [sp+1Eh] [bp-22h]@1
  int v29; // [sp+24h] [bp-1Ch]@4
  int v30; // [sp+28h] [bp-18h]@4
  unsigned int v31; // [sp+2Ch] [bp-14h]@4
  int v32; // [sp+30h] [bp-10h]@4
  char v33[6]; // [sp+34h] [bp-Ch]@4
  int v34; // [sp+3Ch] [bp-4h]@4

  v28 = sub_1006CFD0(a6);
  v7 = sub_1006D000(a6);
  v8 = v7[1];
  v24 = v7[1];
  v26 = sub_1006D920(a6, 0) & 0xFFFFFF00;
  v9 = sub_1006D040(a6);
  v25 = v9 & 0xFFFFFFFE | 2;
  if ( a7 & 0x200 )
  {
    v27 = 0;
    a3 = (const char *)&unk_100C4192;
  }
  else
  {
    v27 = a5;
  }
  v10 = sub_1006D070(a6);
  v11 = v10;
  v29 = v10;
  *(_DWORD *)&v33[2] = sub_1006CFD0(a6);
  v30 = v8;
  v12 = v9 & 0xFFFFFFFC;
  v34 = v11;
  v32 = sub_1006D920(a6, 0);
  v31 = v9 & 0xFFFFFFFC;
  *(_WORD *)v33 = a4;
  v13 = sub_1009DA50(v30, a2, v9 & 0xFFFFFFFC);
  v14 = v27;
  v15 = 0;
  if ( v27 > 0 && a4 > 0 )
    v15 = *(_WORD *)(v30 + 28);
  if ( a6 & 0xC000 )
  {
    if ( (a6 & 0xC000) == 0x8000 )
    {
      if ( v27 && a4 )
      {
        v17 = v15 + v27 + a4;
        v18 = v13 - *(_WORD *)(v30 + 28) - v27 + 1;
        v16 = (((signed int)v18 - HIDWORD(v18)) >> 1) - 1;
        LODWORD(v18) = v17 / 2 + v16 + 1;
        LOWORD(v17) = v17 - *(_WORD *)(v30 + 28);
        *(_WORD *)v33 = v18;
        v14 = v17 - v18;
        v27 = v14;
      }
      else
      {
        LOWORD(v16) = 0;
        v31 = v12 & 0xFFFFFFFD | 1;
        v25 = v25 & 0xFFFFFFFD | 1;
      }
    }
    else
    {
      v16 = -v27;
    }
  }
  else
  {
    if ( a4 > v13 )
    {
      v19 = v15 - *(_WORD *)(v30 + 28);
      *(_WORD *)v33 = v13;
      v20 = a4 + v19 - v13;
      v14 = v20 + v27;
      v27 += v20;
    }
    LOWORD(v16) = *(_WORD *)v33 - 1;
  }
  *(_WORD *)(a1 + 438) += v16;
  v21 = *(_DWORD *)(a1 + 56);
  v22 = *(_WORD *)(v21 + 240);
  if ( *(_WORD *)v33 > 0 )
  {
    LOBYTE(v21) = sub_1006D130(*(_BYTE *)(v21 + 242), v22, a1, a2, &v30, *(_WORD *)(v21 + 240) != -128, 1);
    v14 = v27;
  }
  if ( v14 > 0 )
  {
    if ( v22 != -128 )
      v22 -= strlen(a2);
    LOBYTE(v21) = sub_1006D130(
                    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
                    v22,
                    a1,
                    a3,
                    &v24,
                    *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
                    1);
  }
  return v21;
}

//----- (1006DF10) --------------------------------------------------------
void __cdecl sub_1006DF10(int a1, int (__cdecl *a2)(int))
{
  char v2; // bl@2

  if ( !*(_DWORD *)(a1 + 72) )
  {
    v2 = sub_10003D40(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 8));
    if ( sub_10003D40(a2) != v2 )
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8);
  }
}

//----- (1006DF50) --------------------------------------------------------
void sub_1006DF50()
{
  dword_1068B4A8 = 0;
}
// 1068B4A8: using guessed type int dword_1068B4A8;

//----- (1006DF60) --------------------------------------------------------
unsigned int __usercall sub_1006DF60@<eax>(unsigned int result@<eax>)
{
  unsigned int *v1; // ecx@2
  unsigned int v2; // ecx@3

  if ( !dword_1068B4A8 )
  {
    dword_1068B4A8 = *(_DWORD *)(result + 32);
    v1 = *(unsigned int **)(result + 32);
    if ( v1 )
    {
      v2 = *v1;
      *(_DWORD *)(result + 32) = v2;
      if ( !v2 || *(_DWORD *)(result + 48) < v2 )
        *(_DWORD *)(result + 48) = v2;
      result = v2;
      if ( v2 )
        *(_DWORD *)(v2 + 4) = 0;
    }
  }
  return result;
}
// 1068B4A8: using guessed type int dword_1068B4A8;

//----- (1006DFA0) --------------------------------------------------------
int __usercall sub_1006DFA0@<eax>(int result@<eax>)
{
  if ( dword_1068B4A8 )
  {
    *(_DWORD *)(*(_DWORD *)(result + 32) + 4) = dword_1068B4A8;
    *(_DWORD *)dword_1068B4A8 = *(_DWORD *)(result + 32);
    *(_DWORD *)(result + 32) = dword_1068B4A8;
    dword_1068B4A8 = 0;
  }
  return result;
}
// 1068B4A8: using guessed type int dword_1068B4A8;

//----- (1006DFD0) --------------------------------------------------------
void __cdecl sub_1006DFD0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5)
{
  void *v5; // ecx@0
  int (__cdecl *v6)(int); // ebx@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // eax@2
  char v10; // bl@13
  int v11; // eax@22
  int v12; // edx@26
  int v13; // ecx@26
  int v14; // edx@26
  int v15; // ecx@26
  int v16; // edx@26
  int v17; // eax@29
  unsigned int v18; // eax@32
  unsigned int v19; // ebx@34
  int (__cdecl *v20)(int); // eax@46
  int v21; // eax@59
  bool v22; // al@63
  int v23; // edx@63
  int (__cdecl *v24)(int); // [sp+10h] [bp-D8h]@1
  unsigned int v25; // [sp+14h] [bp-D4h]@32
  __int16 i; // [sp+18h] [bp-D0h]@25
  unsigned int v27; // [sp+1Ch] [bp-CCh]@25
  int (__cdecl *v28)(int); // [sp+20h] [bp-C8h]@25
  int v29; // [sp+24h] [bp-C4h]@25
  int v30; // [sp+28h] [bp-C0h]@26
  int v31; // [sp+2Ch] [bp-BCh]@26
  int v32; // [sp+30h] [bp-B8h]@26
  int v33; // [sp+34h] [bp-B4h]@26
  int v34; // [sp+38h] [bp-B0h]@26
  int v35; // [sp+3Ch] [bp-ACh]@26

  v6 = a3;
  v7 = *(_DWORD *)(a1 + 48);
  v8 = 0;
  v24 = a3;
  if ( v7 )
  {
    v9 = a2;
    switch ( a2 )
    {
      case -1:
        sub_1006DFA0(a1);
        goto LABEL_4;
      case -5:
LABEL_4:
        v8 = *(_DWORD *)(a1 + 32);
        v7 = 0;
        goto LABEL_20;
      case -2:
        v8 = 0;
        do
        {
          if ( sub_10003D90(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v8 = v7;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        goto LABEL_20;
      case -3:
        do
        {
          if ( sub_10003D90(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        v8 = v7;
        if ( v7 )
          v7 = *(_DWORD *)(v7 + 4);
        goto LABEL_20;
      case -6:
        v8 = *(_DWORD *)(a1 + 48);
        v10 = sub_10003D90(a3);
        if ( !v7 )
          goto LABEL_16;
        break;
      case -7:
        if ( (unsigned __int8)sub_10070100(v5) )
        {
          sub_1006DF60(a1);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        else
        {
          sub_1006DF10(a1, a3);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        goto LABEL_20;
      case -8:
        if ( (unsigned __int8)sub_10070100(v5) )
        {
          sub_1006DFA0(a1);
LABEL_45:
          v7 = *(_DWORD *)(a1 + 32);
          v8 = *(_DWORD *)v7;
        }
        else
        {
          v20 = *(int (__cdecl **)(int))(a1 + 72);
          if ( v20 )
          {
            v8 = *(_DWORD *)(a1 + 32);
            v7 = 0;
            v24 = *(int (__cdecl **)(int))(a1 + 72);
            *(_DWORD *)(a1 + 72) = 0;
            v6 = v20;
          }
        }
        goto LABEL_20;
      case -4:
        goto LABEL_45;
      default:
        if ( a2 > 0 )
        {
          do
          {
            if ( !v7 )
              break;
            --v9;
            v8 = v7;
            v7 = *(_DWORD *)(v7 + 4);
          }
          while ( v9 > 0 );
        }
        goto LABEL_20;
    }
    do
    {
      if ( sub_10003D90(*(int (__cdecl **)(int))(v8 + 8)) == v10 )
      {
        if ( *(int (__cdecl **)(int))(v8 + 8) == a3 )
        {
          v8 = *(_DWORD *)v8;
          v24 = 0;
        }
        v7 = *(_DWORD *)(v8 + 4);
        goto LABEL_19;
      }
      v8 = *(_DWORD *)(v8 + 4);
    }
    while ( v8 );
LABEL_16:
    v7 = *(_DWORD *)(a1 + 48);
    v8 = 0;
    if ( v7 )
    {
      while ( sub_10003D90(*(int (__cdecl **)(int))(v7 + 8)) == -1 )
      {
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          goto LABEL_19;
      }
      v8 = *(_DWORD *)v7;
    }
LABEL_19:
    v6 = v24;
  }
LABEL_20:
  if ( v6 )
  {
    if ( a4 || (v11 = v7) == 0 )
    {
LABEL_25:
      ++*(_BYTE *)(a1 + 4);
      i = -32703;
      v27 = 0;
      v28 = v6;
      LOBYTE(v29) = 0;
      if ( a5 )
      {
        v12 = *(_DWORD *)(a5 + 4);
        v30 = *(_DWORD *)a5;
        v13 = *(_DWORD *)(a5 + 8);
        v31 = v12;
        v14 = *(_DWORD *)(a5 + 12);
        v32 = v13;
        v15 = *(_DWORD *)(a5 + 16);
        v33 = v14;
        v16 = *(_DWORD *)(a5 + 20);
        v34 = v15;
        v35 = v16;
        LOBYTE(v29) = 1;
      }
      sub_10002670(a1, (int)&i, 204);
    }
    else
    {
      while ( *(int (__cdecl **)(int))(v11 + 8) != v6 )
      {
        v11 = *(_DWORD *)(v11 + 4);
        if ( !v11 )
          goto LABEL_25;
      }
      v7 = *(_DWORD *)(v11 + 4);
      v8 = v11;
      v24 = 0;
      v6 = 0;
    }
  }
  if ( v8 )
  {
    v17 = sub_10002450(a1, (int)v6);
    if ( !v6 || !v17 || !sub_10001AE0(a1, v17) )
    {
      v18 = sub_10001840(a1, v7);
      v25 = v18;
      if ( v18 )
        *(_BYTE *)(v18 + 26) = 0;
      v19 = v7;
      if ( v7 )
      {
        while ( v19 >= v18 )
        {
          i = -32734;
          v27 = v19;
          sub_10002670(a1, (int)&i, 204);
          v19 = *(_DWORD *)(v19 + 4);
          if ( !v19 )
            break;
          v18 = v25;
        }
      }
      v6 = v24;
    }
  }
  if ( !v6 || v8 )
  {
    if ( v7 && v8 )
    {
      i = -32665;
      v27 = v7;
      v22 = sub_10001AE0(a1, *(_DWORD *)v7);
      v23 = *(_DWORD *)(a1 + 56);
      LOBYTE(v28) = v22;
      v29 = *(_DWORD *)(v8 + 8);
      *(_BYTE *)(v23 + 25) = v22;
      sub_10002670(a1, (int)&i, 204);
    }
  }
  else
  {
    v21 = *(_DWORD *)(a1 + 48);
    if ( v21 )
    {
      i = -32695;
      v27 = v21;
      sub_10002670(a1, (int)&i, 204);
    }
  }
  for ( i = -32744; v8; v8 = *(_DWORD *)v8 )
  {
    v27 = v8;
    sub_10002670(a1, (int)&i, 204);
  }
}

//----- (1006E380) --------------------------------------------------------
void __cdecl sub_1006E380(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4)
{
  sub_1006DFD0(a1, a2, a3, a4, 0);
}

//----- (1006E3A0) --------------------------------------------------------
char __cdecl sub_1006E3A0(char a1, char a2, char a3)
{
  char result; // al@1
  unsigned int v4; // ecx@1

  result = 0;
  v4 = 0;
  while ( byte_100E15F4[v4] != a1 || byte_100E15F5[v4] != a2 || byte_100E15F6[v4] != a3 )
  {
    v4 += 3;
    ++result;
    if ( v4 >= 0x39 )
      return -1;
  }
  return result;
}

//----- (1006E3E0) --------------------------------------------------------
int __cdecl sub_1006E3E0(unsigned __int16 a1, char a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@1
  char v5; // cl@2
  signed int v6; // edi@2
  unsigned __int16 v7; // si@3
  int v8; // ecx@4
  char v9; // dl@5
  int v10; // esi@10
  int v11; // ecx@11
  __int16 v12; // dx@12
  char v13; // bl@13

  result = BMP_get_xfrm(a1);
  v4 = result;
  if ( a2 )
  {
    v5 = *(_BYTE *)(BMP_get_bm_def(a1) + 8);
    result = a3;
    v6 = 1 << v5;
    if ( v4 )
    {
      v10 = 0;
      if ( v6 > 0 )
      {
        v11 = 0;
        do
        {
          v12 = *(_WORD *)(v4 + 2 * v11);
          if ( (unsigned __int16)v12 < 0x100u )
          {
            v13 = byte_10572900[(unsigned __int16)v12];
            if ( v13 != 127 )
              v12 = word_105728D8[(unsigned __int8)byte_100E1630[(unsigned __int8)v13]];
          }
          ++v10;
          *(_WORD *)(a3 + 2 * v11) = v12;
          v11 = (unsigned __int16)v10;
        }
        while ( (unsigned __int16)v10 < v6 );
      }
    }
    else
    {
      v7 = 0;
      if ( v6 > 0 )
      {
        v8 = 0;
        do
        {
          v9 = byte_10572900[v8];
          if ( v9 == 127 )
            *(_WORD *)(a3 + 2 * v8) = v7;
          else
            *(_WORD *)(a3 + 2 * v8) = word_105728D8[(unsigned __int8)byte_100E1630[(unsigned __int8)v9]];
          v8 = ++v7;
        }
        while ( v7 < v6 );
      }
    }
  }
  return result;
}
// 1009B1F0: using guessed type int __cdecl BMP_get_bm_def(_DWORD);
// 1009B1F6: using guessed type int __cdecl BMP_get_xfrm(_DWORD);
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1006E4B0) --------------------------------------------------------
int sub_1006E4B0()
{
  int v0; // ebx@1
  char *v1; // esi@1
  int result; // eax@2

  memset(byte_10572900, 127, 0x100u);
  v0 = 0;
  v1 = byte_100E15F5;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color((unsigned __int8)*(v1 - 1), (unsigned __int8)*v1, (unsigned __int8)v1[1]);
    word_105728D8[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_10572900[(unsigned __int8)result] = v0;
    v1 += 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_100E162E );
  return result;
}
// 1009C300: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 105728D8: using guessed type __int16 word_105728D8[];

//----- (1006E510) --------------------------------------------------------
void sub_1006E510()
{
  dword_1068B4B4 = -15;
}
// 1068B4B4: using guessed type int dword_1068B4B4;

//----- (1006E520) --------------------------------------------------------
int sub_1006E520()
{
  return (*(int (**)(void))(dword_1068B4B0 + 8))();
}
// 1068B4B0: using guessed type int dword_1068B4B0;

//----- (1006E530) --------------------------------------------------------
void *__cdecl sub_1006E530(void *a1)
{
  char v2; // [sp+28h] [bp-34h]@1

  sub_1006E520();
  return memcpy_0(a1, &v2, 0x2Cu);
}

//----- (1006E570) --------------------------------------------------------
int __cdecl sub_1006E570(double *a1, int a2)
{
  double *v2; // ecx@1
  double v3; // st7@1
  double v4; // st7@2
  char v5; // bl@2
  double v6; // st7@4
  double v7; // st6@4
  double v8; // st5@4
  double v9; // st4@4
  double v10; // st3@4
  double v11; // st7@4
  double v12; // st4@4
  char v13; // cl@4
  int result; // eax@6
  float v15; // [sp+8h] [bp-8h]@4
  float v16; // [sp+Ch] [bp-4h]@4
  float v17; // [sp+14h] [bp+4h]@1
  float v18; // [sp+14h] [bp+4h]@4
  float v19; // [sp+14h] [bp+4h]@4
  float v20; // [sp+14h] [bp+4h]@4
  float v21; // [sp+14h] [bp+4h]@4
  float v22; // [sp+14h] [bp+4h]@4
  float v23; // [sp+14h] [bp+4h]@4
  float v24; // [sp+14h] [bp+4h]@4
  float v25; // [sp+14h] [bp+4h]@4
  float v26; // [sp+14h] [bp+4h]@4
  float v27; // [sp+14h] [bp+4h]@4
  float v28; // [sp+14h] [bp+4h]@6

  v2 = a1;
  v17 = *a1;
  v3 = v17;
  if ( v17 >= 0.0 )
  {
    v4 = 1.570796370506287 - v3;
    v5 = 1;
  }
  else
  {
    v4 = v3 + 1.570796370506287;
    v5 = 0;
  }
  v18 = v4;
  v6 = v18;
  v19 = v18 * v18;
  v7 = v19;
  v20 = v19 * v6;
  v8 = v20;
  v21 = v20 * v7;
  v9 = v21;
  v22 = v21 * v7;
  v10 = v22;
  v23 = v22 * v7;
  v11 = v8 * 508600.09375 + v6 * 6361537.0 + v9 * 53122.0859375 + v10 * 5252.830078125;
  v12 = 539.4000244140625 * v23;
  v24 = v7 * v23;
  v15 = v11 + v12 + v24 * 54.0;
  v25 = v2[1];
  v16 = cos(v25);
  v26 = sin(v25);
  v13 = 1;
  v27 = v26 * v15;
  if ( v27 >= 0.0 )
    v13 = 0;
  result = a2;
  *(float *)(a2 + 4) = v27 + 2000000.0;
  v28 = v15 * v16;
  if ( v5 )
    v28 = -v28;
  *(_BYTE *)(a2 + 2) = 0;
  *(float *)(a2 + 8) = v28 + 2000000.0;
  if ( v13 )
  {
    *(_BYTE *)(a2 + 3) = v5 != 0 ? 89 : 65;
    *(_WORD *)a2 = 24415;
  }
  else
  {
    *(_BYTE *)(a2 + 3) = v5 != 0 ? 90 : 66;
    *(_WORD *)a2 = 24415;
  }
  return result;
}

//----- (1006E6F0) --------------------------------------------------------
void __cdecl sub_1006E6F0(long double *a1, int a2, float *a3, float *a4, float *a5)
{
  double v5; // st7@1
  long double v6; // st7@1
  long double v7; // st7@1
  double v8; // st7@1
  double v9; // st7@1
  long double v10; // st6@1
  double v11; // st6@4
  double v12; // rt2@4
  double v13; // st6@4
  double v14; // st7@4
  double v15; // st6@4
  bool v16; // c0@5
  double v17; // st7@5
  bool v18; // c0@12
  bool v19; // c3@12
  double v20; // st7@12
  double v21; // [sp+50h] [bp-78h]@1
  long double v22; // [sp+58h] [bp-70h]@1
  long double v23; // [sp+60h] [bp-68h]@1
  long double v24; // [sp+68h] [bp-60h]@1
  long double v25; // [sp+70h] [bp-58h]@1
  long double v26; // [sp+78h] [bp-50h]@1
  long double v27; // [sp+80h] [bp-48h]@1
  long double v28; // [sp+88h] [bp-40h]@1
  long double v29; // [sp+90h] [bp-38h]@1
  long double v30; // [sp+98h] [bp-30h]@1
  long double v31; // [sp+A0h] [bp-28h]@1
  long double v32; // [sp+A8h] [bp-20h]@1
  long double v33; // [sp+B0h] [bp-18h]@1
  long double v34; // [sp+B8h] [bp-10h]@1
  long double v35; // [sp+C0h] [bp-8h]@1

  sub_1006F9D0((int)a1, a2 + 2, &v21);
  v5 = v21;
  sub_100A72A0(v21);
  v21 = v5;
  v23 = sin(*a1);
  v6 = cos(*a1);
  v22 = v6;
  v28 = v23 * v23;
  v34 = v23 / v6;
  v29 = v34 * v34;
  v30 = v29 * v29;
  v27 = *a4 / (1.0 - *a4);
  v26 = v6 * v21;
  v32 = v26 * v26;
  v35 = v32 * v26;
  v31 = v35 * v26;
  v25 = v26 * v31;
  v33 = *a3 / sqrt(1.0 - v28 * *a4) * 0.9996;
  v7 = v27;
  v27 = v22 * v22 * v27;
  v24 = v7 * v28;
  v8 = sub_1006F830(a1, &v23, &v22, a5, a3);
  v9 = ((61.0 - 58.0 * v29 + v30 + 270.0 * v27 - v24 * 330.0) * (v25 * v26 * 0.001388888888888889)
      + v32 * 0.5
      + (9.0 * v27 + 5.0 - v29 + v27 * 4.0 * v27) * (v31 * 0.04166666666666666))
     * (v34
      * v33)
     + v8 * 0.9996
     + 0.5;
  v10 = v33
      * ((v30 + 5.0 - v29 * 18.0 + v27 * 14.0 - v24 * 58.0) * (v25 * 0.008333333333333333)
       + (v27 + 1.0 - v29) * (v35 * 0.1666666666666667)
       + v26)
      + 0.5
      + 500000.0;
  if ( *a1 < 0.0 )
  {
    if ( v9 >= 0.0 )
    {
      ++*(_BYTE *)(a2 + 3);
      v9 = 0.0;
    }
    else
    {
      v9 = v9 + 10000000.0;
    }
  }
  *(float *)&v21 = (double)(signed int)v10;
  v11 = *(float *)&v21;
  *(float *)(a2 + 4) = *(float *)&v21;
  v12 = v11;
  v13 = v9;
  v14 = v12;
  *(_WORD *)a2 = 24415;
  *(float *)&v21 = (double)(signed int)v13;
  v15 = *(float *)&v21;
  *(float *)(a2 + 8) = *(float *)&v21;
  if ( v12 <= -0.5 )
  {
    v17 = 9999999.5;
  }
  else
  {
    v16 = 9999999.5 < v14;
    v17 = 9999999.5;
    if ( !v16 )
      goto LABEL_11;
  }
  *(float *)(a2 + 4) = 9.9999996e24;
LABEL_11:
  if ( v15 <= -0.5 )
  {
    v20 = 9.9999996e24;
    goto LABEL_15;
  }
  v18 = v15 < v17;
  v19 = v15 == v17;
  v20 = 9.9999996e24;
  if ( !v18 && !v19 )
LABEL_15:
    *(float *)(a2 + 8) = v20;
}

//----- (1006E9E0) --------------------------------------------------------
int __cdecl sub_1006E9E0(int a1, int a2)
{
  int v2; // edi@1
  __int16 v3; // bx@1
  char v4; // al@1
  double v5; // st7@3
  __int16 v6; // bx@5
  char v7; // al@6
  int result; // eax@9
  char v9; // [sp+14h] [bp+8h]@6

  v2 = a2;
  *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 2);
  v3 = sub_1006F960(*(_BYTE *)a1);
  v4 = *(_BYTE *)(a1 + 3);
  if ( v4 == 90 || v4 == 66 )
    v5 = (double)(v3 - (signed int)(signed __int16)sub_1006F960(65)) * 100000.0 + *(float *)(a1 + 4);
  else
    v5 = (double)(v3 - (signed int)(signed __int16)sub_1006F960(90)) * 100000.0 + *(float *)(a1 + 4) - 100000.0;
  *(float *)(a2 + 4) = v5;
  *(float *)(a2 + 4) = *(float *)(a2 + 4) + 2000000.0;
  v6 = sub_1006F8F0(*(_BYTE *)(a1 + 1));
  if ( *(_BYTE *)(a1 + 3) < 0x59u )
  {
    v7 = 78;
    v9 = 77;
  }
  else
  {
    v7 = 72;
    v9 = 71;
  }
  if ( *(_BYTE *)(a1 + 1) < (unsigned __int8)v7 )
  {
    result = v6 - (signed __int16)sub_1006F8F0(v9);
    *(float *)(v2 + 8) = (double)result * 100000.0 + *(float *)(a1 + 8) - 100000.0;
    *(float *)(v2 + 8) = *(float *)(v2 + 8) + 2000000.0;
  }
  else
  {
    result = v6 - (signed __int16)sub_1006F8F0(v7);
    *(float *)(v2 + 8) = (double)result * 100000.0 + *(float *)(a1 + 8);
    *(float *)(v2 + 8) = *(float *)(v2 + 8) + 2000000.0;
  }
  return result;
}

//----- (1006EB10) --------------------------------------------------------
int __cdecl sub_1006EB10(int a1, int a2)
{
  int v2; // ebx@1
  signed __int16 v3; // ax@1
  char v4; // ST04_1@1
  int v5; // esi@1
  signed int v6; // eax@1
  signed __int16 v7; // si@1
  signed __int16 v8; // ax@3
  signed __int16 v9; // cx@3
  int result; // eax@5
  int v11; // [sp+18h] [bp+8h]@3

  v2 = a2;
  *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 2);
  v3 = sub_1006F8F0(*(_BYTE *)a1);
  v4 = *(_BYTE *)(a2 + 3);
  *(float *)(a2 + 4) = (double)(v3 % 8 + 1) * 100000.0 + *(float *)(a1 + 4);
  v5 = (signed __int16)sub_1006F8F0(v4);
  v6 = (signed int)((double)(v5 - (signed __int16)sub_1006F8F0(78)) * 8.895600318908691);
  v7 = v6;
  if ( *(_BYTE *)(a2 + 3) <= 0x4Du )
    v7 = v6 + 99;
  v11 = (unsigned __int16)sub_1006F8D0((_BYTE *)(a2 + 2));
  v8 = v7 - v7 % 20 - v11 + sub_1006F8F0(*(_BYTE *)(a1 + 1));
  v9 = v8;
  if ( v8 < v7 )
    v9 = 20 * ((unsigned __int16)(v7 - v8 - 1) / 0x14u) + 20 + v8;
  result = v9;
  *(float *)(v2 + 8) = (double)v9 * 100000.0 + *(float *)(a1 + 8);
  return result;
}

//----- (1006EC20) --------------------------------------------------------
void __cdecl sub_1006EC20(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // cf@1
  double *v4; // edi@3
  float v5; // ST10_4@5
  float v6; // [sp+10h] [bp-4h]@1
  float v7; // [sp+18h] [bp+4h]@1
  float v8; // [sp+18h] [bp+4h]@3
  float v9; // [sp+18h] [bp+4h]@3
  float v10; // [sp+18h] [bp+4h]@3
  float v11; // [sp+18h] [bp+4h]@3
  float v12; // [sp+1Ch] [bp+8h]@5
  float v13; // [sp+1Ch] [bp+8h]@5
  float v14; // [sp+1Ch] [bp+8h]@5

  v2 = a1;
  v3 = *(_BYTE *)(a1 + 3) < 0x59u;
  v7 = *(float *)(a1 + 8) - 2000000.0;
  v6 = *(float *)(v2 + 4) - 2000000.0;
  if ( !v3 )
    v7 = -v7;
  v4 = (double *)a2;
  *(double *)(a2 + 8) = sub_100A7420(v6, v7);
  v8 = v6 * v6 + v7 * v7;
  v9 = sqrt(v8) / 12637640.0;
  v10 = atan(v9);
  v11 = 1.570796370506287 - (v10 + v10);
  if ( *(_BYTE *)(v2 + 3) <= 0x42u )
    v11 = -v11;
  v12 = v11 + v11;
  v5 = sin(sub_100A72C0(v12));
  v13 = v12 + v12;
  v14 = sin(sub_100A72C0(v13));
  *v4 = v14 * 0.000006627690254390473 + v5 * 0.00337077584117651 + v11;
}

//----- (1006ED30) --------------------------------------------------------
char __cdecl sub_1006ED30(int a1, int a2)
{
  int v2; // esi@1
  __int16 v3; // ax@1
  double v4; // st7@3
  char result; // al@4
  float v6; // [sp+Ch] [bp+4h]@1
  float v7; // [sp+Ch] [bp+4h]@3
  float v8; // [sp+Ch] [bp+4h]@3

  v2 = a1;
  *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 2);
  v6 = fmod(*(float *)(a1 + 8), 100000.0);
  *(float *)(a2 + 8) = v6;
  v3 = 8 - (signed int)((*(float *)(v2 + 8) - (v6 + 2000000.0)) / -100000.0);
  if ( *(_BYTE *)(v2 + 3) <= 0x42u )
    v3 += 5;
  *(_BYTE *)(a2 + 1) = sub_1006F920(v3);
  v7 = fmod(*(float *)(v2 + 4), 100000.0);
  *(float *)(a2 + 4) = v7;
  v8 = *(float *)(v2 + 4) - (v7 + 2000000.0);
  v4 = v8;
  if ( v8 >= 0.0 )
  {
    result = sub_1006F990((signed int)(v4 / 100000.0));
    *(_BYTE *)a2 = result;
  }
  else
  {
    result = sub_1006F990((signed int)((v4 + 1800000.0) / 100000.0));
    *(_BYTE *)a2 = result;
  }
  return result;
}

//----- (1006EE10) --------------------------------------------------------
void __cdecl sub_1006EE10(int a1, int a2, float *a3, float *a4, float *a5)
{
  bool v5; // cf@1
  double v6; // st7@1
  long double v7; // st7@3
  double v8; // st6@3
  long double v9; // st7@5
  unsigned __int16 v10; // si@5
  double v11; // st7@6
  long double v12; // st7@6
  long double v13; // st6@6
  long double v14; // st7@8
  long double v15; // st7@10
  long double v16; // st5@10
  long double v17; // st7@11
  double v18; // st4@13
  long double v19; // st6@13
  long double v20; // st5@14
  double v21; // st7@14
  long double v22; // st3@16
  long double v23; // st3@16
  long double v24; // rtt@16
  long double v25; // st3@16
  double v26; // st4@16
  double v27; // st7@16
  double v28; // [sp+30h] [bp-58h]@3
  double v29; // [sp+30h] [bp-58h]@10
  double v30; // [sp+30h] [bp-58h]@13
  long double v31; // [sp+38h] [bp-50h]@5
  long double v32; // [sp+40h] [bp-48h]@6
  long double v33; // [sp+48h] [bp-40h]@6
  long double v34; // [sp+50h] [bp-38h]@3
  double v35; // [sp+58h] [bp-30h]@3
  double v36; // [sp+60h] [bp-28h]@3
  long double v37; // [sp+68h] [bp-20h]@10
  double v38; // [sp+70h] [bp-18h]@1
  long double v39; // [sp+78h] [bp-10h]@10
  long double v40; // [sp+80h] [bp-8h]@10

  v5 = *(_BYTE *)(a1 + 3) < 0x4Eu;
  v38 = *(float *)(a1 + 4) - 500000.0;
  v6 = *(float *)(a1 + 8);
  if ( v5 )
    v6 = v6 - 10000000.0;
  v7 = v6 / 0.9996;
  v34 = v7;
  v36 = *a4 / (1.0 - *a4);
  v35 = *a4;
  v8 = (1.0 - *a5) * *a3;
  v28 = v8;
  if ( 0.0 == v8 )
  {
    v8 = 9.999999999999999e-26;
    v28 = 9.999999999999999e-26;
  }
  v9 = v7 / v8;
  v10 = 0;
  v31 = v9;
  do
  {
    v33 = sin(v9);
    v32 = cos(v31);
    v11 = sub_1006F830(&v31, &v33, &v32, a5, a3);
    v12 = v34 - v11;
    ++v10;
    v31 = v12 / v28 + v31;
    v13 = v12;
    v9 = v31;
  }
  while ( fabs(v13) >= 0.5 && v10 < 0xAu );
  v33 = sin(v31);
  v14 = cos(v31);
  v32 = v14;
  if ( 0.0 == v14 )
  {
    v14 = 9.999999999999999e-26;
    v32 = 9.999999999999999e-26;
  }
  v37 = v33 * v33;
  v29 = v14 * v14;
  v40 = v33 / v14;
  v39 = v40 * v40;
  v34 = v39 * v39;
  v15 = sqrt(1.0 - v37 * v35);
  v16 = 1.0e25;
  if ( 0.0 == v15 )
    v17 = 1.0e25;
  else
    v17 = *a3 / v15;
  v18 = v29 * v36;
  v30 = v18 * v18;
  v19 = v36 * v37;
  if ( 0.0 == v17 )
  {
    v21 = v18;
  }
  else
  {
    v20 = v17;
    v21 = v18;
    v16 = v38 / (v20 * 0.9996);
  }
  v22 = v16 * v16 * v16;
  v37 = v22;
  v23 = v22 * v16;
  v38 = v23 * v16;
  v24 = v23;
  v25 = v39;
  v26 = v38;
  *(long double *)a2 = v31
                     - ((90.0 * v39 + 61.0 + v21 * 46.0 + v34 * 45.0 - v19 * 252.0 - v30 * 3.0)
                      * (v38
                       * v16
                       * 0.001388888888888889)
                      + v16 * v16 * 0.5
                      - (3.0 * v39 + 5.0 + v21 - v30 * 4.0 - v19 * 9.0) * (v24 * 0.04166666666666666))
                     * ((v21 + 1.0)
                      * v40);
  v27 = ((v21 * 6.0 + 5.0 + v25 * 28.0 + v19 * 8.0 + v34 * 24.0) * (v26 * 0.008333333333333333)
       + v16
       - (v25 + v25 + 1.0 + v21) * (v37 * 0.1666666666666667))
      * (1.0
       / v32)
      + (double)(6 * *(_BYTE *)(a1 + 2) - 183) * 0.01745329251994333;
  sub_100A72A0(v27);
  *(double *)(a2 + 8) = v27;
}

//----- (1006F0F0) --------------------------------------------------------
char __cdecl sub_1006F0F0(int a1, int a2)
{
  signed int v2; // eax@1
  signed int v3; // eax@1
  int v4; // ebp@1
  __int16 v5; // ax@1
  char result; // al@1

  *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 2);
  v2 = (signed int)(*(float *)(a1 + 4) / 100000.0);
  *(float *)(a2 + 4) = *(float *)(a1 + 4) - 100000.0 * (double)(signed __int16)v2;
  *(_BYTE *)a2 = sub_1006F920(v2 + 8 * ((*(_BYTE *)(a1 + 2) - 1) % 3));
  v3 = (signed int)(*(float *)(a1 + 8) / 100000.0);
  v4 = (signed __int16)v3;
  *(float *)(a2 + 8) = *(float *)(a1 + 8) - 100000.0 * (double)(signed __int16)v3;
  v5 = sub_1006F8D0((_BYTE *)(a1 + 2));
  result = sub_1006F920((v4 + v5) % 20 + 1);
  *(_BYTE *)(a2 + 1) = result;
  return result;
}

//----- (1006F1A0) --------------------------------------------------------
unsigned int __cdecl sub_1006F1A0(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // esi@2

  v6 = (a3 >> 24) + *(_WORD *)(a2 + 24) + ((a3 >> 16) & 0xFF) - *(_WORD *)(a2 + 26);
  v7 = 0;
  if ( v6 <= a4 )
  {
    v8 = v6 + a5;
    do
    {
      v6 += v8;
      ++v7;
    }
    while ( v6 <= a4 );
  }
  *a6 = v7;
  return strlen(a1) + 2 * (v7 - 1 <= 0 ? 0 : v7 - 1) + 1;
}

//----- (1006F210) --------------------------------------------------------
int __cdecl sub_1006F210(int a1, int a2, int a3, int a4, int a5, char a6, char *a7)
{
  char *v7; // eax@1
  char *v8; // esi@1
  char *v9; // edx@2
  char v10; // cl@3
  int v11; // ebx@7
  signed int v12; // edi@7
  signed int i; // edx@9
  int v14; // ebp@13
  int v15; // eax@13
  int v16; // ebp@13
  int v17; // edi@13
  char *v18; // eax@14
  char *v19; // ebp@14
  unsigned int v20; // eax@15
  int v21; // ebx@17
  int v22; // eax@17
  int v23; // edi@21
  int j; // ebp@21
  int v25; // ST14_4@22
  int v26; // ST0C_4@22
  char v27; // al@26
  int v28; // edi@29
  char v29; // al@32
  char v30; // al@40
  int v31; // edx@45
  int v32; // ecx@45
  int v33; // edi@55
  char *v34; // eax@58
  char v35; // dl@59
  int v36; // eax@61
  int v37; // edi@61
  int v38; // ecx@67
  char v39; // al@67
  char *v40; // edi@67
  char *v41; // eax@72
  int v42; // edx@72
  char v43; // cl@73
  _BYTE *v44; // ebp@74
  char *v45; // ST2C_4@78
  char v47; // [sp+13h] [bp-25h]@1
  int v48; // [sp+14h] [bp-24h]@14
  char *v49; // [sp+18h] [bp-20h]@26
  int v50; // [sp+1Ch] [bp-1Ch]@1
  signed int v51; // [sp+20h] [bp-18h]@7
  int v52; // [sp+24h] [bp-14h]@21
  int v53; // [sp+24h] [bp-14h]@26
  int v54; // [sp+28h] [bp-10h]@13
  int v55; // [sp+2Ch] [bp-Ch]@1
  signed int v56; // [sp+2Ch] [bp-Ch]@21
  int v57; // [sp+2Ch] [bp-Ch]@26
  int v58; // [sp+30h] [bp-8h]@29
  int v59; // [sp+34h] [bp-4h]@28

  v7 = (char *)a1;
  v8 = a7;
  v47 = 0;
  v55 = 0;
  v50 = 1;
  if ( a7 != (char *)a1 )
  {
    v9 = &a7[-a1];
    do
    {
      v10 = *v7;
      v7[(_DWORD)v9] = *v7;
      ++v7;
    }
    while ( v10 );
  }
  if ( a4 < 1 || a5 < 1 )
  {
    v47 = 1;
    v50 = 0;
    *v8 = 0;
  }
  v11 = a3;
  v12 = (((unsigned int)a3 >> 16) & 0x3F) - 1;
  v51 = v12;
  if ( v12 < 0 )
  {
    v12 = *(_WORD *)(a2 + 28);
    v51 = *(_WORD *)(a2 + 28);
  }
  for ( i = 0; i < (signed int)strlen(v8); ++i )
  {
    if ( v8[i] == 10 )
      ++v55;
  }
  LOWORD(a1) = 10;
  v14 = v12 + sub_1009DA50(a2, &a1, a3);
  v15 = sub_1009DA50(a2, v8, v11);
  v16 = v55 * v14;
  v17 = a5 * a4 - v16 - v15;
  v54 = a5 * a4 - v16 - v15;
  if ( v47 )
    return -1;
  while ( 1 )
  {
    v18 = strchr(v8, 10);
    v19 = v18;
    v48 = (int)v18;
    if ( v18 )
    {
      LOBYTE(a7) = 1;
      *v18 = 0;
    }
    else
    {
      LOBYTE(a7) = 0;
      v20 = strlen(v8);
      v19 = &v8[v20];
      v48 = (int)&v8[v20];
    }
    v21 = sub_1009DA50(a2, v8, a3);
    v22 = a4;
    if ( v21 > a4 )
    {
      if ( v50 >= a5 )
        goto LABEL_79;
      v52 = 0;
      v23 = a4;
      v56 = strlen(v8) - 1;
      for ( j = v56 / 2; ; j = (v56 + j + 1) / 2 )
      {
        while ( 1 )
        {
          v25 = a3;
          LOBYTE(a1) = v8[j + 1];
          v26 = a2;
          v8[j + 1] = 0;
          v21 = sub_1009DA50(v26, v8, v25);
          v8[j + 1] = a1;
          if ( v21 <= v23 )
            break;
          v56 = j;
          j = (v52 + j) / 2;
        }
        if ( v51 + v21 + sub_1009DA50(a2, &a1, a3) > v23 )
          break;
        v52 = j + 1;
      }
      v57 = v23 - v21;
      v49 = &v8[j];
      v27 = v8[j + 1];
      v53 = j;
      if ( v27 == 32 )
        goto LABEL_67;
      if ( !v27 )
        goto LABEL_67;
      v59 = v54 - v57;
      if ( v54 - v57 <= 0 )
        goto LABEL_67;
      v58 = 0;
      v28 = j;
      if ( j >= 0 )
      {
        while ( 1 )
        {
          if ( !isalnum((unsigned __int8)v8[v28]) || v8[v28] == 45 )
          {
            v29 = v8[v28];
            if ( v29 != 39 && v29 != 40 && v29 != 41 && v29 != 34 )
            {
              if ( v28 <= 0 )
                break;
              if ( v8[v28 - 1] != 32 )
              {
                if ( !isdigit((unsigned __int8)v8[v28 + 1]) || !isdigit((unsigned __int8)v8[v28 - 1]) )
                  break;
                v30 = v8[v28];
                if ( (v30 != 32 || v8[v28 + 2] != 47) && v30 != 47 )
                  break;
              }
            }
          }
          if ( --v28 < 0 )
            goto LABEL_48;
        }
        v31 = a3;
        LOBYTE(a1) = v49[1];
        v32 = a2;
        v49[1] = 0;
        v58 = v51 + sub_1009DA50(v32, &v8[v28 + 1], v31);
        v49[1] = a1;
        if ( v8[v28] == 32 && v28 > 0 )
          --v28;
      }
LABEL_48:
      if ( v28 == -1 || v28 == j || v58 > v59 )
      {
        if ( !isalpha((unsigned __int8)*v49) || !isalpha((unsigned __int8)v49[1]) || !a6 )
          goto LABEL_67;
        LOBYTE(a1) = 45;
        v33 = v51 + sub_1009DA50(a2, &a1, a3);
        if ( v33 + v21 <= a4 )
        {
          if ( (_BYTE)a7 )
            *(_BYTE *)v48 = 10;
          v34 = v49 + 1;
          do
            v35 = *v34++;
          while ( v35 );
          memcpy_0(v49 + 2, v49 + 1, v34 - (v49 + 2) + 1);
          v21 += v33;
          *(_BYTE *)(v48++ + 1) = 0;
          v49[1] = 45;
          v53 = j + 1;
          goto LABEL_67;
        }
        LOBYTE(a1) = *v49;
        v36 = v51 + sub_1009DA50(a2, &a1, a3);
        v37 = v21 + v33 - v36;
        if ( v37 > a4 || v59 < v36 )
        {
LABEL_67:
          v38 = v53;
          v54 -= v57;
          v39 = v8[v53 + 1];
          v40 = &v8[v53 + 1];
          if ( v39 )
          {
            if ( v39 == 32 )
              v38 = v53++ + 1;
            if ( (_BYTE)a7 )
              *(_BYTE *)v48 = 10;
            v40 = &v8[v38 + 1];
            v41 = &v8[v38 + 1];
            v42 = (int)&v8[v38 + 2];
            do
              v43 = *v41++;
            while ( v43 );
            memcpy_0(&v8[v53 + 2], v40, (size_t)&v41[-v42 + 1]);
            v44 = (_BYTE *)(v48 + 1);
            *v40 = 10;
            *(_BYTE *)(v48 + 1) = 0;
          }
          else
          {
            v44 = (_BYTE *)v48;
          }
          if ( (_BYTE)a7 )
          {
            LOBYTE(a7) = 0;
            *v44 = 10;
          }
          v22 = a4;
          v45 = v40;
          v17 = v54;
          v19 = v45;
          goto LABEL_79;
        }
        if ( (_BYTE)a7 )
          *(_BYTE *)v48 = 10;
        memcpy_0(v49 + 1, v49, strlen(v49) + 1);
        *(_BYTE *)(v48++ + 1) = 0;
        *v49 = 45;
        v21 = v37;
      }
      else
      {
        v53 = v28;
        v21 -= v58;
      }
      v57 = a4 - v21;
      goto LABEL_67;
    }
    if ( !(_BYTE)a7 )
      return v50;
    v17 += v21 - a4;
    v54 = v17;
LABEL_79:
    if ( (_BYTE)a7 )
      *v19 = 10;
    if ( v50 >= a5 )
      break;
    if ( !*v19 )
      goto LABEL_85;
    ++v50;
    v8 = v19 + 1;
  }
  if ( *v19 )
  {
LABEL_86:
    *v19 = 0;
    return -1;
  }
LABEL_85:
  if ( v21 > v22 )
    goto LABEL_86;
  return v50;
}

//----- (1006F7A0) --------------------------------------------------------
int __cdecl sub_1006F7A0(int a1)
{
  int result; // eax@1
  int v2; // [sp-10h] [bp-E0h]@2
  __int16 *v3; // [sp-Ch] [bp-DCh]@2
  __int16 v4; // [sp+0h] [bp-D0h]@2
  int v5; // [sp+4h] [bp-CCh]@5
  int v6; // [sp+8h] [bp-C8h]@5

  result = a1;
  if ( (unsigned int)(a1 - 108000) > 0x26DE )
  {
    if ( (unsigned int)(a1 - 118000) > 0x4A2E )
      return result;
    v3 = &v4;
    v4 = -32661;
    v2 = 2;
  }
  else
  {
    v3 = &v4;
    v4 = -32660;
    v2 = 10;
  }
  v5 = 0;
  v6 = a1;
  return sub_1009B450(v2, (int)v3, 60000, 1);
}

//----- (1006F830) --------------------------------------------------------
double __cdecl sub_1006F830(double *a1, double *a2, double *a3, float *a4, float *a5)
{
  double v5; // st5@1
  double v6; // st7@1

  v5 = *a4 / (2.0 - *a4);
  v6 = v5 * v5;
  return *a5
       / (v5 + 1.0)
       * (*a3 * 2.0 * *a2 * ((v6 * 0.125 - 1.0) * (v5 * 1.5))
        + (v6 * (v6 * 0.015625 + 0.25) + 1.0) * *a1
        + (1.0 - v6 * 0.25) * (v6 * 0.9375) * (2.0 * (*a3 * *a3 - *a2 * *a2) * (*a3 * 2.0 * *a2)));
}

//----- (1006F8D0) --------------------------------------------------------
int __cdecl sub_1006F8D0(_BYTE *a1)
{
  return 5 * ((*a1 + 1) % 2);
}

//----- (1006F8F0) --------------------------------------------------------
int __cdecl sub_1006F8F0(char a1)
{
  int result; // eax@1

  result = 0;
  do
  {
    if ( a1 == byte_100E27D4[(signed __int16)result] )
      break;
    ++result;
  }
  while ( (signed __int16)result < 24 );
  return result;
}

//----- (1006F920) --------------------------------------------------------
char __cdecl sub_1006F920(__int16 a1)
{
  __int16 v1; // ax@1
  char result; // al@2

  v1 = a1 - 1;
  if ( (signed __int16)(a1 - 1) >= 0 )
  {
    if ( v1 < 24 )
      result = byte_100E27D4[v1];
    else
      result = byte_100E27D4[23];
  }
  else
  {
    result = 65;
  }
  return result;
}

//----- (1006F960) --------------------------------------------------------
int __cdecl sub_1006F960(char a1)
{
  int result; // eax@1

  result = 0;
  do
  {
    if ( a1 == byte_100E27C0[(signed __int16)result] )
      break;
    ++result;
  }
  while ( (signed __int16)result < 18 );
  return result;
}

//----- (1006F990) --------------------------------------------------------
char __cdecl sub_1006F990(__int16 a1)
{
  char result; // al@2

  if ( a1 >= 0 )
  {
    if ( a1 < 18 )
      result = byte_100E27C0[a1];
    else
      result = byte_100E27C0[17];
  }
  else
  {
    result = 65;
  }
  return result;
}

//----- (1006F9D0) --------------------------------------------------------
int __cdecl sub_1006F9D0(int a1, int a2, double *a3)
{
  char v3; // al@1
  signed int v4; // eax@5
  char v5; // al@9
  char v6; // al@14
  int result; // eax@24

  v3 = sub_1006F920((signed int)(*(double *)a1 * 7.161972439135274 + 13.0));
  *(_BYTE *)(a2 + 1) = v3;
  if ( (unsigned __int8)v3 <= 0x58u )
  {
    if ( (unsigned __int8)v3 < 0x43u )
      *(_BYTE *)(a2 + 1) = 67;
  }
  else
  {
    *(_BYTE *)(a2 + 1) = 88;
  }
  v4 = (signed int)(*(double *)(a1 + 8) * 9.5492965855137 + 31.0);
  *(_BYTE *)a2 = v4;
  if ( (char)v4 >= 1 )
  {
    if ( (char)v4 > 60 )
      *(_BYTE *)a2 = 60;
  }
  else
  {
    *(_BYTE *)a2 = 1;
  }
  v5 = *(_BYTE *)(a2 + 1);
  if ( v5 != 86 || *(_BYTE *)a2 != 31 )
  {
    if ( v5 != 88 )
      goto LABEL_24;
    v6 = *(_BYTE *)a2;
    if ( *(_BYTE *)a2 == 32 )
    {
      if ( *(double *)(a1 + 8) < 0.15707963267949 )
      {
        *(_BYTE *)a2 = 31;
        goto LABEL_24;
      }
LABEL_19:
      *(_BYTE *)a2 = 33;
      goto LABEL_24;
    }
    if ( v6 == 34 )
    {
      if ( *(double *)(a1 + 8) < 0.36651914291881 )
        goto LABEL_19;
    }
    else
    {
      if ( v6 != 36 )
        goto LABEL_24;
      if ( *(double *)(a1 + 8) >= 0.57595865315813 )
      {
        *(_BYTE *)a2 = 37;
        goto LABEL_24;
      }
    }
    *(_BYTE *)a2 = 35;
    goto LABEL_24;
  }
  if ( *(double *)(a1 + 8) >= 0.05235987755983 )
    *(_BYTE *)a2 = 32;
LABEL_24:
  result = 3 * *(_BYTE *)a2;
  *a3 = *(double *)(a1 + 8) - (double)(6 * *(_BYTE *)a2 - 183) * 0.01745329251994333;
  return result;
}

//----- (1006FAD0) --------------------------------------------------------
char __cdecl sub_1006FAD0(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32723;
  qmemcpy(&v3, a1, 0x1C8u);
  return sub_1007A960((int)&v2);
}

//----- (1006FB40) --------------------------------------------------------
void __cdecl sub_1006FB40(const char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@2

  if ( a1 )
  {
    v3 = strlen(a1);
    if ( v3 < a2 )
      memset((void *)&a1[v3], a3, a2 - v3);
    a1[a2] = 0;
  }
}

//----- (1006FB90) --------------------------------------------------------
void __cdecl sub_1006FB90(const char *a1, char a2, char a3)
{
  unsigned int v3; // esi@4
  unsigned int v4; // ecx@4

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v3 = strlen(a1);
        v4 = 0;
        if ( v3 )
        {
          do
          {
            if ( a1[v4] == a2 )
              a1[v4] = a3;
            ++v4;
          }
          while ( v4 < v3 );
        }
      }
    }
  }
}

//----- (1006FBE0) --------------------------------------------------------
int __cdecl sub_1006FBE0(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1006FC30) --------------------------------------------------------
signed int __cdecl sub_1006FC30(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // ebx@2
  _BYTE *v5; // edi@2
  int v6; // esi@3
  int v7; // eax@3
  signed int result; // eax@7

  v3 = a3;
  if ( a3 <= 0 )
  {
LABEL_7:
    result = -2;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = tolower(*v5++);
      v7 = tolower(*v4++);
      if ( v6 > v7 )
        return 1;
      if ( v6 < v7 )
        return -1;
      if ( !v6 )
        break;
      if ( --v3 <= 0 )
        goto LABEL_7;
    }
    result = 0;
  }
  return result;
}

//----- (1006FCA0) --------------------------------------------------------
int __cdecl sub_1006FCA0(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1006FCD0) --------------------------------------------------------
int __cdecl sub_1006FCD0(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (1006FD30) --------------------------------------------------------
int __cdecl sub_1006FD30(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1006FD70) --------------------------------------------------------
int sub_1006FD70(char *arg0, size_t arg4, char *arg8, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, arg8);
  result = sub_1006FD30(arg0, arg4, arg8, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1006FDA0) --------------------------------------------------------
int __cdecl sub_1006FDA0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1006FBE0((int)&a1[v3], a2, a3 - v3);
}

//----- (1006FDE0) --------------------------------------------------------
int __cdecl sub_1006FDE0(int a1, int a2)
{
  return sub_1006FCD0(a1, "_ ", a2);
}

//----- (1006FE00) --------------------------------------------------------
char __cdecl sub_1006FE00(_BYTE *a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char result; // al@3
  void *v5; // ecx@6
  __int16 v6; // [sp+8h] [bp-298h]@1
  int v7; // [sp+Ch] [bp-294h]@1
  int v8; // [sp+10h] [bp-290h]@1
  char v9; // [sp+14h] [bp-28Ch]@1
  char v10; // [sp+D4h] [bp-1CCh]@1
  char v11; // [sp+198h] [bp-108h]@1
  char v12; // [sp+199h] [bp-107h]@1

  v2 = sub_100704E0(v1);
  v6 = -32598;
  v7 = 0;
  v8 = 83;
  sub_1006FBE0((int)&v9, a1, 64);
  v10 = 9;
  v11 = 0;
  memset(&v12, 0, 0x100u);
  if ( v2 == 8 )
  {
    if ( sub_1009B3B0(21) == 5 )
      return sub_1009B450(16, (int)&v6, 1000, 1);
  }
  else if ( v2 == 2 )
  {
    return sub_1009B450(3, (int)&v6, 1000, 1);
  }
  if ( sub_10070580(v3) == 1 || (unsigned int)sub_100705C0(v5) & 3 )
  {
    if ( sub_10070480(v5) )
    {
      result = sub_1009B450(1, (int)&v6, 1000, 1);
    }
    else
    {
      sub_1006FBE0((int)&v12, "No available drop down lists on this page.", 256);
      result = sub_1006FAD0(&v10);
    }
  }
  else
  {
    result = sub_1009B450(9, (int)&v6, 1000, 1);
  }
  return result;
}

//----- (1006FF40) --------------------------------------------------------
char __thiscall sub_1006FF40(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 12;
  sub_1009BA00(3000, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1006FF70) --------------------------------------------------------
char __thiscall sub_1006FF70(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 30;
  sub_1009BA00(3001, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1006FFA0) --------------------------------------------------------
char __fastcall sub_1006FFA0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1009C2B0(3, (_BYTE *)&v2 + 2);
  BYTE2(v2) = byte_100E345D[2 * sub_10071590((int *)((char *)&v2 + 2), 1u, (int)&unk_100E345C, 2, 5, -1)];
  if ( sub_1009B830(3002, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1009B9C0(3002, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10070010) --------------------------------------------------------
char __thiscall sub_10070010(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1009BA00(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10070040) --------------------------------------------------------
char __fastcall sub_10070040(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1009C2B0(3, (_BYTE *)&v2 + 2);
  if ( sub_1009B830(3003, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1009B9C0(3003, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10070090) --------------------------------------------------------
char sub_10070090()
{
  return 18;
}

//----- (100700A0) --------------------------------------------------------
char __thiscall sub_100700A0(void *this)
{
  char result; // al@3
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1009C2B0(95, (_BYTE *)&v2 + 2);
  if ( *(_BYTE *)(dword_1068B5C0 + 28249) && !sub_1009B830(3202, (int)&v2 + 3, 1) )
  {
    result = BYTE3(v2);
  }
  else
  {
    sub_1009B9C0(3202, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}
// 1068B5C0: using guessed type int dword_1068B5C0;

//----- (10070100) --------------------------------------------------------
BOOL __thiscall sub_10070100(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1009C2B0(97, (_BYTE *)&v2 + 3);
  return BYTE3(v2) == 1;
}

//----- (10070120) --------------------------------------------------------
char __fastcall sub_10070120(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1009C2B0(4, (_BYTE *)&v2 + 2);
  if ( sub_1009B830(3010, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 5u) )
  {
    sub_1009B9C0(3010, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10070170) --------------------------------------------------------
char __thiscall sub_10070170(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_1009BA00(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (100701A0) --------------------------------------------------------
char __thiscall sub_100701A0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 23;
  sub_1009BA00(3006, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (100701D0) --------------------------------------------------------
char __fastcall sub_100701D0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1009C2B0(5, (_BYTE *)&v2 + 2);
  if ( sub_1009B830(3007, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1009B9C0(3007, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10070220) --------------------------------------------------------
bool __thiscall sub_10070220(void *this)
{
  int v1; // eax@2
  bool result; // al@2
  unsigned __int16 v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  LOBYTE(v4) = sub_100714F0(this);
  v5 = 2;
  sub_1009B890(9129, &v3, 2, &v5);
  if ( sub_10076D80(v4, 4) )
  {
    v1 = sub_10071590(&v4, 1u, (int)&unk_100E3558, 8, 2, 2);
    result = (v3 & (unsigned __int16)word_100E355C[4 * v1]) != 0;
  }
  else
  {
    result = sub_10076D80(v4, 2) || sub_10076E00(6) || sub_10076E00(8) || sub_10076D80(v4, 12) || sub_10076D80(v4, 16);
  }
  return result;
}
// 100E355C: using guessed type __int16 word_100E355C[];

//----- (100702F0) --------------------------------------------------------
char __thiscall sub_100702F0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1009BA00(3011, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10070320) --------------------------------------------------------
char __thiscall sub_10070320(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_1009BA00(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10070350) --------------------------------------------------------
int sub_10070350()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_1009BA00(3012, &v2, 4, &v1);
  return v2;
}

//----- (10070380) --------------------------------------------------------
char __thiscall sub_10070380(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 11;
  sub_1009BA00(3009, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (100703B0) --------------------------------------------------------
char __fastcall sub_100703B0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1009C2B0(42, (_BYTE *)&v2 + 2);
  if ( sub_1009B830(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1009B9C0(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10070400) --------------------------------------------------------
char __cdecl sub_10070400(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74AC: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 100A74B2: using guessed type int SYS_enter_krnl(void);

//----- (10070420) --------------------------------------------------------
int __cdecl sub_10070420(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10070AD0("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10070AD0("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74B8: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10070480) --------------------------------------------------------
char __thiscall sub_10070480(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10070420(5, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100704A0) --------------------------------------------------------
char __thiscall sub_100704A0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10070420(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100704C0) --------------------------------------------------------
char __thiscall sub_100704C0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10070420(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100704E0) --------------------------------------------------------
char __thiscall sub_100704E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10070420(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10070500) --------------------------------------------------------
bool sub_10070500()
{
  void *v0; // ecx@1
  char v1; // bl@1
  void *v2; // ecx@3
  bool result; // al@4
  char v4; // [sp+Ch] [bp-4h]@1

  v4 = j_HWM_pvg_hsdb_get_lrus_online();
  v1 = sub_100714F0(v0);
  if ( sub_10076D80(v1, 2) || sub_10076D80(v1, 18) )
    goto LABEL_12;
  if ( sub_10076D80(v1, 4) )
    return sub_10070220(v2);
  if ( sub_10076D80(v1, 6) && (!v1 || !(v4 & 4)) )
LABEL_12:
    result = 1;
  else
    result = 0;
  return result;
}
// 1009C320: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10070580) --------------------------------------------------------
char __thiscall sub_10070580(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10070420(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100705A0) --------------------------------------------------------
char sub_100705A0()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_10070420(48, &v1);
  return v1;
}

//----- (100705C0) --------------------------------------------------------
void *__thiscall sub_100705C0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10070420(46, (char *)&v2);
  return v2;
}

//----- (100705E0) --------------------------------------------------------
char __cdecl sub_100705E0(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (10070610) --------------------------------------------------------
char __cdecl sub_10070610(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (10070640) --------------------------------------------------------
__int16 __cdecl sub_10070640(unsigned int a1)
{
  return word_100E4094[(a1 >> 17) & 0xF];
}
// 100E4094: using guessed type __int16 word_100E4094[];

//----- (10070660) --------------------------------------------------------
bool __cdecl sub_10070660(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  char *v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = &a1[dword_1068B044[8 * v3]];
    if ( a2 )
      *a2 = (int)v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (100706B0) --------------------------------------------------------
char __cdecl sub_100706B0(int a1, char *a2)
{
  char *v2; // edi@1
  int v3; // esi@1
  char **v4; // eax@2

  v2 = a2;
  v3 = 0;
  if ( sub_10070660(a2, 0, &a2) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
      v2 = a2;
      *(_BYTE *)(v3++ + *(_DWORD *)(a1 + 64)) = 3;
      LOBYTE(v4) = sub_10070660(v2, 0, &a2);
    }
    while ( (_BYTE)v4 );
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
  }
  else
  {
    v4 = *(char ***)(a1 + 56);
    *v4 = v2;
  }
  return (unsigned int)v4;
}

//----- (10070710) --------------------------------------------------------
int __cdecl sub_10070710(int a1, int a2, char *a3, int a4)
{
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v8; // [sp+8h] [bp-4h]@1

  v4 = a3;
  sub_10070660(a3, &v8, 0);
  sub_10001B10(a1, *(_DWORD *)(a1 + 56));
  v5 = *(_DWORD *)(a1 + 56);
  LOWORD(a3) = *(_WORD *)v8 + *(_WORD *)(v5 + 36);
  v6 = *(_DWORD *)v4;
  HIWORD(a3) = *(_WORD *)(v8 + 2) + *(_WORD *)(v5 + 38);
  return ((int (__cdecl *)(int, char *, char **, int, int))dword_1068B040[2 * (unsigned __int8)v6])(a1, v4, &a3, a4, a2);
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (10070780) --------------------------------------------------------
char __cdecl sub_10070780(int a1, char *a2, _WORD *a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_10070AD0("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_10070610(a1, v7, (int)v3);
    sub_10070660(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_10001B10(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, _WORD *))dword_1068B040[2
                                                                                  * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                                 + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 1068B040: using guessed type int dword_1068B040[];

//----- (10070830) --------------------------------------------------------
int __cdecl sub_10070830(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (10070850) --------------------------------------------------------
char *__cdecl sub_10070850(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_100E40C1;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_1068B5C8[(unsigned __int16)sub_10070830(a1)];
  return result;
}
// 1009B1FC: using guessed type int TXT_get_static_string(void);

//----- (10070890) --------------------------------------------------------
char *__cdecl sub_10070890(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_1009B230();
  *(_DWORD *)(a5 + 596) = sub_1009B2D0();
  sub_1009B2F0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1006FBE0(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10075D30((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (100709C0) --------------------------------------------------------
char sub_100709C0()
{
  char result; // al@1

  result = 0;
  byte_10583258 = 0;
  byte_10583259 = 0;
  return result;
}
// 10583258: using guessed type char byte_10583258;
// 10583259: using guessed type char byte_10583259;

//----- (100709D0) --------------------------------------------------------
char __cdecl sub_100709D0(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10070890(-5, a1, a2, a4, a5);
  else
    sub_10070890(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1006FDA0((const char *)(a5 + 485), " DBGA", 100);
  sub_1009B2F0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_10583258 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_10583259 )
LABEL_15:
      result = sub_1009B380(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 1009C330: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 10583258: using guessed type char byte_10583258;
// 10583259: using guessed type char byte_10583259;

//----- (10070AD0) --------------------------------------------------------
char __cdecl sub_10070AD0(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_100709D0(a1, a2, a3, a4, (int)&v5);
}

//----- (10070B40) --------------------------------------------------------
int __cdecl sub_10070B40(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_10071590(&a1, 4u, (int)&unk_100E46E0, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_10070AD0(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_100E46E4 + 2 * v2);
}
// 100E46E4: using guessed type void *off_100E46E4;

//----- (10070BC0) --------------------------------------------------------
int __cdecl sub_10070BC0(int *a1)
{
  int result; // eax@1

  result = sub_1007C900((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_1009B2D0();
    result = sub_1007C740();
  }
  return result;
}

//----- (10070BF0) --------------------------------------------------------
char __usercall sub_10070BF0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_1009B3F0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1007D9C0("%i %i\r\n", 13, v2);
    sub_1007CF60(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_1009B3D0(*(_DWORD *)(a1 + 4));
    v6 = sub_1007D9C0("%i %i\r\n", 14, v5);
    sub_1007CF60(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100E4B6C, (int)v6);
    result = 1;
  }
  else
  {
    sub_10070AD0(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10070CA0) --------------------------------------------------------
int __cdecl sub_10070CA0(const char *a1)
{
  int result; // eax@1

  result = sub_1007AA60();
  if ( a1 )
    result = sub_1007C930(dword_1058325C[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 1058325C: using guessed type int dword_1058325C[];

//----- (10070CE0) --------------------------------------------------------
char __cdecl sub_10070CE0(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1007C880((char *)a1 + 4);
  v1 = sub_100832E0();
  sub_1007C820((int)v1, 0, 0);
  dword_1058325C[sub_1007AA60()] = (int)a1;
  v2 = sub_100832A0((int)sub_10070CA0);
  return sub_1007C950(v2);
}
// 1058325C: using guessed type int dword_1058325C[];

//----- (10070D30) --------------------------------------------------------
signed int __cdecl sub_10070D30(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_1009B2D0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_1009B4D0(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_1009B2D0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_1009B560(&v23);
          }
          while ( sub_1009B2D0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_1009B2B0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_1009B2F0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1007D9C0("The %s task is loaded.", &v24);
            sub_1007CF60(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1007D9C0("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_1007CF60(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1007D9C0("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_1007CF60(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1007D9C0(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_1007CF60(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_1009B210(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1007D9C0("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_1007CF60(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1007D9C0("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_1007CF60(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_1007CF60(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_1009B380(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_100832A0((int)sub_10070CA0);
        sub_1007D030((int)v15);
        v16 = sub_10084680((int)sub_10070CA0);
        sub_1007D030((int)v16);
        v17 = sub_10084680((int)sub_10070CA0);
        sub_1007C950(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_100832A0((int)sub_10070CA0);
        sub_1007D030((int)v18);
        v19 = sub_10084680((int)sub_10070CA0);
        sub_1007D030((int)v19);
        v20 = sub_100832A0((int)sub_10070CA0);
        sub_1007C950(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10070BF0(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (100710D0) --------------------------------------------------------
char **sub_100710D0()
{
  return off_100E4B58;
}
// 100E4B58: using guessed type char *off_100E4B58[3];

//----- (10071100) --------------------------------------------------------
int __cdecl sub_10071100(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10583270 = a1;
  return result;
}
// 10583270: using guessed type int dword_10583270;

//----- (10071110) --------------------------------------------------------
int __cdecl sub_10071110(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10583274 = a1;
  return result;
}
// 10583274: using guessed type int dword_10583274;

//----- (10071120) --------------------------------------------------------
char sub_10071120()
{
  void *v0; // ecx@1
  void *v1; // ecx@1
  void *v2; // ecx@1
  void *v3; // ecx@1
  char result; // al@1

  j_FIL_vfs_dyn_linker();
  nullsub_1();
  sub_1007B940();
  sub_10076C30(v0);
  sub_10076FC0(v1);
  sub_10084720(v2);
  sub_100846F0();
  sub_1000EBA0();
  dword_10590A10 = (int)sub_100705C0(v3);
  sub_1009B8D0(6465, (int)&dword_105909F4, 28);
  result = sub_1008E9C0();
  if ( !result )
  {
    result = dword_10590A10;
    dword_105909F4 = dword_10590A10;
    dword_105909F8 = dword_10590A10;
    dword_105909FC = dword_10590A10;
    dword_10590A00 = dword_10590A10;
    dword_10590A04 = dword_10590A10;
    dword_10590A08 = dword_10590A10;
    dword_10590A0C = dword_10590A10;
  }
  return result;
}
// 10079350: using guessed type int nullsub_1(void);
// 1009BAB0: using guessed type int j_FIL_vfs_dyn_linker(void);
// 105909F4: using guessed type int dword_105909F4;
// 105909F8: using guessed type int dword_105909F8;
// 105909FC: using guessed type int dword_105909FC;
// 10590A00: using guessed type int dword_10590A00;
// 10590A04: using guessed type int dword_10590A04;
// 10590A08: using guessed type int dword_10590A08;
// 10590A0C: using guessed type int dword_10590A0C;
// 10590A10: using guessed type int dword_10590A10;

//----- (10071150) --------------------------------------------------------
_DWORD *__cdecl sub_10071150(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (10071160) --------------------------------------------------------
int *__cdecl sub_10071160(int *a1, int a2)
{
  int *result; // eax@1
  int i; // esi@1

  result = a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (int *)(*(int (__cdecl **)(_DWORD, _DWORD))i)(i, a2);
  return result;
}

//----- (10071190) --------------------------------------------------------
_DWORD *__cdecl sub_10071190(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (100711A0) --------------------------------------------------------
char __cdecl sub_100711A0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (100711E0) --------------------------------------------------------
char __cdecl sub_100711E0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10070AD0("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10071250) --------------------------------------------------------
signed int __cdecl sub_10071250(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10070AD0("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100712D0) --------------------------------------------------------
char __cdecl sub_100712D0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10070AD0("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10071340) --------------------------------------------------------
char __cdecl sub_10071340(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10070AD0("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (100713F0) --------------------------------------------------------
char __cdecl sub_100713F0(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10070AD0("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (100714F0) --------------------------------------------------------
char __thiscall sub_100714F0(void *this)
{
  void *v1; // eax@1

  v1 = sub_100705C0(this);
  return sub_100713F0((int)v1);
}

//----- (10071500) --------------------------------------------------------
char __cdecl sub_10071500(char a1, unsigned __int16 a2, char a3)
{
  char result; // al@1

  result = a1;
  do
    result += a3;
  while ( !(a2 & (unsigned __int16)word_100E6D90[(unsigned __int8)result]) && result != a1 );
  return result;
}
// 100E6D90: using guessed type __int16 word_100E6D90[];

//----- (10071530) --------------------------------------------------------
signed int __cdecl sub_10071530(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_100C8DC4;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 1 );
  if ( result == 1 )
    result = -1;
  return result;
}
// 100C8DC4: using guessed type int (__cdecl *off_100C8DC4)(int);

//----- (10071560) --------------------------------------------------------
char *__cdecl sub_10071560(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 1 )
    result = (char *)&unk_100C4192;
  else
    result = &aDiagnostics[56 * a1];
  return result;
}

//----- (10071590) --------------------------------------------------------
int __cdecl sub_10071590(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10071720) --------------------------------------------------------
int __cdecl sub_10071720(_DWORD *a1, unsigned int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int result; // eax@1
  int v7; // ebx@1
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  unsigned int v21; // edx@23
  char *i; // ecx@23
  int v23; // [sp+20h] [bp+14h]@1

  v5 = a5;
  result = a5 - 1;
  v7 = a3 + a4 * (a5 - 1);
  v23 = a5 - 1;
  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && v5 > 0 )
  {
    if ( result > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v23;
        if ( v20 )
        {
          v7 -= a4;
          result = v23 - 1;
          v23 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a2;
    for ( i = (char *)v7; v21 >= 4; i += 4 )
    {
      if ( *(_DWORD *)&i[(_DWORD)a1 - v7] != *(_DWORD *)i )
        break;
      v21 -= 4;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10071840) --------------------------------------------------------
signed int __cdecl sub_10071840(unsigned int a1)
{
  int v1; // eax@1

  v1 = sub_10071AF0(a1);
  return sub_10073110(v1);
}

//----- (10071860) --------------------------------------------------------
bool __cdecl sub_10071860(unsigned int a1, _DWORD *a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // esi@1
  bool result; // al@3

  v2 = sub_10071AF0(a1);
  v3 = v2;
  if ( v2 < 0xFFFFFFC2 && v2 )
  {
    sub_100735F0(v2, 0, 0);
    result = sub_10073970(v3, a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100718C0) --------------------------------------------------------
signed int __cdecl sub_100718C0(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10071AF0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_100735F0(v4, a4, 0) == a4 )
      result = sub_10073590(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10071920) --------------------------------------------------------
signed int __cdecl sub_10071920(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10071AF0(a1);
  return sub_100735F0(v3, a2, a3);
}

//----- (10071940) --------------------------------------------------------
unsigned int __cdecl sub_10071940(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // esi@1
  int v4; // ebp@2
  int v5; // edi@4
  unsigned int v6; // eax@4
  unsigned int v7; // esi@4
  bool v8; // ST3B_1@6
  unsigned int result; // eax@9
  int v10; // [sp+14h] [bp-318h]@4
  int v11; // [sp+18h] [bp-314h]@4
  __int16 v12; // [sp+1Ch] [bp-310h]@4
  int v13; // [sp+20h] [bp-30Ch]@4
  int v14; // [sp+24h] [bp-308h]@4
  __int16 v15; // [sp+28h] [bp-304h]@4
  void *v16; // [sp+2Ch] [bp-300h]@4
  int v17; // [sp+30h] [bp-2FCh]@4
  void *v18; // [sp+34h] [bp-2F8h]@4
  int v19; // [sp+38h] [bp-2F4h]@4
  int v20; // [sp+3Ch] [bp-2F0h]@4
  char v21; // [sp+40h] [bp-2ECh]@4
  int v22; // [sp+44h] [bp-2E8h]@4
  char v23; // [sp+48h] [bp-2E4h]@4

  v3 = a1;
  if ( sub_10071C50(a1) && (v4 = a2, a2 <= a3) && a3 < *(_WORD *)(a1 + 16) )
  {
    while ( 1 )
    {
      v5 = sub_1009B5D0(29, -1);
      memset(&v10, 0, 0x34u);
      v13 = v3 + 48;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v14 = 0;
      v15 = 0;
      v16 = &unk_10584278;
      v17 = 4096;
      v18 = &unk_10585278;
      v19 = 46920;
      v20 = 15;
      v21 = -2;
      v22 = 0xFFFF;
      v6 = sub_10073480(v3, v4, 4, &v23, (int)&v10);
      v7 = v6;
      if ( v6 >= 0xFFFFFFC2 || !v6 )
      {
        sub_1009B5A0(v5, 29);
        return v7;
      }
      v8 = sub_10071860(v6, 0);
      sub_10071840(v7);
      sub_1009B5A0(v5, 29);
      if ( !v8 )
        return -14;
      if ( ++v4 > a3 )
        break;
      v3 = a1;
    }
    result = 0;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10071AB0) --------------------------------------------------------
signed int __cdecl sub_10071AB0(int a1)
{
  signed int result; // eax@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  result = sub_10072CE0(a1, 0, (unsigned int *)&v2);
  if ( v2 >= 0 )
    result = sub_10071940(a1, v2, v2);
  return result;
}

//----- (10071AF0) --------------------------------------------------------
unsigned int __cdecl sub_10071AF0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10071B10) --------------------------------------------------------
int __cdecl sub_10071B10(int a1)
{
  return a1 | 1;
}

//----- (10071B20) --------------------------------------------------------
bool __cdecl sub_10071B20(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10071BF0) --------------------------------------------------------
int __cdecl sub_10071BF0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10071C10) --------------------------------------------------------
int __cdecl sub_10071C10(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10071BF0(a1 + 20);
  return result;
}

//----- (10071C50) --------------------------------------------------------
bool __cdecl sub_10071C50(int a1)
{
  unsigned int v1; // esi@2
  unsigned int v2; // ecx@5
  bool result; // al@11

  result = a1
        && (v1 = *(_DWORD *)(a1 + 116), v1 < 0xFFFFFFC2)
        && v1
        && *(_DWORD *)a1 != -1
        && ((v2 = *(_DWORD *)(a1 + 120), *(_DWORD *)a1 + 22 <= v2)
         && *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20) + 22 <= v2
         || !v2
         || *(_DWORD *)(a1 + 4) != v1)
        && *(_DWORD *)(a1 + 8) == 101010256
        && *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 12);
  return result;
}

//----- (10071CB0) --------------------------------------------------------
signed int __cdecl sub_10071CB0(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_1009BB80(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_1009BB80(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10071D70) --------------------------------------------------------
signed int __cdecl sub_10071D70(int a1, int a2, int a3)
{
  int v3; // esi@3
  signed int result; // eax@9

  if ( sub_1009BB80(*(_DWORD *)(a1 + 116), (void *)a3, 30, *(_DWORD *)(a2 + 42), 0) != 30 )
    goto LABEL_13;
  if ( *(_BYTE *)(a2 + 8) & 8 )
  {
    v3 = *(_DWORD *)(a2 + 42) + *(_DWORD *)(a2 + 20) + sub_10071C10(0, a3);
    sub_1009BB80(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3, 0);
    if ( *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16) )
      sub_1009BB80(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3 + 4, 0);
  }
  if ( *(_DWORD *)a3 != 67324752
    || *(_DWORD *)(a3 + 18) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16)
    || *(_WORD *)(a3 + 26) != *(_WORD *)(a2 + 28) )
  {
LABEL_13:
    result = -15;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10071E20) --------------------------------------------------------
int __cdecl sub_10071E20(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10071E40) --------------------------------------------------------
signed int __cdecl sub_10071E40(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // edi@2
  _BYTE *v5; // ebx@2
  int v6; // esi@3
  signed int result; // eax@5
  int v8; // [sp+1Ch] [bp+Ch]@3

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = *v5;
      --v3;
      v8 = tolower(*v4++);
      ++v5;
      if ( tolower(v6) != v8 )
        break;
      if ( !v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10071EA0) --------------------------------------------------------
int __usercall sub_10071EA0@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // ebx@2
  int v6; // ebp@5
  int v7; // eax@5
  int v8; // ST04_4@5
  int v10; // [sp+Ch] [bp-4h]@4
  int v11; // [sp+18h] [bp+8h]@4

  v3 = a2;
  if ( a3 )
  {
    v4 = a2;
    v3 = *(_DWORD *)(a1 + 116);
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 116);
    v5 = *(_DWORD *)(a1 + 120);
  }
  v11 = *(_DWORD *)(a1 + 24);
  sub_1009BC60(v3);
  v10 = sub_1009BAD0(v4, v5, v3, v11, *(_DWORD *)(a1 + 20));
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 120) = v11;
    v6 = sub_1009BC90(v3, v11, 0);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = v5 + *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v7;
    v10 = sub_1009BC90(v4, v8, 0) | v6;
  }
  *(_DWORD *)(a1 + 120) = sub_1009BC60(*(_DWORD *)(a1 + 116));
  return v10;
}

//----- (10071FB0) --------------------------------------------------------
int __usercall sub_10071FB0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10088E00(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_1009BC60(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_1009BC90(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 1009BCB0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10072060) --------------------------------------------------------
signed int __usercall sub_10072060@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_1009BCC0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10089250((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10071CB0(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1009BB80(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_1009BB80(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_10089120(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_1009BCC0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_1009BCC0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10072230) --------------------------------------------------------
char __usercall sub_10072230@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_10088DB0(a2, a3, a1 + 212);
}

//----- (10072240) --------------------------------------------------------
int __usercall sub_10072240@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10071FB0(result + 148, result);
  return result;
}

//----- (10072260) --------------------------------------------------------
char __usercall sub_10072260@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10072280) --------------------------------------------------------
unsigned int __usercall sub_10072280@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  unsigned int result; // eax@1

  v2 = sub_100A7070(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_100A7070(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (100722C0) --------------------------------------------------------
int __cdecl sub_100722C0(unsigned int a1)
{
  int i; // ebx@1
  int v2; // edi@1
  signed int v3; // eax@1
  signed int v4; // ebp@1
  int result; // eax@2
  int v6; // esi@7
  int v7; // ebx@9
  int v8; // eax@10
  unsigned int v9; // ecx@11
  int *v10; // edx@11
  char *v11; // esi@11
  int v12; // edi@15
  int v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // esi@16
  int v16; // ecx@18
  _BYTE *v17; // edx@18
  _BYTE *v18; // esi@18
  _BYTE *v19; // edx@20
  _BYTE *v20; // esi@20
  signed int v21; // ecx@22
  signed int v22; // [sp+Ch] [bp-9Ch]@1
  int v23; // [sp+10h] [bp-98h]@7
  signed int v24; // [sp+14h] [bp-94h]@1
  int v25; // [sp+18h] [bp-90h]@1
  int v26; // [sp+20h] [bp-88h]@1
  char v27[128]; // [sp+24h] [bp-84h]@9

  i = 65557;
  v2 = 0;
  v22 = 65557;
  v25 = 0;
  v26 = 101010256;
  v3 = sub_1009BC60(a1);
  v4 = v3;
  v24 = v3;
  if ( v3 >= 0 )
  {
    if ( (unsigned int)v3 >= 0x10015 )
      goto LABEL_7;
    v22 = v3;
    if ( v3 > 0 )
    {
      for ( i = v3; ; i = v22 )
      {
LABEL_7:
        v6 = v2 + 128;
        v23 = v2 + 128;
        if ( v2 + 128 > i )
        {
          v6 = i;
          v23 = i;
        }
        v7 = v6 - v2;
        if ( sub_1009BB80(a1, v27, v6 - v2, v4 - v6, 0) != v6 - v2 )
          break;
        v8 = v7 - 4;
        if ( v7 - 4 >= 0 )
        {
          while ( 1 )
          {
            v9 = 4;
            v10 = &v26;
            v11 = &v27[v8];
            do
            {
              if ( *(_DWORD *)v11 != *v10 )
                goto LABEL_15;
              v9 -= 4;
              ++v10;
              v11 += 4;
            }
            while ( v9 >= 4 );
            if ( !v9 )
            {
LABEL_24:
              v21 = 0;
              goto LABEL_25;
            }
LABEL_15:
            v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
            if ( (unsigned __int8)*v11 == *(_BYTE *)v10 )
            {
              v13 = v9 - 1;
              v14 = (char *)v10 + 1;
              v15 = v11 + 1;
              if ( !v13 )
                goto LABEL_24;
              v12 = *v15 - *v14;
              if ( *v15 == *v14 )
              {
                v16 = v13 - 1;
                v17 = v14 + 1;
                v18 = v15 + 1;
                if ( !v16 )
                  goto LABEL_24;
                v12 = *v18 - *v17;
                if ( *v18 == *v17 )
                {
                  v19 = v17 + 1;
                  v20 = v18 + 1;
                  if ( v16 == 1 )
                    goto LABEL_24;
                  v12 = *v20 - *v19;
                  if ( *v20 == *v19 )
                    goto LABEL_24;
                }
              }
            }
            v21 = 1;
            if ( v12 <= 0 )
              v21 = -1;
LABEL_25:
            if ( !v21 )
              return v24 + v8 - v23;
            if ( --v8 < 0 )
            {
              v4 = v24;
              v2 = v25;
              v6 = v23;
              break;
            }
          }
        }
        v2 = v2 + v7 - 3;
        v25 = v2;
        if ( v6 >= v22 )
          break;
      }
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 100722C0: using guessed type char var_84[128];

//----- (10072470) --------------------------------------------------------
int __fastcall sub_10072470(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10072490) --------------------------------------------------------
int __usercall sub_10072490@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 732) = result;
  ++*(_DWORD *)(result + 124);
  return result;
}

//----- (100724A0) --------------------------------------------------------
int __usercall sub_100724A0@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_1009BD10(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_1009BC90(v4, v3, 0);
}
// 1009BCB0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100724E0) --------------------------------------------------------
signed int __usercall sub_100724E0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10072470(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_100A7090(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10072230(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_1008B1B0(a2 + 28, 4);
      else
        v22 = sub_1008B1B0(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10072230(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 1009BCB0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100726F0) --------------------------------------------------------
int __cdecl sub_100726F0(void *a1)
{
  unsigned int v1; // ecx@2
  unsigned int v2; // eax@4
  int v3; // edi@4
  int v4; // edi@7
  int result; // eax@8

  if ( a1 && (v1 = *((_DWORD *)a1 + 29), v1 < 0xFFFFFFC2) && v1 )
  {
    v2 = *((_DWORD *)a1 + 1);
    v3 = 0;
    if ( v1 != v2 && v2 < 0xFFFFFFC2 )
    {
      if ( v2 )
      {
        v4 = sub_10071EA0((int)a1, v2, 0);
        v3 = sub_100724A0((int)a1) | v4;
      }
    }
    sub_1009BA60(*((_DWORD *)a1 + 29));
    memset(a1, 0, 0x80u);
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10072750) --------------------------------------------------------
int __cdecl sub_10072750(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@3
  signed int v5; // edi@5
  unsigned int v6; // eax@6
  int v8; // eax@11
  int v9; // eax@17

  memset(a3, 0, 0x80u);
  *((_DWORD *)a3 + 8) = -1;
  *((_DWORD *)a3 + 9) = -1;
  *((_BYTE *)a3 + 48) = 0;
  if ( a4 )
    sub_1006FBE0((int)a3 + 48, (_BYTE *)a4, 64);
  *((_BYTE *)a3 + 112) = 3;
  v4 = j_FIL_vfs_open(a1, a2, 0);
  *((_DWORD *)a3 + 29) = v4;
  if ( v4 >= 0xFFFFFFC2 || !v4 )
  {
    v5 = v4;
    if ( !v4 )
      return v5;
LABEL_6:
    v6 = *((_DWORD *)a3 + 29);
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_1009BA60(*((_DWORD *)a3 + 29));
    }
    memset(a3, 0, 0x80u);
    return v5;
  }
  *((_DWORD *)a3 + 1) = v4;
  v8 = sub_1009BC60(v4);
  *((_DWORD *)a3 + 30) = v8;
  if ( v8 < 0 )
  {
LABEL_12:
    v5 = -15;
    goto LABEL_6;
  }
  if ( v8 || !(a2 & 2) )
  {
    v9 = sub_100722C0(*((_DWORD *)a3 + 29));
    *(_DWORD *)a3 = v9;
    if ( v9 == -1 || (unsigned int)(v9 + 22) > *((_DWORD *)a3 + 30) )
      goto LABEL_12;
    sub_1009BB80(*((_DWORD *)a3 + 1), (char *)a3 + 8, 22, v9, 0);
    if ( !sub_10071C50((int)a3) )
    {
      v5 = -15;
      goto LABEL_6;
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = 101010256;
  }
  return 0;
}
// 1009BB30: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10072850) --------------------------------------------------------
signed int __cdecl sub_10072850(int a1, unsigned __int64 a2)
{
  unsigned int v2; // eax@3
  signed int v3; // esi@3
  unsigned int v4; // ebp@4
  int v5; // edx@8
  void *v6; // eax@9
  unsigned __int16 v7; // si@10
  unsigned __int16 v8; // cx@10
  void *v9; // ecx@17
  unsigned __int16 v10; // ax@19
  signed int result; // eax@24
  int v12; // ecx@25
  int v13; // [sp+8h] [bp-4h]@4

  if ( sub_10071C50(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = -15;
    if ( (unsigned int)a2 < v2 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      v13 = 0;
LABEL_5:
      while ( v4 < *(_DWORD *)(a1 + 120) )
      {
        v3 = sub_1009BB80(*(_DWORD *)(a1 + 4), (void *)(HIDWORD(a2) + 4), 46, v4, 0);
        if ( v3 != 46 || *(_DWORD *)(HIDWORD(a2) + 4) != 33639248 )
        {
          v12 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v12;
          v3 = -15;
          break;
        }
        v5 = a1;
        *(_DWORD *)(a1 + 32) = v13;
        *(_DWORD *)(a1 + 36) = v4;
        if ( v13 == (_DWORD)a2 )
        {
          v6 = *(void **)(HIDWORD(a2) + 52);
          v3 = 0;
          *(_DWORD *)HIDWORD(a2) = v4;
          *(_WORD *)(HIDWORD(a2) + 58) = -1;
          if ( v6 )
          {
            v7 = *(_WORD *)(HIDWORD(a2) + 56);
            v8 = *(_WORD *)(HIDWORD(a2) + 32);
            if ( v7 <= v8 )
            {
              sub_1006FBE0((int)v6, &unk_100C4192, v7);
              v5 = a1;
              v3 = -15;
            }
            else if ( sub_1009BB80(*(_DWORD *)(a1 + 4), v6, v8, v4 + 46, 0) == *(_WORD *)(HIDWORD(a2) + 32) )
            {
              v5 = a1;
              *(_WORD *)(HIDWORD(a2) + 58) = *(_WORD *)(HIDWORD(a2) + 32);
              v3 = 0;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
            else
            {
              v5 = a1;
              v3 = -15;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
          }
          else
          {
            *(_WORD *)(HIDWORD(a2) + 58) = -1;
          }
          v9 = *(void **)(HIDWORD(a2) + 60);
          *(_WORD *)(HIDWORD(a2) + 66) = -1;
          if ( v9 )
          {
            if ( !v3 )
            {
              v10 = *(_WORD *)(HIDWORD(a2) + 34);
              if ( *(_WORD *)(HIDWORD(a2) + 64) < v10
                || sub_1009BB80(*(_DWORD *)(v5 + 4), v9, v10, *(_WORD *)(HIDWORD(a2) + 32) + v4 + 46, 0) != *(_WORD *)(HIDWORD(a2) + 34) )
              {
                v3 = -15;
              }
              else
              {
                v3 = 0;
                *(_WORD *)(HIDWORD(a2) + 66) = *(_WORD *)(HIDWORD(a2) + 34);
              }
            }
          }
        }
        v4 += sub_10071BF0(HIDWORD(a2) + 4);
        if ( ++v13 > (unsigned int)a2 )
          return v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 32);
      if ( v2 <= (unsigned int)a2 )
        goto LABEL_5;
    }
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10072A50) --------------------------------------------------------
signed int __cdecl sub_10072A50(int a1, int a2)
{
  return sub_10071D70(*(_DWORD *)(a1 + 732), a1 + 20, a2);
}

//----- (10072A70) --------------------------------------------------------
int __cdecl sub_10072A70(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10072240(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10075D30(&v23);
    sub_10075CB0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10071C10(v1, (int)&v24);
  v13 = sub_1009BC60(v31);
  if ( v3 == v31 )
  {
    result = sub_1009BAD0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_1009BD10(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_1009BAD0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_1009BD10(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10071BF0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_100724A0(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_1009BC60(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 1009BCB0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10072CE0) --------------------------------------------------------
signed int __cdecl sub_10072CE0(int a1, unsigned int a2, unsigned int *a3)
{
  unsigned int v3; // esi@3
  signed int result; // eax@3
  char v5; // [sp+8h] [bp-44h]@3
  char v6; // [sp+14h] [bp-38h]@5

  if ( sub_10071C50(a1) && a3 )
  {
    *a3 = -1;
    memset(&v5, 0, 0x44u);
    v3 = a2;
    result = 0;
    if ( a2 < *(_WORD *)(a1 + 16) )
    {
      while ( 1 )
      {
        result = sub_10072850(a1, __PAIR__(&v5, v3));
        if ( !result )
        {
          if ( v6 & 1 )
            break;
        }
        if ( ++v3 >= *(_WORD *)(a1 + 16) )
          return result;
      }
      *a3 = v3;
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10072D70) --------------------------------------------------------
int __cdecl sub_10072D70(void *a1, int a2, char a3)
{
  _BYTE *v3; // eax@1
  char *v4; // edi@3
  int result; // eax@4

  memset(a1, 0, 0x2E0u);
  *((_DWORD *)a1 + 17) = *(_DWORD *)(a2 + 4);
  *((_WORD *)a1 + 36) = *(_WORD *)(a2 + 8);
  *((_DWORD *)a1 + 19) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a1 + 40) = *(_WORD *)(a2 + 20);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *((_DWORD *)a1 + 24) = *(_DWORD *)(a2 + 24);
  *((_DWORD *)a1 + 25) = *(_DWORD *)(a2 + 28);
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
  sub_10071E20((int)a1 + 116);
  v3 = *(_BYTE **)(a2 + 12);
  if ( v3 )
    sub_1006FBE0((int)a1 + 148, v3, 64);
  v4 = (char *)a1 + 116;
  if ( a3 )
    result = sub_1008B470(
               (int)v4,
               *(_BYTE *)(a2 + 44),
               8,
               -*(_DWORD *)(a2 + 40),
               *(_DWORD *)(a2 + 48),
               0,
               *(_DWORD *)(a2 + 32),
               *(_DWORD *)(a2 + 36));
  else
    result = sub_1008CDD0((int)v4, -*(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36));
  return result;
}

//----- (10072E40) --------------------------------------------------------
signed int __cdecl sub_10072E40(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_1009BD10(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_100724E0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10072EE0) --------------------------------------------------------
unsigned int __usercall sub_10072EE0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10072260(a1);
  *v3 ^= v2;
  return sub_10072280(v1, *v3);
}

//----- (10072F00) --------------------------------------------------------
unsigned int __usercall sub_10072F00@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  unsigned int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10072EE0(a2);
  return result;
}

//----- (10072F30) --------------------------------------------------------
signed int __usercall sub_10072F30@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10072280(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_1009BB80(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10072FA0) --------------------------------------------------------
int __cdecl sub_10072FA0(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebx@4
  int v5; // esi@6
  int result; // eax@11
  signed int v7; // [sp+8h] [bp-F4h]@6
  char v8; // [sp+Ch] [bp-F0h]@4
  char *v9; // [sp+40h] [bp-BCh]@4
  __int16 v10; // [sp+44h] [bp-B8h]@4
  unsigned __int16 v11; // [sp+46h] [bp-B6h]@8
  char v12; // [sp+50h] [bp-ACh]@4

  v3 = a2;
  if ( sub_10071C50(a1) && a2 && *a2 )
  {
    memset(&v8, 0, 0x44u);
    v9 = &v12;
    v10 = 168;
    v4 = strlen(a2);
    strchr(a2, 92);
    if ( *a2 == 47 )
    {
      v3 = a2 + 1;
      --v4;
    }
    v5 = a3;
    v7 = -24;
    if ( a3 < (unsigned int)*(_WORD *)(a1 + 16) )
    {
      while ( sub_10072850(a1, __PAIR__(&v8, v5)) || v4 != v11 || sub_10071E40(v3, &v12, v4) )
      {
        if ( ++v5 >= (unsigned int)*(_WORD *)(a1 + 16) )
          return -24;
      }
      v7 = v5;
    }
    result = v7;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10073110) --------------------------------------------------------
signed int __cdecl sub_10073110(int a1)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)(a1 + 732) )
  {
    --*(_DWORD *)(*(_DWORD *)(a1 + 732) + 124);
    if ( *(_BYTE *)(a1 + 8) )
      exit(a1);
    sub_1008C2A0(a1 + 116);
    result = 0;
    *(_DWORD *)a1 = -858993460;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10073170) --------------------------------------------------------
char __usercall sub_10073170@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10088D60(a1, a2, a3 + 212);
  else
    result = sub_10072F00(a2, a3 + 148);
  return result;
}

//----- (100731A0) --------------------------------------------------------
signed int __usercall sub_100731A0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10072060(v3, v1);
  else
    result = sub_10072F30(v3, v1);
  return result;
}

//----- (100731D0) --------------------------------------------------------
BOOL __usercall sub_100731D0@<eax>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+10h] [bp+4h]@2

  v2 = a2;
  v3 = 0;
  v4 = a2 + 148;
  do
  {
    v6 = *(_BYTE *)(a1 + v3 + 76);
    sub_10072EE0(v4);
    ++v3;
  }
  while ( v3 < 0xC );
  return *(_BYTE *)(v2 + 39) == v6;
}

//----- (10073210) --------------------------------------------------------
signed int __cdecl sub_10073210(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10071E20(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_1008CEC0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_100731A0(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10073260) --------------------------------------------------------
signed int __cdecl sub_10073260(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_1009BB80(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10073170(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_1009BB80(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10088E00(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10072470(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1008E280(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_100A7090(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_100A7090(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10073450) --------------------------------------------------------
bool __usercall sub_10073450@<al>(int a1@<eax>)
{
  int v1; // ecx@4
  int v2; // edx@4
  int v3; // eax@4
  signed int v4; // ecx@6
  int v5; // eax@2

  if ( *(_WORD *)(a1 + 30) != 99 )
    return sub_100731D0(a1 + 148, a1);
  v5 = a1 + 148;
  v1 = v5 + 543;
  v2 = v5 + 571;
  v3 = *(_BYTE *)(v5 + 571) - *(_BYTE *)(v5 + 543);
  if ( v3 || (v3 = *(_BYTE *)(v2 + 1) - *(_BYTE *)(v1 + 1), *(_BYTE *)(v2 + 1) != *(_BYTE *)(v1 + 1)) )
  {
    v4 = 1;
    if ( v3 <= 0 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  return v4 == 0;
}

//----- (10073480) --------------------------------------------------------
int __cdecl sub_10073480(int a1, int a2, char a3, void *a4, int a5)
{
  int result; // eax@6
  unsigned __int64 v6; // ST04_8@7
  char v7; // [sp+8h] [bp-54h]@8
  int v8; // [sp+28h] [bp-34h]@4
  int v9; // [sp+34h] [bp-28h]@4

  if ( !sub_10071C50(a1) || !a4 || a3 & 2 )
    return -15;
  qmemcpy(&v8, (const void *)a5, 0x34u);
  if ( !v9 )
    v9 = a1 + 48;
  result = sub_10072D70(a4, (int)&v8, 0);
  if ( !result )
  {
    HIDWORD(v6) = (char *)a4 + 16;
    LODWORD(v6) = a2;
    if ( sub_10072850(a1, v6) )
      return -15;
    sub_10072490(a1, (int)a4);
    if ( sub_10072A50((int)a4, (int)&v7) )
    {
      sub_10071840((unsigned int)a4);
      return -15;
    }
    *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10071C10((int)a4, (int)&v7);
    *((_DWORD *)a4 + 3) = a2;
    sub_10073210((unsigned int)a4);
    if ( !(*((_BYTE *)a4 + 28) & 1) || sub_10073450((int)a4) )
    {
      result = sub_10071B10((int)a4);
    }
    else
    {
      sub_10073110((int)a4);
      result = -34;
    }
  }
  return result;
}

//----- (10073590) --------------------------------------------------------
signed int __cdecl sub_10073590(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10073260(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10071B20(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100735F0) --------------------------------------------------------
signed int __cdecl sub_100735F0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10073210(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10071E20(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10073210(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10073590(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10073780) --------------------------------------------------------
int __cdecl sub_10073780(int a1, char *a2, int a3, void *a4, int a5)
{
  int result; // eax@10
  bool v6; // zf@11
  int v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // [sp+Ch] [bp-34h]@5
  int v10; // [sp+18h] [bp-28h]@5
  char v11; // [sp+38h] [bp-8h]@11

  if ( sub_10071C50(a1) && a2 && a4 && a5 )
  {
    qmemcpy(&v9, (const void *)a5, 0x34u);
    if ( !v10 )
      v10 = a1 + 48;
    *((_DWORD *)a4 + 1) = a3;
    if ( a3 & 8 )
    {
      if ( *(_WORD *)(a1 + 16) >= 0xFFFFu || *(_WORD *)(a1 + 18) >= 0xFFFFu )
      {
        result = -22;
      }
      else
      {
        result = sub_10072D70(a4, (int)&v9, 1);
        if ( !result )
        {
          *((_DWORD *)a4 + 1) = a3;
          *((_BYTE *)a4 + 8) = 1;
          *((_DWORD *)a4 + 183) = a1;
          *((_DWORD *)a4 + 3) = *(_WORD *)(a1 + 16);
          *((_DWORD *)a4 + 22) = -1;
          *((_WORD *)a4 + 12) = 20;
          *((_WORD *)a4 + 13) = 20;
          *((_DWORD *)a4 + 5) = 33639248;
          *((_WORD *)a4 + 14) = 0;
          *((_WORD *)a4 + 16) = 0;
          *((_WORD *)a4 + 17) = 0;
          *((_DWORD *)a4 + 9) = 0;
          *((_DWORD *)a4 + 10) = 0;
          *((_DWORD *)a4 + 11) = 0;
          v6 = v11 == 0;
          *((_WORD *)a4 + 24) = strlen(a2);
          *((_WORD *)a4 + 25) = 0;
          *((_WORD *)a4 + 26) = 0;
          *((_WORD *)a4 + 27) = 0;
          *((_WORD *)a4 + 28) = 0;
          *(_DWORD *)((char *)a4 + 58) = 0;
          if ( v6 )
            *((_WORD *)a4 + 15) = 0;
          else
            *((_WORD *)a4 + 15) = 8;
          if ( *(_BYTE *)a4 & 4 )
          {
            *(_WORD *)((char *)a4 + 689) = *((_WORD *)a4 + 15);
            *((_WORD *)a4 + 15) = 99;
            *((_WORD *)a4 + 14) = 1;
          }
          *(_DWORD *)((char *)a4 + 62) = *(_DWORD *)(a1 + 120);
          *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10071C10((int)a4, 0);
          sub_10072490(a1, (int)a4);
          v7 = *(_DWORD *)((char *)a4 + 62);
          v8 = sub_10071C10((int)a4, 0);
          sub_1009BCC0(*(_DWORD *)(a1 + 116), *((_DWORD *)a4 + 24), v8, v7);
          if ( *((_BYTE *)a4 + 28) & 1 )
            sub_100731A0((int)a4);
          result = sub_10071B10((int)a4);
        }
      }
    }
    else
    {
      *((_BYTE *)a4 + 8) = 0;
      result = sub_10072FA0(a1, a2, 0);
      if ( result >= 0 )
        result = sub_10073480(a1, result, a3, a4, (int)&v9);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10073970) --------------------------------------------------------
bool __cdecl sub_10073970(unsigned int a1, _DWORD *a2)
{
  bool result; // al@3

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    result = sub_100735F0(a1, *(_DWORD *)(a1 + 44), 0) == *(_DWORD *)(a1 + 44) && sub_10071B20(a1);
    if ( a2 )
      *a2 = *(_DWORD *)(a1 + 36);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100739C0) --------------------------------------------------------
int __cdecl sub_100739C0(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_100E891C[a1];
  return result;
}
// 100E891C: using guessed type __int16 word_100E891C[];

//----- (100739E0) --------------------------------------------------------
signed int sub_100739E0()
{
  signed int result; // eax@1

  result = -15;
  dword_105909DC = -15;
  dword_105909E8 = -15;
  dword_105909C4 = -15;
  dword_105909EC = -15;
  dword_105909D8 = -15;
  dword_105909C8 = -15;
  dword_105909C0 = -15;
  dword_105909D4 = -15;
  dword_105909E4 = -15;
  dword_105909E0 = -15;
  dword_105909D0 = -15;
  dword_105909CC = -15;
  return result;
}
// 105909C0: using guessed type int dword_105909C0;
// 105909C4: using guessed type int dword_105909C4;
// 105909C8: using guessed type int dword_105909C8;
// 105909CC: using guessed type int dword_105909CC;
// 105909D0: using guessed type int dword_105909D0;
// 105909D4: using guessed type int dword_105909D4;
// 105909D8: using guessed type int dword_105909D8;
// 105909DC: using guessed type int dword_105909DC;
// 105909E0: using guessed type int dword_105909E0;
// 105909E4: using guessed type int dword_105909E4;
// 105909E8: using guessed type int dword_105909E8;
// 105909EC: using guessed type int dword_105909EC;

//----- (10073A30) --------------------------------------------------------
signed int __usercall sub_10073A30@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_1009C150((int)&off_100E893C);
      break;
    case 0:
      result = sub_1009C150((int)&off_100E8950);
      break;
    case 1:
      result = sub_1009C150((int)&off_100E8964);
      break;
    case 2:
      result = sub_1009C150((int)&off_100E898C);
      break;
    case 3:
      result = sub_1009C150((int)&off_100E8978);
      break;
    case 5:
      result = sub_1009C150((int)&off_100E89A0);
      break;
    default:
      result = sub_1009C150(a2);
      break;
  }
  return result;
}
// 100E893C: using guessed type char *off_100E893C;
// 100E8950: using guessed type char *off_100E8950;
// 100E8964: using guessed type char *off_100E8964;
// 100E8978: using guessed type char *off_100E8978;
// 100E898C: using guessed type char *off_100E898C;
// 100E89A0: using guessed type char *off_100E89A0;

//----- (10073AD0) --------------------------------------------------------
int __usercall sub_10073AD0@<eax>(char a1@<al>)
{
  return sub_1009B3D0(dword_100E846C[a1]);
}
// 100E846C: using guessed type int dword_100E846C[];

//----- (10073AF0) --------------------------------------------------------
int __usercall sub_10073AF0@<eax>(char a1@<al>)
{
  return sub_1009B3F0(dword_100E846C[a1], 10);
}
// 100E846C: using guessed type int dword_100E846C[];

//----- (10073B10) --------------------------------------------------------
unsigned __int16 __usercall sub_10073B10@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  unsigned __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10073A30(a1, a1) )
        {
          sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_105909DC + 2 * a2 + 241212);
        v3 = result < 0x256u;
        goto LABEL_32;
      }
      sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10073A30(a1, a1) )
      {
        result = *(_WORD *)(dword_105909E8 + 2 * a2 + 284664);
        v3 = result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10070400(15000) )
        goto LABEL_6;
      sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10073A30(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_105909C4 + 2 * a2 + 447808);
      v3 = result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10073A30(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_105909EC + 2 * a2 + 356016);
      v3 = result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10073A30(a1, a1) )
      {
        sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_105909D8 + 2 * a2 + 23096);
      v3 = result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10073A30(a1, a1) )
        {
          result = *(_WORD *)(dword_105909C8 + 2 * a2 + 1804);
          v3 = result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 105909C4: using guessed type int dword_105909C4;
// 105909C8: using guessed type int dword_105909C8;
// 105909D8: using guessed type int dword_105909D8;
// 105909DC: using guessed type int dword_105909DC;
// 105909E8: using guessed type int dword_105909E8;
// 105909EC: using guessed type int dword_105909EC;

//----- (10073D50) --------------------------------------------------------
char __cdecl sub_10073D50(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  unsigned __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10073B10(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10073A30(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_105909DC + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10073A30(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_105909E8 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10073A30(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_105909C4 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10073A30(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_105909EC + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10073A30(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_105909D8 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10073A30(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_105909C8 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 105909C4: using guessed type int dword_105909C4;
// 105909C8: using guessed type int dword_105909C8;
// 105909D8: using guessed type int dword_105909D8;
// 105909DC: using guessed type int dword_105909DC;
// 105909E8: using guessed type int dword_105909E8;
// 105909EC: using guessed type int dword_105909EC;

//----- (10073ED0) --------------------------------------------------------
char __cdecl sub_10073ED0(char a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10073B10(a1, a2);
  if ( v3 != -1 && !sub_10073AF0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10073A30(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_105909DC + 24 * (v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10073A30(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_105909E8 + 24 * v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10073A30(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_105909C4 + 24 * v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10073A30(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_105909EC + 24 * (v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10073A30(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_105909D8 + 24 * v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10073A30(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_105909C8 + 24 * v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10073AD0(a1);
        return 1;
      default:
LABEL_17:
        sub_10073AD0(a1);
        break;
    }
  }
  return 0;
}
// 105909C4: using guessed type int dword_105909C4;
// 105909C8: using guessed type int dword_105909C8;
// 105909D8: using guessed type int dword_105909D8;
// 105909DC: using guessed type int dword_105909DC;
// 105909E8: using guessed type int dword_105909E8;
// 105909EC: using guessed type int dword_105909EC;

//----- (10074030) --------------------------------------------------------
char __cdecl sub_10074030(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  unsigned __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10073A30(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10073B10(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10073D50(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_1009B2D0();
      v13 = 0;
      LOBYTE(v7) = sub_1007A840(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10074170) --------------------------------------------------------
char __cdecl sub_10074170(char a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10073B10(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_1007A840(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10074250) --------------------------------------------------------
char __cdecl sub_10074250(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  unsigned __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_1009B2D0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10073B10(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10073A30(a1, v7) )
            goto LABEL_30;
          v9 = 3 * v8 + 75;
          v10 = dword_105909DC + 14952;
          v11 = 52 * v8 + dword_105909DC + 210116;
          v12 = dword_105909DC + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10073A30(a1, v7) )
            goto LABEL_30;
          v14 = 3 * v8;
          v10 = dword_105909E8 + 13228;
          v11 = 52 * v8 + dword_105909E8 + 257156;
          v12 = dword_105909E8 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10073A30(a1, v7) )
            goto LABEL_30;
          v15 = 3 * v8;
          v10 = dword_105909C4 + 60628;
          v11 = 52 * v8 + dword_105909C4 + 321708;
          v12 = dword_105909C4 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10073A30(a1, v7) )
            goto LABEL_30;
          v16 = 3 * v8 + 72;
          v10 = dword_105909EC + 14328;
          v11 = 52 * v8 + dword_105909EC + 326220;
          v12 = dword_105909EC + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10073A30(a1, v7) )
            goto LABEL_30;
          v17 = 3 * v8;
          v10 = dword_105909D8 + 2052;
          v11 = 52 * v8 + dword_105909D8 + 18832;
          v12 = dword_105909D8 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10073A30(a1, v7) )
            goto LABEL_30;
          v18 = 3 * v8;
          v10 = dword_105909C8 + 100;
          v11 = 52 * v8 + dword_105909C8 + 1596;
          v12 = dword_105909C8 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10073AF0(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10073AD0(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 105909C0: using guessed type int dword_105909C0;
// 105909C4: using guessed type int dword_105909C4;
// 105909C8: using guessed type int dword_105909C8;
// 105909D4: using guessed type int dword_105909D4;
// 105909D8: using guessed type int dword_105909D8;
// 105909DC: using guessed type int dword_105909DC;
// 105909E4: using guessed type int dword_105909E4;
// 105909E8: using guessed type int dword_105909E8;
// 105909EC: using guessed type int dword_105909EC;

//----- (100744D0) --------------------------------------------------------
char __cdecl sub_100744D0(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10074250(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10074500) --------------------------------------------------------
char __cdecl sub_10074500(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10074250(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10074530) --------------------------------------------------------
char __cdecl sub_10074530(char a1, int a2, void *a3, int a4)
{
  return sub_10074250(a1, a2, 0, 0, a3, a4);
}

//----- (10074560) --------------------------------------------------------
int __cdecl sub_10074560(_BYTE *a1)
{
  return sub_10076430(a1, 0, 0xBu, 0, 0);
}

//----- (10074580) --------------------------------------------------------
unsigned int __cdecl sub_10074580(char *a1)
{
  return sub_10076130(a1, -100, 100, 0, 0);
}

//----- (100745A0) --------------------------------------------------------
int __cdecl sub_100745A0(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 2u, 0, 0);
}

//----- (100745C0) --------------------------------------------------------
int __cdecl sub_100745C0(_BYTE *a1)
{
  return sub_10076430(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (100745E0) --------------------------------------------------------
int __cdecl sub_100745E0(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 1u, 1u, 0);
}

//----- (10074600) --------------------------------------------------------
unsigned int __cdecl sub_10074600(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10075FF0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10076340((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_10075FF0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076340((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076340((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10074930) --------------------------------------------------------
unsigned int __cdecl sub_10074930(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10075FF0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075FF0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10076130((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10074D70) --------------------------------------------------------
unsigned int __cdecl sub_10074D70(_BYTE *a1)
{
  return sub_10076220(a1, -1, 5, -1, 0);
}

//----- (10074D90) --------------------------------------------------------
int __cdecl sub_10074D90(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 5u, 0, 0);
}

//----- (10074DB0) --------------------------------------------------------
int __cdecl sub_10074DB0(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 4u, 2u, 0);
}

//----- (10074DD0) --------------------------------------------------------
int __cdecl sub_10074DD0(_BYTE *a1)
{
  return sub_10076430(a1, 0, 2u, 0, 0);
}

//----- (10074DF0) --------------------------------------------------------
int __cdecl sub_10074DF0(int a1)
{
  return sub_10076040(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10074E40) --------------------------------------------------------
int __cdecl sub_10074E40(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10074DF0((int)(a1 + 4));
  if ( !result )
    result = sub_10074DB0(a1);
  return result;
}

//----- (10074E60) --------------------------------------------------------
int __cdecl sub_10074E60(int a1)
{
  int result; // eax@1

  result = sub_10074D90((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10074D90((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10074D90((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_1008E2A0((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_10075FF0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_10075FF0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_10075FF0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_10075FF0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10074EF0) --------------------------------------------------------
unsigned int __cdecl sub_10074EF0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10074D70((_BYTE *)a1);
  if ( !result )
    result = sub_10074D70((_BYTE *)(a1 + 4));
  return result;
}

//----- (10074F10) --------------------------------------------------------
unsigned int __cdecl sub_10074F10(int a1)
{
  unsigned int result; // eax@1

  result = sub_10074D70((_BYTE *)a1);
  if ( !result )
    result = sub_10074D70((_BYTE *)(a1 + 4));
  return result;
}

//----- (10074F30) --------------------------------------------------------
signed int __cdecl sub_10074F30(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_10075FF0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_10075FF0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10074F80) --------------------------------------------------------
unsigned int __cdecl sub_10074F80(int a1)
{
  unsigned int result; // eax@1

  result = sub_10074D70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10074D70((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10074D70((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10074D70((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_10075FF0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10074FE0) --------------------------------------------------------
int __cdecl sub_10074FE0(_BYTE *a1)
{
  return sub_10076430(a1, 0, 0x20u, 2u, 0);
}

//----- (10075000) --------------------------------------------------------
unsigned int __cdecl sub_10075000(_BYTE *a1)
{
  return sub_10076220(a1, -1, 4, -1, 0);
}

//----- (10075020) --------------------------------------------------------
int __cdecl sub_10075020(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 9u, 0, 0);
}

//----- (10075040) --------------------------------------------------------
int __cdecl sub_10075040(_BYTE *a1)
{
  return sub_10076430(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10075060) --------------------------------------------------------
signed int __cdecl sub_10075060(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10076430(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10075090) --------------------------------------------------------
int __cdecl sub_10075090(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10076390(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100750D0) --------------------------------------------------------
signed int __cdecl sub_100750D0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10076390(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10075100) --------------------------------------------------------
int __cdecl sub_10075100(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10075060((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10075090((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075090((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1008E3E0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10075090((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10075190) --------------------------------------------------------
int __cdecl sub_10075190(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 2u, 0, 0);
}

//----- (100751B0) --------------------------------------------------------
int __cdecl sub_100751B0(int a1)
{
  int result; // eax@1

  result = sub_10076340((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10076340((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (100751E0) --------------------------------------------------------
int __cdecl sub_100751E0(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 3u, 1u, 0);
}

//----- (10075200) --------------------------------------------------------
unsigned int __cdecl sub_10075200(int a1)
{
  unsigned int result; // eax@1

  result = sub_10076220((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10076220((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10075230) --------------------------------------------------------
int __cdecl sub_10075230(int a1)
{
  int result; // eax@1

  result = sub_10076040(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10076040(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10076040(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10076040(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10076040(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10075320) --------------------------------------------------------
int __cdecl sub_10075320(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10075FF0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10076340((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10075200(a1 + 36);
        if ( !result )
        {
          result = sub_10076040(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10075230(a1 + 8);
            if ( !result )
            {
              result = sub_10075200(a1 + 28);
              if ( !result )
              {
                result = sub_10076390((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10075190((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_100751B0(a1 + 57);
                    if ( !result )
                    {
                      result = sub_10075FF0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_100751E0((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10075430) --------------------------------------------------------
signed int __cdecl sub_10075430(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10076340(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10075460) --------------------------------------------------------
signed int __cdecl sub_10075460(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10076390(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10075490) --------------------------------------------------------
signed int __cdecl sub_10075490(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10076340(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100754C0) --------------------------------------------------------
int __cdecl sub_100754C0(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10075520) --------------------------------------------------------
int __cdecl sub_10075520(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10075FF0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_100754C0((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10075530) --------------------------------------------------------
signed int __cdecl sub_10075530(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10076430(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10075560) --------------------------------------------------------
int __cdecl sub_10075560(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10076340((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10076340((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (100755E0) --------------------------------------------------------
unsigned int __cdecl sub_100755E0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10074580((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10074580((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10074580((char *)a1);
      if ( !result )
        result = sub_10074580((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10075620) --------------------------------------------------------
unsigned int __cdecl sub_10075620(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_100755E0(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_100745A0((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_100745E0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10075670) --------------------------------------------------------
int __cdecl sub_10075670(int a1)
{
  int result; // eax@1

  result = sub_100745C0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10076390((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (100756A0) --------------------------------------------------------
int __cdecl sub_100756A0(int a1)
{
  int result; // eax@1

  result = sub_10074DD0((_BYTE *)a1);
  if ( !result )
    result = sub_10075040((_BYTE *)(a1 + 4));
  return result;
}

//----- (100756D0) --------------------------------------------------------
unsigned int __cdecl sub_100756D0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10074D70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10074D70((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10075000((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10075700) --------------------------------------------------------
unsigned int __cdecl sub_10075700(int a1)
{
  unsigned int result; // eax@1

  result = sub_10074D70((_BYTE *)a1);
  if ( !result )
    result = sub_10075020((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10075720) --------------------------------------------------------
unsigned int __cdecl sub_10075720(int a1)
{
  unsigned int result; // eax@1

  result = sub_10074D70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10076340((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10075000((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10075760) --------------------------------------------------------
void __cdecl __noreturn sub_10075760(int a1)
{
  exit_0(a1 + 4);
}

//----- (100758D0) --------------------------------------------------------
signed int __cdecl sub_100758D0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10075430((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10075460((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10075490((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10075930) --------------------------------------------------------
signed int __usercall sub_10075930@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_100758D0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10076340((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_10075FF0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10074930(v2 + 5, a2);
    else
      result = sub_10074600(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10075530((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10075A00) --------------------------------------------------------
signed int __cdecl sub_10075A00(int a1)
{
  return sub_10075930(a1, 0);
}

//----- (10075A10) --------------------------------------------------------
int __cdecl sub_10075A10(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_100E98EA[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_100E98EA[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10075B00) --------------------------------------------------------
int __cdecl sub_10075B00(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( (a3 - a2) % 4 )
    result = -1;
  else
    result = a1 + 126230400 * ((a3 - a2) / 4);
  return result;
}

//----- (10075B40) --------------------------------------------------------
int __cdecl sub_10075B40(int *a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // eax@9
  int v4; // ecx@9
  signed int v5; // eax@9
  int i; // ecx@9
  int v7; // ecx@13

  result = a2 >> 16;
  if ( HIWORD(a2) > 0x7C5u )
  {
    if ( HIWORD(a2) > 0x84Eu
      || HIWORD(a2) == 2126 && (unsigned __int8)a2 > 2u
      || HIWORD(a2) == 2126 && (_BYTE)a2 == 2 && BYTE1(a2) > 5u )
    {
      *a1 = -23296;
    }
    else
    {
      v3 = (HIWORD(a2) - 1990) / 4;
      v4 = v3;
      v5 = 4 * v3 + 1990;
      for ( i = 1461 * v4; v5 < HIWORD(a2); ++v5 )
      {
        i += 365;
        if ( !(v5 % 4) )
          ++i;
      }
      v7 = *(_WORD *)&word_100E98EA[2 * (unsigned __int8)a2] + i;
      if ( (unsigned __int8)a2 > 2u && !(HIWORD(a2) % 4) )
        ++v7;
      result = 86400 * (v7 + BYTE1(a2));
      *a1 = result;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 0;
  }
  return result;
}

//----- (10075C30) --------------------------------------------------------
__int16 __cdecl sub_10075C30(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10075C80) --------------------------------------------------------
int __cdecl sub_10075C80(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (10075CB0) --------------------------------------------------------
__int16 __cdecl sub_10075CB0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10075C30((int)&v5, *a1);
  sub_10075A10((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10075D30) --------------------------------------------------------
char __cdecl sub_10075D30(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10070420(13, (char *)&v3 + 3);
  sub_10070420(12, a1);
  return BYTE3(v3);
}

//----- (10075D60) --------------------------------------------------------
char __cdecl sub_10075D60(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10075D30((char *)&v4);
  if ( v2 )
  {
    if ( sub_10070320(v1) == 1 )
      sub_1007A5C0((int *)&v4, v4);
    sub_10075A10(a1, v4);
  }
  return v2;
}

//----- (10075DB0) --------------------------------------------------------
bool __cdecl sub_10075DB0(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_1008E410(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_100739C0(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_10074500(v5[0], v6, a2) && !sub_10075FF0(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10075E30) --------------------------------------------------------
char __cdecl sub_10075E30(unsigned __int16 a1, char a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  unsigned __int16 v4; // ax@1
  int v6; // [sp+0h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@1

  LOBYTE(v6) = -1;
  v7 = 0;
  v3 = sub_1007A9F0(v2);
  LOBYTE(v8) = v3 != 0;
  LOBYTE(v4) = sub_1008E470(a1, v3 != 0, &v6, &v7);
  if ( (_BYTE)v4 == 1 )
  {
    v4 = sub_100739C0(v6);
    if ( (unsigned __int16)v7 < v4 )
      LOBYTE(v4) = sub_10074030(v6, v7, &a2, 0, 1, 1);
  }
  return v4;
}

//----- (10075EA0) --------------------------------------------------------
bool __cdecl sub_10075EA0(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_1007A9F0(v2) != 0;
  return sub_10075DB0(a1, a2, v3);
}

//----- (10075ED0) --------------------------------------------------------
char __cdecl sub_10075ED0(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_1008E770(a1, v4, &v6) == 1 )
  {
    v2 = sub_100739C0(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10070AD0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_10074500(v4[0], v6, &v5) && !sub_10076040((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10075FF0) --------------------------------------------------------
signed int __cdecl sub_10075FF0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10076040) --------------------------------------------------------
int __cdecl sub_10076040(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10076130) --------------------------------------------------------
unsigned int __cdecl sub_10076130(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10076180) --------------------------------------------------------
unsigned int __cdecl sub_10076180(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  int v8; // eax@9
  char v9; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((signed __int16)a1 >= a2 ? (v8 = (signed __int16)a1 < a3,
                                    LOBYTE(v8) = (signed __int16)a1 <= a3,
                                    result = (v8 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v9 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v9;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10076220) --------------------------------------------------------
unsigned int __cdecl sub_10076220(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (100762E0) --------------------------------------------------------
signed int __cdecl sub_100762E0(void *a1, size_t a2, int a3)
{
  signed int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1006FCA0(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10076340) --------------------------------------------------------
int __cdecl sub_10076340(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10076390) --------------------------------------------------------
int __cdecl sub_10076390(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10076430) --------------------------------------------------------
int __cdecl sub_10076430(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (100764E0) --------------------------------------------------------
int sub_100764E0()
{
  __int16 v1; // [sp+0h] [bp-3Ch]@1

  v1 = -32754;
  return sub_1009B450(49, (int)&v1, 500, 1);
}

//----- (10076520) --------------------------------------------------------
int __cdecl sub_10076520(__int16 a1)
{
  __int16 v2; // [sp+0h] [bp-3Ch]@1
  __int16 v3; // [sp+6h] [bp-36h]@1

  v2 = -32751;
  v3 = a1;
  return sub_1009B450(49, (int)&v2, 500, 1);
}

//----- (10076570) --------------------------------------------------------
int __cdecl sub_10076570(char a1, __int16 a2, char *a3)
{
  __int16 v4; // [sp+0h] [bp-3Ch]@1
  char v5; // [sp+8h] [bp-34h]@1
  __int16 v6; // [sp+Ah] [bp-32h]@1
  char v7; // [sp+Ch] [bp-30h]@1

  v4 = -32753;
  v7 = 0;
  v5 = a1;
  v6 = a2;
  if ( a3 && *a3 )
    strncpy(&v7, a3, 0x28u);
  return sub_1009B450(49, (int)&v4, 500, 1);
}

//----- (100765E0) --------------------------------------------------------
int __usercall sub_100765E0@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  int result; // eax@4
  int v4; // [sp+0h] [bp-20h]@1
  int v5; // [sp+4h] [bp-1Ch]@1
  int v6; // [sp+8h] [bp-18h]@1
  int v7; // [sp+Ch] [bp-14h]@1
  int v8; // [sp+10h] [bp-10h]@1
  int *v9; // [sp+14h] [bp-Ch]@1
  int v10; // [sp+18h] [bp-8h]@1
  int v11; // [sp+1Ch] [bp-4h]@1

  v6 = 0;
  v11 = a2 != 0 ? 4 : 1;
  v4 = a2;
  v7 = a1;
  v8 = 56;
  v9 = &v4;
  v10 = 500;
  v5 = a3;
  if ( sub_1009B230() == 37 )
    v10 = 0;
  if ( sub_1009B480(49, (int)&v7) )
  {
    sub_10070AD0("..\\lib\\adl\\mon_log_intf.c", 1267, 0, 0);
    result = 0;
  }
  else
  {
    result = (unsigned __int8)v6;
  }
  return result;
}

//----- (10076690) --------------------------------------------------------
char __cdecl sub_10076690(int a1, char a2, __int16 a3, void *a4)
{
  char result; // al@1
  unsigned __int16 v5; // [sp+4h] [bp-40h]@1
  __int16 v6; // [sp+8h] [bp-3Ch]@1
  int v7; // [sp+Ch] [bp-38h]@1
  char v8; // [sp+10h] [bp-34h]@1
  __int16 v9; // [sp+12h] [bp-32h]@1

  v8 = a2;
  v9 = a3;
  v6 = -32765;
  v7 = a1;
  result = sub_100765E0((int)&v6, (int)&v5, 2);
  if ( result == 1 )
    result = sub_10079150(0, v5, a4);
  return result;
}

//----- (10076700) --------------------------------------------------------
char __cdecl sub_10076700(char a1, void *a2)
{
  char result; // al@1
  unsigned __int16 v3; // [sp+4h] [bp-40h]@1
  __int16 v4; // [sp+8h] [bp-3Ch]@1
  char v5; // [sp+10h] [bp-34h]@1

  v4 = -32764;
  v5 = a1;
  result = sub_100765E0((int)&v4, (int)&v3, 2);
  if ( result == 1 )
    result = sub_10079150(0, v3, a2);
  return result;
}

//----- (10076760) --------------------------------------------------------
char __cdecl sub_10076760(char a1, __int16 a2, void *a3)
{
  char result; // al@1
  unsigned __int16 v4; // [sp+4h] [bp-40h]@1
  __int16 v5; // [sp+8h] [bp-3Ch]@1
  char v6; // [sp+10h] [bp-34h]@1
  __int16 v7; // [sp+12h] [bp-32h]@1

  v7 = a2;
  v5 = -32763;
  v6 = a1;
  result = sub_100765E0((int)&v5, (int)&v4, 2);
  if ( result == 1 )
    result = sub_10079150(0, v4, a3);
  return result;
}

//----- (100767D0) --------------------------------------------------------
char __cdecl sub_100767D0(char a1, __int16 a2, int a3, int a4)
{
  char v4; // bl@1
  __int16 v6; // [sp+8h] [bp-68h]@1
  char v7; // [sp+10h] [bp-60h]@1
  __int16 v8; // [sp+12h] [bp-5Eh]@1
  char v9; // [sp+40h] [bp-30h]@1

  v8 = a2;
  v6 = -32761;
  v7 = a1;
  v4 = sub_100765E0((int)&v6, (int)&v9, 41);
  if ( v4 == 1 )
    sub_1006FBE0(a3, &v9, a4);
  return v4;
}

//----- (10076840) --------------------------------------------------------
char __cdecl sub_10076840(char a1, int a2, int a3)
{
  char v3; // bl@1
  __int16 v5; // [sp+8h] [bp-5Ch]@1
  char v6; // [sp+10h] [bp-54h]@1
  char v7; // [sp+40h] [bp-24h]@1

  v5 = -32762;
  v6 = a1;
  v3 = sub_100765E0((int)&v5, (int)&v7, 32);
  if ( v3 == 1 )
    sub_1006FBE0(a2, &v7, a3);
  return v3;
}

//----- (100768B0) --------------------------------------------------------
char __cdecl sub_100768B0(char a1, void *a2)
{
  char result; // al@1
  unsigned __int16 v3; // [sp+4h] [bp-40h]@1
  __int16 v4; // [sp+8h] [bp-3Ch]@1
  char v5; // [sp+10h] [bp-34h]@1

  v4 = -32760;
  v5 = a1;
  result = sub_100765E0((int)&v4, (int)&v3, 2);
  if ( result == 1 )
    result = sub_10079150(0, v3, a2);
  return result;
}

//----- (10076910) --------------------------------------------------------
char __cdecl sub_10076910(char a1, __int16 a2, void *a3)
{
  char result; // al@1
  unsigned __int16 v4; // [sp+4h] [bp-40h]@1
  __int16 v5; // [sp+8h] [bp-3Ch]@1
  char v6; // [sp+10h] [bp-34h]@1
  __int16 v7; // [sp+12h] [bp-32h]@1

  v7 = a2;
  v5 = -32759;
  v6 = a1;
  result = sub_100765E0((int)&v5, (int)&v4, 2);
  if ( result == 1 )
    result = sub_10079150(0, v4, a3);
  return result;
}

//----- (10076980) --------------------------------------------------------
char __cdecl sub_10076980(char a1, _WORD *a2)
{
  __int16 v2; // dx@1
  char result; // al@1
  unsigned __int16 v4; // [sp+4h] [bp-40h]@1
  __int16 v5; // [sp+8h] [bp-3Ch]@1
  __int16 v6; // [sp+Ch] [bp-38h]@1
  __int16 v7; // [sp+Eh] [bp-36h]@1
  char v8; // [sp+10h] [bp-34h]@1

  v2 = a2[7];
  v6 = a2[6];
  v7 = v2;
  v5 = -32758;
  v8 = a1;
  result = sub_100765E0((int)&v5, (int)&v4, 2);
  if ( result == 1 )
    result = sub_10079150(0, v4, a2);
  return result;
}

//----- (100769F0) --------------------------------------------------------
char __cdecl sub_100769F0(char a1, __int16 a2, _WORD *a3)
{
  __int16 v3; // cx@1
  __int16 v4; // dx@1
  char result; // al@1
  unsigned __int16 v6; // [sp+4h] [bp-40h]@1
  __int16 v7; // [sp+8h] [bp-3Ch]@1
  __int16 v8; // [sp+Ch] [bp-38h]@1
  __int16 v9; // [sp+Eh] [bp-36h]@1
  char v10; // [sp+10h] [bp-34h]@1
  __int16 v11; // [sp+12h] [bp-32h]@1

  v3 = a3[6];
  v4 = a3[7];
  v10 = a1;
  v8 = v3;
  v9 = v4;
  v7 = -32757;
  v11 = a2;
  result = sub_100765E0((int)&v7, (int)&v6, 2);
  if ( result == 1 )
    result = sub_10079150(0, v6, a3);
  return result;
}

//----- (10076A70) --------------------------------------------------------
char __cdecl sub_10076A70(char a1, _WORD *a2)
{
  __int16 v2; // dx@1
  char result; // al@1
  unsigned __int16 v4; // [sp+4h] [bp-40h]@1
  __int16 v5; // [sp+8h] [bp-3Ch]@1
  __int16 v6; // [sp+Ch] [bp-38h]@1
  __int16 v7; // [sp+Eh] [bp-36h]@1
  char v8; // [sp+10h] [bp-34h]@1

  v2 = a2[7];
  v6 = a2[6];
  v7 = v2;
  v5 = -32756;
  v8 = a1;
  result = sub_100765E0((int)&v5, (int)&v4, 2);
  if ( result == 1 )
    result = sub_10079150(0, v4, a2);
  return result;
}

//----- (10076AE0) --------------------------------------------------------
char __cdecl sub_10076AE0(char a1, __int16 a2, _WORD *a3)
{
  __int16 v3; // cx@1
  __int16 v4; // dx@1
  char result; // al@1
  unsigned __int16 v6; // [sp+4h] [bp-40h]@1
  __int16 v7; // [sp+8h] [bp-3Ch]@1
  __int16 v8; // [sp+Ch] [bp-38h]@1
  __int16 v9; // [sp+Eh] [bp-36h]@1
  char v10; // [sp+10h] [bp-34h]@1
  __int16 v11; // [sp+12h] [bp-32h]@1

  v3 = a3[6];
  v4 = a3[7];
  v10 = a1;
  v8 = v3;
  v9 = v4;
  v7 = -32755;
  v11 = a2;
  result = sub_100765E0((int)&v7, (int)&v6, 2);
  if ( result == 1 )
    result = sub_10079150(0, v6, a3);
  return result;
}

//----- (10076B60) --------------------------------------------------------
__int16 __cdecl sub_10076B60(char a1)
{
  int v2; // [sp+0h] [bp-40h]@1
  __int16 v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+Ch] [bp-34h]@1

  v2 = 0xFFFF;
  v3 = -32748;
  v4 = a1;
  sub_100765E0((int)&v3, (int)&v2, 2);
  return v2;
}

//----- (10076BB0) --------------------------------------------------------
char __cdecl sub_10076BB0(int a1, int a2)
{
  char v2; // bl@1

  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_id_is_set(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74BE: using guessed type int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD);

//----- (10076C30) --------------------------------------------------------
char __thiscall sub_10076C30(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_105910B8 = sub_100704E0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_105910C0, 0, 0x1540u);
  memset(&unk_10592600, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_105910C0;
  do
  {
    sub_1008E680(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_10592600 );
  v3 = 0;
  v4 = &unk_10592600;
  do
  {
    result = sub_1008E700(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&unk_10593FB0 );
  return result;
}
// 105910B8: using guessed type int dword_105910B8;

//----- (10076CC0) --------------------------------------------------------
char __cdecl sub_10076CC0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_105910B8 != 1379255385;
  v7 = 0;
  v8 = dword_105910B8 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1009B5D0(86, 10);
      memset((char *)&unk_105910C0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_1008E680(a1, (int)&unk_105910C0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_10591398[v6] == a2 || byte_10591399[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1009B5A0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 105910B8: using guessed type int dword_105910B8;

//----- (10076D80) --------------------------------------------------------
char __cdecl sub_10076D80(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_10076F10(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (10076DD0) --------------------------------------------------------
char __cdecl sub_10076DD0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10076CC0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10076E00) --------------------------------------------------------
char __cdecl sub_10076E00(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10076D80(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (10076E40) --------------------------------------------------------
bool __cdecl sub_10076E40(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_105C0388 != 1379255385 )
    {
      sub_1008E660(a1, (int)&byte_105C0390[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_105C0395[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_105C0394[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 105C0388: using guessed type int dword_105C0388;

//----- (10076EB0) --------------------------------------------------------
bool __cdecl sub_10076EB0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_105C0388 != 1379255385 )
      sub_1008E660(a1, (int)&byte_105C0390[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_105C03A4[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 105C0388: using guessed type int dword_105C0388;
// 105C03A4: using guessed type int dword_105C03A4[];

//----- (10076F10) --------------------------------------------------------
bool __cdecl sub_10076F10(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_105C0388 != 1379255385 )
    {
      sub_1008E660(a1, (int)&byte_105C0390[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_105C039C[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 105C0388: using guessed type int dword_105C0388;
// 105C039C: using guessed type int dword_105C039C[];

//----- (10076F80) --------------------------------------------------------
char __cdecl sub_10076F80(char a1, _BYTE *a2)
{
  if ( dword_105C0388 != 1379255385 )
    sub_1008E660(a1, (int)&byte_105C0390[24 * (unsigned __int8)a1]);
  *a2 = byte_105C0390[24 * (unsigned __int8)a1];
  return 1;
}
// 105C0388: using guessed type int dword_105C0388;

//----- (10076FC0) --------------------------------------------------------
char __thiscall sub_10076FC0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_105C0388 = sub_100704E0(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_105C0390, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_105C0390;
  do
  {
    result = sub_1008E660(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 105C0388: using guessed type int dword_105C0388;

//----- (10077030) --------------------------------------------------------
char __cdecl sub_10077030(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10071250(a1);
  v3 = sub_1009C580(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10077060) --------------------------------------------------------
char __cdecl sub_10077060(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10071250(a1);
  v3 = sub_1009C5F0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10077090) --------------------------------------------------------
char __cdecl sub_10077090(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10071340(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10076F10(v7, *a4, (int)a5);
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10076E40(v7, *a4, (int)a5);
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_10076EB0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10076F80(v7, a5);
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10077060(v7, (int)a5);
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10077030(v7, (int)a5);
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10070AD0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10077260) --------------------------------------------------------
int __cdecl sub_10077260(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (100772A0) --------------------------------------------------------
void *__usercall sub_100772A0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_1009B830(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_1009B980(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (100772F0) --------------------------------------------------------
signed int sub_100772F0()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_1068B5C0 = 0;
  v4 = 0;
  sub_1009C2B0(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_1009B900(3201, (int)&v4, 1);
    sub_1009C2E0(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_1009B900(3201, (int)&v4, 1);
    sub_1009C2E0(94, (int)&v4);
  }
  sub_100772A0(1u, 6011, &unk_105C03D8);
  sub_100772A0(0x16u, 6194, &unk_105C03D9);
  sub_100772A0(1u, 6012, &unk_105C03EF);
  sub_100772A0(1u, 6013, &unk_105C03F0);
  sub_100772A0(1u, 6014, &unk_105C03F1);
  sub_100772A0(1u, 6015, &unk_105C03F2);
  sub_100772A0(4u, 6078, &unk_105C03F4);
  sub_100772A0(4u, 6104, &unk_105C03F8);
  sub_100772A0(0x20u, 6016, &unk_105C03FC);
  sub_100772A0(0x20u, 6017, &unk_105C041C);
  sub_100772A0(0x20u, 6018, &unk_105C043C);
  sub_100772A0(0x20u, 6019, &unk_105C045C);
  sub_100772A0(0x20u, 6020, &unk_105C047C);
  sub_100772A0(0x20u, 6021, &unk_105C049C);
  sub_100772A0(0x20u, 6022, &unk_105C04BC);
  sub_100772A0(0x20u, 6023, &unk_105C04DC);
  sub_100772A0(0x20u, 6024, &unk_105C04FC);
  sub_100772A0(0x20u, 6025, &unk_105C051C);
  sub_100772A0(0x20u, 6026, &unk_105C053C);
  sub_100772A0(0x20u, 6027, &unk_105C055C);
  sub_100772A0(0x20u, 6028, &unk_105C057C);
  sub_100772A0(0x20u, 6029, &unk_105C059C);
  sub_100772A0(0x20u, 6030, &unk_105C05BC);
  sub_100772A0(0x20u, 6031, &unk_105C05DC);
  sub_100772A0(0x20u, 6032, &unk_105C05FC);
  sub_100772A0(0x20u, 6033, &unk_105C061C);
  sub_100772A0(0x20u, 6034, &unk_105C063C);
  sub_100772A0(0x20u, 6035, &unk_105C065C);
  sub_100772A0(0x20u, 6036, &unk_105C067C);
  sub_100772A0(0x20u, 6037, &unk_105C069C);
  sub_100772A0(0x20u, 6038, &unk_105C06BC);
  sub_100772A0(0x20u, 6039, &unk_105C06DC);
  sub_100772A0(0x20u, 6040, &unk_105C06FC);
  sub_100772A0(0x20u, 6041, &unk_105C071C);
  sub_100772A0(0x20u, 6042, &unk_105C073C);
  sub_100772A0(0x20u, 6043, &unk_105C075C);
  sub_100772A0(4u, 6044, &unk_105C077C);
  sub_100772A0(4u, 6045, &unk_105C0780);
  sub_100772A0(4u, 6046, &unk_105C0784);
  sub_100772A0(4u, 6357, &unk_105C0788);
  sub_100772A0(4u, 6358, &unk_105C078C);
  sub_100772A0(4u, 6359, &unk_105C0790);
  sub_100772A0(0x20u, 6047, &unk_105C0794);
  sub_100772A0(0x20u, 6048, &unk_105C07B4);
  sub_100772A0(0x20u, 6049, &unk_105C07D4);
  sub_100772A0(0x20u, 6050, &unk_105C07F4);
  sub_100772A0(0x20u, 6051, &unk_105C0814);
  sub_100772A0(0x20u, 6052, &unk_105C0834);
  sub_100772A0(0x20u, 6053, &unk_105C0854);
  sub_100772A0(0x20u, 6054, &unk_105C0874);
  sub_100772A0(1u, 6511, &unk_105C0894);
  sub_100772A0(1u, 6522, &unk_105C0895);
  sub_100772A0(1u, 6057, &unk_105C0896);
  sub_100772A0(0x20u, 6075, &unk_105C08E8);
  sub_100772A0(0x20u, 6076, &unk_105C0908);
  sub_100772A0(1u, 6077, &unk_105C0928);
  sub_100772A0(4u, 6079, &unk_105C092C);
  sub_100772A0(4u, 6080, &unk_105C0930);
  sub_100772A0(0x20u, 6082, &unk_105C0934);
  sub_100772A0(0x20u, 6083, &unk_105C0954);
  sub_100772A0(0x20u, 6084, &unk_105C0974);
  sub_100772A0(0x20u, 6085, &unk_105C0994);
  sub_100772A0(0x20u, 6086, &unk_105C09B4);
  sub_100772A0(0x20u, 6087, &unk_105C09D4);
  sub_100772A0(0x20u, 6088, &unk_105C09F4);
  sub_100772A0(0x20u, 6089, &unk_105C0A14);
  sub_100772A0(0x20u, 6123, &unk_105C0A34);
  sub_100772A0(0x48u, 6906, &unk_105C0A54);
  sub_100772A0(0x48u, 6907, &unk_105C0A9C);
  sub_100772A0(0x48u, 6908, &unk_105C0AE4);
  sub_100772A0(0x48u, 6909, &unk_105C0B2C);
  sub_100772A0(0x48u, 6910, &unk_105C0B74);
  sub_100772A0(0x48u, 6911, &unk_105C0BBC);
  sub_100772A0(0x48u, 6912, &unk_105C0C04);
  sub_100772A0(0x48u, 6913, &unk_105C0C4C);
  sub_100772A0(0x48u, 6914, &unk_105C0C94);
  sub_100772A0(0x48u, 6915, &unk_105C0CDC);
  sub_100772A0(0x48u, 6916, &unk_105C0D24);
  sub_100772A0(0x48u, 6917, &unk_105C0D6C);
  sub_100772A0(0x48u, 6918, &unk_105C0DB4);
  sub_100772A0(0x48u, 6919, &unk_105C0DFC);
  sub_100772A0(0x48u, 6920, &unk_105C0E44);
  sub_100772A0(0x48u, 6921, &unk_105C0E8C);
  sub_100772A0(0x48u, 6922, &unk_105C0ED4);
  sub_100772A0(0x48u, 6923, &unk_105C0F1C);
  sub_100772A0(0x48u, 6924, &unk_105C0F64);
  sub_100772A0(0x48u, 6925, &unk_105C0FAC);
  sub_100772A0(0x48u, 6926, &unk_105C0FF4);
  sub_100772A0(0x48u, 6927, &unk_105C103C);
  sub_100772A0(0x48u, 6928, &unk_105C1084);
  sub_100772A0(0x48u, 6929, &unk_105C10CC);
  sub_100772A0(0x48u, 6930, &unk_105C1114);
  sub_100772A0(0x48u, 6931, &unk_105C115C);
  sub_100772A0(0x48u, 6932, &unk_105C11A4);
  sub_100772A0(0x48u, 6933, &unk_105C11EC);
  sub_100772A0(0x48u, 6934, &unk_105C1234);
  sub_100772A0(0x48u, 6935, &unk_105C127C);
  sub_100772A0(0x18u, 6163, &unk_105C12C4);
  sub_100772A0(0x20u, 6164, &unk_105C12DC);
  sub_100772A0(0x20u, 6165, &unk_105C12FC);
  sub_100772A0(2u, 6166, &unk_105C131C);
  sub_100772A0(0xA4u, 40100, &unk_105C1320);
  sub_100772A0(0xA4u, 40101, &unk_105C13C4);
  sub_100772A0(0xA4u, 40102, &unk_105C1468);
  sub_100772A0(0xA4u, 40103, &unk_105C150C);
  sub_100772A0(0xA4u, 40104, &unk_105C15B0);
  sub_100772A0(0xA4u, 40105, &unk_105C1654);
  sub_100772A0(0xA4u, 40106, &unk_105C16F8);
  sub_100772A0(0xA4u, 40107, &unk_105C179C);
  sub_100772A0(0xA4u, 40108, &unk_105C1840);
  sub_100772A0(0xA4u, 40109, &unk_105C18E4);
  sub_100772A0(0xA4u, 40110, &unk_105C1988);
  sub_100772A0(0xA4u, 40111, &unk_105C1A2C);
  sub_100772A0(0xA4u, 40112, &unk_105C1AD0);
  sub_100772A0(0xA4u, 40113, &unk_105C1B74);
  sub_100772A0(0xA4u, 40114, &unk_105C1C18);
  sub_100772A0(0xA4u, 40115, &unk_105C1CBC);
  sub_100772A0(0xA4u, 40116, &unk_105C1D60);
  sub_100772A0(0xA4u, 40117, &unk_105C1E04);
  sub_100772A0(0xA4u, 40118, &unk_105C1EA8);
  sub_100772A0(0xA4u, 40119, &unk_105C1F4C);
  sub_100772A0(0xA4u, 40120, &unk_105C1FF0);
  sub_100772A0(0xA4u, 40121, &unk_105C2094);
  sub_100772A0(0xA4u, 40122, &unk_105C2138);
  sub_100772A0(0xA4u, 40123, &unk_105C21DC);
  sub_100772A0(0xA4u, 40124, &unk_105C2280);
  sub_100772A0(0xA4u, 40125, &unk_105C2324);
  sub_100772A0(0xA4u, 40126, &unk_105C23C8);
  sub_100772A0(0xA4u, 40127, &unk_105C246C);
  sub_100772A0(0xA4u, 40128, &unk_105C2510);
  sub_100772A0(0xA4u, 40129, &unk_105C25B4);
  sub_100772A0(0xA4u, 40130, &unk_105C2658);
  sub_100772A0(0xA4u, 40131, &unk_105C26FC);
  sub_100772A0(0xA4u, 40132, &unk_105C27A0);
  sub_100772A0(0xA4u, 40133, &unk_105C2844);
  sub_100772A0(0xA4u, 40134, &unk_105C28E8);
  sub_100772A0(0xA4u, 40135, &unk_105C298C);
  sub_100772A0(0xA4u, 40136, &unk_105C2A30);
  sub_100772A0(0xA4u, 40137, &unk_105C2AD4);
  sub_100772A0(0xA4u, 40138, &unk_105C2B78);
  sub_100772A0(0xA4u, 40139, &unk_105C2C1C);
  sub_100772A0(0xA4u, 40140, &unk_105C2CC0);
  sub_100772A0(0xA4u, 40141, &unk_105C2D64);
  sub_100772A0(0xA4u, 40142, &unk_105C2E08);
  sub_100772A0(0xA4u, 40143, &unk_105C2EAC);
  sub_100772A0(0xA4u, 40144, &unk_105C2F50);
  sub_100772A0(0xA4u, 40145, &unk_105C2FF4);
  sub_100772A0(0xA4u, 40146, &unk_105C3098);
  sub_100772A0(0xA4u, 40147, &unk_105C313C);
  sub_100772A0(0xA4u, 40148, &unk_105C31E0);
  sub_100772A0(0xA4u, 40149, &unk_105C3284);
  sub_100772A0(0xA4u, 40150, &unk_105C3328);
  sub_100772A0(0xA4u, 40151, &unk_105C33CC);
  sub_100772A0(0xA4u, 40152, &unk_105C3470);
  sub_100772A0(0xA4u, 40153, &unk_105C3514);
  sub_100772A0(0xA4u, 40154, &unk_105C35B8);
  sub_100772A0(0xA4u, 40155, &unk_105C365C);
  sub_100772A0(0xA4u, 40156, &unk_105C3700);
  sub_100772A0(0xA4u, 40157, &unk_105C37A4);
  sub_100772A0(0xA4u, 40158, &unk_105C3848);
  sub_100772A0(0xA4u, 40159, &unk_105C38EC);
  sub_100772A0(0xA4u, 40160, &unk_105C3990);
  sub_100772A0(0xA4u, 40161, &unk_105C3A34);
  sub_100772A0(0xA4u, 40162, &unk_105C3AD8);
  sub_100772A0(0xA4u, 40163, &unk_105C3B7C);
  sub_100772A0(0xA4u, 40164, &unk_105C3C20);
  sub_100772A0(0xA4u, 40165, &unk_105C3CC4);
  sub_100772A0(0xA4u, 40166, &unk_105C3D68);
  sub_100772A0(0xA4u, 40167, &unk_105C3E0C);
  sub_100772A0(0xA4u, 40168, &unk_105C3EB0);
  sub_100772A0(0xA4u, 40169, &unk_105C3F54);
  sub_100772A0(0xA4u, 40170, &unk_105C3FF8);
  sub_100772A0(0xA4u, 40171, &unk_105C409C);
  sub_100772A0(0xA4u, 40172, &unk_105C4140);
  sub_100772A0(0xA4u, 40173, &unk_105C41E4);
  sub_100772A0(0xA4u, 40174, &unk_105C4288);
  sub_100772A0(0xA4u, 40175, &unk_105C432C);
  sub_100772A0(0xA4u, 40176, &unk_105C43D0);
  sub_100772A0(0xA4u, 40177, &unk_105C4474);
  sub_100772A0(0xA4u, 40178, &unk_105C4518);
  sub_100772A0(0xA4u, 40179, &unk_105C45BC);
  sub_100772A0(0xA4u, 40180, &unk_105C4660);
  sub_100772A0(0xA4u, 40181, &unk_105C4704);
  sub_100772A0(0xA4u, 40182, &unk_105C47A8);
  sub_100772A0(0xA4u, 40183, &unk_105C484C);
  sub_100772A0(0xA4u, 40184, &unk_105C48F0);
  sub_100772A0(0xA4u, 40185, &unk_105C4994);
  sub_100772A0(0xA4u, 40186, &unk_105C4A38);
  sub_100772A0(0xA4u, 40187, &unk_105C4ADC);
  sub_100772A0(0xA4u, 40188, &unk_105C4B80);
  sub_100772A0(0xA4u, 40189, &unk_105C4C24);
  sub_100772A0(0xA4u, 40190, &unk_105C4CC8);
  sub_100772A0(0xA4u, 40191, &unk_105C4D6C);
  sub_100772A0(0xA4u, 40192, &unk_105C4E10);
  sub_100772A0(0xA4u, 40193, &unk_105C4EB4);
  sub_100772A0(0xA4u, 40194, &unk_105C4F58);
  sub_100772A0(0xA4u, 40195, &unk_105C4FFC);
  sub_100772A0(0xA4u, 40196, &unk_105C50A0);
  sub_100772A0(0xA4u, 40197, &unk_105C5144);
  sub_100772A0(0xA4u, 40198, &unk_105C51E8);
  sub_100772A0(0xA4u, 40199, &unk_105C528C);
  sub_100772A0(0x20u, 6190, &unk_105C5330);
  sub_100772A0(0x20u, 6191, &unk_105C5350);
  sub_100772A0(0x20u, 6192, &unk_105C5370);
  sub_100772A0(0x20u, 6199, &unk_105C5390);
  sub_100772A0(0x28u, 6207, &unk_105C53B0);
  sub_100772A0(4u, 6231, &unk_105C5EC8);
  sub_100772A0(4u, 6232, &unk_105C5ECC);
  sub_100772A0(4u, 6233, &unk_105C5ED0);
  sub_100772A0(4u, 6234, &unk_105C5ED4);
  sub_100772A0(0x1Cu, 40000, &unk_105C53D8);
  sub_100772A0(0x1Cu, 40001, &unk_105C53F4);
  sub_100772A0(0x1Cu, 40002, &unk_105C5410);
  sub_100772A0(0x1Cu, 40003, &unk_105C542C);
  sub_100772A0(0x1Cu, 40004, &unk_105C5448);
  sub_100772A0(0x1Cu, 40005, &unk_105C5464);
  sub_100772A0(0x1Cu, 40006, &unk_105C5480);
  sub_100772A0(0x1Cu, 40007, &unk_105C549C);
  sub_100772A0(0x1Cu, 40008, &unk_105C54B8);
  sub_100772A0(0x1Cu, 40009, &unk_105C54D4);
  sub_100772A0(0x1Cu, 40010, &unk_105C54F0);
  sub_100772A0(0x1Cu, 40011, &unk_105C550C);
  sub_100772A0(0x1Cu, 40012, &unk_105C5528);
  sub_100772A0(0x1Cu, 40013, &unk_105C5544);
  sub_100772A0(0x1Cu, 40014, &unk_105C5560);
  sub_100772A0(0x1Cu, 40015, &unk_105C557C);
  sub_100772A0(0x1Cu, 40016, &unk_105C5598);
  sub_100772A0(0x1Cu, 40017, &unk_105C55B4);
  sub_100772A0(0x1Cu, 40018, &unk_105C55D0);
  sub_100772A0(0x1Cu, 40019, &unk_105C55EC);
  sub_100772A0(0x1Cu, 40020, &unk_105C5608);
  sub_100772A0(0x1Cu, 40021, &unk_105C5624);
  sub_100772A0(0x1Cu, 40022, &unk_105C5640);
  sub_100772A0(0x1Cu, 40023, &unk_105C565C);
  sub_100772A0(0x1Cu, 40024, &unk_105C5678);
  sub_100772A0(0x1Cu, 40025, &unk_105C5694);
  sub_100772A0(0x1Cu, 40026, &unk_105C56B0);
  sub_100772A0(0x1Cu, 40027, &unk_105C56CC);
  sub_100772A0(0x1Cu, 40028, &unk_105C56E8);
  sub_100772A0(0x1Cu, 40029, &unk_105C5704);
  sub_100772A0(0x1Cu, 40030, &unk_105C5720);
  sub_100772A0(0x1Cu, 40031, &unk_105C573C);
  sub_100772A0(0x1Cu, 40032, &unk_105C5758);
  sub_100772A0(0x1Cu, 40033, &unk_105C5774);
  sub_100772A0(0x1Cu, 40034, &unk_105C5790);
  sub_100772A0(0x1Cu, 40035, &unk_105C57AC);
  sub_100772A0(0x1Cu, 40036, &unk_105C57C8);
  sub_100772A0(0x1Cu, 40037, &unk_105C57E4);
  sub_100772A0(0x1Cu, 40038, &unk_105C5800);
  sub_100772A0(0x1Cu, 40039, &unk_105C581C);
  sub_100772A0(0x1Cu, 40040, &unk_105C5838);
  sub_100772A0(0x1Cu, 40041, &unk_105C5854);
  sub_100772A0(0x1Cu, 40042, &unk_105C5870);
  sub_100772A0(0x1Cu, 40043, &unk_105C588C);
  sub_100772A0(0x1Cu, 40044, &unk_105C58A8);
  sub_100772A0(0x1Cu, 40045, &unk_105C58C4);
  sub_100772A0(0x1Cu, 40046, &unk_105C58E0);
  sub_100772A0(0x1Cu, 40047, &unk_105C58FC);
  sub_100772A0(0x1Cu, 40048, &unk_105C5918);
  sub_100772A0(0x1Cu, 40049, &unk_105C5934);
  sub_100772A0(0x1Cu, 40050, &unk_105C5950);
  sub_100772A0(0x1Cu, 40051, &unk_105C596C);
  sub_100772A0(0x1Cu, 40052, &unk_105C5988);
  sub_100772A0(0x1Cu, 40053, &unk_105C59A4);
  sub_100772A0(0x1Cu, 40054, &unk_105C59C0);
  sub_100772A0(0x1Cu, 40055, &unk_105C59DC);
  sub_100772A0(0x1Cu, 40056, &unk_105C59F8);
  sub_100772A0(0x1Cu, 40057, &unk_105C5A14);
  sub_100772A0(0x1Cu, 40058, &unk_105C5A30);
  sub_100772A0(0x1Cu, 40059, &unk_105C5A4C);
  sub_100772A0(0x1Cu, 40060, &unk_105C5A68);
  sub_100772A0(0x1Cu, 40061, &unk_105C5A84);
  sub_100772A0(0x1Cu, 40062, &unk_105C5AA0);
  sub_100772A0(0x1Cu, 40063, &unk_105C5ABC);
  sub_100772A0(0x1Cu, 40064, &unk_105C5AD8);
  sub_100772A0(0x1Cu, 40065, &unk_105C5AF4);
  sub_100772A0(0x1Cu, 40066, &unk_105C5B10);
  sub_100772A0(0x1Cu, 40067, &unk_105C5B2C);
  sub_100772A0(0x1Cu, 40068, &unk_105C5B48);
  sub_100772A0(0x1Cu, 40069, &unk_105C5B64);
  sub_100772A0(0x1Cu, 40070, &unk_105C5B80);
  sub_100772A0(0x1Cu, 40071, &unk_105C5B9C);
  sub_100772A0(0x1Cu, 40072, &unk_105C5BB8);
  sub_100772A0(0x1Cu, 40073, &unk_105C5BD4);
  sub_100772A0(0x1Cu, 40074, &unk_105C5BF0);
  sub_100772A0(0x1Cu, 40075, &unk_105C5C0C);
  sub_100772A0(0x1Cu, 40076, &unk_105C5C28);
  sub_100772A0(0x1Cu, 40077, &unk_105C5C44);
  sub_100772A0(0x1Cu, 40078, &unk_105C5C60);
  sub_100772A0(0x1Cu, 40079, &unk_105C5C7C);
  sub_100772A0(0x1Cu, 40080, &unk_105C5C98);
  sub_100772A0(0x1Cu, 40081, &unk_105C5CB4);
  sub_100772A0(0x1Cu, 40082, &unk_105C5CD0);
  sub_100772A0(0x1Cu, 40083, &unk_105C5CEC);
  sub_100772A0(0x1Cu, 40084, &unk_105C5D08);
  sub_100772A0(0x1Cu, 40085, &unk_105C5D24);
  sub_100772A0(0x1Cu, 40086, &unk_105C5D40);
  sub_100772A0(0x1Cu, 40087, &unk_105C5D5C);
  sub_100772A0(0x1Cu, 40088, &unk_105C5D78);
  sub_100772A0(0x1Cu, 40089, &unk_105C5D94);
  sub_100772A0(0x1Cu, 40090, &unk_105C5DB0);
  sub_100772A0(0x1Cu, 40091, &unk_105C5DCC);
  sub_100772A0(0x1Cu, 40092, &unk_105C5DE8);
  sub_100772A0(0x1Cu, 40093, &unk_105C5E04);
  sub_100772A0(0x1Cu, 40094, &unk_105C5E20);
  sub_100772A0(0x1Cu, 40095, &unk_105C5E3C);
  sub_100772A0(0x1Cu, 40096, &unk_105C5E58);
  sub_100772A0(0x1Cu, 40097, &unk_105C5E74);
  sub_100772A0(0x1Cu, 40098, &unk_105C5E90);
  sub_100772A0(0x1Cu, 40099, &unk_105C5EAC);
  sub_100772A0(4u, 6238, &unk_105C5ED8);
  sub_100772A0(4u, 6239, &unk_105C5EDC);
  sub_100772A0(4u, 6240, &unk_105C5EE0);
  sub_100772A0(4u, 6242, &unk_105C5EE4);
  sub_100772A0(4u, 6244, &unk_105C5EE8);
  sub_100772A0(4u, 6245, &unk_105C5EEC);
  sub_100772A0(4u, 6246, &unk_105C5EF0);
  sub_100772A0(4u, 6251, &unk_105C5EF4);
  sub_100772A0(4u, 6252, &unk_105C5EF8);
  sub_100772A0(4u, 6253, &unk_105C5EFC);
  sub_100772A0(4u, 6254, &unk_105C5F00);
  sub_100772A0(1u, 6255, &unk_105C5F04);
  sub_100772A0(4u, 6256, &unk_105C5F08);
  sub_100772A0(4u, 6257, &unk_105C5F0C);
  sub_100772A0(0xE2u, 6286, &unk_105C5F10);
  v0 = 18000;
  v1 = &unk_105C5FF4;
  v2 = 16;
  do
  {
    sub_100772A0(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_100772A0(4u, 6262, &unk_105C71B4);
  sub_100772A0(0x28u, 6263, &unk_105C71B8);
  sub_100772A0(0x28u, 6264, &unk_105C71E0);
  sub_100772A0(0x40u, 6268, &unk_105C7208);
  sub_100772A0(4u, 6272, &unk_105C72C8);
  sub_100772A0(4u, 6273, &unk_105C72CC);
  sub_100772A0(1u, 6274, &unk_105C72D0);
  sub_100772A0(2u, 6275, &unk_105C72D2);
  sub_100772A0(1u, 6276, &unk_105C72D4);
  sub_100772A0(1u, 6277, &unk_105C72D5);
  sub_100772A0(1u, 6278, &unk_105C72D6);
  sub_100772A0(0x40u, 6279, &unk_105C72D8);
  sub_100772A0(0x28u, 6753, &unk_105C818D);
  sub_100772A0(0x30u, 6754, &unk_105C81B8);
  sub_100772A0(0x28u, 6958, &unk_105C81E8);
  sub_100772A0(0x80u, 6802, &unk_105C7248);
  sub_100772A0(1u, 6760, &unk_105C8210);
  sub_100772A0(0x10u, 6312, &unk_105C765C);
  sub_100772A0(0x10u, 6313, &unk_105C766C);
  sub_100772A0(0x10u, 6314, &unk_105C767C);
  sub_100772A0(1u, 6307, &unk_105C768C);
  sub_100772A0(1u, 6308, &unk_105C768D);
  sub_100772A0(1u, 6309, &unk_105C768E);
  sub_100772A0(4u, 6285, &unk_105C7690);
  sub_100772A0(0xA8u, 6318, &unk_105C7694);
  sub_100772A0(4u, 6319, &unk_105C773C);
  sub_100772A0(1u, 6350, &unk_105C7740);
  sub_100772A0(0x50u, 6351, &unk_105C7744);
  sub_100772A0(4u, 6352, &unk_105C7794);
  sub_100772A0(4u, 6353, &unk_105C7798);
  sub_100772A0(0x54u, 6448, &unk_105C79E4);
  sub_100772A0(0x54u, 6449, &unk_105C7A38);
  sub_100772A0(8u, 6287, &unk_105C733C);
  sub_100772A0(8u, 6288, &unk_105C7344);
  sub_100772A0(8u, 6289, &unk_105C734C);
  sub_100772A0(8u, 6290, &unk_105C7354);
  sub_100772A0(8u, 6291, &unk_105C735C);
  sub_100772A0(8u, 6292, &unk_105C7364);
  sub_100772A0(8u, 6293, &unk_105C736C);
  sub_100772A0(8u, 6294, &unk_105C7374);
  sub_100772A0(8u, 6295, &unk_105C737C);
  sub_100772A0(8u, 6296, &unk_105C7384);
  sub_100772A0(8u, 6297, &unk_105C738C);
  sub_100772A0(8u, 6298, &unk_105C7394);
  sub_100772A0(8u, 6299, &unk_105C739C);
  sub_100772A0(8u, 6300, &unk_105C73A4);
  sub_100772A0(8u, 6301, &unk_105C73AC);
  sub_100772A0(8u, 6302, &unk_105C73B4);
  sub_100772A0(8u, 6303, &unk_105C73BC);
  sub_100772A0(8u, 6304, &unk_105C73C4);
  sub_100772A0(8u, 6305, &unk_105C73CC);
  sub_100772A0(8u, 6306, &unk_105C73D4);
  sub_100772A0(8u, 6409, &unk_105C73DC);
  sub_100772A0(8u, 6410, &unk_105C73E4);
  sub_100772A0(8u, 6411, &unk_105C73EC);
  sub_100772A0(8u, 6412, &unk_105C73F4);
  sub_100772A0(8u, 6413, &unk_105C73FC);
  sub_100772A0(8u, 6414, &unk_105C7404);
  sub_100772A0(8u, 6415, &unk_105C740C);
  sub_100772A0(8u, 6416, &unk_105C7414);
  sub_100772A0(8u, 6417, &unk_105C741C);
  sub_100772A0(8u, 6418, &unk_105C7424);
  sub_100772A0(8u, 6419, &unk_105C742C);
  sub_100772A0(8u, 6420, &unk_105C7434);
  sub_100772A0(8u, 6421, &unk_105C743C);
  sub_100772A0(8u, 6422, &unk_105C7444);
  sub_100772A0(8u, 6423, &unk_105C744C);
  sub_100772A0(8u, 6424, &unk_105C7454);
  sub_100772A0(8u, 6425, &unk_105C745C);
  sub_100772A0(8u, 6426, &unk_105C7464);
  sub_100772A0(8u, 6427, &unk_105C746C);
  sub_100772A0(8u, 6428, &unk_105C7474);
  sub_100772A0(4u, 6429, &unk_105C797C);
  sub_100772A0(8u, 6430, &unk_105C7980);
  sub_100772A0(8u, 6431, &unk_105C7988);
  sub_100772A0(8u, 6432, &unk_105C7990);
  sub_100772A0(8u, 6433, &unk_105C7998);
  sub_100772A0(8u, 6434, &unk_105C79A0);
  sub_100772A0(8u, 6435, &unk_105C79A8);
  sub_100772A0(8u, 6436, &unk_105C79B0);
  sub_100772A0(8u, 6437, &unk_105C79B8);
  sub_100772A0(8u, 6438, &unk_105C79C0);
  sub_100772A0(8u, 6439, &unk_105C79C8);
  sub_100772A0(8u, 6440, &unk_105C79D0);
  sub_100772A0(0xAu, 6519, &unk_105C7E3C);
  sub_100772A0(4u, 6442, &unk_105C79D8);
  sub_100772A0(4u, 6443, &unk_105C79DC);
  sub_100772A0(0xF0u, 6367, &unk_105C779C);
  sub_100772A0(0xF0u, 6368, &unk_105C788C);
  sub_100772A0(1u, 6446, &unk_105C79E0);
  sub_100772A0(6u, 6452, &unk_105C7A8C);
  sub_100772A0(4u, 6457, &unk_105C7A94);
  sub_100772A0(4u, 6458, &unk_105C7A98);
  sub_100772A0(4u, 6459, &unk_105C7A9C);
  sub_100772A0(4u, 6460, &unk_105C7AA0);
  sub_100772A0(0x208u, 6515, &unk_105C7AA4);
  sub_100772A0(0x160u, 6516, &unk_105C7CAC);
  sub_100772A0(0x18u, 6517, &unk_105C7E0C);
  sub_100772A0(0x18u, 6518, &unk_105C7E24);
  sub_100772A0(1u, 6520, &unk_105C7E46);
  sub_100772A0(0x10u, 6521, &unk_105C7E48);
  sub_100772A0(4u, 6523, &unk_105C7E58);
  sub_100772A0(4u, 6524, &unk_105C7E5C);
  sub_100772A0(4u, 6525, &unk_105C7E60);
  sub_100772A0(1u, 6526, &unk_105C7E64);
  sub_100772A0(1u, 6527, &unk_105C7E65);
  sub_100772A0(0x50u, 6528, &unk_105C7E68);
  sub_100772A0(4u, 6529, &unk_105C7EB8);
  sub_100772A0(1u, 6530, &unk_105C7EBC);
  sub_100772A0(1u, 6531, &unk_105C7EBD);
  sub_100772A0(1u, 6532, &unk_105C7EBE);
  sub_100772A0(0x14u, 6533, &unk_105C7EBF);
  sub_100772A0(0xAu, 6883, &unk_105C85D8);
  sub_100772A0(0xAu, 6884, &unk_105C85E2);
  sub_100772A0(0xAu, 6885, &unk_105C85EC);
  sub_100772A0(1u, 6664, &unk_105C7ED3);
  sub_100772A0(1u, 6666, &unk_105C7ED4);
  sub_100772A0(1u, 6667, &unk_105C7ED5);
  sub_100772A0(1u, 6668, &unk_105C7ED6);
  sub_100772A0(0xA0u, 6669, &unk_105C7ED8);
  sub_100772A0(2u, 6670, &unk_105C7FC8);
  sub_100772A0(4u, 6671, &unk_105C7FCC);
  sub_100772A0(4u, 6672, &unk_105C7FD0);
  sub_100772A0(4u, 6673, &unk_105C7FD4);
  sub_100772A0(4u, 6674, &unk_105C7FD8);
  sub_100772A0(4u, 6675, &unk_105C7FDC);
  sub_100772A0(4u, 6676, &unk_105C7FE4);
  sub_100772A0(4u, 6677, &unk_105C7FEC);
  sub_100772A0(4u, 6678, &unk_105C7FF0);
  sub_100772A0(1u, 6679, &unk_105C7FF4);
  sub_100772A0(0x140u, 6680, &unk_105C7FF8);
  sub_100772A0(4u, 6882, &unk_105C85D4);
  sub_100772A0(0xCu, 6652, &unk_105C8138);
  sub_100772A0(0x48u, 6653, &unk_105C8144);
  sub_100772A0(1u, 6688, &unk_105C818C);
  sub_100772A0(4u, 6771, &unk_105C8214);
  sub_100772A0(4u, 6772, &unk_105C8218);
  sub_100772A0(8u, 6787, &unk_105C821C);
  sub_100772A0(1u, 6832, &unk_105C824C);
  sub_100772A0(1u, 6833, &unk_105C824D);
  sub_100772A0(1u, 6834, &unk_105C824E);
  sub_100772A0(4u, 6835, &unk_105C8250);
  sub_100772A0(4u, 6836, &unk_105C8254);
  sub_100772A0(4u, 6837, &unk_105C8258);
  sub_100772A0(4u, 6838, &unk_105C825C);
  sub_100772A0(1u, 6839, &unk_105C8260);
  sub_100772A0(0x50u, 6840, &unk_105C7F78);
  sub_100772A0(4u, 6841, &unk_105C8264);
  sub_100772A0(4u, 6842, &unk_105C8268);
  sub_100772A0(4u, 6843, &unk_105C826C);
  sub_100772A0(1u, 6844, &unk_105C8270);
  sub_100772A0(0x360u, 6845, &unk_105C8274);
  sub_100772A0(4u, 6846, &unk_105C7FE0);
  sub_100772A0(4u, 6847, &unk_105C7FE8);
  result = 1;
  dword_1068B5C0 = (int)&unk_105C03D8;
  return result;
}
// 1068B5C0: using guessed type int dword_1068B5C0;

//----- (100790F0) --------------------------------------------------------
_DWORD *sub_100790F0()
{
  sub_100024D0();
  return sub_1008EDC0();
}

//----- (10079100) --------------------------------------------------------
int sub_10079100()
{
  sub_100035D0();
  sub_100026E0();
  sub_10001E90();
  sub_100710F0();
  return unknown_libname_4();
}
// 1000D820: using guessed type int unknown_libname_4(void);
// 100710F0: using guessed type int sub_100710F0(void);

//----- (10079120) --------------------------------------------------------
signed int sub_10079120()
{
  signed int result; // eax@1

  result = -15;
  dword_1068B5BC = -15;
  dword_1068B5B8 = -15;
  return result;
}
// 1068B5B8: using guessed type int dword_1068B5B8;
// 1068B5BC: using guessed type int dword_1068B5BC;

//----- (10079130) --------------------------------------------------------
signed int sub_10079130()
{
  return sub_1009C150((int)&off_100F0D30);
}
// 100F0D30: using guessed type char *off_100F0D30;

//----- (10079140) --------------------------------------------------------
signed int sub_10079140()
{
  return sub_1009C150((int)&off_100F0D44);
}
// 100F0D44: using guessed type char *off_100F0D44;

//----- (10079150) --------------------------------------------------------
char __cdecl sub_10079150(char a1, int a2, void *a3)
{
  char v3; // bl@1
  const void *v5; // edx@7

  v3 = 0;
  if ( !a1 )
  {
    if ( !(unsigned __int8)sub_10079130() || (unsigned int)a2 >= 0xA )
      return v3;
    v5 = (const void *)(6916 * a2 + dword_1068B5BC + 136004);
    goto LABEL_14;
  }
  if ( a1 == 1 )
  {
    if ( !(unsigned __int8)sub_10079140() || (unsigned int)a2 >= 0xA )
      return v3;
    v5 = (const void *)(6916 * a2 + dword_1068B5B8 + 136044);
    goto LABEL_14;
  }
  if ( a1 != 2 )
    return 0;
  if ( (unsigned __int8)sub_10079140() && (unsigned int)a2 < 0xA )
  {
    v5 = (const void *)(6916 * a2 + dword_1068B5B8 + 237208);
LABEL_14:
    v3 = 1;
    memcpy(a3, v5, 0x1B04u);
  }
  return v3;
}
// 1068B5B8: using guessed type int dword_1068B5B8;
// 1068B5BC: using guessed type int dword_1068B5BC;

//----- (10079200) --------------------------------------------------------
void sub_10079200()
{
  dword_1068B5B4 = -15;
}
// 1068B5B4: using guessed type int dword_1068B5B4;

//----- (10079210) --------------------------------------------------------
void sub_10079210()
{
  dword_1068B5B0 = -15;
}
// 1068B5B0: using guessed type int dword_1068B5B0;

//----- (10079220) --------------------------------------------------------
int sub_10079220()
{
  int result; // eax@1

  result = 0;
  dword_105C9DA8 = -15;
  dword_1068B5AC = 0;
  dword_1068B5A0 = 0;
  dword_1068B5A4 = 0;
  dword_1068B5A8 = 0;
  return result;
}
// 105C9DA8: using guessed type int dword_105C9DA8;
// 1068B5A0: using guessed type int dword_1068B5A0;
// 1068B5A4: using guessed type int dword_1068B5A4;
// 1068B5A8: using guessed type int dword_1068B5A8;
// 1068B5AC: using guessed type int dword_1068B5AC;

//----- (10079250) --------------------------------------------------------
char sub_10079250()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_1009C150((int)&off_100F0DD8);
  if ( v0 )
  {
    dword_1068B5AC = dword_105C9DA8;
    v1 = *(_BYTE *)(dword_105C9DA8 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_1068B5AC + 36) < (unsigned int)sub_1009B2D0() )
      v0 = 0;
    dword_1068B5A8 = dword_105C9DA8 + 56116;
    result = v0;
    dword_1068B5A0 = dword_105C9DA8 + 1516;
    dword_1068B5A4 = dword_105C9DA8 + 20484;
  }
  else
  {
    dword_1068B5AC = 0;
    dword_1068B5A0 = 0;
    dword_1068B5A4 = 0;
    dword_1068B5A8 = 0;
    result = 0;
  }
  return result;
}
// 100F0DD8: using guessed type char *off_100F0DD8;
// 105C9DA8: using guessed type int dword_105C9DA8;
// 1068B5A0: using guessed type int dword_1068B5A0;
// 1068B5A4: using guessed type int dword_1068B5A4;
// 1068B5A8: using guessed type int dword_1068B5A8;
// 1068B5AC: using guessed type int dword_1068B5AC;

//----- (100792F0) --------------------------------------------------------
int sub_100792F0()
{
  byte_1068B5C8[0] = 0;
  return nullsub_7();
}
// 1008EE50: using guessed type int nullsub_7(void);

//----- (10079300) --------------------------------------------------------
signed int sub_10079300()
{
  return 1000;
}

//----- (10079320) --------------------------------------------------------
signed int sub_10079320()
{
  return 1000;
}

//----- (10079340) --------------------------------------------------------
int sub_10079340()
{
  return sub_1007A980((int)off_100F1318);
}
// 100F1318: using guessed type int (*off_100F1318[4])();

//----- (10079360) --------------------------------------------------------
bool __thiscall sub_10079360(void *this)
{
  return sub_100704C0(this) == 0;
}

//----- (10079370) --------------------------------------------------------
bool __cdecl sub_10079370(char a1)
{
  int v1; // eax@1

  v1 = a1 & 0x3F;
  return !(a1 & 0x3F) || v1 == 6 || v1 == 7 || v1 == 21 || v1 == 9 || v1 == 16 || v1 == 20;
}

//----- (100793A0) --------------------------------------------------------
char *__cdecl sub_100793A0(unsigned __int8 a1)
{
  return off_100F20D0[2 * a1];
}
// 100F20D0: using guessed type char *off_100F20D0[4];

//----- (100793B0) --------------------------------------------------------
char *__cdecl sub_100793B0(unsigned int a1, float *a2)
{
  unsigned __int8 v2; // ST0C_1@1

  v2 = sub_10079420(a1, a2);
  return sub_100793A0(v2);
}

//----- (100793E0) --------------------------------------------------------
char *__cdecl sub_100793E0(unsigned int a1, float *a2)
{
  return off_100F20D4[2 * (unsigned __int8)sub_10079420(a1, a2)];
}
// 100F20D4: using guessed type char *off_100F20D4[3];

//----- (10079400) --------------------------------------------------------
char __cdecl sub_10079400(char a1)
{
  char result; // al@3

  if ( a1 == 1 )
  {
    result = 2;
  }
  else if ( a1 == 3 )
  {
    result = 3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10079420) --------------------------------------------------------
char __cdecl sub_10079420(unsigned int a1, float *a2)
{
  __int16 v2; // si@1
  unsigned int v3; // edx@1
  char v4; // al@1
  char v5; // cl@1
  char result; // al@3
  float *v7; // edi@37
  int v8; // esi@37
  char v9; // al@51

  v2 = a1;
  v3 = a1 & 0x3F;
  v4 = (a1 >> 12) & 1;
  v5 = 31;
  LOBYTE(a1) = 31;
  switch ( v3 )
  {
    case 0u:
    case 1u:
      if ( v4 )
      {
        sub_1009C2B0(44, &a1);
        result = a1;
      }
      else
      {
        result = sub_1006FF40((void *)31);
      }
      break;
    case 2u:
    case 0x1Bu:
      if ( v4 )
      {
        sub_1009C2B0(77, &a1);
        result = a1;
      }
      else
      {
        result = sub_1006FF70((void *)31);
      }
      break;
    case 3u:
      result = sub_1006FF70((void *)31) != 30 ? 29 : 12;
      break;
    case 4u:
      v5 = sub_1006FF70((void *)31);
      if ( v5 == 21 )
      {
        if ( !a2 || *a2 >= 1000.0 )
          goto LABEL_60;
        result = 29;
      }
      else
      {
        if ( !a2 || *a2 >= 185.2 )
          goto LABEL_60;
        result = 12;
      }
      break;
    case 5u:
      result = 18;
      break;
    case 0xAu:
      result = 32;
      break;
    case 0xBu:
      result = sub_10070170((void *)31);
      break;
    case 0xCu:
      if ( v4 )
      {
        sub_1009C2B0(17, &a1);
        result = a1;
      }
      else
      {
        result = 33;
      }
      break;
    case 0xDu:
    case 0xEu:
      result = sub_10070090();
      break;
    case 0xFu:
      if ( v4 )
      {
        sub_1009C2B0(49, &a1);
        result = a1;
      }
      else
      {
        result = sub_100701A0((void *)31);
      }
      break;
    case 0x10u:
    case 0x11u:
      if ( v4 )
      {
        sub_1009C2B0(14, &a1);
        result = a1;
      }
      else
      {
        result = sub_100701D0(31);
      }
      break;
    case 0x12u:
      result = 49;
      break;
    case 0x13u:
      result = 39;
      break;
    case 0x14u:
      if ( v4 )
      {
        sub_1009C2B0(45, &a1);
        result = a1;
      }
      else
      {
        result = sub_10070380((void *)31);
      }
      break;
    case 0x15u:
      if ( v4 )
      {
        sub_1009C2B0(15, &a1);
        result = a1;
      }
      else
      {
        result = sub_10070040(31);
      }
      break;
    case 0x24u:
      v7 = a2;
      v8 = v2 & 0x1000;
      switch ( sub_10079420(v8 | 0x15, a2) )
      {
        case 0xD:
          result = sub_10079420(v8 | 2, v7) != 21 ? 45 : 57;
          break;
        case 0x18:
          result = sub_10079420(v8 | 2, v7) != 21 ? 54 : 59;
          break;
        case 0x10:
          result = sub_10079420(v8 | 2, v7) != 21 ? 53 : 58;
          break;
        case 0x13:
          result = sub_10079420(v8 | 2, v7) != 21 ? 55 : 60;
          break;
        default:
          result = 4 * (sub_10079420(v8 | 2, v7) == 21) + 52;
          break;
      }
      break;
    case 0x16u:
      if ( v4 )
      {
        sub_1009C2B0(16, &a1);
        result = a1;
      }
      else
      {
        result = sub_1006FFA0(31);
      }
      break;
    case 0x17u:
      result = 50;
      break;
    case 0x18u:
      result = 0;
      break;
    case 0x19u:
      result = 34;
      break;
    case 0x1Au:
      result = 1;
      break;
    case 0x26u:
    case 0x27u:
    case 0x2Au:
    case 0x2Bu:
      result = 5;
      break;
    case 0x28u:
    case 0x29u:
      v9 = sub_1009CBE0();
      result = sub_10079400(v9);
      break;
    case 0x1Du:
      result = 41;
      break;
    case 0x1Eu:
      result = 42;
      break;
    case 0x1Fu:
      result = 43;
      break;
    case 0x20u:
      result = sub_100703B0(31);
      break;
    case 0x21u:
      result = 46;
      break;
    case 0x22u:
      result = 47;
      break;
    case 0x23u:
      result = 48;
      break;
    case 0x25u:
      v5 = (sub_100703B0(31) != 19) + 61;
      goto LABEL_60;
    default:
LABEL_60:
      result = v5;
      break;
  }
  return result;
}

//----- (10079840) --------------------------------------------------------
double __cdecl sub_10079840(int a1, unsigned int a2)
{
  __int16 v2; // si@1
  char v3; // al@1
  void *v4; // ecx@1
  double result; // st7@3
  int v6; // eax@26
  int v7; // eax@27
  int v8; // eax@33
  int v9; // eax@34
  double v10; // st7@42
  float v11; // ST0C_4@44
  int v12; // eax@48
  int v13; // eax@49
  int v14; // eax@55
  int v15; // eax@56
  float v16; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v16 = 1.0;
  v3 = sub_10079420(a2, (float *)&a1);
  v4 = (void *)(v2 & 0x3F);
  switch ( v4 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 0x1Bu:
      switch ( v3 )
      {
        case 0xC:
          *(float *)&a1 = (float)3.2808399 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)0.00053995679 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)39.370079 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_67;
        default:
          goto LABEL_69;
      }
      goto LABEL_69;
    case 0xAu:
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v3 != 15 )
        goto LABEL_8;
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_8:
      *(float *)&a1 = (float)0.00029530001 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v3 == 40 )
      {
        *(float *)&a1 = (float)0.0000099999997 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0001450377 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v3 == 22 )
      {
        *(float *)&a1 = (float)3.5999999 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)1.9438444 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v3 == 28 )
      {
        *(float *)&a1 = (float)60.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)196.85039 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v3 != 10 )
        goto LABEL_69;
      sub_1008EE60((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v3 != 10 )
        goto LABEL_68;
      *(float *)&a1 = (float)1.8 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v3 )
      {
        case 0xD:
          *(float *)&a1 = (float)0.26417205 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)0.21997361 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v6 = (unsigned __int8)sub_10070010(v4);
          if ( (_BYTE)v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                *(float *)&a1 = (float)0.77890778 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.84999973 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.80407244 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.71895844 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v8 = (unsigned __int8)sub_10070010(v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
              {
                *(float *)&a1 = (float)1.7171981 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.8756201 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.7726756 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.5850322 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_69;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v3 < 0x38u || (unsigned __int8)v3 > 0x3Cu )
        v10 = 0.00053995679;
      else
        v10 = 0.001;
      v11 = v10;
      *(float *)&a1 = v11 * *(float *)&a1;
      *(float *)&a1 = sub_10079E70(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v3 )
      {
        case 0xE:
          *(float *)&a1 = (float)951.01935 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)791.90497 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_10070010(v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
              {
                *(float *)&a1 = (float)2804.0679 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)3059.999 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)2894.6609 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)2588.2505 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_10070010(v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
              {
                *(float *)&a1 = (float)6181.9131 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)6752.2324 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)6381.6323 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)5706.1162 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)3600.0 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v3 == 19 )
        goto LABEL_67;
      *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v3 == 61 )
      {
LABEL_67:
        v16 = 0.001;
LABEL_68:
        *(float *)&a1 = v16 * *(float *)&a1;
LABEL_69:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_69;
  }
}

//----- (10079E70) --------------------------------------------------------
double __cdecl sub_10079E70(int a1, unsigned int a2)
{
  __int16 v2; // di@1
  unsigned int v3; // esi@1
  void *v4; // ecx@1
  char v5; // bl@1
  double result; // st7@5
  int v7; // eax@28
  int v8; // eax@29
  int v9; // eax@35
  int v10; // eax@36
  double v11; // st7@44
  float v12; // ST1C_4@46
  int v13; // eax@50
  int v14; // eax@51
  int v15; // eax@57
  int v16; // eax@58
  float v17; // [sp+14h] [bp-4h]@1

  v17 = 1.0;
  v2 = a2;
  v3 = a2 & 0x3F;
  v5 = sub_10079420(a2, 0);
  if ( v3 == 4 )
    sub_10070AD0("..\\lib\\adl\\cdp_cnvt.c", 1174, 1, 0);
  switch ( v3 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 0x1Bu:
      switch ( v5 )
      {
        case 0xC:
          *(float *)&a1 = (float)0.3048 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)1852.0 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)0.0254 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_69;
        default:
          goto LABEL_71;
      }
      goto LABEL_71;
    case 0xAu:
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v5 != 15 )
        goto LABEL_10;
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_10:
      *(float *)&a1 = (float)3386.3867 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v5 == 40 )
      {
        *(float *)&a1 = (float)100000.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)6894.7593 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v5 == 22 )
      {
        *(float *)&a1 = (float)0.27777779 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.51444447 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v5 == 11 )
      {
        *(float *)&a1 = (float)0.00508 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.016666668 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v5 != 10 )
        goto LABEL_71;
      sub_1008EE80((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v5 != 10 )
        goto LABEL_70;
      *(float *)&a1 = (float)0.55555558 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v5 )
      {
        case 0xD:
          *(float *)&a1 = (float)3.7854118 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)4.546 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v7 = (unsigned __int8)sub_10070010(v4);
          if ( (_BYTE)v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                *(float *)&a1 = (float)1.283849 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.176471 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.243669 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.390901 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v9 = (unsigned __int8)sub_10070010(v4);
          if ( (_BYTE)v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              if ( v10 == 1 )
              {
                *(float *)&a1 = (float)0.582344 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.53315699 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.56411898 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.63090199 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_71;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v5 < 0x38u || (unsigned __int8)v5 > 0x3Cu )
        v11 = 1852.0;
      else
        v11 = 1000.0;
      v12 = v11;
      *(float *)&a1 = v12 * *(float *)&a1;
      *(float *)&a1 = sub_10079840(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v5 )
      {
        case 0xE:
          *(float *)&a1 = (float)0.0010515032 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)0.0012627778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v13 = (unsigned __int8)sub_10070010(v4);
          if ( (_BYTE)v13 )
          {
            v14 = v13 - 1;
            if ( v14 )
            {
              if ( v14 == 1 )
              {
                *(float *)&a1 = (float)0.00035662472 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00032679751 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00034546363 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00038636138 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v15 = (unsigned __int8)sub_10070010(v4);
          if ( (_BYTE)v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              if ( v16 == 1 )
              {
                *(float *)&a1 = (float)0.00016176222 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00014809916 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00015669972 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00017525055 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)0.00027777778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v5 == 19 )
        goto LABEL_69;
      *(float *)&a1 = (float)453.59241 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v5 == 61 )
      {
LABEL_69:
        v17 = 1000.0;
LABEL_70:
        *(float *)&a1 = v17 * *(float *)&a1;
LABEL_71:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)453.59241 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_71;
  }
}

//----- (1007A560) --------------------------------------------------------
char __thiscall sub_1007A560(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_1009B890(3024, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1007A590) --------------------------------------------------------
char __cdecl sub_1007A590(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_1009C2B0(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (1007A5C0) --------------------------------------------------------
int __cdecl sub_1007A5C0(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_1068B590)();
  *a1 = result;
  return result;
}
// 1068B590: using guessed type int dword_1068B590;

//----- (1007A5E0) --------------------------------------------------------
void __cdecl sub_1007A5E0(int a1, float a2)
{
  float v2; // [sp+8h] [bp+8h]@1

  v2 = a2 / 0.01745329238474369;
  *(float *)a1 = v2;
  if ( v2 < 0.0 )
    *(float *)a1 = v2 + 360.0;
}

//----- (1007A610) --------------------------------------------------------
void __cdecl sub_1007A610(int a1, float a2)
{
  float v2; // [sp+10h] [bp+8h]@1

  v2 = a2 * 0.01745329238474369;
  *(float *)a1 = v2;
  *(float *)a1 = sub_100A72C0(v2);
}

//----- (1007A640) --------------------------------------------------------
int __cdecl sub_1007A640(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (1007A660) --------------------------------------------------------
int __cdecl sub_1007A660(int a1, double a2, double a3)
{
  long double v3; // st6@1
  long double v4; // st4@1
  int result; // eax@3
  double v6; // st7@6
  double v7; // [sp+0h] [bp-10h]@6
  double v8; // [sp+8h] [bp-8h]@6

  v3 = fabs(a2);
  v4 = fabs(a3);
  if ( v3 > 1.5707963267949 || v4 >= 3.1415926535898 )
  {
    if ( v3 > 4.7123889803847 || v4 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = a2;
      v8 = a3;
      sub_1007A740((int)&v7);
      v6 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v6;
      *(_DWORD *)(a1 + 4) = (signed int)v6;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(a2 * 683565275.5764301);
    result = (signed int)(683565275.5764301 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (1007A740) --------------------------------------------------------
void __cdecl sub_1007A740(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        sub_100A72A0(v9);
        *(double *)(a1 + 8) = v9;
        return;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
}

//----- (1007A840) --------------------------------------------------------
char __cdecl sub_1007A840(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10071590((_DWORD *)a2, 2u, (int)&unk_100F31C0, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100F31C4[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_1009B480(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_1009B230();
        sub_1006FD70(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10070AD0("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100F31C4: using guessed type int dword_100F31C4[];

//----- (1007A960) --------------------------------------------------------
char __cdecl sub_1007A960(int a1)
{
  return sub_1007A840(32, a1);
}

//----- (1007A970) --------------------------------------------------------
char __cdecl sub_1007A970(int a1)
{
  return sub_1007A840(31, a1);
}

//----- (1007A980) --------------------------------------------------------
int __cdecl sub_1007A980(int a1)
{
  int result; // eax@1

  result = a1;
  dword_105C9DC0 = *(_DWORD *)a1;
  dword_105C9DC4 = *(_DWORD *)(a1 + 4);
  dword_105C9DC8 = *(_DWORD *)(a1 + 8);
  dword_105C9DCC = *(_DWORD *)(a1 + 12);
  dword_1068B590 = (int)&dword_105C9DC0;
  return result;
}
// 105C9DC0: using guessed type int dword_105C9DC0;
// 105C9DC4: using guessed type int dword_105C9DC4;
// 105C9DC8: using guessed type int dword_105C9DC8;
// 105C9DCC: using guessed type int dword_105C9DCC;
// 1068B590: using guessed type int dword_1068B590;

//----- (1007A9C0) --------------------------------------------------------
char __cdecl sub_1007A9C0(char a1)
{
  char result; // al@1

  result = sub_1008F310();
  if ( result == 2 )
    result = byte_100F4874[8 * sub_10071590(&a1, 4u, (int)&unk_100F4870, 8, 7, 7)];
  return result;
}

//----- (1007A9F0) --------------------------------------------------------
char __thiscall sub_1007A9F0(void *this)
{
  char v1; // al@1

  v1 = (unsigned int)sub_100705C0(this);
  return sub_1007A9C0(v1);
}

//----- (1007AA10) --------------------------------------------------------
char *__cdecl sub_1007AA10(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_100C4192;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (1007AA60) --------------------------------------------------------
int sub_1007AA60()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_1009B230();
  result = 0;
  while ( 1 )
  {
    v3 = dword_105C9DEC[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_105C9DEC[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 105C9DEC: using guessed type int dword_105C9DEC[];

//----- (1007AAA0) --------------------------------------------------------
int __cdecl sub_1007AAA0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1007AB10) --------------------------------------------------------
signed int __cdecl sub_1007AB10(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1007ABB0) --------------------------------------------------------
int __usercall sub_1007ABB0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_1007AB10(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1007ABE0) --------------------------------------------------------
signed int __usercall sub_1007ABE0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_1007AB10((_BYTE *)a3, (int)(&off_100F5C30)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_100F5C34[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_100AA9F8(a3, (int)&unk_100CC178, (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_100AA9F8(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_100AA9F8(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 100F5C30: using guessed type char *off_100F5C30;

//----- (1007ADB0) --------------------------------------------------------
char *__usercall sub_1007ADB0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, word_100D2B44, 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (1007AE10) --------------------------------------------------------
unsigned int __usercall sub_1007AE10@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  unsigned int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_1007AB10((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1007AEA0) --------------------------------------------------------
int __usercall sub_1007AEA0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_1007ABB0(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (1007AEF0) --------------------------------------------------------
char **__usercall sub_1007AEF0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_1007AA10(v6);
      if ( !sub_1007AB10((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (1007AF50) --------------------------------------------------------
const char *__usercall sub_1007AF50@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (1007AF70) --------------------------------------------------------
int __usercall sub_1007AF70@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_105C9DD8[sub_1007AA60()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 105C9DD8: using guessed type int dword_105C9DD8[];

//----- (1007AFB0) --------------------------------------------------------
int __usercall sub_1007AFB0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_1007ABE0(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (1007B040) --------------------------------------------------------
int __usercall sub_1007B040@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (1007B190) --------------------------------------------------------
int __usercall sub_1007B190@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1007CEE0(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_1007BA70(v3, v6, 0);
        v7 = -*v3;
        sub_1007CEE0(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_1007CEE0(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_100F58E8);
      sub_1008F320(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_100F58E8);
      sub_1007CEE0(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (1007B230) --------------------------------------------------------
int __usercall sub_1007B230@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (1007B270) --------------------------------------------------------
char *__cdecl sub_1007B270(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_1007ADB0(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_1007ADB0(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_1007ADB0(result, v5, (int)&v20);
      v10 = (const char *)&unk_100C4192;
    }
    LOBYTE(v9) = 0;
    sub_1007ADB0(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_1007ADB0(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_1007ADB0(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_1007ADB0(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_1007CE70(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 1007B270: using guessed type int var_61C[6];

//----- (1007B420) --------------------------------------------------------
int __usercall sub_1007B420@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_1007AA10((char **)a1);
  result = sub_1007CF00(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_100F58E8);
  return result;
}

//----- (1007B450) --------------------------------------------------------
int __usercall sub_1007B450@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_100F58E8);
  v2 = (unsigned int)sub_1007AA10((char **)a1);
  return sub_1007CEE0(10, v2);
}

//----- (1007B480) --------------------------------------------------------
void __cdecl sub_1007B480(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_1007AA10(v5);
            v7 = sub_1007AA10((char **)v3);
            if ( !sub_1007AAA0(v7, (int)v6) )
            {
              v8 = sub_1007AA10((char **)v3);
              sub_1007CFA0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_1007AA10((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_1007AA10((char **)v3);
        sub_1007CFA0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_1007AF50(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1007D9C0("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_1007AA10((char **)v3);
            sub_1007CFE0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_1007AAA0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_1007AF50(v18);
                  v25 = sub_1007D9C0("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_1007AA10((char **)v3);
                  sub_1007CFE0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_1007AA10((char **)v3);
                  sub_1007CFE0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_1007AA10((char **)v3);
              sub_1007CFE0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_1007AA10((char **)v3);
              sub_1007CFE0(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_1007AA10((char **)v3);
              sub_1007CFE0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_1007B480((int (**)(void))(*(_DWORD *)(v3 + 8) + v11 + 8), (char **)v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_1007AA10((char **)v3);
            sub_1007CFE0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_1007AA10((char **)v3);
            sub_1007CFE0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_1007AA10((char **)v3);
          sub_1007CFE0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_1007AA10((char **)v3);
        sub_1007CFE0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_1007AA10(a2);
      sub_1007CFA0(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (1007B8F0) --------------------------------------------------------
int sub_1007B8F0()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_105C9DD8[sub_1007AA60()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_1007B480(i, 0, &v2);
  }
  return v2;
}
// 105C9DD8: using guessed type int dword_105C9DD8[];

//----- (1007B940) --------------------------------------------------------
void *sub_1007B940()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_105C9DD8[0] = 0;
  dword_105C9DDC = 0;
  dword_105C9DE0 = 0;
  dword_105C9DE4 = 0;
  dword_105C9DE8 = 0;
  result = &unk_105C9E00;
  dword_105C9DEC[0] = -1;
  dword_105C9DF0 = -1;
  dword_105C9DF4 = -1;
  dword_105C9DF8 = -1;
  dword_105C9DFC = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_1007B230((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 105C9DD8: using guessed type int dword_105C9DD8[];
// 105C9DDC: using guessed type int dword_105C9DDC;
// 105C9DE0: using guessed type int dword_105C9DE0;
// 105C9DE4: using guessed type int dword_105C9DE4;
// 105C9DE8: using guessed type int dword_105C9DE8;
// 105C9DEC: using guessed type int dword_105C9DEC[];
// 105C9DF0: using guessed type int dword_105C9DF0;
// 105C9DF4: using guessed type int dword_105C9DF4;
// 105C9DF8: using guessed type int dword_105C9DF8;
// 105C9DFC: using guessed type int dword_105C9DFC;

//----- (1007B9A0) --------------------------------------------------------
char *sub_1007B9A0()
{
  return (char *)&unk_105C9E00 + 56 * sub_1007AA60();
}

//----- (1007B9C0) --------------------------------------------------------
char sub_1007B9C0()
{
  return sub_1007B9A0()[33];
}

//----- (1007B9D0) --------------------------------------------------------
char __cdecl sub_1007B9D0(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_1007B9A0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_1007CA60(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (1007BA10) --------------------------------------------------------
int *__usercall sub_1007BA10@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_1007B9A0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_1007AB10((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (1007BA60) --------------------------------------------------------
char **sub_1007BA60()
{
  return &off_100F5C98;
}
// 100F5C98: using guessed type char *off_100F5C98;

//----- (1007BA70) --------------------------------------------------------
int __cdecl sub_1007BA70(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_10081C30();
  v3 = sub_1007B9A0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_1007B8F0();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_1007B420(a2);
    if ( a3 )
    {
      v7 = sub_1007B190(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_1007B190(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_1007B450(a2);
        return v7;
      }
    }
    sub_1007B450(a2);
    result = v7;
  }
  return result;
}

//----- (1007BB20) --------------------------------------------------------
int __cdecl sub_1007BB20(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_1007ADB0(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_1007ADB0(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_1007ADB0(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_1007CE70(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_1007ADB0(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_1007ADB0(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_1007ADB0(v14, "group-begin", (int)&v29);
          sub_1007CE70(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_1007AA10(v15);
          sub_1007BB20((int)v16[2], (int)v16[3], (int)v16[4], v17, a4);
          sub_1007AA10(v16);
          v18 = sub_1007B270((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_1007ADB0(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_1007ADB0(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_1007ADB0(v20, "group-end", (int)&v29);
          result = sub_1007CE70(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_1007ADB0(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_1007ADB0(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_1007ADB0(v21, a4, (int)&v28);
          v23 = (const char *)&unk_100C4192;
        }
        LOBYTE(v22) = 0;
        v24 = sub_1007ADB0(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_1007ADB0(v24, *(const char **)v5, (int)&v30);
        result = sub_1007CE70(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 1007BB20: using guessed type int var_414[4];

//----- (1007BD30) --------------------------------------------------------
char *__usercall sub_1007BD30@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_1007ADB0(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_1007ADB0(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_1007CE70(2, (int)v11, 2);
  if ( a6 )
  {
    sub_1007BB20(a3, (int)a4, a5, a2, 0);
    result = sub_1007B270(a3, a4, a5, 0);
  }
  return result;
}
// 1007BD30: using guessed type int var_20C[2];

//----- (1007BDF0) --------------------------------------------------------
char *__cdecl sub_1007BDF0(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_105C9DD8[sub_1007AA60()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_1007AA10((char **)v2);
    sub_1007BD30("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_1007B9A0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_1007BD30(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 105C9DD8: using guessed type int dword_105C9DD8[];

//----- (1007BE90) --------------------------------------------------------
int *__cdecl sub_1007BE90(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_105C9DD8[sub_1007AA60()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_1007AA10(v2);
      if ( !sub_1007AB10(a1, (int)v4) )
      {
        v5 = sub_1007AA10(v3);
        sub_1007BD30("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_1007B9A0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_1007AB10(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_1007BD30(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 105C9DD8: using guessed type int dword_105C9DD8[];

//----- (1007BF50) --------------------------------------------------------
int __usercall sub_1007BF50@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_1007AF70(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_1007BA70((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_1007AF70(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_1007BA70((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_1007B420(v5);
        sub_1007B190(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_1007B450(v8);
          v10 = sub_1007AF70(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (1007C0B0) --------------------------------------------------------
signed int __usercall sub_1007C0B0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_105C9DD8[sub_1007AA60()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_1007BA70((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 105C9DD8: using guessed type int dword_105C9DD8[];

//----- (1007C120) --------------------------------------------------------
int __cdecl sub_1007C120(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_1007B9A0();
  switch ( a1 )
  {
    case 9:
      sub_1007CEE0(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_1007AB10((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_1007AB10(v6, (int)"-q") )
            {
              sub_1007BE90(v6);
              v9 = sub_1007B8F0();
              sub_1007CEE0(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_1007BDF0(0);
              v8 = sub_1007B8F0();
              sub_1007CEE0(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_1007BDF0(1);
            v7 = sub_1007B8F0();
            sub_1007CEE0(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_1007CF60(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_1007CEE0(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_1007BDF0(0);
        v4 = sub_1007B8F0();
        sub_1007CEE0(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_1007CEE0(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_105C9DD8[sub_1007AA60()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_1007C120 )
              v12(2, (int)&unk_100F58E8);
          }
        }
      }
      sub_10081C30();
      v3[34] = 0;
      return 0;
    case 3:
      sub_1007CEE0(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_105C9DD8[sub_1007AA60()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_1007CF60(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_1007BF50((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_1007CF60(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_1007C0B0((int)v3);
    case 14:
      exit_1(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_1007CF60(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_1007C120 )
          v15(3, (int)&unk_100F58E8);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 1007C120: using guessed type int __cdecl sub_1007C120(int, int);
// 105C9DD8: using guessed type int dword_105C9DD8[];

//----- (1007C400) --------------------------------------------------------
char **sub_1007C400()
{
  return off_100F5A8C;
}
// 100F5A8C: using guessed type char *off_100F5A8C[3];

//----- (1007C410) --------------------------------------------------------
int __usercall sub_1007C410@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_1007AEA0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_1007AFB0(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_1007C400();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (1007C500) --------------------------------------------------------
int __cdecl sub_1007C500(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_1007B9A0();
  *a1 = 0;
  v4 = sub_1007D9C0("Processing command '%s'", v2);
  sub_1007CF60(3, (int)&unk_100F6420, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_1007B040(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_1007BF50((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_1007C0B0((int)v3);
    v11 = 0;
    v6 = sub_1007AA60();
    v7 = sub_1007AEF0((int (**)(void))dword_105C9DD8[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_1007AE10((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_1007AE10((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1007BA70(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1007BA70(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_1007C410(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_1007BA10(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_1007C410(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_1007C400();
        result = sub_1007C410(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 105C9DD8: using guessed type int dword_105C9DD8[];
// 1007C500: using guessed type char var_2D4[720];

//----- (1007C740) --------------------------------------------------------
int sub_1007C740()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_1007C500(&v4);
  if ( !sub_1007B9A0()[32] )
    sub_1007CEE0(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1007D9C0("%s %i, %s", "Command status:", v0, &v4);
    sub_1007CF60(3, (int)&unk_100F6420, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1007D9C0("%s %i", "Command status:", v0);
    sub_1007CF60(3, (int)&unk_100F6420, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (1007C820) --------------------------------------------------------
int __cdecl sub_1007C820(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_105C9DD8[sub_1007AA60()] = a1;
  sub_1007B9A0()[32] = a3;
  sub_10081C30();
  sub_1008F530(a2);
  v3 = sub_1007BA60();
  sub_1007C950(v3);
  return sub_1007C740();
}
// 105C9DD8: using guessed type int dword_105C9DD8[];

//----- (1007C870) --------------------------------------------------------
int __cdecl sub_1007C870(int a1)
{
  return a1 + 9;
}

//----- (1007C880) --------------------------------------------------------
int __cdecl sub_1007C880(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_1009B230();
  memset(a1, 0, 0xDCu);
  sub_1006FD70((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1007C870(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1008F6C0((int)a1, (int)v3);
}

//----- (1007C900) --------------------------------------------------------
int __cdecl sub_1007C900(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1008F8D0(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1007C930) --------------------------------------------------------
signed int __cdecl sub_1007C930(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  signed int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1009C410(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_1009B2D0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_1009B2D0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1008F6C0(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1007C950) --------------------------------------------------------
char __cdecl sub_1007C950(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_1007B9A0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_1008F370("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_1007C740() )
          v7 = 0;
      }
      v5 = sub_1008F370("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_1007C740() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (1007CA60) --------------------------------------------------------
char __cdecl sub_1007CA60(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (1007CA90) --------------------------------------------------------
bool __cdecl sub_1007CA90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (1007CAC0) --------------------------------------------------------
bool __cdecl sub_1007CAC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (1007CAF0) --------------------------------------------------------
bool __cdecl sub_1007CAF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (1007CB20) --------------------------------------------------------
bool __cdecl sub_1007CB20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (1007CB50) --------------------------------------------------------
bool __cdecl sub_1007CB50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (1007CB80) --------------------------------------------------------
bool __cdecl sub_1007CB80(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (1007CBC0) --------------------------------------------------------
bool __cdecl sub_1007CBC0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (1007CC00) --------------------------------------------------------
bool __cdecl sub_1007CC00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (1007CC30) --------------------------------------------------------
bool __cdecl sub_1007CC30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (1007CC60) --------------------------------------------------------
char __cdecl sub_1007CC60(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (1007CC90) --------------------------------------------------------
bool __cdecl sub_1007CC90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (1007CCC0) --------------------------------------------------------
bool __cdecl sub_1007CCC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (1007CCF0) --------------------------------------------------------
bool __cdecl sub_1007CCF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (1007CD20) --------------------------------------------------------
bool __cdecl sub_1007CD20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (1007CD50) --------------------------------------------------------
bool __cdecl sub_1007CD50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_100F6420, 9u);
}

//----- (1007CD80) --------------------------------------------------------
bool __cdecl sub_1007CD80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (1007CDB0) --------------------------------------------------------
bool __cdecl sub_1007CDB0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (1007CDE0) --------------------------------------------------------
bool __cdecl sub_1007CDE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (1007CE10) --------------------------------------------------------
bool __cdecl sub_1007CE10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (1007CE40) --------------------------------------------------------
bool __cdecl sub_1007CE40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (1007CE70) --------------------------------------------------------
int __cdecl sub_1007CE70(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_1007B9A0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1007CEE0) --------------------------------------------------------
int __cdecl sub_1007CEE0(int a1, char a2)
{
  return sub_1007CE70(a1, (int)&a2, 1);
}

//----- (1007CF00) --------------------------------------------------------
int __cdecl sub_1007CF00(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_1007CE70(a1, (int)&v4, 2);
}

//----- (1007CF30) --------------------------------------------------------
int __cdecl sub_1007CF30(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_1007CE70(a1, (int)&v5, 3);
}

//----- (1007CF60) --------------------------------------------------------
int __cdecl sub_1007CF60(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_1007CE70(a1, (int)&v6, 4);
}

//----- (1007CFA0) --------------------------------------------------------
int __cdecl sub_1007CFA0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_1007CE70(a1, (int)&v7, 5);
}

//----- (1007CFE0) --------------------------------------------------------
int __cdecl sub_1007CFE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_1007CE70(a1, (int)&v8, 6);
}

//----- (1007D030) --------------------------------------------------------
char __cdecl sub_1007D030(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_1007B9A0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (1007D060) --------------------------------------------------------
char __cdecl sub_1007D060(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (1007D070) --------------------------------------------------------
char __cdecl sub_1007D070(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_100C4192;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_1008F9F0(v16) )
        sub_1008F9D0((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_1008FA00((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 1008F9F0: using guessed type _DWORD __cdecl sub_1008F9F0(_DWORD);
// 1007D070: using guessed type char var_104[255];

//----- (1007D1F0) --------------------------------------------------------
signed int __cdecl sub_1007D1F0(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (1007D230) --------------------------------------------------------
signed int __cdecl sub_1007D230(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1007D2D0) --------------------------------------------------------
char __cdecl sub_1007D2D0(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1007D330) --------------------------------------------------------
char __cdecl sub_1007D330(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_1008F9B0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1007D3A0) --------------------------------------------------------
char *__cdecl sub_1007D3A0(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_105C9F18, v1, v2);
  *(&byte_105C9F18 + v2) = 0;
  return &byte_105C9F18;
}

//----- (1007D440) --------------------------------------------------------
int __cdecl sub_1007D440(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1007D4B0) --------------------------------------------------------
bool __cdecl sub_1007D4B0(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_100AA9F8(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_100AA9F8(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1007D540) --------------------------------------------------------
char __cdecl sub_1007D540(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1007D5F0) --------------------------------------------------------
char __cdecl sub_1007D5F0(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1007D600) --------------------------------------------------------
char __cdecl sub_1007D600(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_1008F9B0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1007D680) --------------------------------------------------------
int (__cdecl *__cdecl sub_1007D680(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_1008FA80((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1007D6D0) --------------------------------------------------------
signed int __cdecl sub_1007D6D0(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1007D600(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1007D720) --------------------------------------------------------
char *__cdecl sub_1007D720(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_1008F370("CFG_ActDir", (int)&unk_100C4192);
      v10 = sub_1008F370("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_1008F370("CFG_ExpDir", (int)&unk_100C4192);
      v10 = sub_1008F370("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_1008F370("CFG_ActDir", (int)&unk_100C4192);
      break;
    case 4:
      v10 = sub_1008F370("CFG_ExpDir", (int)&unk_100C4192);
      break;
    default:
      v10 = (char *)&unk_100C4192;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_100C4192;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1007D720: using guessed type char var_104[256];

//----- (1007D8A0) --------------------------------------------------------
int sub_1007D8A0()
{
  return dword_105CEC08[sub_1007AA60()];
}
// 105CEC08: using guessed type int dword_105CEC08[];

//----- (1007D8B0) --------------------------------------------------------
const char *__cdecl sub_1007D8B0(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_100F6650[a1];
  return result;
}
// 100F6650: using guessed type char *off_100F6650[7];

//----- (1007D8D0) --------------------------------------------------------
int __cdecl sub_1007D8D0(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_1007CFA0(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1007D980) --------------------------------------------------------
int __cdecl sub_1007D980(int a1)
{
  int result; // eax@1

  result = sub_1007AA60();
  dword_105D0D14[result] = a1;
  return result;
}
// 105D0D14: using guessed type int dword_105D0D14[];

//----- (1007D9A0) --------------------------------------------------------
int __cdecl sub_1007D9A0(int a1)
{
  int result; // eax@1

  result = sub_1007AA60();
  dword_105CEC08[result] = a1;
  return result;
}
// 105CEC08: using guessed type int dword_105CEC08[];

//----- (1007D9C0) --------------------------------------------------------
char *sub_1007D9C0(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_1007AA60() << 8;
  _vsnprintf(&byte_105CA018[v1], 0x100u, a1, va);
  result = &byte_105CA018[v1];
  byte_105CA116[v1] = 42;
  byte_105CA117[v1] = 0;
  return result;
}

//----- (1007DA00) --------------------------------------------------------
char *__usercall sub_1007DA00@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_100F6664[a1 & 1];
  else
    result = off_100F665C[a2];
  return result;
}
// 100F665C: using guessed type char *off_100F665C[4];
// 100F6664: using guessed type char *off_100F6664[2];

//----- (1007DA20) --------------------------------------------------------
char __usercall sub_1007DA20@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_1007AA60();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1007D8A0() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_105D2308[v6];
      v12 = dword_105D231C[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_105CEC1C[v6];
      v12 = dword_105D0D00[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 105CEC1C: using guessed type int dword_105CEC1C[];
// 105D0D00: using guessed type int dword_105D0D00[];
// 105D2308: using guessed type int dword_105D2308[];
// 105D231C: using guessed type int dword_105D231C[];

//----- (1007DC00) --------------------------------------------------------
int sub_1007DC00()
{
  nullsub_2("..\\lib\\utf\\utf_verify.c", "2370", "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
  return 0;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);

//----- (1007DC20) --------------------------------------------------------
int sub_1007DC20()
{
  return nullsub_2(
           "..\\lib\\utf\\utf_verify.c",
           "2396",
           "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);

//----- (1007DC40) --------------------------------------------------------
int __cdecl sub_1007DC40(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_1007AA60();
  dword_105D0D00[result] = a1;
  if ( a2 >= 0 )
  {
    dword_105CEC1C[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1007D9C0(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_1007CF60(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_105CEC1C[result] = 8;
  }
  return result;
}
// 105CEC1C: using guessed type int dword_105CEC1C[];
// 105D0D00: using guessed type int dword_105D0D00[];

//----- (1007DCA0) --------------------------------------------------------
int __cdecl sub_1007DCA0(int a1)
{
  return sub_1007DC40(0, a1);
}

//----- (1007DCB0) --------------------------------------------------------
int __cdecl sub_1007DCB0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_1007AA60();
  dword_105D231C[result] = a1;
  if ( a2 >= 0 )
  {
    dword_105D2308[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1007D9C0(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_1007CF60(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_105D2308[result] = 8;
  }
  return result;
}
// 105D2308: using guessed type int dword_105D2308[];
// 105D231C: using guessed type int dword_105D231C[];

//----- (1007DD10) --------------------------------------------------------
int __cdecl sub_1007DD10(int a1)
{
  return sub_1007DCB0(0, a1);
}

//----- (1007DD20) --------------------------------------------------------
bool __cdecl sub_1007DD20(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_1007B9C0() )
    v8 = v8 == 0;
  v9 = (&off_100F6634)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_100F6624[v8 != 0];
  v19 = off_100F662C[a1];
  v18 = v10;
  v21 = sub_1007DA00(0, a6);
  v22 = sub_1007DA00(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_1008FC60();
  sub_1007CE70(7, (int)&v14, v11);
  sub_1008FC70(v12);
  return v8;
}
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007DE60) --------------------------------------------------------
bool __cdecl sub_1007DE60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  char v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_1007AA60();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > (unsigned __int8)v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v16 = v16 == 0;
  sub_1007DA20((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_105CB008[v11], 0x400u, &v30, a6);
  byte_105CB406[v11] = 42;
  byte_105CB407[v11] = 0;
  v17 = sub_1007DA20((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v11], 0x400u, &v30, a7);
  byte_105CB806[v11] = 42;
  byte_105CB807[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_105CB808[v11];
    byte_105CB808[v11] = 0;
  }
  else
  {
    v17 = sub_1007DA20((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_105CB808[v11];
    _snprintf(&byte_105CB808[v11], 0x400u, &v30, 0);
    byte_105CBC06[v11] = 42;
    byte_105CBC07[v11] = 0;
  }
  v19 = (&off_100F6634)[4 * a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_105CB008[v11];
  v27 = &byte_105CB408[v11];
  v13 = off_100F662C[a1];
  v23 = off_100F6624[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_1008FC60();
  sub_1007CE70(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v14);
  return v16;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007E210) --------------------------------------------------------
bool __cdecl sub_1007E210(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_1007AA60();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v20 = v20 == 0;
  sub_1007DA20((int)&v34, (char *)&unk_100F6900, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_105CB008[v12], 0x400u, &v34);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v21 = sub_1007DA20((int)&v34, (char *)&unk_100F6900, 3, 0xCu, a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v34, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v13 = &byte_105CB808[v12];
    v21 = sub_1007DA20((int)&v34, (char *)&unk_100F6900, 3, 0xCu, v10);
    _snprintf(&byte_105CB808[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v23 = (&off_100F6634)[4 * a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_105CB008[v12];
  v32 = v13;
  v17 = off_100F662C[a1];
  v27 = off_100F6624[v20 != 0];
  v28 = v17;
  v31 = &byte_105CB408[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_1008FC60();
  sub_1007CE70(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v18);
  return v20;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007E660) --------------------------------------------------------
bool __cdecl sub_1007E660(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_1007AA60();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v25 = v25 == 0;
  sub_1007DA20((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_105CB008[v20], 0x400u, &v40);
  byte_105CB406[v20] = 42;
  byte_105CB407[v20] = 0;
  v26 = sub_1007DA20((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_105CB408[v20], 0x400u, &v40, a7);
  byte_105CB806[v20] = 42;
  byte_105CB807[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_105CB808[v20];
    byte_105CB808[v20] = 0;
  }
  else
  {
    v21 = &byte_105CB808[v20];
    v26 = sub_1007DA20((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_105CB808[v20], 0x400u, &v40, v28);
    byte_105CBC06[v20] = 42;
    byte_105CBC07[v20] = 0;
  }
  v29 = (&off_100F6634)[4 * a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_105CB008[v20];
  v37 = &byte_105CB408[v20];
  v38 = v21;
  v22 = off_100F6624[v25 != 0];
  v34 = off_100F662C[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_1008FC60();
  sub_1007CE70(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v23);
  return v25;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007EB20) --------------------------------------------------------
bool __cdecl sub_1007EB20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v18 = sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_105CB808[v12];
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "int";
  v27 = &byte_105CB008[v12];
  v28 = &byte_105CB408[v12];
  v29 = v13;
  v14 = off_100F6624[v17 != 0];
  v25 = off_100F662C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007EEE0) --------------------------------------------------------
bool __cdecl sub_1007EEE0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v13 = &byte_105CB808[v12];
    v18 = sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_105CB008[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_105CB408[v12];
  v29 = v13;
  v14 = off_100F662C[a1];
  v24 = off_100F6624[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007F2E0) --------------------------------------------------------
bool __cdecl sub_1007F2E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, (char *)&unk_100CC178, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, (char *)&unk_100CC178, 4, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v18 = sub_1007DA20((int)&v31, (char *)&unk_100CC178, 4, 0xCu, (double)a8);
    v13 = &byte_105CB808[v12];
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_105CB008[v12];
  v28 = &byte_105CB408[v12];
  v29 = v13;
  v14 = off_100F6624[v17 != 0];
  v25 = off_100F662C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007F6A0) --------------------------------------------------------
bool __cdecl sub_1007F6A0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_1007AA60();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_1007B9C0() )
        v18 = v18 == 0;
      sub_1007DA20((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_105CB008[3072 * v21], 0x400u, &v33, a6);
      byte_105CB406[v13] = 42;
      byte_105CB407[v13] = 0;
      v19 = sub_1007DA20((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_105CB408[3072 * v21], 0x400u, &v33, a7);
      byte_105CB806[v13] = 42;
      byte_105CB807[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_105CB808[v13];
        byte_105CB808[v13] = 0;
      }
      else
      {
        v19 = sub_1007DA20((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_105CB808[v13];
        _snprintf(&byte_105CB808[v13], 0x400u, &v33, a8);
        byte_105CBC06[v13] = 42;
        byte_105CBC07[v13] = 0;
      }
      v22 = (&off_100F6634)[4 * a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_105CB008[3072 * v21];
      v30 = &byte_105CB408[3072 * v21];
      v15 = off_100F662C[a1];
      v26 = off_100F6624[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_1008FC60();
      sub_1007CE70(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_2(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_1007CF60(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1008FC70(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007FBE0) --------------------------------------------------------
bool __cdecl sub_1007FBE0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v13 = &byte_105CB808[v12];
    v18 = sub_1007DA20((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_105CB008[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_105CB408[v12];
  v29 = v13;
  v14 = off_100F662C[a1];
  v24 = off_100F6624[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (1007FFC0) --------------------------------------------------------
bool __cdecl sub_1007FFC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, (char *)&unk_100CC178, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, (char *)&unk_100CC178, 4, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v18 = sub_1007DA20((int)&v31, (char *)&unk_100CC178, 4, 0xCu, (double)a8);
    v13 = &byte_105CB808[v12];
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_105CB008[v12];
  v28 = &byte_105CB408[v12];
  v29 = v13;
  v14 = off_100F6624[v17 != 0];
  v25 = off_100F662C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (10080380) --------------------------------------------------------
bool __cdecl sub_10080380(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  unsigned int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v18 = sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_105CB808[v12];
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_100F6624[v17 != 0];
  v25 = off_100F662C[a1];
  v24 = v14;
  v27 = &byte_105CB008[v12];
  v28 = &byte_105CB408[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (10080720) --------------------------------------------------------
bool __cdecl sub_10080720(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v13 = &byte_105CB808[v12];
    v18 = sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_105CB008[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_105CB408[v12];
  v29 = v13;
  v14 = off_100F662C[a1];
  v24 = off_100F6624[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (10080B20) --------------------------------------------------------
bool __cdecl sub_10080B20(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  unsigned int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v18 = sub_1007DA20((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_105CB808[v12];
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_100F6624[v17 != 0];
  v25 = off_100F662C[a1];
  v24 = v14;
  v27 = &byte_105CB008[v12];
  v28 = &byte_105CB408[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (10080EC0) --------------------------------------------------------
bool __cdecl sub_10080EC0(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_1007AA60();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_1007B9C0() )
        v19 = v19 == 0;
      sub_1007DA20((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_105CB008[3072 * v22];
      _snprintf(&byte_105CB008[3072 * v22], 0x400u, &v35, a6);
      byte_105CB406[v13] = 42;
      byte_105CB407[v13] = 0;
      v20 = sub_1007DA20((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_105CB408[3072 * v22];
      _snprintf(&byte_105CB408[v13], 0x400u, &v35, a7);
      byte_105CB806[v13] = 42;
      byte_105CB807[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_105CB808[v13];
        byte_105CB808[v13] = 0;
      }
      else
      {
        v20 = sub_1007DA20((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_105CB808[v13];
        _snprintf(&byte_105CB808[v13], 0x400u, &v35, a8);
        byte_105CBC06[v13] = 42;
        byte_105CBC07[v13] = 0;
      }
      v24 = (&off_100F6634)[4 * a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_100F662C[a1];
      v28 = off_100F6624[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_1008FC60();
      sub_1007CE70(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_2(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_1007CF60(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1008FC70(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (100814A0) --------------------------------------------------------
bool __cdecl sub_100814A0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v13 = &byte_105CB808[v12];
    v18 = sub_1007DA20((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_105CB008[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_105CB408[v12];
  v29 = v13;
  v14 = off_100F662C[a1];
  v24 = off_100F6624[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (10081890) --------------------------------------------------------
bool __cdecl sub_10081890(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  unsigned int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1007AA60();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1007B9C0() )
    v17 = v17 == 0;
  sub_1007DA20((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_105CB008[v12], 0x400u, &v31, a6);
  byte_105CB406[v12] = 42;
  byte_105CB407[v12] = 0;
  v18 = sub_1007DA20((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_105CB408[v12], 0x400u, &v31, a7);
  byte_105CB806[v12] = 42;
  byte_105CB807[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_105CB808[v12];
    byte_105CB808[v12] = 0;
  }
  else
  {
    v18 = sub_1007DA20((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_105CB808[v12];
    _snprintf(&byte_105CB808[v12], 0x400u, &v31, a8);
    byte_105CBC06[v12] = 42;
    byte_105CBC07[v12] = 0;
  }
  v20 = (&off_100F6634)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_100F6624[v17 != 0];
  v25 = off_100F662C[a1];
  v24 = v14;
  v27 = &byte_105CB008[v12];
  v28 = &byte_105CB408[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1008FC60();
  sub_1007CE70(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_2(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1007CF60(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1008FC70(v15);
  return v17;
}
// 1007AA00: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD);
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (10081C30) --------------------------------------------------------
int sub_10081C30()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_1007AA60();
  sub_1007D980(1);
  sub_1007DD10(-1);
  result = sub_1007DCA0(-1);
  dword_105CEC08[v0] = 0;
  return result;
}
// 105CEC08: using guessed type int dword_105CEC08[];

//----- (10081C60) --------------------------------------------------------
BOOL __usercall sub_10081C60@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_1007AA60();
  sub_1008FCA0((int)&v13);
  sub_1008FCA0((int)&v14);
  sub_1008FCA0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10090910((int (__cdecl *)(unsigned int))sub_1007DC00, v7, (int)&v13) )
  {
    if ( sub_10090910((int (__cdecl *)(unsigned int))sub_1007DC00, a2, (int)&v14) )
    {
      v9 = sub_10090780(
             dword_105D0D14[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1007DC00,
             (void (__cdecl *)(_DWORD))sub_1007DC20,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10090BB0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_1008FD90((void (__cdecl *)(_DWORD))sub_1007DC20, (int)&v12);
  sub_1008FD90((void (__cdecl *)(_DWORD))sub_1007DC20, (int)&v13);
  sub_1008FD90((void (__cdecl *)(_DWORD))sub_1007DC20, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 105D0D14: using guessed type int dword_105D0D14[];

//----- (10081DD0) --------------------------------------------------------
bool __usercall sub_10081DD0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_1007AA60();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_1007B9C0() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_10080380(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_1007B9C0() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_105CB008[3072 * v24], 0x400u, "%s", v9);
  byte_105CB406[v15] = 42;
  byte_105CB407[v15] = 0;
  _snprintf(&byte_105CB408[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_100F6634)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_105CB806[v15] = 42;
  v17 = off_100F6624[v14 != 0];
  v18 = off_100F662C[a3];
  byte_105CB807[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_105CB008[3072 * v24];
  v34 = &byte_105CB408[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_1008FC60();
  sub_1007CE70(7, (int)&v26, v19);
  sub_1008FC70(v20);
  return v14;
}
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;

//----- (10082040) --------------------------------------------------------
char __cdecl sub_10082040(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_1007AA60();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_105D0D14[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_105D2330[v10];
  sub_1007D720(a3, 1, a6, 0x230u, &byte_105D2330[v10]);
  v27 = &byte_105CEC30[v10];
  sub_1007D720(a3, 2, a7, 0x230u, &byte_105CEC30[v10]);
  v24 = &byte_105D0210[v10];
  sub_1007D720(a3, 3, a6, 0x230u, &byte_105D0210[v10]);
  v26 = &byte_105D0D28[v10];
  sub_1007D720(a3, 4, a7, 0x230u, &byte_105D0D28[v10]);
  _snprintf(&byte_105D1818[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_105D1818[v10];
  byte_105D1A47[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1007D720(a3, 0, v25, 560 - (v11 - &byte_105D1818[v10 + 1]), &byte_105D1818[v10] + v11 - &byte_105D1818[v10 + 1]);
  v13 = &byte_105D1818[v10];
  byte_105D1A47[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_105D1814[v10] + v13 - &byte_105D1818[v10 + 1]) = 0;
  sub_1007D720(a3, 1, (int)&byte_105D1818[v10], 0x230u, &byte_105CA518[v10]);
  sub_1007D720(a3, 1, (int)&byte_105D1818[v10], 0x230u, &byte_105CF720[v10]);
  v15 = sub_10081C60(v22, v27, v21, a2 == 1, (int)&byte_105CA518[v10], (const char **)&v22);
  if ( sub_1007B9C0() )
    v15 = v15 == 0;
  v30 = (&off_100F6634)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_100F662C[a1];
  v34 = off_100F6624[v15 != 0];
  v17 = dword_105D0D14[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_1008FC60();
  sub_1007CE70(7, (int)&v30, v18);
  sub_1008FC70(v19);
  return v15;
}
// 100F6624: using guessed type char *off_100F6624[5];
// 100F662C: using guessed type char *off_100F662C[3];
// 100F6634: using guessed type char *off_100F6634;
// 105D0D14: using guessed type int dword_105D0D14[];

//----- (10082340) --------------------------------------------------------
bool __cdecl sub_10082340(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1007EB20(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (100823F0) --------------------------------------------------------
bool __cdecl sub_100823F0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_10081DD0(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (10082430) --------------------------------------------------------
const char *__cdecl sub_10082430(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (10082470) --------------------------------------------------------
char __cdecl sub_10082470(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_1007AA60();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_105D2E28 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1007D6D0((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_1007D1F0((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1007D6D0((int)v6, 0);
      return v5;
    case 4:
      sub_1007D070((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1007D3A0((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1007D680((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_1007D060((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_1007CA60((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_10082430((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1007D680((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1007D680((int)v6, v55);
        if ( v48 )
          sub_1007D680((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1007D680((int)v6, v55);
        if ( v48 )
          sub_1007D680((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], &word_100D1C0C, 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1007D680((int)v6, v55);
              if ( v48 )
                sub_1007D680((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1007D680((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1007D680((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1007D680((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1007D680((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_1007D2D0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_1007CD80((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_1007CE40((const void **)a2, a3)
          || (LOBYTE(v5) = sub_1007CC90((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_100C4192;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_100C4192;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_100C4192;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_100C4192;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_100C4192;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_100C4192;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_100C4192;
          v10 = sub_1007CD50((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_100C4192;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_1007CA90((const void **)a2, a3) )
      {
        dword_105D2E20 = 2;
        sub_1007D680((int)v6, (const char *)&word_100F78F4);
        sub_1007D680((int)v6, "   Command Format:\r\n");
        sub_1007D680(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1007D680(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1007D680(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1007D680(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1007D680((int)v6, "                                         strings depending upon the command\r\n");
        sub_1007D680((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1007D680(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1007D680(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1007D680((int)v6, (const char *)&word_100F78F4);
        sub_1007D680((int)v6, "   Notes:\r\n");
        sub_1007D680((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1007D680((int)v6, (const char *)&word_100F78F4);
        sub_1007D680(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1007D680(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1007D680(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1007D680((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1007D680((int)v6, (const char *)&word_100F78F4);
        sub_1007D680(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1007D680(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1007D680((int)v6, "       without a test suite name.\r\n");
        sub_1007D680((int)v6, (const char *)&word_100F78F4);
        sub_1007D680((int)v6, "   Examples:\r\n");
        sub_1007D680(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1007D680((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1007D680(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1007D680(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1007D680(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1007D680(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1007D680(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1007D680(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1007D680((int)v6, (const char *)&word_100F78F4);
        sub_1007D680((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1007D680(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_1007CB20((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, (const char *)&word_100F78F4);
        return v5;
      }
      if ( sub_1007CAF0((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_105D2E20,
          &unk_100C4192,
          &v58,
          6 - dword_105D2E20,
          word_100D2B44,
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, v55);
        return v5;
      }
      if ( sub_1007CB50((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_1007CB80((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_105D2E20 += 2;
          return v5;
        }
        if ( sub_1007CBC0((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_105D2E20 < 2 )
            dword_105D2E20 = 0;
          else
            dword_105D2E20 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_105D2E20,
          &unk_100C4192,
          a2[2],
          6 - dword_105D2E20,
          word_100D2B44,
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, v55);
        return v5;
      }
      if ( sub_1007CAC0((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_105D2E20,
          &unk_100C4192,
          a2[3],
          6 - dword_105D2E20,
          word_100D2B44,
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_1007CC30((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, v55);
      }
      else if ( sub_1007CC00((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_10082430((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1007D680((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1007D680((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1007D680((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_10082430((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1007D680((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1007D680((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1007D680((int)v6, v55);
      }
      LOBYTE(v5) = sub_1007D330((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1007D600((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1007D680((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 100D1C0C: using guessed type __int16 word_100D1C0C;
// 100F78F4: using guessed type __int16 word_100F78F4;
// 105D2E20: using guessed type int dword_105D2E20;
// 10082470: using guessed type char var_304[508];

//----- (10083220) --------------------------------------------------------
signed int __cdecl sub_10083220(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_105D2E28 + 580 * sub_1007AA60();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_1007D230(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (100832A0) --------------------------------------------------------
char **__cdecl sub_100832A0(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_105D2E28 + 580 * sub_1007AA60();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1007D440((int)v1, a1, (int)".txt");
  return &off_100F6CC8;
}
// 100F6CC8: using guessed type char *off_100F6CC8;

//----- (100832E0) --------------------------------------------------------
int (**sub_100832E0())()
{
  return off_100F79A8;
}
// 100F79A8: using guessed type int (*off_100F79A8[2])();

//----- (100832F0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100832F0(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_1007AA60();
  return sub_1007D680((int)&unk_105D3980 + 1812 * v1, a1);
}

//----- (10083310) --------------------------------------------------------
const char *sub_10083310()
{
  return "See version control for test execution date";
}

//----- (10083320) --------------------------------------------------------
__int64 sub_10083320()
{
  return 0i64;
}

//----- (10083330) --------------------------------------------------------
const char *sub_10083330()
{
  return "Not Available";
}

//----- (10083340) --------------------------------------------------------
int __usercall sub_10083340@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (10083390) --------------------------------------------------------
signed int __cdecl sub_10083390(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1007AA60();
  return sub_1007D230(a1, a2, (int)&unk_105D3980 + 1812 * v2);
}

//----- (100833C0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100833C0(_DWORD *a1))(int)
{
  _DWORD *v1; // esi@1
  unsigned __int8 *v2; // edi@1
  unsigned __int8 *v3; // eax@1

  v1 = a1;
  sub_100988F0((int)&a1[151 * (*a1 + 1)]);
  v2 = (unsigned __int8 *)sub_10083330();
  sub_10098A40((int)&v1[151 * (*v1 + 1)], (int)"StartTime", v2);
  sub_10098A40((int)&v1[151 * (*v1 + 1)], (int)"EndTime", v2);
  v3 = (unsigned __int8 *)sub_10083310();
  sub_10098A40((int)&v1[151 * (*v1 + 1)], (int)"ExecutionTime", v3);
  sub_10098A40((int)&v1[151 * (*v1 + 1)], (int)"NumCmds", (unsigned __int8 *)"N/A");
  sub_10098A40((int)&v1[151 * (*v1 + 1)], (int)"NumCmdFaults", (unsigned __int8 *)"N/A");
  sub_10098A80((int)&v1[151 * (*v1 + 1)], (int)"NumCompares", v1[4 * *v1 + 1] + v1[4 * *v1 + 2]);
  sub_10098A80((int)&v1[151 * (*v1 + 1)], (int)"NumCompareFails", v1[4 * *v1 + 1]);
  return sub_100988F0((int)&v1[151 * (*v1 + 1)]);
}

//----- (100834E0) --------------------------------------------------------
int __usercall sub_100834E0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  _DWORD *v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_100985A0((int)&a2[151 * (*a2 + 1)], (int)sub_100832F0, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_10083320();
  v4 = sub_1008F370("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_100989F0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_1008F370("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_100989F0((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_100989F0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_10098970((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_10098800((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_1008F370("CFG_OutputTestRevision", (int)"False");
  if ( !sub_1007AB10(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_10098A40((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_10098A40((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_10098970((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_10098970((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_10098A40((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1007D3A0(v3);
  sub_10098A40((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_100988F0((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_1008F330(i, &v15, &v16); ++i )
  {
    sub_10098970((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_10098A40((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_10098A40((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_100988F0((int)&a2[151 * (*a2 + 1)]);
  }
  sub_100988F0((int)&a2[151 * (*a2 + 1)]);
  sub_10098970((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_10098800((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = &a2[4 * *a2 + 1];
  *v14 = 0;
  v14[1] = 0;
  v14[2] = 0;
  v14[3] = 0;
  return result;
}
// 100834E0: using guessed type char var_103[253];

//----- (10083860) --------------------------------------------------------
char __cdecl sub_10083860(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_1007AA60();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_105D3980 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_1007CDE0(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_10083340(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_10098970(v8, (int)"Req");
            sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_1007CDB0(a2, a3) )
      {
        if ( sub_1007D540((int)v5, 3, 1, 0) )
          sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_100988F0(v12);
          sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_10098800(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1007CCF0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10098A40(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_1007CE10(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10098A40(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1007CD80(a2, a3) )
      {
        if ( sub_1007D540((int)v5, 3, 1, 0) )
          sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1007D4B0((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_1007CD20(a2, a3) )
      {
        sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_10098800(v13, (int)"success", (unsigned __int8 *)&word_100D1C0C);
          sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_10098800(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1007D540((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_1007CCC0(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1007D5F0((int)v5) )
            sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_10098A40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1007D540((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_1007D070((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_100834E0((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_1007D060((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_10098A40(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_10098A40(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_10098A40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1007D5F0((int)v5) )
        sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_1007CC60((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_100988A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_10098A40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_1007CA60((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_10098850((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_10098850((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_10098850((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_100F3010, 3u) )
              v44 = (const char *)&unk_100C4192;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], &word_100D1C0C, 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_10098970(v19, (int)"Expected");
          sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1007D540((int)v5, 8, 1, 0) )
        sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_1007D2D0((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1007D330((int)v5, (void (__cdecl *)(int))sub_100833C0);
      return v4;
    case 0:
    case 11:
      sub_1007D6D0((int)v5, (void (__cdecl *)(int))sub_100833C0);
      goto LABEL_139;
    case 1:
      sub_1007D1F0((int)v5);
      goto LABEL_139;
    case 12:
      sub_1007D600((int)v5, (void (__cdecl *)(int))sub_100833C0);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_10098970((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_10098800((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1007D540((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_100988F0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 100D1C0C: using guessed type __int16 word_100D1C0C;
// 10083860: using guessed type char var_104[255];

//----- (10084680) --------------------------------------------------------
char **__cdecl sub_10084680(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_105D3980 + 1812 * sub_1007AA60();
  *((_DWORD *)v1 + 146) = 0;
  sub_1007D440((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_100985A0(v2, (int)sub_100832F0, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_100F7A58;
}
// 100F7A58: using guessed type char *off_100F7A58;

//----- (100846F0) --------------------------------------------------------
int sub_100846F0()
{
  int result; // eax@1

  sub_1009B8D0(6361, (int)&unk_105D5CE4, 4);
  result = sub_1009B8D0(6362, (int)&unk_105D5CE8, 4);
  dword_105D5CEC = 1379255385;
  return result;
}
// 105D5CEC: using guessed type int dword_105D5CEC;

//----- (10084720) --------------------------------------------------------
char __thiscall sub_10084720(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_105D5CF0 = sub_100704E0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_105D5CF8, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_105D5CF8;
  do
  {
    result = sub_1008E680(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 105D5CF0: using guessed type int dword_105D5CF0;

//----- (10084790) --------------------------------------------------------
char __usercall sub_10084790@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_100744D0(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_100744D0(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (100847D0) --------------------------------------------------------
void *__usercall sub_100847D0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_105D5CF0 == 1379255385 )
    goto LABEL_4;
  v4 = sub_1009B5D0(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_105D5CF8 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_1008E680(a1, (int)&unk_105D5CF8 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_105D5CF8 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_105D5CF0 != 1379255385 )
    result = (void *)sub_1009B5A0(v4, 86);
  return result;
}
// 105D5CF0: using guessed type int dword_105D5CF0;

//----- (10084870) --------------------------------------------------------
char __cdecl sub_10084870(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10084790(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (100848B0) --------------------------------------------------------
bool __cdecl sub_100848B0(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_100847D0(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10084910) --------------------------------------------------------
char __cdecl sub_10084910(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10084790(a2, 1, a3, a1);
  return result;
}

//----- (10084950) --------------------------------------------------------
char __cdecl sub_10084950(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_100847D0(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10084980) --------------------------------------------------------
char __cdecl sub_10084980(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10084790(a2 + 10, 1, a3, a1);
  return result;
}

//----- (100849C0) --------------------------------------------------------
char __cdecl sub_100849C0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_100847D0(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10084A00) --------------------------------------------------------
char __cdecl sub_10084A00(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10084790(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10084A40) --------------------------------------------------------
bool __cdecl sub_10084A40(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_100847D0(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10084A90) --------------------------------------------------------
char __cdecl sub_10084A90(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10084790(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10084AD0) --------------------------------------------------------
bool __cdecl sub_10084AD0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_100847D0(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10084B10) --------------------------------------------------------
char __cdecl sub_10084B10(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10084790(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10084B50) --------------------------------------------------------
bool __cdecl sub_10084B50(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_100847D0(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10084B90) --------------------------------------------------------
char __cdecl sub_10084B90(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10084790(1229, 1, a2, a1);
  return result;
}

//----- (10084BC0) --------------------------------------------------------
char __cdecl sub_10084BC0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100847D0(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10084BF0) --------------------------------------------------------
char __cdecl sub_10084BF0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10084790(1212, 16, a2, a1);
  return result;
}

//----- (10084C20) --------------------------------------------------------
char __cdecl sub_10084C20(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100847D0(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10084C50) --------------------------------------------------------
char __cdecl sub_10084C50(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10084790(2400, 65, a2, a1);
  return result;
}

//----- (10084C80) --------------------------------------------------------
char __cdecl sub_10084C80(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100847D0(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10084CB0) --------------------------------------------------------
char __cdecl sub_10084CB0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10084790(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10084CF0) --------------------------------------------------------
char __cdecl sub_10084CF0(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10070AD0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_100847D0(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10084D40) --------------------------------------------------------
char __cdecl sub_10084D40(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10084790(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10084D80) --------------------------------------------------------
char __cdecl sub_10084D80(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_100847D0(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10084DB0) --------------------------------------------------------
char __cdecl sub_10084DB0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10084790(22, 1, a2, a1);
  return result;
}

//----- (10084DE0) --------------------------------------------------------
char __cdecl sub_10084DE0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10084790(832, 4, a2, a1);
  return result;
}

//----- (10084E10) --------------------------------------------------------
char __cdecl sub_10084E10(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100847D0(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10084E40) --------------------------------------------------------
char __cdecl sub_10084E40(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10098AE0(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10084CF0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10084CB0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10084D80(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10084D40(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_100848B0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10084870(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10084AD0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10084A90(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10084B50(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10084B10(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10084950(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10084910(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_100849C0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10084980(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10084DB0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10084C20(v6, a5);
        else
          result = sub_10084BF0(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10084A40(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10084A00(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10084C80(v6, a5);
        else
          result = sub_10084C50(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10084BC0(v6, a5);
        else
          result = sub_10084B90(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10084E10(v6, a5);
        else
          result = sub_10084DE0(v6, a5);
        break;
      default:
        sub_10070AD0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 1009C350: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100851E0) --------------------------------------------------------
signed int __fastcall sub_100851E0(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (100851F0) --------------------------------------------------------
char __cdecl sub_100851F0(unsigned __int8 a1)
{
  return byte_100F895C[6 * sub_100851E0(a1)];
}

//----- (10085210) --------------------------------------------------------
__int16 __cdecl sub_10085210(unsigned __int8 a1)
{
  return word_100F8958[3 * sub_100851E0(a1)];
}
// 100F8958: using guessed type __int16 word_100F8958[];

//----- (10085230) --------------------------------------------------------
signed int __usercall sub_10085230@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100F9980[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100F8D80[2 * (unsigned __int8)v68] ^ dword_100F9180[2 * BYTE1(v65)] ^ dword_100F9580[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100F9980[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100F9980[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100F9980[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100F9980[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100F9980[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100F9980[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100F9980[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100F9980[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100F9980[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100F9D80[(unsigned __int8)v57] ^ dword_100FA980[v58 >> 24] ^ dword_100FA180[BYTE1(v59)] ^ dword_100FA580[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100F9D80[(unsigned __int8)v59] ^ dword_100FA580[(unsigned __int8)(v58 >> 16)] ^ dword_100FA980[v57 >> 24] ^ dword_100FA180[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100F9D80[(unsigned __int8)v60] ^ dword_100FA180[BYTE1(v58)] ^ dword_100FA580[(unsigned __int8)(v57 >> 16)] ^ dword_100FA980[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100F9D80[(unsigned __int8)v58] ^ dword_100FA180[BYTE1(v57)] ^ dword_100FA580[(unsigned __int8)(v59 >> 16)] ^ dword_100FA980[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100F9980[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100F9980[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100F9980[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100F9980[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100F9980[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100F8D80[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100F9180[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100F9580[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100F9980[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100F9D80: using guessed type int dword_100F9D80[];
// 100FA180: using guessed type int dword_100FA180[];
// 100FA580: using guessed type int dword_100FA580[];
// 100FA980: using guessed type int dword_100FA980[];

//----- (100862E0) --------------------------------------------------------
int __usercall sub_100862E0@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10085230(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10086340) --------------------------------------------------------
signed int __usercall sub_10086340@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100FA980[(unsigned __int8)v9] ^ dword_100F9D80[BYTE1(v9)] ^ dword_100FA180[(unsigned __int8)(v9 >> 16)] ^ dword_100FA580[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100FA980[(unsigned __int8)v129] ^ dword_100F9D80[BYTE1(v129)] ^ dword_100FA180[(unsigned __int8)(v129 >> 16)] ^ dword_100FA580[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100FA980[(unsigned __int8)v133] ^ dword_100F9D80[BYTE1(v133)] ^ dword_100FA180[(unsigned __int8)(v133 >> 16)] ^ dword_100FA580[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100FA980[(unsigned __int8)v137] ^ dword_100F9D80[BYTE1(v137)] ^ dword_100FA180[(unsigned __int8)(v137 >> 16)] ^ dword_100FA580[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100FA980[(unsigned __int8)v141] ^ dword_100F9D80[BYTE1(v141)] ^ dword_100FA180[(unsigned __int8)(v141 >> 16)] ^ dword_100FA580[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100FA980[(unsigned __int8)v145] ^ dword_100F9D80[BYTE1(v145)] ^ dword_100FA180[(unsigned __int8)(v145 >> 16)] ^ dword_100FA580[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100FA980[(unsigned __int8)v149] ^ dword_100F9D80[BYTE1(v149)] ^ dword_100FA180[(unsigned __int8)(v149 >> 16)] ^ dword_100FA580[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100FA980[(unsigned __int8)v153] ^ dword_100F9D80[BYTE1(v153)] ^ dword_100FA180[(unsigned __int8)(v153 >> 16)] ^ dword_100FA580[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100FA980[(unsigned __int8)v157] ^ dword_100F9D80[BYTE1(v157)] ^ dword_100FA180[(unsigned __int8)(v157 >> 16)] ^ dword_100FA580[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100FA980[(unsigned __int8)v161] ^ dword_100F9D80[BYTE1(v161)] ^ dword_100FA180[(unsigned __int8)(v161 >> 16)] ^ dword_100FA580[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100FA980[(unsigned __int8)v77] ^ dword_100F9D80[BYTE1(v77)] ^ dword_100FA180[(unsigned __int8)(v77 >> 16)] ^ dword_100FA580[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100FA980[(unsigned __int8)v82] ^ dword_100F9D80[BYTE1(v82)] ^ dword_100FA180[(unsigned __int8)(v82 >> 16)] ^ dword_100FA580[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100FA980[(unsigned __int8)v89] ^ dword_100F9D80[BYTE1(v89)] ^ dword_100FA180[(unsigned __int8)(v89 >> 16)] ^ dword_100FA580[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100FA980[(unsigned __int8)v94] ^ dword_100F9D80[BYTE1(v94)] ^ dword_100FA180[(unsigned __int8)(v94 >> 16)] ^ dword_100FA580[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100FA980[(unsigned __int8)v100] ^ dword_100F9D80[BYTE1(v100)] ^ dword_100FA180[(unsigned __int8)(v100 >> 16)] ^ dword_100FA580[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100FA980[(unsigned __int8)v100] ^ dword_100F9D80[BYTE1(v100)] ^ dword_100FA180[(unsigned __int8)(v100 >> 16)] ^ dword_100FA580[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100FA980[(unsigned __int8)v108] ^ dword_100F9D80[BYTE1(v108)] ^ dword_100FA180[(unsigned __int8)(v108 >> 16)] ^ dword_100FA580[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100FA980[(unsigned __int8)v114] ^ dword_100F9D80[BYTE1(v114)] ^ dword_100FA180[(unsigned __int8)(v114 >> 16)] ^ dword_100FA580[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100FA980[(unsigned __int8)v120] ^ dword_100F9D80[BYTE1(v120)] ^ dword_100FA180[(unsigned __int8)(v120 >> 16)] ^ dword_100FA580[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100FA980[(unsigned __int8)v19] ^ dword_100F9D80[BYTE1(v19)] ^ dword_100FA180[(unsigned __int8)(v19 >> 16)] ^ dword_100FA580[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100F9D80[(unsigned __int8)v23] ^ dword_100FA180[BYTE1(v23)] ^ dword_100FA580[(unsigned __int8)(v23 >> 16)] ^ dword_100FA980[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100FA980[(unsigned __int8)v26] ^ dword_100F9D80[BYTE1(v26)] ^ dword_100FA180[(unsigned __int8)(v26 >> 16)] ^ dword_100FA580[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100F9D80[(unsigned __int8)v31] ^ dword_100FA180[BYTE1(v31)] ^ dword_100FA580[(unsigned __int8)(v31 >> 16)] ^ dword_100FA980[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100FA980[(unsigned __int8)v35] ^ dword_100F9D80[BYTE1(v35)] ^ dword_100FA180[(unsigned __int8)(v35 >> 16)] ^ dword_100FA580[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100F9D80[(unsigned __int8)v41] ^ dword_100FA180[BYTE1(v41)] ^ dword_100FA580[(unsigned __int8)(v41 >> 16)] ^ dword_100FA980[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100FA980[(unsigned __int8)v43] ^ dword_100F9D80[BYTE1(v43)] ^ dword_100FA180[(unsigned __int8)(v43 >> 16)] ^ dword_100FA580[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100F9D80[(unsigned __int8)v47] ^ dword_100FA180[BYTE1(v47)] ^ dword_100FA580[(unsigned __int8)(v47 >> 16)] ^ dword_100FA980[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100FA980[(unsigned __int8)v52] ^ dword_100F9D80[BYTE1(v52)] ^ dword_100FA180[(unsigned __int8)(v52 >> 16)] ^ dword_100FA580[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100F9D80[(unsigned __int8)v58] ^ dword_100FA180[BYTE1(v58)] ^ dword_100FA580[(unsigned __int8)(v58 >> 16)] ^ dword_100FA980[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100FA980[(unsigned __int8)v60] ^ dword_100F9D80[BYTE1(v60)] ^ dword_100FA180[(unsigned __int8)(v60 >> 16)] ^ dword_100FA580[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100F9D80[(unsigned __int8)v66] ^ dword_100FA180[BYTE1(v66)] ^ dword_100FA580[(unsigned __int8)(v66 >> 16)] ^ dword_100FA980[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100FA980[(unsigned __int8)v69] ^ dword_100F9D80[BYTE1(v69)] ^ dword_100FA180[(unsigned __int8)(v69 >> 16)] ^ dword_100FA580[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100F9D80: using guessed type int dword_100F9D80[];
// 100FA180: using guessed type int dword_100FA180[];
// 100FA580: using guessed type int dword_100FA580[];
// 100FA980: using guessed type int dword_100FA980[];

//----- (100870C0) --------------------------------------------------------
void *__usercall sub_100870C0@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (100870E0) --------------------------------------------------------
unsigned int __cdecl sub_100870E0(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_1009B2D0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 1009B370: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10087140) --------------------------------------------------------
int __usercall sub_10087140@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = &unk_10325476;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (10087180) --------------------------------------------------------
int __usercall sub_10087180@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (100888A0) --------------------------------------------------------
unsigned int __usercall sub_100888A0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100FADA8[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100FADB8[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_10087180(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_10087180(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100FADA8: using guessed type int dword_100FADA8[];
// 100FADB8: using guessed type int dword_100FADB8[];

//----- (100889A0) --------------------------------------------------------
void *__usercall sub_100889A0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  char *v3; // ebp@1
  unsigned int v4; // ebx@1
  int v5; // edi@1
  size_t v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (char *)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*((_DWORD *)v3 + 1);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy(&v3[v5 + 28], v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_10087180((int)v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy(&v3[v5 + 28], v9, v4);
}

//----- (10088A20) --------------------------------------------------------
void *__usercall sub_10088A20@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_100888A0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10087140(v3 + 64);
    result = sub_100889A0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_100889A0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10088AC0) --------------------------------------------------------
int __usercall sub_10088AC0@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10088A20(a1, 0, 0);
  sub_100888A0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10087140(a1 + 64);
  sub_100889A0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_100889A0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_100888A0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (10088B80) --------------------------------------------------------
int __usercall sub_10088B80@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10087140(a2 + 64);
    sub_100889A0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_100889A0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10088BE0) --------------------------------------------------------
int __usercall sub_10088BE0@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  char *v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = &a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_10087180((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *((_DWORD *)v8 + 1) = v9;
    v12 = v18;
    *((_DWORD *)v8 + 2) = result;
    v1 += 20;
    *((_DWORD *)v8 + 3) = v11;
    *((_DWORD *)v8 + 4) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10088BE0: using guessed type char var_40[64];

//----- (10088CA0) --------------------------------------------------------
int __usercall sub_10088CA0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10088BE0((char *)a1);
  return sub_10088BE0(v8);
}

//----- (10088D60) --------------------------------------------------------
char __cdecl sub_10088D60(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10088A20(a3 + 296, a2, a1);
    sub_100862E0(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10088DB0) --------------------------------------------------------
char __cdecl sub_10088DB0(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_100862E0(a3, (int)a1, a2);
    sub_10088A20(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10088E00) --------------------------------------------------------
bool __cdecl sub_10088E00(int a1, int a2)
{
  if ( a2 )
    sub_10088AC0(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (10088E30) --------------------------------------------------------
unsigned int __usercall sub_10088E30@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  unsigned int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_100870C0(&v24);
  sub_10088B80(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10088A20((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10088A20((int)&v23, v12, (char *)&v31);
          sub_10088AC0((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 10088E30: using guessed type char var_14[16];

//----- (10089040) --------------------------------------------------------
int __usercall sub_10089040@<eax>(void *a1@<eax>, int a2)
{
  char *v2; // ebx@1
  signed int v3; // esi@1

  v2 = (char *)a1;
  memset(a1, 0, 0x210u);
  *((_DWORD *)v2 + 131) = a2;
  sub_10088CA0((int)v2);
  v3 = 20;
  do
  {
    sub_10088BE0(v2);
    --v3;
  }
  while ( v3 );
  return sub_10088CA0((int)v2);
}

//----- (10089090) --------------------------------------------------------
char *__cdecl sub_10089090(int a1, int a2)
{
  char *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10088CA0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (10089120) --------------------------------------------------------
signed int __cdecl sub_10089120(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_10088E30(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10086340(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_100870C0((void *)(a6 + 296));
      sub_10088B80(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 10089120: using guessed type char var_40[8];
// 10089120: using guessed type __int16 var_38[26];

//----- (10089250) --------------------------------------------------------
bool __cdecl sub_10089250(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_10089040(&v4, (int)sub_100870E0);
  if ( v2 )
    sub_10089090(a2, (int)&v4);
  return v2;
}

//----- (100892D0) --------------------------------------------------------
BOOL __usercall sub_100892D0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100FB5C0[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100FB4C0[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100FB3C0[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (10089370) --------------------------------------------------------
int __usercall sub_10089370@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10089400) --------------------------------------------------------
unsigned int __fastcall sub_10089400(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (10089420) --------------------------------------------------------
int __usercall sub_10089420@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (100894B0) --------------------------------------------------------
int __usercall sub_100894B0@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100FB5C0[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100FB5C0[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100FADC8[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100FB6C0[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100FB4C0[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100FB3C0[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100FAE50[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100FB738[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100FADC8: using guessed type int dword_100FADC8[];
// 100FAE50: using guessed type int dword_100FAE50[];
// 100FB6C0: using guessed type int dword_100FB6C0[];
// 100FB738: using guessed type int dword_100FB738[];

//----- (10089930) --------------------------------------------------------
int __usercall sub_10089930@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_10089420(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (100899E0) --------------------------------------------------------
void *__usercall sub_100899E0@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10089A40) --------------------------------------------------------
int __usercall sub_10089A40@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10089C10) --------------------------------------------------------
signed int __usercall sub_10089C10@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10089400(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10089C90) --------------------------------------------------------
_WORD *__fastcall sub_10089C90(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10089D00) --------------------------------------------------------
signed int __usercall sub_10089D00@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 5764);
  v2 = *(_DWORD *)(a1 + 5736);
  *(_DWORD *)(a1 + 5744) = 2 * *(_DWORD *)(a1 + 5748);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 5736), 0, 2 * *(_DWORD *)(a1 + 5764) - 2);
  v3 = 6 * *(_BYTE *)(a1 + 5784);
  *(_DWORD *)(a1 + 5700) = (unsigned __int16)word_100FB7B2[6 * *(_BYTE *)(a1 + 5784)];
  *(_DWORD *)(a1 + 5704) = (unsigned __int16)word_100FB7B0[v3];
  *(_DWORD *)(a1 + 5708) = (unsigned __int16)word_100FB7B4[v3];
  v4 = (unsigned __int16)word_100FB7B6[v3];
  result = 2;
  *(_DWORD *)(a1 + 5680) = 0;
  *(_DWORD *)(a1 + 5664) = 0;
  *(_DWORD *)(a1 + 5688) = 0;
  *(_DWORD *)(a1 + 5676) = 0;
  *(_DWORD *)(a1 + 5760) = 0;
  *(_DWORD *)(a1 + 5696) = v4;
  *(_DWORD *)(a1 + 5692) = 2;
  *(_DWORD *)(a1 + 5668) = 2;
  return result;
}
// 100FB7B0: using guessed type __int16 word_100FB7B0[];
// 100FB7B2: using guessed type __int16 word_100FB7B2[];
// 100FB7B4: using guessed type __int16 word_100FB7B4[];
// 100FB7B6: using guessed type __int16 word_100FB7B6[];

//----- (10089DC0) --------------------------------------------------------
unsigned int __usercall sub_10089DC0@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10089F70) --------------------------------------------------------
unsigned int __usercall sub_10089F70@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (1008A040) --------------------------------------------------------
int __usercall sub_1008A040@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (1008A0F0) --------------------------------------------------------
int __usercall sub_1008A0F0@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (1008A130) --------------------------------------------------------
unsigned int __usercall sub_1008A130@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_1008C1A0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1008A190) --------------------------------------------------------
signed int __usercall sub_1008A190@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (1008A270) --------------------------------------------------------
int __usercall sub_1008A270@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (1008A810) --------------------------------------------------------
_WORD *__fastcall sub_1008A810(int a1, int a2)
{
  *(_DWORD *)(a2 + 5628) = a2 + 2936;
  *(_DWORD *)(a2 + 5652) = a2 + 5472;
  *(_DWORD *)(a2 + 5636) = &off_100FB964;
  *(_DWORD *)(a2 + 5640) = a2 + 5228;
  *(_DWORD *)(a2 + 5648) = &off_100FB978;
  *(_DWORD *)(a2 + 5660) = &unk_100FB98C;
  *(_WORD *)(a2 + 2924) = 0;
  *(_DWORD *)(a2 + 2932) = 0;
  *(_DWORD *)(a2 + 2928) = 8;
  return sub_10089C90(a2 + 5228, a2);
}
// 100FB964: using guessed type void *off_100FB964;
// 100FB978: using guessed type void *off_100FB978;

//----- (1008A870) --------------------------------------------------------
signed int __cdecl sub_1008A870(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  int v3; // ecx@5
  signed int result; // eax@5

  if ( a1 && (v1 = *(_DWORD *)(a1 + 24)) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(v1 + 5808) = *(_DWORD *)(v1 + 5800);
    v2 = *(_DWORD *)(v1 + 5780);
    *(_DWORD *)(v1 + 5812) = 0;
    if ( v2 < 0 )
      *(_DWORD *)(v1 + 5780) = -v2;
    *(_DWORD *)(v1 + 5788) = *(_DWORD *)(v1 + 5780) != 0 ? 42 : 113;
    *(_DWORD *)(a1 + 28) = sub_1008C1A0(0, 0, 0);
    *(_DWORD *)(v1 + 5792) = 0;
    sub_1008A810(v3, v1);
    sub_10089D00(v1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1008A900) --------------------------------------------------------
int __usercall sub_1008A900@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_10089370(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_10089370(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_10089370(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (1008AB40) --------------------------------------------------------
int __usercall sub_1008AB40@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10089930(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10089930(a1, a3, a4);
  }
  return result;
}

//----- (1008ABE0) --------------------------------------------------------
signed int __usercall sub_1008ABE0@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_1008A040(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_1008A040(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_1008A040(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10089A40(a1, a2);
  return sub_10089C10(a1, v16, v5);
}

//----- (1008ADC0) --------------------------------------------------------
unsigned int __usercall sub_1008ADC0@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_1008A130(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (1008AF00) --------------------------------------------------------
int __usercall sub_1008AF00@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100FAE3C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_1008A270(a1, a1 + 2936, a2 - 1);
  return sub_1008A270(v24, v24 + 5228, a3 - 1);
}

//----- (1008B1B0) --------------------------------------------------------
signed int __cdecl sub_1008B1B0(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_1008A0F0(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_1008A0F0(v9, *(_WORD *)(a1 + 30));
      sub_1008A0F0(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_1008C1A0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_100899E0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100FB7B8 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_1008A900(v2);
    }
    else
    {
      sub_1008AB40(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_100899E0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_1008A0F0(v2, *(_WORD *)(a1 + 30));
    sub_1008A0F0(v13, *(_WORD *)(a1 + 28));
    sub_100899E0(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100FB7B8: using guessed type int (__cdecl *off_100FB7B8)(int, int);

//----- (1008B470) --------------------------------------------------------
signed int __cdecl sub_1008B470(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  signed int v8; // edx@1
  int v9; // eax@5
  unsigned int v10; // edi@12
  signed int v11; // ebp@12
  signed int v12; // eax@12
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // esi@14
  int v16; // esi@14
  signed int result; // eax@14

  v8 = 1;
  if ( a1 && a7 )
  {
    if ( a2 == -1 )
      a2 = 6;
    v9 = a4;
    if ( a4 < 0 )
    {
      v8 = 0;
      v9 = -a4;
      a4 = -a4;
    }
    if ( (unsigned int)(a5 - 1) > 7 || a3 != 8 || (unsigned int)(v9 - 9) > 6 || a2 > 9u || a6 > 3u )
    {
      result = -2;
    }
    else
    {
      v10 = 1 << (a5 + 6);
      v11 = 1 << v9;
      v12 = 1 << (a5 + 7);
      if ( (signed int)(2 * (v12 + 2 * (v10 + v11) + 2908)) > a8 || a7 & 3 )
      {
        result = -4;
      }
      else
      {
        *(_DWORD *)(a1 + 24) = a7;
        *(_DWORD *)(a7 + 5780) = v8;
        *(_DWORD *)(a7 + 5764) = v12;
        *(_DWORD *)(a7 + 5752) = a4;
        *(_DWORD *)(a7 + 5768) = a5 + 7;
        *(_DWORD *)(a7 + 5772) = v12 - 1;
        *(_DWORD *)(a7 + 5756) = v11 - 1;
        *(_DWORD *)(a7 + 5748) = v11;
        *(_DWORD *)(a7 + 5740) = a7 + 5816;
        v13 = 2 * v11;
        v14 = v13 + a7 + 5816;
        *(_DWORD *)(a7 + 5732) = v14;
        v15 = v13 + v14;
        *(_DWORD *)(a7 + 5776) = (a5 + 9) / 3u;
        *(_DWORD *)(a7 + 5736) = v15;
        v16 = v15 + 2 * (1 << (a5 + 7));
        *(_DWORD *)(a7 + 5804) = 4 * v10;
        *(_DWORD *)(a7 + 5716) = v10 + v16 + 2 * v10;
        *(_DWORD *)(a7 + 5712) = v16 + 2 * (v10 >> 1);
        *(_DWORD *)(a7 + 5724) = v10;
        *(_DWORD *)(a7 + 5800) = v16;
        *(_BYTE *)(a7 + 5784) = a2;
        *(_BYTE *)(a7 + 5796) = a6;
        *(_BYTE *)(a7 + 5720) = 8;
        result = sub_1008A870(a1);
      }
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1008B620) --------------------------------------------------------
signed int __usercall sub_1008B620@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_1008A190(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_1008A190(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_1008ABE0(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100FAE3C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100FAE3B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100FAE3A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100FAE39[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (1008B6F0) --------------------------------------------------------
_WORD *__usercall sub_1008B6F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_1008ABE0(a2, a2 + 5628);
  sub_1008ABE0(v4, v4 + 5640);
  v8 = sub_1008B620(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_1008AB40(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_100894B0(v4, (int)&unk_100FAEC8, (int)&unk_100FB348);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_1008AF00(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_100894B0(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10089C90(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_10089420(v4);
  return result;
}

//----- (1008B910) --------------------------------------------------------
signed int __cdecl sub_1008B910(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1008ADC0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10089DC0(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10089F70(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_100892D0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_100892D0(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_1008B6F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_100899E0(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_1008B6F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_100899E0(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1008BC20) --------------------------------------------------------
signed int __cdecl sub_1008BC20(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1008ADC0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10089DC0(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10089F70(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_100892D0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_1008B6F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_100899E0(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_100892D0(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_1008B6F0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_100899E0(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_100892D0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_1008B6F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_100899E0(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1008C030) --------------------------------------------------------
signed int __cdecl sub_1008C030(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_1008ADC0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_1008B6F0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_100899E0(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_1008B6F0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_100899E0(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_1008B6F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_100899E0(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1008C1A0) --------------------------------------------------------
_BYTE *__cdecl sub_1008C1A0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  _BYTE *result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = (_BYTE *)(v4 | (v5 << 16));
  }
  else
  {
    result = a2 + 1;
  }
  return result;
}

//----- (1008C2A0) --------------------------------------------------------
signed int __cdecl sub_1008C2A0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1008C2C0) --------------------------------------------------------
signed int __usercall sub_1008C2C0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 1008C2C0: using guessed type int var_78[14];
// 1008C2C0: using guessed type int var_3C[15];

//----- (1008C760) --------------------------------------------------------
int (__cdecl *__usercall sub_1008C760@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (1008C7B0) --------------------------------------------------------
int __usercall sub_1008C7B0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (1008C7D0) --------------------------------------------------------
signed int __cdecl sub_1008C7D0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100FB9A0[a1];
  v51 = dword_100FB9A0[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100FB9A0[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100FB9A0[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100FB9A0[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100FB9A0[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100FB9A0: using guessed type int dword_100FB9A0[];

//----- (1008CB80) --------------------------------------------------------
int __usercall sub_1008CB80@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (1008CCC0) --------------------------------------------------------
signed int __usercall sub_1008CCC0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_1008C2C0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (1008CD10) --------------------------------------------------------
signed int __usercall sub_1008CD10@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_1008C2C0(a7, a6, a4, 257, (int)&unk_100FBA38, (int)&unk_100FBAB8, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_1008C2C0(a8, &a6[a4], a5, 0, (int)&unk_100FBB38, (int)&unk_100FBBB0, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1008CDB0) --------------------------------------------------------
int __usercall sub_1008CDB0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100FBC28;
  *a4 = &unk_100FCC28;
  return 0;
}

//----- (1008CDD0) --------------------------------------------------------
signed int __cdecl sub_1008CDD0(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@12
  int v5; // esi@12
  int v6; // ecx@1
  signed int v7; // ebx@1
  signed int result; // eax@9

  v6 = a2;
  v7 = 0;
  if ( a2 < 0 )
  {
    v7 = 1;
    v6 = -a2;
  }
  if ( (1 << v6) + 14152 > a4 || a3 & 3 )
  {
    result = -4;
  }
  else
  {
    *(_DWORD *)(a1 + 24) = a3;
    *(_DWORD *)(a3 + 16) = v6;
    *(_DWORD *)(a3 + 12) = v7;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 20) = a3 + 24;
    *(_DWORD *)(a3 + 14128) = a3 + 14152;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14108) = (1 << v6) + *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14104);
    **(_BYTE **)(a3 + 20) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1428) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1424) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14124) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1420) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14112) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14116) = 0;
    if ( *(_DWORD *)(a3 + 12) )
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = 0;
    else
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = sub_1008C1A0;
    sub_1008C760(0, *(_DWORD *)(a3 + 20), a1);
    if ( a1 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      v5 = *(_DWORD *)(v4 + 20);
      *(_BYTE *)v4 = *(_DWORD *)(v4 + 12) != 0 ? 7 : 0;
      sub_1008C760(0, v5, a1);
      result = 0;
    }
    else
    {
      result = -2;
    }
  }
  return result;
}

//----- (1008CEC0) --------------------------------------------------------
void __cdecl sub_1008CEC0(int a1)
{
  JUMPOUT(&loc_1008CC80);
}

//----- (1008CED0) --------------------------------------------------------
int __usercall sub_1008CED0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  signed int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_1008C7D0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100FB9A0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100FB9A0[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100FB9A0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100FB9A0[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_1008CB80(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_1008CB80(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_1008CB80(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_1008CB80(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100FB9A0: using guessed type int dword_100FB9A0[];

//----- (1008D570) --------------------------------------------------------
int __usercall sub_1008D570@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  signed int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_1008CDB0(&v67, &v69, &v66, &v68);
          sub_1008C7B0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_1008CB80(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100FB9E8[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100FB9E8[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_1008CCC0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_1008CD10(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_1008C7B0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_1008CED0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_1008CB80(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_1008CB80(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_1008CB80(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100FB9A0[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100FB9A0[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_1008CB80(v7, v3, v58);
}
// 100FB9A0: using guessed type int dword_100FB9A0[];
// 100FB9E8: using guessed type int dword_100FB9E8[];

//----- (1008DF50) --------------------------------------------------------
signed int __usercall sub_1008DF50@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_1008D570(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_1008C760((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1008E280) --------------------------------------------------------
signed int __cdecl sub_1008E280(int a1, int a2)
{
  return sub_1008DF50(a1, a2);
}

//----- (1008E2A0) --------------------------------------------------------
int __cdecl sub_1008E2A0(unsigned __int8 *a1)
{
  return sub_10076340(a1, 0, 0, 0, 0);
}

//----- (1008E2C0) --------------------------------------------------------
signed int __cdecl sub_1008E2C0(void *a1)
{
  return sub_100762E0(a1, 0xCu, 0);
}

//----- (1008E2E0) --------------------------------------------------------
signed int __cdecl sub_1008E2E0(void *a1)
{
  return sub_100762E0(a1, 0x20u, 0);
}

//----- (1008E300) --------------------------------------------------------
signed int __cdecl sub_1008E300(void *a1)
{
  return sub_100762E0(a1, 0x1Cu, 0);
}

//----- (1008E320) --------------------------------------------------------
signed int __cdecl sub_1008E320(void *a1)
{
  return sub_100762E0(a1, 0x10u, 0);
}

//----- (1008E340) --------------------------------------------------------
signed int __cdecl sub_1008E340(void *a1)
{
  return sub_100762E0(a1, 0xCu, 0);
}

//----- (1008E360) --------------------------------------------------------
signed int __cdecl sub_1008E360(void *a1)
{
  return sub_100762E0(a1, 8u, 0);
}

//----- (1008E380) --------------------------------------------------------
signed int __cdecl sub_1008E380(void *a1)
{
  signed int result; // eax@1

  result = sub_1008E2E0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1008E300((char *)a1 + 36);
    if ( !result )
    {
      result = sub_1008E320(a1);
      if ( !result )
      {
        result = sub_1008E2C0((char *)a1 + 96);
        if ( !result )
        {
          result = sub_1008E340((char *)a1 + 24);
          if ( !result )
            result = sub_1008E360((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (1008E3E0) --------------------------------------------------------
int __cdecl sub_1008E3E0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10076340(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1008E410) --------------------------------------------------------
char __cdecl sub_1008E410(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_10124D98[8 * a1];
  *a4 = word_10124D9A[a2 + 4 * a1];
  return 1;
}
// 10124D9A: using guessed type __int16 word_10124D9A[];

//----- (1008E470) --------------------------------------------------------
char __cdecl sub_1008E470(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_10126660[16 * a1];
  *a4 = word_10126668[a2 + 8 * a1];
  return 1;
}
// 10126668: using guessed type __int16 word_10126668[];

//----- (1008E4D0) --------------------------------------------------------
signed int __cdecl sub_1008E4D0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_100FEB08;
    v6 = &unk_100FEB08;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_100FEB20;
    v6 = &unk_100FEB20;
    v5 = &a1;
  }
  v3 = sub_10071590(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (1008E530) --------------------------------------------------------
int __cdecl sub_1008E530(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10071590(&a1, 1u, (int)&unk_100FEB68, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100FEB6C[2 * v1];
  return result;
}
// 100FEB6C: using guessed type int dword_100FEB6C[];

//----- (1008E570) --------------------------------------------------------
signed int __cdecl sub_1008E570(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_100FEB78;
    v7 = &unk_100FEB78;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_100FEB90;
    v7 = &unk_100FEB90;
    v6 = &a1;
  }
  v4 = sub_10071590(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (1008E5E0) --------------------------------------------------------
int __cdecl sub_1008E5E0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10071590(&a1, 1u, (int)&unk_100FEBA8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100FEBAC[2 * v1];
  return result;
}
// 100FEBAC: using guessed type int dword_100FEBAC[];

//----- (1008E620) --------------------------------------------------------
int __cdecl sub_1008E620(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10071590(&a1, 1u, (int)&unk_100FEBC0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100FEBC4[2 * v1];
  return result;
}
// 100FEBC4: using guessed type int dword_100FEBC4[];

//----- (1008E660) --------------------------------------------------------
char __cdecl sub_1008E660(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1008E4D0(a1, 11);
  return sub_1009B850(v2, a2, 24);
}

//----- (1008E680) --------------------------------------------------------
char __cdecl sub_1008E680(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1008E530(a1);
  return sub_1009B850(v2, a2, 2720);
}

//----- (1008E6B0) --------------------------------------------------------
char __cdecl sub_1008E6B0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_1008E570(a1, 11, 1);
  sub_1009B850(v2, a2, 36);
  v3 = sub_1008E570(a1, 11, 0);
  return sub_1009B850(v3, a2 + 36, 32);
}

//----- (1008E700) --------------------------------------------------------
char __cdecl sub_1008E700(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1008E5E0(a1);
  return sub_1009B850(v2, a2, 2192);
}

//----- (1008E730) --------------------------------------------------------
char __cdecl sub_1008E730(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1008E620(a1);
  return sub_1009B850(v2, a2, 60);
}

//----- (1008E750) --------------------------------------------------------
char __cdecl sub_1008E750(int a1)
{
  return sub_1009B850(6453, a1, 5);
}

//----- (1008E770) --------------------------------------------------------
char __cdecl sub_1008E770(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_100FEBD0[4 * a1];
    *a3 = word_100FEBD2[2 * a1];
    result = 1;
  }
  else
  {
    sub_10070AD0("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 100FEBD2: using guessed type __int16 word_100FEBD2[];

//----- (1008E7D0) --------------------------------------------------------
int __cdecl sub_1008E7D0(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1009C690: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1008E840) --------------------------------------------------------
bool __cdecl sub_1008E840(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_100714F0(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100FF8A0[(unsigned __int8)v4](v3) )
    {
      sub_1008E7D0((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10085210(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_100739C0(2) )
    result = 0;
  else
    result = sub_10074500(2, v5, a2) == 1 && !sub_1008E380(a2);
  return result;
}
// 100FF8A0: using guessed type int (__cdecl *off_100FF8A0[3])(char);

//----- (1008E900) --------------------------------------------------------
char __cdecl sub_1008E900(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_1008E840(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_100851F0(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (1008E9C0) --------------------------------------------------------
char sub_1008E9C0()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_1009B8D0(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 1008E9C0: using guessed type int var_1C[7];

//----- (1008EA40) --------------------------------------------------------
int __cdecl sub_1008EA40(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10071590(&a1, 1u, (int)&unk_10101FF8, 8, 67, 0);
  if ( v1 )
  {
    result = dword_10101FFC[2 * v1];
  }
  else
  {
    sub_10070AD0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 10101FFC: using guessed type int dword_10101FFC[];

//----- (1008EA90) --------------------------------------------------------
char __cdecl sub_1008EA90(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10076DD0(11);
  }
  else
  {
    result = sub_10076DD0(5);
  }
  return result;
}

//----- (1008EAC0) --------------------------------------------------------
char sub_1008EAC0()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10074500(1, 1309, &v1) )
    sub_10075760((int)&v1);
  return 0;
}

//----- (1008EB60) --------------------------------------------------------
BOOL __cdecl sub_1008EB60(int a1, int a2)
{
  return sub_1009B830(6455, a2, 252) == 0;
}

//----- (1008EB80) --------------------------------------------------------
char __cdecl sub_1008EB80(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1008EB60(a1, a5);
  }
  else
  {
    result = sub_1008EAC0();
  }
  return result;
}

//----- (1008EBC0) --------------------------------------------------------
char __thiscall sub_1008EBC0(void *this)
{
  char *v1; // eax@1
  char result; // al@3

  v1 = (char *)sub_100705C0(this) - 2;
  if ( v1 )
  {
    if ( v1 == (char *)2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1008EBE0) --------------------------------------------------------
_DWORD *__usercall sub_1008EBE0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_1009ABE0(a2, a1);
  result = (_DWORD *)sub_10077260(a3, a4);
  if ( (_BYTE)result )
    result = sub_10002700(a2);
  return result;
}

//----- (1008EC10) --------------------------------------------------------
char __cdecl sub_1008EC10(int a1, int a2)
{
  int v2; // edi@1
  int v3; // ecx@1
  int v4; // eax@1
  char *v5; // ST20_4@3
  void *v6; // ST14_4@3
  char v7; // al@3
  char v9; // [sp+Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  v4 = *(_DWORD *)(v3 + 4);
  if ( v4 && *(_WORD *)v3 == -32665 )
  {
    v9 = sub_10071530(*(int (__cdecl **)(int))(v4 + 8));
    v5 = sub_10071560(v9);
    v6 = *(void **)(v2 + 64);
    v7 = sub_1008EBC0(v6);
    LOBYTE(v4) = sub_1009AC00(v7, v9, -1, 0, 0, (int)v6, 0, 0, v5);
  }
  return v4;
}

//----- (1008EC70) --------------------------------------------------------
char __cdecl sub_1008EC70(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  char *v4; // ST20_4@2
  void *v5; // ST14_4@2
  char v6; // al@2
  char v8; // [sp+Ch] [bp+8h]@2

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 == -32703 )
  {
    v8 = sub_10071530(*(int (__cdecl **)(int))(v3 + 8));
    v4 = sub_10071560(v8);
    v5 = *(void **)(v2 + 64);
    v6 = sub_1008EBC0(v5);
    LOBYTE(v3) = sub_1009AC00(v6, v8, -1, 0, 0, (int)v5, 0, 0, v4);
  }
  return v3;
}

//----- (1008ECC0) --------------------------------------------------------
char __cdecl sub_1008ECC0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_10071530(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_10071530(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_1008EBC0(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_10071560(v16);
  LOBYTE(v3) = sub_1009AC00(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (1008EDC0) --------------------------------------------------------
_DWORD *sub_1008EDC0()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_1009B8D0(6463, (int)&v1, 256);
  sub_1008EBE0((int)sub_1008EC70, (int)&unk_10636F9C, &v1, "PAGE_INIT");
  sub_1008EBE0((int)sub_1008EC10, (int)&unk_10636F8C, &v1, "PAGE_SET_FOCUS");
  return sub_1008EBE0((int)sub_1008ECC0, (int)&unk_10636F94, &v1, "KEY_PRESS");
}

//----- (1008EE60) --------------------------------------------------------
int __cdecl sub_1008EE60(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = a2 * 1.799999952316284 + 32.0;
  return result;
}

//----- (1008EE80) --------------------------------------------------------
int __cdecl sub_1008EE80(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = (a2 - 32.0) * 0.5555555820465088;
  return result;
}

//----- (1008EEA0) --------------------------------------------------------
char __cdecl sub_1008EEA0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_10074500(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_10074500(0, 183, a2);
  }
  return result;
}

//----- (1008EEF0) --------------------------------------------------------
unsigned __int8 __cdecl sub_1008EEF0(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_1009B900(dword_10104D28[a1], (int)&a2, 1);
  }
  return result;
}
// 10104D28: using guessed type int dword_10104D28[];

//----- (1008EF30) --------------------------------------------------------
int __cdecl sub_1008EF30(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_1008EEA0(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1008EF70) --------------------------------------------------------
char __cdecl sub_1008EF70(char a1)
{
  return byte_10105BE9[2 * (unsigned __int8)sub_10071590(&a1, 1u, (int)&unk_10105BE8, 2, 4, 3)];
}

//----- (1008EFA0) --------------------------------------------------------
char __cdecl sub_1008EFA0(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10074500(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_1009ACD0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10074500(1, 538, a2);
  }
  if ( !v4 || sub_10075670((int)v3) )
    return 0;
  return 1;
}

//----- (1008F020) --------------------------------------------------------
int __cdecl sub_1008F020(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_1008EFA0(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1008F070) --------------------------------------------------------
void __cdecl sub_1008F070(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_1009B900(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_1009AD40(a2);
        sub_10070AD0("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_1009B900(2010, (int)&a2, 1);
    }
  }
}

//----- (1008F0E0) --------------------------------------------------------
char __cdecl sub_1008F0E0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_1068B4B0)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 1068B4B0: using guessed type int dword_1068B4B0;

//----- (1008F130) --------------------------------------------------------
char __cdecl sub_1008F130(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1068B4B0)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 1068B4B0: using guessed type int dword_1068B4B0;

//----- (1008F1E0) --------------------------------------------------------
char __cdecl sub_1008F1E0(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_1068B4B0)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 1068B4B0: using guessed type int dword_1068B4B0;

//----- (1008F240) --------------------------------------------------------
char __cdecl sub_1008F240(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1068B4B0)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 1068B4B0: using guessed type int dword_1068B4B0;

//----- (1008F310) --------------------------------------------------------
char sub_1008F310()
{
  return 2;
}

//----- (1008F320) --------------------------------------------------------
int __cdecl sub_1008F320(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1008F330) --------------------------------------------------------
char __cdecl sub_1008F330(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10636FB0[592 * a1]) || byte_10637000[v3]) )
  {
    *a2 = &byte_10636FB0[v3];
    *a3 = &byte_10637000[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1008F370) --------------------------------------------------------
char *__cdecl sub_1008F370(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10636FB0;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_10637000[592 * v2];
}

//----- (1008F3E0) --------------------------------------------------------
char *__usercall sub_1008F3E0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (1008F410) --------------------------------------------------------
void __cdecl sub_1008F410(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_1008F370(v2 + 3, (int)&unk_100C4192);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_1008F410(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (1008F4D0) --------------------------------------------------------
void __cdecl sub_1008F4D0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  signed int v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  signed int v8; // edx@4
  char v9; // cl@5

  if ( dword_10636FA8 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10636FA8;
    v4 = &byte_10636FB0[592 * dword_10636FA8] - a1;
    do
    {
      v5 = *v2;
      v2[v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_10637000[v3];
    v8 = &byte_10637000[v3] - a2;
    do
    {
      v9 = *v6;
      v6[v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_1008F410(v7);
    ++dword_10636FA8;
  }
}
// 10636FA8: using guessed type int dword_10636FA8;

//----- (1008F530) --------------------------------------------------------
void *__cdecl sub_1008F530(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10636FB0, 0, 0x73A0u);
  dword_10636FA8 = 0;
  if ( a1 )
  {
    v2 = sub_1008FA00(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_1008FBE0((int)&v11, 512, v2) )
      {
        do
        {
          sub_1008F3E0(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_1008F4D0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_1008F4D0(&v11, v4 + 1);
          }
        }
        while ( sub_1008FBE0((int)&v11, 512, v3) );
      }
      result = (void *)sub_1008F9B0(v3);
    }
    else
    {
      result = (void *)sub_1007CFE0(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10636FA8: using guessed type int dword_10636FA8;

//----- (1008F6C0) --------------------------------------------------------
int __cdecl sub_1008F6C0(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1009C380: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1009C390: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1009C3A0: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1009C3B0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1009C460: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1008F800) --------------------------------------------------------
char __usercall sub_1008F800@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1008F8D0) --------------------------------------------------------
signed int __cdecl sub_1008F8D0(_DWORD *a1, char *a2)
{
  int *v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *v2;
    v10 = *v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1009C3C0(v2[1], (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1008F800((int)v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)v2 + 15, (char)a1);
          v3 = v10;
          *a2 = v8;
          v2[6] += v6;
        }
        else
        {
          v7 = v2[1];
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1008F6C0((int)v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1009C470: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1008F9B0) --------------------------------------------------------
BOOL __cdecl sub_1008F9B0(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_1009BA60(a1) == 0;
}
// 1009BA50: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (1008F9D0) --------------------------------------------------------
BOOL __cdecl sub_1008F9D0(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 1009BAA0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (1008FA00) --------------------------------------------------------
unsigned int __cdecl sub_1008FA00(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 1009BB30: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1008FA60) --------------------------------------------------------
signed int __cdecl sub_1008FA60(void *a1, int a2, unsigned int a3)
{
  return sub_1009BB40(a3, a1, a2);
}

//----- (1008FA80) --------------------------------------------------------
int __cdecl sub_1008FA80(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 1009BCB0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1008FAA0) --------------------------------------------------------
char __cdecl sub_1008FAA0(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_1008FA00((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_1008FA00((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_1008FA60(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_1008FA80((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_1008FA60(&v8, 512, v3);
        }
        v2 = i;
        sub_1008F9B0(v4);
      }
      sub_1008F9B0(v3);
    }
    return v2;
  }
  return 1;
}

//----- (1008FBE0) --------------------------------------------------------
int __cdecl sub_1008FBE0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_1008FA60(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (1008FC60) --------------------------------------------------------
int sub_1008FC60()
{
  return 0;
}

//----- (1008FC70) --------------------------------------------------------
void __cdecl sub_1008FC70(int a1)
{
  if ( a1 > 0 )
    exit_1(14);
}

//----- (1008FCA0) --------------------------------------------------------
int __cdecl sub_1008FCA0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1008FCC0) --------------------------------------------------------
bool __cdecl sub_1008FCC0(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (1008FCF0) --------------------------------------------------------
void *__cdecl sub_1008FCF0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (1008FD30) --------------------------------------------------------
unsigned int __usercall sub_1008FD30@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (1008FD50) --------------------------------------------------------
unsigned int __usercall sub_1008FD50@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (1008FD70) --------------------------------------------------------
int __usercall sub_1008FD70@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (1008FD90) --------------------------------------------------------
char __cdecl sub_1008FD90(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_1008FCC0(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_1008FCA0(a2);
  }
  return result;
}

//----- (1008FDC0) --------------------------------------------------------
signed int __cdecl sub_1008FDC0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  unsigned int *v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( v5[1] )
      {
        do
        {
          v10 = sub_1008FD30((int)v5, v7, v9);
          v11 = (_BYTE *)sub_1008FD30(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_1008FD50(a4, v7, v9);
            sub_1008FD70(v16, (int)&unk_10106B28);
          }
          ++v9;
        }
        while ( v9 < v5[1] );
      }
      ++v7;
    }
    while ( v7 < *v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (1008FEA0) --------------------------------------------------------
void __cdecl sub_1008FEA0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_1008FD30((int)v3, v4, v6);
          v8 = sub_1008FD30(a2, v4, v6);
          v9 = sub_1008FD50(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (1008FF50) --------------------------------------------------------
void *__usercall sub_1008FF50@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  unsigned int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  unsigned int v34; // [sp+14h] [bp-Ch]@1
  unsigned int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_1008FD50(a1, v31, v4);
      v6 = sub_1008FD30(a2, 0, 0);
      sub_1008FD70(v5, v6);
      v7 = sub_1008FD50(a1, v33, v4);
      v8 = sub_1008FD30(a2, *(_DWORD *)a2 - 1, 0);
      sub_1008FD70(v7, v8);
      v9 = sub_1008FD50(a1, v31, v34 - v4 - 1);
      v10 = sub_1008FD30(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_1008FD70(v9, v10);
      v11 = sub_1008FD50(a1, v33, v34 - v4 - 1);
      v12 = sub_1008FD30(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_1008FD70(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_1008FD30(a2, 0, 1);
    v16 = (void *)sub_1008FD50(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_1008FD50(a1, a3 + i, v18);
      v20 = sub_1008FD30(a2, i, 0);
      sub_1008FD70(v19, v20);
      v21 = sub_1008FD50(a1, i + a3, v34 - v18 - 1);
      v22 = sub_1008FD30(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_1008FD70(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_1008FD30(a2, i, 1);
    v25 = (void *)sub_1008FD50(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_1008FD30(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_1008FD50(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (100901D0) --------------------------------------------------------
void __cdecl sub_100901D0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_1008FD30(a1, v2, v4);
          v6 = sub_1008FD50(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (100902A0) --------------------------------------------------------
char __cdecl sub_100902A0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_1008FCC0(a1);
  if ( result )
  {
    result = sub_1008FCC0(a4);
    if ( result )
    {
      sub_1008FD90(a3, a4);
      sub_1008FCF0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10090310) --------------------------------------------------------
int __usercall sub_10090310@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_1008FCF0(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_1008FF50((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_1008FD30((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_1008FD50(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_1008FD90((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_100902A0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10090670) --------------------------------------------------------
int __usercall sub_10090670@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_1008FCF0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_1008FEA0(v8, a3, (int)&v16);
  sub_1008FCF0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10090310(9u, v7, (int)&v16, (int)&unk_10106B04, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_1008FD30((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_1008FD50(a6, v9, v11);
            sub_1008FD70(v13, (int)&unk_10106B28);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_1008FD90(a5, (int)&v15);
  sub_1008FD90(a5, (int)&v16);
  return v10;
}

//----- (10090780) --------------------------------------------------------
int __cdecl sub_10090780(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_1008FCF0(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_100901D0(a3, a8);
  if ( a1 )
    result = sub_10090670(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_1008FDC0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10090910) --------------------------------------------------------
char __cdecl sub_10090910(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_1008FA00((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_1008FA60(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_1008FA60(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_1008FCF0(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_1008FA60(v6, v7, v12) == v7 && (!v9 || sub_1008FA60(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_1008F9B0(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10090A60) --------------------------------------------------------
char __usercall sub_10090A60@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  unsigned int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  unsigned int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  unsigned int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_1008FA00(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_1008FA80((int)&v14, 14, v9) == 14 && sub_1008FA80((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_1008FA80(v12, v6, v10) == v6 && (!v7 || sub_1008FA80((int)&unk_10106CD0, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_1008F9B0(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_1008F9B0(v10);
  }
  return v30;
}

//----- (10090BB0) --------------------------------------------------------
char __cdecl sub_10090BB0(int a1, int a2)
{
  char result; // al@2

  if ( sub_1008FCC0(a1) )
    result = sub_10090A60(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10090BF0) --------------------------------------------------------
signed int __cdecl sub_10090BF0(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_1063E351 = 1;
    byte_1063E350 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1063E350 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1063E351 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 1063E350: using guessed type char byte_1063E350;
// 1063E351: using guessed type char byte_1063E351;

//----- (10090C50) --------------------------------------------------------
bool __cdecl sub_10090C50(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_1007CF30(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_1011E8C8, (int)"failing_subroutine( depth-1 )");
    sub_10090C50(a1 - 1);
    exit_1(14);
  }
  return sub_100823F0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10090CC0) --------------------------------------------------------
int sub_10090CC0()
{
  const char *v0; // eax@1

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_1063E350 )
  {
    sub_100823F0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_1007CF30(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10090C50(1);
    exit_1(14);
  }
  return sub_1007CF60(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 1063E350: using guessed type char byte_1063E350;

//----- (10090FE0) --------------------------------------------------------
char sub_10090FE0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  int v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  int v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1063E350 )
  {
    v2 = 0;
    do
    {
      if ( off_1010793C[v2] )
      {
        sub_1007D720((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10107944[v2 * 4], 0x100u, &v11);
        sub_1007D720((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1010793C[v2], 0x100u, &v12);
        sub_1008FAA0(&v12, &v11);
      }
      if ( byte_10107938[v2 * 4] )
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_10107940[v2];
        v4 = *(_DWORD *)&off_10107944[v2 * 4];
        v5 = sub_1007D9C0(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10107944[v2 * 4],
               off_10107940[v2]);
        v6 = sub_10082040(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1007DD20(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_10107940[v2];
        v8 = *(_DWORD *)&off_10107944[v2 * 4];
        v9 = sub_1007D9C0(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10107944[v2 * 4],
               off_10107940[v2]);
        v10 = sub_10082040(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1007DD20(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1010793C: using guessed type char *off_1010793C[3];
// 10107940: using guessed type char *off_10107940[2];
// 1063E350: using guessed type char byte_1063E350;

//----- (10091200) --------------------------------------------------------
char sub_10091200()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1063E350 )
  {
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1007DD20(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1007DD20(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1007DD20(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1007DD20(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1007DD20(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1063E350: using guessed type char byte_1063E350;

//----- (10091400) --------------------------------------------------------
char sub_10091400()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_101079CC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_101079C9[v2 * 4];
        v4 = byte_101079C8[v2 * 4];
        v5 = sub_1007D9C0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + dword_101079CC[v2])],
               (&off_101079D0)[v2 * 4]);
        v6 = sub_1007DE60(
               0,
               *(&dword_1010791C + dword_101079CC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1007D9C0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_101079CC[v2]],
               (&off_101079D0)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101079CC: using guessed type int dword_101079CC[];
// 101079D0: using guessed type char *off_101079D0;
// 1063E350: using guessed type char byte_1063E350;

//----- (10091580) --------------------------------------------------------
char sub_10091580()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10107C50[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10107C48[v2 / 8];
        v4 = dbl_10107C40[v2 / 8];
        v5 = dbl_10107C38[v2 / 8];
        v6 = sub_1007D9C0(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_10107C54[v2]);
        v7 = sub_1007E210(
               0,
               *(&dword_1010791C + dword_10107C50[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10107C50[v2 / 4]],
               *(_DWORD *)&off_10107C54[v2]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10107C38: using guessed type double dbl_10107C38[];
// 10107C40: using guessed type double dbl_10107C40[];
// 10107C48: using guessed type double dbl_10107C48[];
// 10107C50: using guessed type int dword_10107C50[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10091700) --------------------------------------------------------
char sub_10091700()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10108864[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10108860[v2];
        v4 = flt_1010885C[v2];
        v5 = flt_10108858[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_10108868[v2 * 4]);
        v7 = sub_1007E660(
               0,
               *(&dword_1010791C + dword_10108864[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10108864[v2]],
               *(_DWORD *)&off_10108868[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10108858: using guessed type float flt_10108858[];
// 1010885C: using guessed type float flt_1010885C[];
// 10108860: using guessed type float flt_10108860[];
// 10108864: using guessed type int dword_10108864[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10091870) --------------------------------------------------------
char sub_10091870()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1063E350 )
  {
    sub_10082340(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10091870,
      (int)sub_10091870,
      (int)"This test is expected to fail");
    sub_10082340(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10091870,
      0,
      (int)"This test is expected to fail");
    result = sub_10082340(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10091870,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1063E350: using guessed type char byte_1063E350;

//----- (10091970) --------------------------------------------------------
char sub_10091970()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010900C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10109008[v2];
        v4 = dword_10109004[v2];
        v5 = dword_10109000[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_10109010)[v2 * 4]);
        v7 = sub_1007EB20(
               0,
               *(&dword_1010791C + dword_1010900C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010900C[v2]],
               (&off_10109010)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10109000: using guessed type int dword_10109000[];
// 10109004: using guessed type int dword_10109004[];
// 10109008: using guessed type int dword_10109008[];
// 1010900C: using guessed type int dword_1010900C[];
// 10109010: using guessed type char *off_10109010;
// 1063E350: using guessed type char byte_1063E350;

//----- (10091AD0) --------------------------------------------------------
char sub_10091AD0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_101097A0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1010979C[v2 / 2];
        v4 = word_1010979A[v2 / 2];
        v5 = word_10109798[v2 / 2];
        v6 = sub_1007D9C0(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_101097A4)[v2]);
        v7 = sub_1007EEE0(
               0,
               *(&dword_1010791C + dword_101097A0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_101097A0[v2 / 4]],
               (&off_101097A4)[v2]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10109798: using guessed type __int16 word_10109798[];
// 1010979A: using guessed type __int16 word_1010979A[];
// 1010979C: using guessed type __int16 word_1010979C[];
// 101097A0: using guessed type int dword_101097A0[];
// 101097A4: using guessed type char *off_101097A4;
// 1063E350: using guessed type char byte_1063E350;

//----- (10091C30) --------------------------------------------------------
char sub_10091C30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10109DB4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10109DB0[v2];
        v4 = dword_10109DAC[v2];
        v5 = dword_10109DA8[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_10109DB8[v2 * 4]);
        v7 = sub_1007F2E0(
               0,
               *(&dword_1010791C + dword_10109DB4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10109DB4[v2]],
               *(_DWORD *)&off_10109DB8[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10109DA8: using guessed type int dword_10109DA8[];
// 10109DAC: using guessed type int dword_10109DAC[];
// 10109DB0: using guessed type int dword_10109DB0[];
// 10109DB4: using guessed type int dword_10109DB4[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10091D90) --------------------------------------------------------
char sub_10091D90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010A558[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1010A554[v2];
        LODWORD(v3) = dword_1010A550[v2];
        HIDWORD(v4) = dword_1010A54C[v2];
        LODWORD(v4) = dword_1010A548[v2];
        HIDWORD(v5) = dword_1010A544[v2];
        LODWORD(v5) = dword_1010A540[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_1010A55C[v2 * 4]);
        v7 = sub_1007F6A0(
               0,
               *(&dword_1010791C + dword_1010A558[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010A558[v2]],
               *(_DWORD *)&off_1010A55C[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010A540: using guessed type int dword_1010A540[];
// 1010A544: using guessed type int dword_1010A544[];
// 1010A548: using guessed type int dword_1010A548[];
// 1010A54C: using guessed type int dword_1010A54C[];
// 1010A550: using guessed type int dword_1010A550[];
// 1010A554: using guessed type int dword_1010A554[];
// 1010A558: using guessed type int dword_1010A558[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10091F00) --------------------------------------------------------
char sub_10091F00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010B164[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1010B162[v2 * 4];
        v4 = byte_1010B161[v2 * 4];
        v5 = byte_1010B160[v2 * 4];
        v6 = sub_1007D9C0(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_1010B168)[v2 * 4]);
        v7 = sub_1007FBE0(
               0,
               *(&dword_1010791C + dword_1010B164[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010B164[v2]],
               (&off_1010B168)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010B164: using guessed type int dword_1010B164[];
// 1010B168: using guessed type char *off_1010B168;
// 1063E350: using guessed type char byte_1063E350;

//----- (10092060) --------------------------------------------------------
char sub_10092060()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010B5FC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1010B5F8[v2];
        v4 = dword_1010B5F4[v2];
        v5 = dword_1010B5F0[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_1010B600)[v2 * 4]);
        v7 = sub_1007FFC0(
               0,
               *(&dword_1010791C + dword_1010B5FC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010B5FC[v2]],
               (&off_1010B600)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010B5F0: using guessed type int dword_1010B5F0[];
// 1010B5F4: using guessed type int dword_1010B5F4[];
// 1010B5F8: using guessed type int dword_1010B5F8[];
// 1010B5FC: using guessed type int dword_1010B5FC[];
// 1010B600: using guessed type char *off_1010B600;
// 1063E350: using guessed type char byte_1063E350;

//----- (100921C0) --------------------------------------------------------
char sub_100921C0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1063E350 )
  {
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_100823F0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100C4192,
           (int)"This test is expected to fail");
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_100823F0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_100C4192,
           "a",
           (int)"This test is expected to fail");
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_100823F0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100C4192,
           (const char *)&unk_100C4192,
           (int)"This test is expected to fail");
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_100823F0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1007DD20(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1063E350: using guessed type char byte_1063E350;

//----- (100923E0) --------------------------------------------------------
char sub_100923E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010BD94[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1010BD90[v2];
        v4 = dword_1010BD8C[v2];
        v5 = dword_1010BD88[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_1010BD98[v2 * 4]);
        v7 = sub_10080380(
               0,
               *(&dword_1010791C + dword_1010BD94[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010BD94[v2]],
               *(_DWORD *)&off_1010BD98[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010BD88: using guessed type int dword_1010BD88[];
// 1010BD8C: using guessed type int dword_1010BD8C[];
// 1010BD90: using guessed type int dword_1010BD90[];
// 1010BD94: using guessed type int dword_1010BD94[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10092540) --------------------------------------------------------
char sub_10092540()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010C100[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1010C0FC[v2 / 2];
        v4 = word_1010C0FA[v2 / 2];
        v5 = word_1010C0F8[v2 / 2];
        v6 = sub_1007D9C0(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_1010C104)[v2]);
        v7 = sub_10080720(
               0,
               *(&dword_1010791C + dword_1010C100[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010C100[v2 / 4]],
               (&off_1010C104)[v2]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010C0F8: using guessed type __int16 word_1010C0F8[];
// 1010C0FA: using guessed type __int16 word_1010C0FA[];
// 1010C0FC: using guessed type __int16 word_1010C0FC[];
// 1010C100: using guessed type int dword_1010C100[];
// 1010C104: using guessed type char *off_1010C104;
// 1063E350: using guessed type char byte_1063E350;

//----- (100926A0) --------------------------------------------------------
char sub_100926A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010C3C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1010C3C0[v2];
        v4 = dword_1010C3BC[v2];
        v5 = dword_1010C3B8[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_1010C3C8[v2 * 4]);
        v7 = sub_10080B20(
               0,
               *(&dword_1010791C + dword_1010C3C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010C3C4[v2]],
               *(_DWORD *)&off_1010C3C8[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010C3B8: using guessed type int dword_1010C3B8[];
// 1010C3BC: using guessed type int dword_1010C3BC[];
// 1010C3C0: using guessed type int dword_1010C3C0[];
// 1010C3C4: using guessed type int dword_1010C3C4[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10092800) --------------------------------------------------------
char sub_10092800()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010C740[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1010C73C[v2];
        LODWORD(v3) = dword_1010C738[v2];
        HIDWORD(v4) = dword_1010C734[v2];
        LODWORD(v4) = dword_1010C730[v2];
        HIDWORD(v5) = dword_1010C72C[v2];
        LODWORD(v5) = dword_1010C728[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_1010C744)[v2 * 4]);
        v7 = sub_10080EC0(
               0,
               *(&dword_1010791C + dword_1010C740[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010C740[v2]],
               (&off_1010C744)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010C728: using guessed type int dword_1010C728[];
// 1010C72C: using guessed type int dword_1010C72C[];
// 1010C730: using guessed type int dword_1010C730[];
// 1010C734: using guessed type int dword_1010C734[];
// 1010C738: using guessed type int dword_1010C738[];
// 1010C73C: using guessed type int dword_1010C73C[];
// 1010C740: using guessed type int dword_1010C740[];
// 1010C744: using guessed type char *off_1010C744;
// 1063E350: using guessed type char byte_1063E350;

//----- (10092970) --------------------------------------------------------
char sub_10092970()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010CCAC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1010CCAA[v2 * 4];
        v4 = byte_1010CCA9[v2 * 4];
        v5 = byte_1010CCA8[v2 * 4];
        v6 = sub_1007D9C0(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_1010CCB0)[v2 * 4]);
        v7 = sub_100814A0(
               0,
               *(&dword_1010791C + dword_1010CCAC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010CCAC[v2]],
               (&off_1010CCB0)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010CCAC: using guessed type int dword_1010CCAC[];
// 1010CCB0: using guessed type char *off_1010CCB0;
// 1063E350: using guessed type char byte_1063E350;

//----- (10092AD0) --------------------------------------------------------
char sub_10092AD0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010CEC4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1010CEC0[v2];
        v4 = dword_1010CEBC[v2];
        v5 = dword_1010CEB8[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_1010CEC8[v2 * 4]);
        v7 = sub_10081890(
               0,
               *(&dword_1010791C + dword_1010CEC4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010CEC4[v2]],
               *(_DWORD *)&off_1010CEC8[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010CEB8: using guessed type int dword_1010CEB8[];
// 1010CEBC: using guessed type int dword_1010CEBC[];
// 1010CEC0: using guessed type int dword_1010CEC0[];
// 1010CEC4: using guessed type int dword_1010CEC4[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10092C30) --------------------------------------------------------
char sub_10092C30()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  int v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  int v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1063E350 )
  {
    v2 = 0;
    do
    {
      if ( off_1010D22C[v2] )
      {
        sub_1007D720((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1010D234[v2 * 4], 0x100u, &v11);
        sub_1007D720((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1010D22C[v2], 0x100u, &v12);
        sub_1008FAA0(&v12, &v11);
      }
      if ( byte_1010D228[v2 * 4] )
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_1010D230[v2];
        v4 = *(_DWORD *)&off_1010D234[v2 * 4];
        v5 = sub_1007D9C0(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1010D234[v2 * 4],
               off_1010D230[v2]);
        v6 = sub_10082040(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1007DD20(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_1010D230[v2];
        v8 = *(_DWORD *)&off_1010D234[v2 * 4];
        v9 = sub_1007D9C0(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1010D234[v2 * 4],
               off_1010D230[v2]);
        v10 = sub_10082040(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1007DD20(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1010D22C: using guessed type char *off_1010D22C[3];
// 1010D230: using guessed type char *off_1010D230[2];
// 1063E350: using guessed type char byte_1063E350;

//----- (10092E50) --------------------------------------------------------
char sub_10092E50()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_1063E350 )
  {
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1007DD20(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1007DD20(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1007DD20(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1007DD20(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1007DD20(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1063E350: using guessed type char byte_1063E350;

//----- (10093050) --------------------------------------------------------
char sub_10093050()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010D2BC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_1010D2B9[v2 * 4];
        v4 = byte_1010D2B8[v2 * 4];
        v5 = sub_1007D9C0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + dword_1010D2BC[v2])],
               (&off_1010D2C0)[v2 * 4]);
        v6 = sub_1007DE60(
               1,
               *(&dword_1010791C + dword_1010D2BC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1007D9C0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010D2BC[v2]],
               (&off_1010D2C0)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010D2BC: using guessed type int dword_1010D2BC[];
// 1010D2C0: using guessed type char *off_1010D2C0;
// 1063E350: using guessed type char byte_1063E350;

//----- (100931D0) --------------------------------------------------------
char sub_100931D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010D540[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1010D538[v2 / 8];
        v4 = dbl_1010D530[v2 / 8];
        v5 = dbl_1010D528[v2 / 8];
        v6 = sub_1007D9C0(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_1010D544)[v2]);
        v7 = sub_1007E210(
               1,
               *(&dword_1010791C + dword_1010D540[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010D540[v2 / 4]],
               (&off_1010D544)[v2]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010D528: using guessed type double dbl_1010D528[];
// 1010D530: using guessed type double dbl_1010D530[];
// 1010D538: using guessed type double dbl_1010D538[];
// 1010D540: using guessed type int dword_1010D540[];
// 1010D544: using guessed type char *off_1010D544;
// 1063E350: using guessed type char byte_1063E350;

//----- (10093350) --------------------------------------------------------
char sub_10093350()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010E154[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1010E150[v2];
        v4 = flt_1010E14C[v2];
        v5 = flt_1010E148[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_1010E158[v2 * 4]);
        v7 = sub_1007E660(
               1,
               *(&dword_1010791C + dword_1010E154[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010E154[v2]],
               *(_DWORD *)&off_1010E158[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010E148: using guessed type float flt_1010E148[];
// 1010E14C: using guessed type float flt_1010E14C[];
// 1010E150: using guessed type float flt_1010E150[];
// 1010E154: using guessed type int dword_1010E154[];
// 1063E350: using guessed type char byte_1063E350;

//----- (100934C0) --------------------------------------------------------
char sub_100934C0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1063E350 )
  {
    sub_10082340(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_100934C0,
      (int)sub_100934C0,
      0);
    sub_10082340(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_100934C0,
      0,
      0);
    result = sub_10082340(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100934C0,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1063E350: using guessed type char byte_1063E350;

//----- (100935B0) --------------------------------------------------------
char sub_100935B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010E8EC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1010E8E8[v2];
        v4 = dword_1010E8E4[v2];
        v5 = dword_1010E8E0[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_1010E8F0)[v2 * 4]);
        v7 = sub_1007EB20(
               1,
               *(&dword_1010791C + dword_1010E8EC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010E8EC[v2]],
               (&off_1010E8F0)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010E8E0: using guessed type int dword_1010E8E0[];
// 1010E8E4: using guessed type int dword_1010E8E4[];
// 1010E8E8: using guessed type int dword_1010E8E8[];
// 1010E8EC: using guessed type int dword_1010E8EC[];
// 1010E8F0: using guessed type char *off_1010E8F0;
// 1063E350: using guessed type char byte_1063E350;

//----- (10093710) --------------------------------------------------------
char sub_10093710()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010F080[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1010F07C[v2 / 2];
        v4 = word_1010F07A[v2 / 2];
        v5 = word_1010F078[v2 / 2];
        v6 = sub_1007D9C0(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_1010F084)[v2]);
        v7 = sub_1007EEE0(
               1,
               *(&dword_1010791C + dword_1010F080[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010F080[v2 / 4]],
               (&off_1010F084)[v2]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010F078: using guessed type __int16 word_1010F078[];
// 1010F07A: using guessed type __int16 word_1010F07A[];
// 1010F07C: using guessed type __int16 word_1010F07C[];
// 1010F080: using guessed type int dword_1010F080[];
// 1010F084: using guessed type char *off_1010F084;
// 1063E350: using guessed type char byte_1063E350;

//----- (10093870) --------------------------------------------------------
char sub_10093870()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010F694[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1010F690[v2];
        v4 = dword_1010F68C[v2];
        v5 = dword_1010F688[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_1010F698[v2 * 4]);
        v7 = sub_1007F2E0(
               1,
               *(&dword_1010791C + dword_1010F694[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010F694[v2]],
               *(_DWORD *)&off_1010F698[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010F688: using guessed type int dword_1010F688[];
// 1010F68C: using guessed type int dword_1010F68C[];
// 1010F690: using guessed type int dword_1010F690[];
// 1010F694: using guessed type int dword_1010F694[];
// 1063E350: using guessed type char byte_1063E350;

//----- (100939D0) --------------------------------------------------------
char sub_100939D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1010FE38[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1010FE34[v2];
        LODWORD(v3) = dword_1010FE30[v2];
        HIDWORD(v4) = dword_1010FE2C[v2];
        LODWORD(v4) = dword_1010FE28[v2];
        HIDWORD(v5) = dword_1010FE24[v2];
        LODWORD(v5) = dword_1010FE20[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_1010FE3C[v2 * 4]);
        v7 = sub_1007F6A0(
               1,
               *(&dword_1010791C + dword_1010FE38[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1010FE38[v2]],
               *(_DWORD *)&off_1010FE3C[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010FE20: using guessed type int dword_1010FE20[];
// 1010FE24: using guessed type int dword_1010FE24[];
// 1010FE28: using guessed type int dword_1010FE28[];
// 1010FE2C: using guessed type int dword_1010FE2C[];
// 1010FE30: using guessed type int dword_1010FE30[];
// 1010FE34: using guessed type int dword_1010FE34[];
// 1010FE38: using guessed type int dword_1010FE38[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10093B40) --------------------------------------------------------
char sub_10093B40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10110A44[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10110A42[v2 * 4];
        v4 = byte_10110A41[v2 * 4];
        v5 = byte_10110A40[v2 * 4];
        v6 = sub_1007D9C0(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_10110A48)[v2 * 4]);
        v7 = sub_1007FBE0(
               1,
               *(&dword_1010791C + dword_10110A44[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10110A44[v2]],
               (&off_10110A48)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10110A44: using guessed type int dword_10110A44[];
// 10110A48: using guessed type char *off_10110A48;
// 1063E350: using guessed type char byte_1063E350;

//----- (10093CA0) --------------------------------------------------------
char sub_10093CA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10110EDC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10110ED8[v2];
        v4 = dword_10110ED4[v2];
        v5 = dword_10110ED0[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_10110EE0)[v2 * 4]);
        v7 = sub_1007FFC0(
               1,
               *(&dword_1010791C + dword_10110EDC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10110EDC[v2]],
               (&off_10110EE0)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10110ED0: using guessed type int dword_10110ED0[];
// 10110ED4: using guessed type int dword_10110ED4[];
// 10110ED8: using guessed type int dword_10110ED8[];
// 10110EDC: using guessed type int dword_10110EDC[];
// 10110EE0: using guessed type char *off_10110EE0;
// 1063E350: using guessed type char byte_1063E350;

//----- (10093E00) --------------------------------------------------------
char sub_10093E00()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1063E350 )
  {
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_100823F0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100C4192,
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_100823F0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_100C4192,
           "a",
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_100823F0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100C4192,
           (const char *)&unk_100C4192,
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_100823F0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1007DD20(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1063E350: using guessed type char byte_1063E350;

//----- (10094000) --------------------------------------------------------
char sub_10094000()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10111674[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10111670[v2];
        v4 = dword_1011166C[v2];
        v5 = dword_10111668[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_10111678[v2 * 4]);
        v7 = sub_10080380(
               1,
               *(&dword_1010791C + dword_10111674[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10111674[v2]],
               *(_DWORD *)&off_10111678[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10111668: using guessed type int dword_10111668[];
// 1011166C: using guessed type int dword_1011166C[];
// 10111670: using guessed type int dword_10111670[];
// 10111674: using guessed type int dword_10111674[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10094160) --------------------------------------------------------
char sub_10094160()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_101119E0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_101119DC[v2 / 2];
        v4 = word_101119DA[v2 / 2];
        v5 = word_101119D8[v2 / 2];
        v6 = sub_1007D9C0(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_101119E4)[v2]);
        v7 = sub_10080720(
               1,
               *(&dword_1010791C + dword_101119E0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_101119E0[v2 / 4]],
               (&off_101119E4)[v2]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101119D8: using guessed type __int16 word_101119D8[];
// 101119DA: using guessed type __int16 word_101119DA[];
// 101119DC: using guessed type __int16 word_101119DC[];
// 101119E0: using guessed type int dword_101119E0[];
// 101119E4: using guessed type char *off_101119E4;
// 1063E350: using guessed type char byte_1063E350;

//----- (100942C0) --------------------------------------------------------
char sub_100942C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10111CA4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10111CA0[v2];
        v4 = dword_10111C9C[v2];
        v5 = dword_10111C98[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_10111CA8[v2 * 4]);
        v7 = sub_10080B20(
               1,
               *(&dword_1010791C + dword_10111CA4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10111CA4[v2]],
               *(_DWORD *)&off_10111CA8[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10111C98: using guessed type int dword_10111C98[];
// 10111C9C: using guessed type int dword_10111C9C[];
// 10111CA0: using guessed type int dword_10111CA0[];
// 10111CA4: using guessed type int dword_10111CA4[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10094420) --------------------------------------------------------
char sub_10094420()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10112020[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1011201C[v2];
        LODWORD(v3) = dword_10112018[v2];
        HIDWORD(v4) = dword_10112014[v2];
        LODWORD(v4) = dword_10112010[v2];
        HIDWORD(v5) = dword_1011200C[v2];
        LODWORD(v5) = dword_10112008[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_10112024)[v2 * 4]);
        v7 = sub_10080EC0(
               1,
               *(&dword_1010791C + dword_10112020[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10112020[v2]],
               (&off_10112024)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10112008: using guessed type int dword_10112008[];
// 1011200C: using guessed type int dword_1011200C[];
// 10112010: using guessed type int dword_10112010[];
// 10112014: using guessed type int dword_10112014[];
// 10112018: using guessed type int dword_10112018[];
// 1011201C: using guessed type int dword_1011201C[];
// 10112020: using guessed type int dword_10112020[];
// 10112024: using guessed type char *off_10112024;
// 1063E350: using guessed type char byte_1063E350;

//----- (10094590) --------------------------------------------------------
char sub_10094590()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_1011258C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1011258A[v2 * 4];
        v4 = byte_10112589[v2 * 4];
        v5 = byte_10112588[v2 * 4];
        v6 = sub_1007D9C0(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               (&off_10112590)[v2 * 4]);
        v7 = sub_100814A0(
               1,
               *(&dword_1010791C + dword_1011258C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_1011258C[v2]],
               (&off_10112590)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1011258C: using guessed type int dword_1011258C[];
// 10112590: using guessed type char *off_10112590;
// 1063E350: using guessed type char byte_1063E350;

//----- (100946F0) --------------------------------------------------------
char sub_100946F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1063E350 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_101127A4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101127A0[v2];
        v4 = dword_1011279C[v2];
        v5 = dword_10112798[v2];
        v6 = sub_1007D9C0(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * *(&dword_1010791C + v0)],
               *(_DWORD *)&off_101127A8[v2 * 4]);
        v7 = sub_10081890(
               1,
               *(&dword_1010791C + dword_101127A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1007D9C0(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_101127A4[v2]],
               *(_DWORD *)&off_101127A8[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10112798: using guessed type int dword_10112798[];
// 1011279C: using guessed type int dword_1011279C[];
// 101127A0: using guessed type int dword_101127A0[];
// 101127A4: using guessed type int dword_101127A4[];
// 1063E350: using guessed type char byte_1063E350;

//----- (10094850) --------------------------------------------------------
char sub_10094850()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_1063E351 )
  {
    sub_100823F0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_1007CF60(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1007EB20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_1007B9C0() )
      v1 = 3;
    sub_1007EB20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_1007B9C0();
    sub_1007EB20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_1007CF60(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1007EB20(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1063E351: using guessed type char byte_1063E351;

//----- (10094DF0) --------------------------------------------------------
char sub_10094DF0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  int v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  int v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1063E351 )
  {
    v2 = 0;
    do
    {
      if ( off_10112B0C[v2] )
      {
        sub_1007D720((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10112B14[v2 * 4], 0x100u, &v13);
        sub_1007D720((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10112B0C[v2], 0x100u, &v14);
        sub_1008FAA0(&v14, &v13);
      }
      if ( byte_10112B08[v2 * 4] )
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_10112B10[v2];
        v4 = *(_DWORD *)&off_10112B14[v2 * 4];
        v5 = sub_1007D9C0(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10112B14[v2 * 4],
               off_10112B10[v2]);
        v12 = 1;
        v11 = sub_10082040(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2114", (int)v5, v4, (int)v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_10112B10[v2];
        v7 = *(_DWORD *)&off_10112B14[v2 * 4];
        v8 = sub_1007D9C0(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10112B14[v2 * 4],
               off_10112B10[v2]);
        v12 = 1;
        v11 = sub_10082040(0, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2123", (int)v8, v7, (int)v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10112B0C: using guessed type char *off_10112B0C[3];
// 10112B10: using guessed type char *off_10112B10[2];
// 1063E351: using guessed type char byte_1063E351;

//----- (10095000) --------------------------------------------------------
char sub_10095000()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1063E351 )
  {
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1007DD20(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1007DD20(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1007DD20(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1007DD20(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1007DD20(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1063E351: using guessed type char byte_1063E351;

//----- (100951F0) --------------------------------------------------------
char sub_100951F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_10112B5C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_10112B59[v2 * 4];
        v4 = byte_10112B58[v2 * 4];
        v5 = sub_1007D9C0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * dword_10112B5C[v2]],
               (&off_10112B60)[v2 * 4]);
        v6 = sub_1007DE60(0, dword_10112B5C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1007D9C0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_10112B5C[v2]],
               (&off_10112B60)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 10112B5C: using guessed type int dword_10112B5C[];
// 10112B60: using guessed type char *off_10112B60;
// 1063E351: using guessed type char byte_1063E351;

//----- (10095360) --------------------------------------------------------
char sub_10095360()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_10112DD8[v2 / 2];
      v4 = dbl_10112DD0[v2 / 2];
      v5 = dbl_10112DC8[v2 / 2];
      v6 = sub_1007D9C0(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10112DE0[v2]],
             (&off_10112DE4)[v2 * 4]);
      v7 = sub_1007E210(0, dword_10112DE0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10112DE0[v2]],
             (&off_10112DE4)[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10112DC8: using guessed type double dbl_10112DC8[];
// 10112DD0: using guessed type double dbl_10112DD0[];
// 10112DD8: using guessed type double dbl_10112DD8[];
// 10112DE0: using guessed type int dword_10112DE0[];
// 10112DE4: using guessed type char *off_10112DE4;
// 1063E351: using guessed type char byte_1063E351;

//----- (100954D0) --------------------------------------------------------
char sub_100954D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_101139F0[v2];
      v4 = flt_101139EC[v2];
      v5 = flt_101139E8[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_101139F4[v2]],
             *(_DWORD *)&off_101139F8[v2 * 4]);
      v7 = sub_1007E660(0, dword_101139F4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_101139F4[v2]],
             *(_DWORD *)&off_101139F8[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101139E8: using guessed type float flt_101139E8[];
// 101139EC: using guessed type float flt_101139EC[];
// 101139F0: using guessed type float flt_101139F0[];
// 101139F4: using guessed type int dword_101139F4[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10095630) --------------------------------------------------------
char sub_10095630()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1063E351 )
  {
    sub_10082340(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_10095630,
      (int)sub_10095630,
      0);
    sub_10082340(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_10095630,
      0,
      0);
    result = sub_10082340(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10095630,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1063E351: using guessed type char byte_1063E351;

//----- (10095720) --------------------------------------------------------
char sub_10095720()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_10114188[v2];
      v4 = dword_10114184[v2];
      v5 = dword_10114180[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011418C[v2]],
             (&off_10114190)[v2 * 4]);
      v7 = sub_1007EB20(0, dword_1011418C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011418C[v2]],
             (&off_10114190)[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10114180: using guessed type int dword_10114180[];
// 10114184: using guessed type int dword_10114184[];
// 10114188: using guessed type int dword_10114188[];
// 1011418C: using guessed type int dword_1011418C[];
// 10114190: using guessed type char *off_10114190;
// 1063E351: using guessed type char byte_1063E351;

//----- (10095880) --------------------------------------------------------
char sub_10095880()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_1011491C[v2 / 2];
      v4 = word_1011491A[v2 / 2];
      v5 = word_10114918[v2 / 2];
      v6 = sub_1007D9C0(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10114920[v2 / 4]],
             (&off_10114924)[v2]);
      v7 = sub_1007EEE0(
             0,
             dword_10114920[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10114920[v2 / 4]],
             (&off_10114924)[v2]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10114918: using guessed type __int16 word_10114918[];
// 1011491A: using guessed type __int16 word_1011491A[];
// 1011491C: using guessed type __int16 word_1011491C[];
// 10114920: using guessed type int dword_10114920[];
// 10114924: using guessed type char *off_10114924;
// 1063E351: using guessed type char byte_1063E351;

//----- (100959E0) --------------------------------------------------------
char sub_100959E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_10114F30[v2];
      v4 = dword_10114F2C[v2];
      v5 = dword_10114F28[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10114F34[v2]],
             *(_DWORD *)&off_10114F38[v2 * 4]);
      v7 = sub_1007F2E0(0, dword_10114F34[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10114F34[v2]],
             *(_DWORD *)&off_10114F38[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10114F28: using guessed type int dword_10114F28[];
// 10114F2C: using guessed type int dword_10114F2C[];
// 10114F30: using guessed type int dword_10114F30[];
// 10114F34: using guessed type int dword_10114F34[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10095B40) --------------------------------------------------------
char sub_10095B40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_101156D4[v2];
      LODWORD(v3) = dword_101156D0[v2];
      HIDWORD(v4) = dword_101156CC[v2];
      LODWORD(v4) = dword_101156C8[v2];
      HIDWORD(v5) = dword_101156C4[v2];
      LODWORD(v5) = dword_101156C0[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_101156D8[v2]],
             *(_DWORD *)&off_101156DC[v2 * 4]);
      v7 = sub_1007F6A0(0, dword_101156D8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_101156D8[v2]],
             *(_DWORD *)&off_101156DC[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101156C0: using guessed type int dword_101156C0[];
// 101156C4: using guessed type int dword_101156C4[];
// 101156C8: using guessed type int dword_101156C8[];
// 101156CC: using guessed type int dword_101156CC[];
// 101156D0: using guessed type int dword_101156D0[];
// 101156D4: using guessed type int dword_101156D4[];
// 101156D8: using guessed type int dword_101156D8[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10095CB0) --------------------------------------------------------
char sub_10095CB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_101162E2[v2 * 4];
      v4 = byte_101162E1[v2 * 4];
      v5 = byte_101162E0[v2 * 4];
      v6 = sub_1007D9C0(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_101162E4[v2]],
             (&off_101162E8)[v2 * 4]);
      v7 = sub_1007FBE0(0, dword_101162E4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_101162E4[v2]],
             (&off_101162E8)[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101162E4: using guessed type int dword_101162E4[];
// 101162E8: using guessed type char *off_101162E8;
// 1063E351: using guessed type char byte_1063E351;

//----- (10095E10) --------------------------------------------------------
char sub_10095E10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_10116778[v2];
      v4 = dword_10116774[v2];
      v5 = dword_10116770[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011677C[v2]],
             (&off_10116780)[v2 * 4]);
      v7 = sub_1007FFC0(0, dword_1011677C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011677C[v2]],
             (&off_10116780)[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10116770: using guessed type int dword_10116770[];
// 10116774: using guessed type int dword_10116774[];
// 10116778: using guessed type int dword_10116778[];
// 1011677C: using guessed type int dword_1011677C[];
// 10116780: using guessed type char *off_10116780;
// 1063E351: using guessed type char byte_1063E351;

//----- (10095F70) --------------------------------------------------------
char sub_10095F70()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1063E351 )
  {
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_100823F0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100C4192,
           (const char *)&unk_100C4192,
           0);
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_100823F0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_100823F0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100C4192,
           0);
    sub_1007DD20(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_100823F0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           (const char *)&unk_100CF000,
           0);
    result = sub_1007DD20(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1063E351: using guessed type char byte_1063E351;

//----- (10096170) --------------------------------------------------------
char sub_10096170()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_10116F10[v2];
      v4 = dword_10116F0C[v2];
      v5 = dword_10116F08[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10116F14[v2]],
             *(_DWORD *)&off_10116F18[v2 * 4]);
      v7 = sub_10080380(0, dword_10116F14[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10116F14[v2]],
             *(_DWORD *)&off_10116F18[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10116F08: using guessed type int dword_10116F08[];
// 10116F0C: using guessed type int dword_10116F0C[];
// 10116F10: using guessed type int dword_10116F10[];
// 10116F14: using guessed type int dword_10116F14[];
// 1063E351: using guessed type char byte_1063E351;

//----- (100962D0) --------------------------------------------------------
char sub_100962D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_1011727C[v2 / 2];
      v4 = word_1011727A[v2 / 2];
      v5 = word_10117278[v2 / 2];
      v6 = sub_1007D9C0(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10117280[v2 / 4]],
             (&off_10117284)[v2]);
      v7 = sub_10080720(
             0,
             dword_10117280[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10117280[v2 / 4]],
             (&off_10117284)[v2]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10117278: using guessed type __int16 word_10117278[];
// 1011727A: using guessed type __int16 word_1011727A[];
// 1011727C: using guessed type __int16 word_1011727C[];
// 10117280: using guessed type int dword_10117280[];
// 10117284: using guessed type char *off_10117284;
// 1063E351: using guessed type char byte_1063E351;

//----- (10096430) --------------------------------------------------------
char sub_10096430()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_10117540[v2];
      v4 = dword_1011753C[v2];
      v5 = dword_10117538[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10117544[v2]],
             *(_DWORD *)&off_10117548[v2 * 4]);
      v7 = sub_10080B20(0, dword_10117544[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10117544[v2]],
             *(_DWORD *)&off_10117548[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10117538: using guessed type int dword_10117538[];
// 1011753C: using guessed type int dword_1011753C[];
// 10117540: using guessed type int dword_10117540[];
// 10117544: using guessed type int dword_10117544[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10096590) --------------------------------------------------------
char sub_10096590()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_101178BC[v2];
      LODWORD(v3) = dword_101178B8[v2];
      HIDWORD(v4) = dword_101178B4[v2];
      LODWORD(v4) = dword_101178B0[v2];
      HIDWORD(v5) = dword_101178AC[v2];
      LODWORD(v5) = dword_101178A8[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_101178C0[v2]],
             (&off_101178C4)[v2 * 4]);
      v7 = sub_10080EC0(0, dword_101178C0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_101178C0[v2]],
             (&off_101178C4)[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101178A8: using guessed type int dword_101178A8[];
// 101178AC: using guessed type int dword_101178AC[];
// 101178B0: using guessed type int dword_101178B0[];
// 101178B4: using guessed type int dword_101178B4[];
// 101178B8: using guessed type int dword_101178B8[];
// 101178BC: using guessed type int dword_101178BC[];
// 101178C0: using guessed type int dword_101178C0[];
// 101178C4: using guessed type char *off_101178C4;
// 1063E351: using guessed type char byte_1063E351;

//----- (10096700) --------------------------------------------------------
char sub_10096700()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_10117E2A[v2 * 4];
      v4 = byte_10117E29[v2 * 4];
      v5 = byte_10117E28[v2 * 4];
      v6 = sub_1007D9C0(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10117E2C[v2]],
             (&off_10117E30)[v2 * 4]);
      v7 = sub_100814A0(0, dword_10117E2C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10117E2C[v2]],
             (&off_10117E30)[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10117E2C: using guessed type int dword_10117E2C[];
// 10117E30: using guessed type char *off_10117E30;
// 1063E351: using guessed type char byte_1063E351;

//----- (10096860) --------------------------------------------------------
char sub_10096860()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_10118040[v2];
      v4 = dword_1011803C[v2];
      v5 = dword_10118038[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10118044[v2]],
             *(_DWORD *)&off_10118048[v2 * 4]);
      v7 = sub_10081890(0, dword_10118044[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10118044[v2]],
             *(_DWORD *)&off_10118048[v2 * 4]);
      result = sub_1007DD20(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10118038: using guessed type int dword_10118038[];
// 1011803C: using guessed type int dword_1011803C[];
// 10118040: using guessed type int dword_10118040[];
// 10118044: using guessed type int dword_10118044[];
// 1063E351: using guessed type char byte_1063E351;

//----- (100969C0) --------------------------------------------------------
char sub_100969C0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  int v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  int v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1063E351 )
  {
    v2 = 0;
    do
    {
      if ( off_101183AC[v2] )
      {
        sub_1007D720((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_101183B4[v2 * 4], 0x100u, &v13);
        sub_1007D720((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_101183AC[v2], 0x100u, &v14);
        sub_1008FAA0(&v14, &v13);
      }
      if ( byte_101183A8[v2 * 4] )
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_101183B0[v2];
        v4 = *(_DWORD *)&off_101183B4[v2 * 4];
        v5 = sub_1007D9C0(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_101183B4[v2 * 4],
               off_101183B0[v2]);
        v12 = 1;
        v11 = sub_10082040(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2745", (int)v5, v4, (int)v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_101183B0[v2];
        v7 = *(_DWORD *)&off_101183B4[v2 * 4];
        v8 = sub_1007D9C0(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_101183B4[v2 * 4],
               off_101183B0[v2]);
        v12 = 1;
        v11 = sub_10082040(1, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2754", (int)v8, v7, (int)v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101183AC: using guessed type char *off_101183AC[3];
// 101183B0: using guessed type char *off_101183B0[2];
// 1063E351: using guessed type char byte_1063E351;

//----- (10096BD0) --------------------------------------------------------
char sub_10096BD0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1063E351 )
  {
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1007DD20(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1007DD20(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1007DD20(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1007DD20(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1007DD20(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1063E351: using guessed type char byte_1063E351;

//----- (10096DC0) --------------------------------------------------------
char sub_10096DC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      v0 = dword_101183FC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_101183F9[v2 * 4];
        v4 = byte_101183F8[v2 * 4];
        v5 = sub_1007D9C0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10107900[4 * dword_101183FC[v2]],
               (&off_10118400)[v2 * 4]);
        v6 = sub_1007DE60(1, dword_101183FC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1007D9C0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10107900[4 * dword_101183FC[v2]],
               (&off_10118400)[v2 * 4]);
        LOBYTE(v0) = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1007CF60(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 101183FC: using guessed type int dword_101183FC[];
// 10118400: using guessed type char *off_10118400;
// 1063E351: using guessed type char byte_1063E351;

//----- (10096F30) --------------------------------------------------------
char sub_10096F30()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_10118678[v2 / 2];
      v4 = dbl_10118670[v2 / 2];
      v5 = dbl_10118668[v2 / 2];
      v6 = sub_1007D9C0(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10118680[v2]],
             (&off_10118684)[v2 * 4]);
      v7 = sub_1007E210(1, dword_10118680[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10118680[v2]],
             (&off_10118684)[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10118668: using guessed type double dbl_10118668[];
// 10118670: using guessed type double dbl_10118670[];
// 10118678: using guessed type double dbl_10118678[];
// 10118680: using guessed type int dword_10118680[];
// 10118684: using guessed type char *off_10118684;
// 1063E351: using guessed type char byte_1063E351;

//----- (100970A0) --------------------------------------------------------
char sub_100970A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_10119290[v2];
      v4 = flt_1011928C[v2];
      v5 = flt_10119288[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10119294[v2]],
             *(_DWORD *)&off_10119298[v2 * 4]);
      v7 = sub_1007E660(1, dword_10119294[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10119294[v2]],
             *(_DWORD *)&off_10119298[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10119288: using guessed type float flt_10119288[];
// 1011928C: using guessed type float flt_1011928C[];
// 10119290: using guessed type float flt_10119290[];
// 10119294: using guessed type int dword_10119294[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10097200) --------------------------------------------------------
char sub_10097200()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1063E351 )
  {
    sub_10082340(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_10097200,
      (int)sub_10097200,
      0);
    sub_10082340(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_10097200,
      0,
      0);
    result = sub_10082340(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10097200,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1063E351: using guessed type char byte_1063E351;

//----- (100972F0) --------------------------------------------------------
char sub_100972F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_10119A28[v2];
      v4 = dword_10119A24[v2];
      v5 = dword_10119A20[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_10119A2C[v2]],
             (&off_10119A30)[v2 * 4]);
      v7 = sub_1007EB20(1, dword_10119A2C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_10119A2C[v2]],
             (&off_10119A30)[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10119A20: using guessed type int dword_10119A20[];
// 10119A24: using guessed type int dword_10119A24[];
// 10119A28: using guessed type int dword_10119A28[];
// 10119A2C: using guessed type int dword_10119A2C[];
// 10119A30: using guessed type char *off_10119A30;
// 1063E351: using guessed type char byte_1063E351;

//----- (10097450) --------------------------------------------------------
char sub_10097450()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_1011A1BC[v2 / 2];
      v4 = word_1011A1BA[v2 / 2];
      v5 = word_1011A1B8[v2 / 2];
      v6 = sub_1007D9C0(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011A1C0[v2 / 4]],
             (&off_1011A1C4)[v2]);
      v7 = sub_1007EEE0(
             1,
             dword_1011A1C0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011A1C0[v2 / 4]],
             (&off_1011A1C4)[v2]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011A1B8: using guessed type __int16 word_1011A1B8[];
// 1011A1BA: using guessed type __int16 word_1011A1BA[];
// 1011A1BC: using guessed type __int16 word_1011A1BC[];
// 1011A1C0: using guessed type int dword_1011A1C0[];
// 1011A1C4: using guessed type char *off_1011A1C4;
// 1063E351: using guessed type char byte_1063E351;

//----- (100975B0) --------------------------------------------------------
char sub_100975B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_1011A7D0[v2];
      v4 = dword_1011A7CC[v2];
      v5 = dword_1011A7C8[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011A7D4[v2]],
             *(_DWORD *)&off_1011A7D8[v2 * 4]);
      v7 = sub_1007F2E0(1, dword_1011A7D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011A7D4[v2]],
             *(_DWORD *)&off_1011A7D8[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011A7C8: using guessed type int dword_1011A7C8[];
// 1011A7CC: using guessed type int dword_1011A7CC[];
// 1011A7D0: using guessed type int dword_1011A7D0[];
// 1011A7D4: using guessed type int dword_1011A7D4[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10097710) --------------------------------------------------------
char sub_10097710()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_1011AF74[v2];
      LODWORD(v3) = dword_1011AF70[v2];
      HIDWORD(v4) = dword_1011AF6C[v2];
      LODWORD(v4) = dword_1011AF68[v2];
      HIDWORD(v5) = dword_1011AF64[v2];
      LODWORD(v5) = dword_1011AF60[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011AF78[v2]],
             *(_DWORD *)&off_1011AF7C[v2 * 4]);
      v7 = sub_1007F6A0(1, dword_1011AF78[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011AF78[v2]],
             *(_DWORD *)&off_1011AF7C[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011AF60: using guessed type int dword_1011AF60[];
// 1011AF64: using guessed type int dword_1011AF64[];
// 1011AF68: using guessed type int dword_1011AF68[];
// 1011AF6C: using guessed type int dword_1011AF6C[];
// 1011AF70: using guessed type int dword_1011AF70[];
// 1011AF74: using guessed type int dword_1011AF74[];
// 1011AF78: using guessed type int dword_1011AF78[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10097880) --------------------------------------------------------
char sub_10097880()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_1011BB82[v2 * 4];
      v4 = byte_1011BB81[v2 * 4];
      v5 = byte_1011BB80[v2 * 4];
      v6 = sub_1007D9C0(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011BB84[v2]],
             (&off_1011BB88)[v2 * 4]);
      v7 = sub_1007FBE0(1, dword_1011BB84[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011BB84[v2]],
             (&off_1011BB88)[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011BB84: using guessed type int dword_1011BB84[];
// 1011BB88: using guessed type char *off_1011BB88;
// 1063E351: using guessed type char byte_1063E351;

//----- (100979E0) --------------------------------------------------------
char sub_100979E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_1011C018[v2];
      v4 = dword_1011C014[v2];
      v5 = dword_1011C010[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011C01C[v2]],
             (&off_1011C020)[v2 * 4]);
      v7 = sub_1007FFC0(1, dword_1011C01C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011C01C[v2]],
             (&off_1011C020)[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011C010: using guessed type int dword_1011C010[];
// 1011C014: using guessed type int dword_1011C014[];
// 1011C018: using guessed type int dword_1011C018[];
// 1011C01C: using guessed type int dword_1011C01C[];
// 1011C020: using guessed type char *off_1011C020;
// 1063E351: using guessed type char byte_1063E351;

//----- (10097B40) --------------------------------------------------------
char sub_10097B40()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1007CF60(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1007D8B0(0);
  sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_1007CF60(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1063E351 )
  {
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_100823F0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100C4192,
           (const char *)&unk_100C4192,
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_100823F0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_100823F0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100C4192,
           0);
    sub_1007DD20(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_100823F0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           (const char *)&unk_100CF000,
           0);
    result = sub_1007DD20(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1063E351: using guessed type char byte_1063E351;

//----- (10097D40) --------------------------------------------------------
char sub_10097D40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_1011C7B0[v2];
      v4 = dword_1011C7AC[v2];
      v5 = dword_1011C7A8[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011C7B4[v2]],
             *(_DWORD *)&off_1011C7B8[v2 * 4]);
      v7 = sub_10080380(1, dword_1011C7B4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011C7B4[v2]],
             *(_DWORD *)&off_1011C7B8[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011C7A8: using guessed type int dword_1011C7A8[];
// 1011C7AC: using guessed type int dword_1011C7AC[];
// 1011C7B0: using guessed type int dword_1011C7B0[];
// 1011C7B4: using guessed type int dword_1011C7B4[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10097EA0) --------------------------------------------------------
char sub_10097EA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_1011CB1C[v2 / 2];
      v4 = word_1011CB1A[v2 / 2];
      v5 = word_1011CB18[v2 / 2];
      v6 = sub_1007D9C0(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011CB20[v2 / 4]],
             (&off_1011CB24)[v2]);
      v7 = sub_10080720(
             1,
             dword_1011CB20[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011CB20[v2 / 4]],
             (&off_1011CB24)[v2]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011CB18: using guessed type __int16 word_1011CB18[];
// 1011CB1A: using guessed type __int16 word_1011CB1A[];
// 1011CB1C: using guessed type __int16 word_1011CB1C[];
// 1011CB20: using guessed type int dword_1011CB20[];
// 1011CB24: using guessed type char *off_1011CB24;
// 1063E351: using guessed type char byte_1063E351;

//----- (10098000) --------------------------------------------------------
char sub_10098000()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_1011CDE0[v2];
      v4 = dword_1011CDDC[v2];
      v5 = dword_1011CDD8[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011CDE4[v2]],
             *(_DWORD *)&off_1011CDE8[v2 * 4]);
      v7 = sub_10080B20(1, dword_1011CDE4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011CDE4[v2]],
             *(_DWORD *)&off_1011CDE8[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011CDD8: using guessed type int dword_1011CDD8[];
// 1011CDDC: using guessed type int dword_1011CDDC[];
// 1011CDE0: using guessed type int dword_1011CDE0[];
// 1011CDE4: using guessed type int dword_1011CDE4[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10098160) --------------------------------------------------------
char sub_10098160()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_1011D15C[v2];
      LODWORD(v3) = dword_1011D158[v2];
      HIDWORD(v4) = dword_1011D154[v2];
      LODWORD(v4) = dword_1011D150[v2];
      HIDWORD(v5) = dword_1011D14C[v2];
      LODWORD(v5) = dword_1011D148[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011D160[v2]],
             (&off_1011D164)[v2 * 4]);
      v7 = sub_10080EC0(1, dword_1011D160[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011D160[v2]],
             (&off_1011D164)[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011D148: using guessed type int dword_1011D148[];
// 1011D14C: using guessed type int dword_1011D14C[];
// 1011D150: using guessed type int dword_1011D150[];
// 1011D154: using guessed type int dword_1011D154[];
// 1011D158: using guessed type int dword_1011D158[];
// 1011D15C: using guessed type int dword_1011D15C[];
// 1011D160: using guessed type int dword_1011D160[];
// 1011D164: using guessed type char *off_1011D164;
// 1063E351: using guessed type char byte_1063E351;

//----- (100982D0) --------------------------------------------------------
char sub_100982D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_1011D6CA[v2 * 4];
      v4 = byte_1011D6C9[v2 * 4];
      v5 = byte_1011D6C8[v2 * 4];
      v6 = sub_1007D9C0(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011D6CC[v2]],
             (&off_1011D6D0)[v2 * 4]);
      v7 = sub_100814A0(1, dword_1011D6CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011D6CC[v2]],
             (&off_1011D6D0)[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011D6CC: using guessed type int dword_1011D6CC[];
// 1011D6D0: using guessed type char *off_1011D6D0;
// 1063E351: using guessed type char byte_1063E351;

//----- (10098430) --------------------------------------------------------
char sub_10098430()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1063E351 )
  {
    sub_1007CF60(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1007D8B0(0);
    sub_1007CF60(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_1007CF60(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1007D9A0(0);
    v2 = 0;
    do
    {
      sub_1007D8D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_1011D8E0[v2];
      v4 = dword_1011D8DC[v2];
      v5 = dword_1011D8D8[v2];
      v6 = sub_1007D9C0(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10107900[4 * dword_1011D8E4[v2]],
             *(_DWORD *)&off_1011D8E8[v2 * 4]);
      v7 = sub_10081890(1, dword_1011D8E4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1007D9C0(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10107900[4 * dword_1011D8E4[v2]],
             *(_DWORD *)&off_1011D8E8[v2 * 4]);
      result = sub_1007DD20(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1007CF60(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011D8D8: using guessed type int dword_1011D8D8[];
// 1011D8DC: using guessed type int dword_1011D8DC[];
// 1011D8E0: using guessed type int dword_1011D8E0[];
// 1011D8E4: using guessed type int dword_1011D8E4[];
// 1063E351: using guessed type char byte_1063E351;

//----- (10098590) --------------------------------------------------------
char **sub_10098590()
{
  return off_10108FEC;
}
// 10108FEC: using guessed type char *off_10108FEC[3];

//----- (100985A0) --------------------------------------------------------
int __cdecl sub_100985A0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (100985C0) --------------------------------------------------------
int (__cdecl *__usercall sub_100985C0@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (100985D0) --------------------------------------------------------
int __usercall sub_100985D0@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (10098800) --------------------------------------------------------
int (__cdecl *__cdecl sub_10098800(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_100985C0(a1, (int)word_100D2B44);
  sub_100985C0(a1, a2);
  sub_100985C0(a1, (int)&unk_10121B2C);
  v3 = sub_100985D0(a3, a1);
  sub_100985C0(a1, v3);
  return sub_100985C0(a1, (int)&unk_10121B28);
}

//----- (10098850) --------------------------------------------------------
int (__cdecl *__cdecl sub_10098850(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_100985C0(a1, (int)word_100D2B44);
  sub_100985C0(a1, a2);
  sub_100985C0(a1, (int)&unk_10121B34);
  v3 = sub_100985D0(a3, a1);
  sub_100985C0(a1, v3);
  return sub_100985C0(a1, (int)&unk_10121B30);
}

//----- (100988A0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100988A0(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_100985C0(a1, (int)&unk_100D1D24);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_100985D0(a2, a1);
    result = sub_100985C0(a1, v3);
  }
  return result;
}

//----- (100988F0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100988F0(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_10121B3C;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_100985C0(a1, dword_10121A94[(signed int)result]);
      sub_100985C0(a1, (int)&unk_10121B38);
      sub_100985C0(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100D1D24;
    }
    result = sub_100985C0(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_100985C0(a1, (int)&word_100F78F4);
  }
  return result;
}
// 100F78F4: using guessed type __int16 word_100F78F4;
// 10121A94: using guessed type int dword_10121A94[];

//----- (10098970) --------------------------------------------------------
int __cdecl sub_10098970(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_100985C0(a1, (int)&unk_100D1D24);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_100985C0(a1, (int)(&off_10121A98)[2 * (*(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84))]);
  sub_100985C0(a1, (int)&unk_100D1D34);
  sub_100985C0(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}
// 10121A98: using guessed type __int16 *off_10121A98;

//----- (100989F0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100989F0(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_100985D0(a2, a1);
    sub_100985C0(a1, v3);
    result = sub_100985C0(a1, (int)&word_100F78F4);
  }
  else
  {
    sub_100985C0(a1, (int)a2);
    result = sub_100985C0(a1, (int)&word_100F78F4);
  }
  return result;
}
// 100F78F4: using guessed type __int16 word_100F78F4;

//----- (10098A40) --------------------------------------------------------
int (__cdecl *__cdecl sub_10098A40(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_10098970(a1, a2);
  if ( a3 && *a3 )
    sub_100988A0(a1, a3);
  return sub_100988F0(a1);
}

//----- (10098A80) --------------------------------------------------------
int (__cdecl *__cdecl sub_10098A80(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_10098A40(a1, a2, (unsigned __int8 *)&v4);
}

//----- (10098AE0) --------------------------------------------------------
char __cdecl sub_10098AE0(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10098B20) --------------------------------------------------------
int __cdecl sub_10098B20(char a1)
{
  return sub_10071590(&a1, 1u, (int)&unk_1013B6C0, 8, 2, 2);
}

//----- (10098B40) --------------------------------------------------------
BOOL __cdecl sub_10098B40(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_1008EA40(a1);
  return sub_10074500(0, 604, a2) && sub_10073ED0(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (10098BA0) --------------------------------------------------------
int __usercall sub_10098BA0@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_10098B20(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_1013B6C4[2 * v1];
  return result;
}
// 1013B6C4: using guessed type int dword_1013B6C4[];

//----- (10098BD0) --------------------------------------------------------
BOOL __cdecl sub_10098BD0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10098BA0(a1);
  return sub_1009B830(v2, a2, 16) == 0;
}

//----- (10098C00) --------------------------------------------------------
int __cdecl sub_10098C00(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10098BD0(a1, (int)a5);
  else
    result = sub_10098B40(a1, a5);
  return result;
}

//----- (10098C30) --------------------------------------------------------
char __cdecl sub_10098C30(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10074530(1, 1947, a1, (int)&v3);
}

//----- (10098C50) --------------------------------------------------------
BOOL __cdecl sub_10098C50(int a1)
{
  return sub_1009B830(6792, a1, 284) == 0;
}

//----- (10098C70) --------------------------------------------------------
char __cdecl sub_10098C70(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_10098C50((int)a5);
  else
    result = sub_10098C30(a5);
  return result;
}

//----- (10098CA0) --------------------------------------------------------
bool __cdecl sub_10098CA0(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10071590(&a2, 4u, (int)&dword_1013C538, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_1009B830((unsigned __int16)word_1013C53C[a1 + 6 * v3], a3, (unsigned __int16)word_1013C540[6 * v3]) == 0;
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 1013C538: using guessed type int dword_1013C538;
// 1013C53C: using guessed type __int16 word_1013C53C[];
// 1013C540: using guessed type __int16 word_1013C540[];

//----- (10098D30) --------------------------------------------------------
bool __cdecl sub_10098D30(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1009AB60(a1);
  v6 = sub_10071590(&a3, 1u, (int)&unk_1013C55C, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10071590(&dword_1013C560[2 * v6], 4u, (int)&dword_1013C538, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_1013C540[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10098CA0(v11, *(int *)((char *)&dword_1013C538 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1013C538: using guessed type int dword_1013C538;
// 1013C540: using guessed type __int16 word_1013C540[];

//----- (10098DD0) --------------------------------------------------------
bool __cdecl sub_10098DD0(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_1009B830((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (10098E10) --------------------------------------------------------
signed int __usercall sub_10098E10@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (10098E30) --------------------------------------------------------
bool __cdecl sub_10098E30(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  void *v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_10098E10(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10073ED0(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10074530(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_10098DD0(a1, a2);
  }
  else
  {
    v9 = sub_100705C0(v4);
    v8 = 1708;
    sub_10074030(1, 0, &v8, 0, 8, 1);
    sub_10074170(1, 0, v2);
    result = 0;
  }
  return result;
}
// 1009C320: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1009C350: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10098F20) --------------------------------------------------------
bool __cdecl sub_10098F20(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_10098DD0(a1, a5);
  else
    result = sub_10098E30(a1, a5);
  return result;
}

//----- (10098F50) --------------------------------------------------------
BOOL __cdecl sub_10098F50(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (10098F60) --------------------------------------------------------
BOOL __usercall sub_10098F60@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_10098F50(a1) && *v2 < 3u && a2 == 24;
}

//----- (10098F90) --------------------------------------------------------
bool __cdecl sub_10098F90(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_10098F50(a1) )
    {
      v6 = 10 * v5;
      if ( sub_1008E900((unsigned __int8)byte_1013D978[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10074500(1, (unsigned __int16)word_1013D970[v6], &Tm.tm_mon) || sub_10075620((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_1008F020(a1, &v15) || v15 != dword_1013D990[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10074500(1, (unsigned __int16)word_1013D974[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 1013D970: using guessed type __int16 word_1013D970[];
// 1013D974: using guessed type __int16 word_1013D974[];
// 1013D990: using guessed type int dword_1013D990[];

//----- (10099140) --------------------------------------------------------
bool __cdecl sub_10099140(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_10098F50(a1) )
    result = sub_1009B830((unsigned __int16)word_1013D97A[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 1013D97A: using guessed type __int16 word_1013D97A[];

//----- (10099180) --------------------------------------------------------
bool __cdecl sub_10099180(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_1008EF70(a1);
  if ( !(unsigned __int8)sub_10098F60(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10098F90(v9, a3, *a4, (int)a5);
  if ( sub_1008E900((unsigned __int8)byte_1013D978[20 * v6], (bool *)&v8) && v8 && sub_10099140(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10099180: using guessed type int var_20[7];

//----- (10099270) --------------------------------------------------------
char __cdecl sub_10099270(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_10640BE8, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_1008E700(a1, (int)byte_10640BE8);
    v3 = 4 * a2 - 64;
    v4 = byte_10640BE9[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10640BE8[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (10099310) --------------------------------------------------------
bool __cdecl sub_10099310(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_10640BE8, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_1008E700(a1, (int)byte_10640BE8);
    v3 = (char *)&unk_10640C88 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (10099390) --------------------------------------------------------
char __cdecl sub_10099390(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10640BE8, 0, 0x890u);
  sub_1008E700(a1, (int)byte_10640BE8);
  if ( a2 > 0x10u )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_10640F58[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_10640F5C[2 * a2];
    result = 1;
  }
  return result;
}
// 10640F58: using guessed type int dword_10640F58[];
// 10640F5C: using guessed type int dword_10640F5C[];

//----- (10099400) --------------------------------------------------------
char __cdecl sub_10099400(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10074500(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10074500(0, 572, a2);
    }
    else
    {
      sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10074500(0, 226, a2);
  }
  return result;
}

//----- (10099480) --------------------------------------------------------
char __cdecl sub_10099480(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_10640BE8, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10099400(a1, byte_10640BE8);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_10640BE9[v4];
    *(_BYTE *)a3 = byte_10640BE8[v4];
  }
  return result;
}

//----- (10099500) --------------------------------------------------------
char __cdecl sub_10099500(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_10640BE8, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10099400(a1, byte_10640BE8);
    v4 = (char *)&unk_10640C88 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (10099580) --------------------------------------------------------
char __cdecl sub_10099580(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10640BE8, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10099400(a1, byte_10640BE8);
    *(_DWORD *)a3 = dword_10640F58[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_10640F5C[2 * a2];
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 10640F58: using guessed type int dword_10640F58[];
// 10640F5C: using guessed type int dword_10640F5C[];

//----- (100995F0) --------------------------------------------------------
char __cdecl sub_100995F0(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1009AD70(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_10099390(v6, *a4, a5);
    else
      result = sub_10099580(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_10099270(v6, *a4, a5);
    else
      result = sub_10099480(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_10099310(v6, *a4, a5);
    else
      result = sub_10099500(v6, *a4, a5);
  }
  return result;
}

//----- (10099700) --------------------------------------------------------
char __cdecl sub_10099700(char a1, void *a2)
{
  return sub_10074500(6, (unsigned __int16)word_1013E4BA[8 * (unsigned __int8)a1], a2);
}
// 1013E4BA: using guessed type __int16 word_1013E4BA[];

//----- (10099720) --------------------------------------------------------
bool __cdecl sub_10099720(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_1009B830(dword_1013E4C0[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 1013E4C0: using guessed type int dword_1013E4C0[];

//----- (10099760) --------------------------------------------------------
char __cdecl sub_10099760(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1009ADB0(a1);
  if ( a2 )
    result = sub_10099720(v6, (char *)a5);
  else
    result = sub_10099700(v6, a5);
  return result;
}

//----- (100997A0) --------------------------------------------------------
BOOL sub_100997A0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_1008E840(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10099800) --------------------------------------------------------
char __cdecl sub_10099800(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10074500(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_100997A0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10075320((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (100998F0) --------------------------------------------------------
BOOL __cdecl sub_100998F0(int a1, int a2)
{
  return sub_1009B830(6200, a2, 60) == 0;
}

//----- (10099910) --------------------------------------------------------
char __cdecl sub_10099910(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_100998F0(a1, (int)a5);
  }
  else
  {
    result = sub_10099800(a1, a5);
  }
  return result;
}

//----- (10099950) --------------------------------------------------------
char __cdecl sub_10099950(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10074500(2, 284, &v6) || sub_10075520((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10099A00) --------------------------------------------------------
BOOL __cdecl sub_10099A00(int a1, int a2)
{
  return sub_1009B830(6169, a2, 40) == 0;
}

//----- (10099A20) --------------------------------------------------------
char __cdecl sub_10099A20(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10099A00(a1, a5);
  }
  else
  {
    result = sub_10099950(a1, a5);
  }
  return result;
}

//----- (10099A60) --------------------------------------------------------
char __cdecl sub_10099A60(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10074500(2, 363, a1);
}

//----- (10099A80) --------------------------------------------------------
char __cdecl sub_10099A80(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_1009B830(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10099BD0) --------------------------------------------------------
char __cdecl sub_10099BD0(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10099A80(a5);
      else
        result = sub_10099A60(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10099A80(&unk_10641478);
      else
        v7 = sub_10099A60(&unk_10641478);
      v8 = v7;
      memcpy(a5, (char *)&unk_10641478 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10099A80(&unk_10641478);
      else
        v9 = sub_10099A60(&unk_10641478);
      v10 = v9;
      memcpy(a5, (char *)&unk_10644380 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10099A80(&unk_10641478);
      else
        v11 = sub_10099A60(&unk_10641478);
      v12 = v11;
      memcpy(a5, (char *)&unk_10644880 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10099A80(&unk_10641478);
      else
        v13 = sub_10099A60(&unk_10641478);
      v14 = v13;
      memcpy(a5, &unk_10644928, a6);
      result = v14;
      break;
    default:
      sub_10070AD0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10099D70) --------------------------------------------------------
char __cdecl sub_10099D70(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10099DB0) --------------------------------------------------------
__int16 __usercall sub_10099DB0@<ax>(unsigned __int8 a1@<al>)
{
  return word_10141070[a1];
}
// 10141070: using guessed type __int16 word_10141070[];

//----- (10099DC0) --------------------------------------------------------
char __cdecl sub_10099DC0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_10099DB0(a1);
    if ( sub_10074530(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10099E90) --------------------------------------------------------
char __cdecl sub_10099E90(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10099D70(a1);
  if ( a3 != 11 )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10099DC0(v7, a5);
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10099F10) --------------------------------------------------------
char __cdecl sub_10099F10(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1009B150(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1009AF50(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1009AFD0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1009B050(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1009B0D0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1009A020) --------------------------------------------------------
int __cdecl sub_1009A020(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10071590(&a1, 1u, (int)&unk_101418A8, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_101418AC[2 * v1];
  }
  return result;
}
// 101418AC: using guessed type int dword_101418AC[];

//----- (1009A070) --------------------------------------------------------
char __cdecl sub_1009A070(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_1008E730(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_1009B830(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_1008E750((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1009A1E0) --------------------------------------------------------
int __usercall sub_1009A1E0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1009A070(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1009A1E0: using guessed type int var_2C[10];

//----- (1009A220) --------------------------------------------------------
int __usercall sub_1009A220@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1009A070(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1009A220: using guessed type int var_14[4];

//----- (1009A260) --------------------------------------------------------
signed int sub_1009A260()
{
  return sub_1009C150((int)&off_10142758);
}
// 10142758: using guessed type char *off_10142758;

//----- (1009A270) --------------------------------------------------------
char __cdecl sub_1009A270(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1009A260() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1068B58C + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1068B58C + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_1068B58C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1068B58C: using guessed type int dword_1068B58C;

//----- (1009A2D0) --------------------------------------------------------
char __cdecl sub_1009A2D0(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1009A260() )
  {
    if ( (sub_1008EA90(a1)
       || *(_BYTE *)(dword_1068B58C + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_1068B58C + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_1068B58C + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 176))
      && *(_BYTE *)(dword_1068B58C + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_1068B58C + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1068B58C + 162) )
    {
      qmemcpy(a2, (const void *)(dword_1068B58C + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1068B58C: using guessed type int dword_1068B58C;

//----- (1009A3F0) --------------------------------------------------------
char __cdecl sub_1009A3F0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1009A260() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_1068B58C + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1068B58C + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1068B58C + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_1068B58C + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_1068B58C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1068B58C: using guessed type int dword_1068B58C;

//----- (1009A470) --------------------------------------------------------
char __cdecl sub_1009A470(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10070AD0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1009A220(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1009A3F0(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1009A1E0(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1009A270(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1009A070(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1009A2D0(v6, a5);
        }
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10070AD0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1009A620) --------------------------------------------------------
char __cdecl sub_1009A620(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10070AD0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10074530(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10074530(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10075A00((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_10644950, (char *)&v6 + 1, 0x20u);
      byte_10644948 = 1;
      byte_10644949 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_10644970, (char *)&v6 + 1, 0x20u);
    byte_10644949 = 1;
    byte_1064494A = 1;
    return result;
  }
  return 0;
}
// 10644948: using guessed type char byte_10644948;
// 10644949: using guessed type char byte_10644949;
// 1064494A: using guessed type char byte_1064494A;

//----- (1009A750) --------------------------------------------------------
char __cdecl sub_1009A750(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_1008E6B0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10070AD0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (1009A7D0) --------------------------------------------------------
bool __cdecl sub_1009A7D0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_10644948 == 0;
    qmemcpy(a1, &unk_10644950, 0x40u);
    result = !v1 && byte_1064494A;
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 10644948: using guessed type char byte_10644948;
// 1064494A: using guessed type char byte_1064494A;

//----- (1009A820) --------------------------------------------------------
char __cdecl sub_1009A820(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10070AD0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_10076DD0(15);
    v3 = 555;
  }
  else
  {
    result = sub_10076DD0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_10644949 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10074030(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 1009C350: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10644949: using guessed type char byte_10644949;

//----- (1009A900) --------------------------------------------------------
__int16 __usercall sub_1009A900@<ax>(unsigned __int8 a1@<al>)
{
  return word_10142878[a1];
}
// 10142878: using guessed type __int16 word_10142878[];

//----- (1009A910) --------------------------------------------------------
char __cdecl sub_1009A910(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_1009A900(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10074030(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10074170(1, v3, 0xFFFFFFF);
}

//----- (1009A9A0) --------------------------------------------------------
char __cdecl sub_1009A9A0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10070AD0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_10644949 != 0 ? 25 : 11;
      sub_1009A910(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_1009A910(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 10644949: using guessed type char byte_10644949;

//----- (1009AA60) --------------------------------------------------------
bool __cdecl sub_1009AA60(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_1009A750(a1, (int)a5);
    return 1;
  }
  if ( byte_10644949 )
  {
    if ( sub_1009A620(a1, &v6, 1) )
    {
LABEL_14:
      byte_1064494B = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1064494B >= 5u )
    {
      byte_10644948 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_1009A620(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1064494B >= 5u )
    {
      byte_1064494A = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_1009A750(a1, (int)&v6);
    sub_1009A820(a1, (int)&v6);
  }
  sub_1009A9A0(a1, 11);
  return sub_1009A7D0(a5);
}
// 1009C350: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10644948: using guessed type char byte_10644948;
// 10644949: using guessed type char byte_10644949;
// 1064494A: using guessed type char byte_1064494A;
// 1064494B: using guessed type char byte_1064494B;

//----- (1009AB60) --------------------------------------------------------
char __cdecl sub_1009AB60(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10070AD0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1009ABE0) --------------------------------------------------------
int __cdecl sub_1009ABE0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (1009AC00) --------------------------------------------------------
char __cdecl sub_1009AC00(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_1007A970((int)&v12);
}
// 1009AC00: using guessed type char var_518[1300];

//----- (1009ACD0) --------------------------------------------------------
bool __cdecl sub_1009ACD0(void *a1)
{
  char v1; // al@1

  v1 = sub_10074500(1, 1946, a1);
  *((_DWORD *)a1 + 1) = (unsigned int)(*((_DWORD *)a1 + 1) * (unsigned __int64)(unsigned int)&unk_10624DD3 >> 32) >> 6;
  return v1 && !sub_10075670((int)a1);
}

//----- (1009AD10) --------------------------------------------------------
char __cdecl sub_1009AD10(char a1)
{
  sub_10074030(1, 1672, &a1, 0, 1, 1);
  return sub_10074170(1, 0x688u, 0xFFFFFFF);
}

//----- (1009AD40) --------------------------------------------------------
char __cdecl sub_1009AD40(char a1)
{
  int v1; // eax@1

  v1 = sub_1009B900(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_1009AD10(a1);
  return v1;
}

//----- (1009AD70) --------------------------------------------------------
char __cdecl sub_1009AD70(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10070AD0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1009ADB0) --------------------------------------------------------
char __cdecl sub_1009ADB0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1009ADD0) --------------------------------------------------------
int __cdecl sub_1009ADD0(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_10147964[2 * sub_10071590(&a1, 1u, (int)&unk_10147960, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_101479A4[2 * sub_10071590(&a2, 1u, (int)&unk_101479A0, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_101479D4[2 * sub_10071590(&a2, 1u, (int)&unk_101479D0, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_1014797C[2 * sub_10071590(&a2, 1u, (int)&unk_10147978, 8, 5, 5)];
  }
  return result;
}
// 10147964: using guessed type int dword_10147964[];
// 1014797C: using guessed type int dword_1014797C[];
// 101479A4: using guessed type int dword_101479A4[];
// 101479D4: using guessed type int dword_101479D4[];

//----- (1009AE80) --------------------------------------------------------
bool __usercall sub_1009AE80@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_10149547[44 * a1] - (unsigned __int8)byte_10149542[44 * a1];
}

//----- (1009AEB0) --------------------------------------------------------
char __usercall sub_1009AEB0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_1009AE80(a1, a4, a5) )
  {
    v6 = a3
       + sub_1009ADD0(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_10149542[44 * a1] - (unsigned __int8)byte_10149547[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_1009ADD0(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (1009AF50) --------------------------------------------------------
char __cdecl sub_1009AF50(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1009A020(a1);
  sub_1009B850(v5, (int)&v7, 3684);
  return sub_1009AEB0(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1009AFD0) --------------------------------------------------------
char __cdecl sub_1009AFD0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1009A020(a1);
  sub_1009B850(v5, (int)&v7, 3684);
  return sub_1009AEB0(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1009B050) --------------------------------------------------------
char __cdecl sub_1009B050(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1009A020(a1);
  sub_1009B850(v5, (int)&v7, 3684);
  return sub_1009AEB0(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1009B0D0) --------------------------------------------------------
char __cdecl sub_1009B0D0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1009A020(a1);
  sub_1009B850(v5, (int)&v7, 3684);
  return sub_1009AEB0(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1009B150) --------------------------------------------------------
char __cdecl sub_1009B150(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10070AD0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1009B210) --------------------------------------------------------
int __cdecl sub_1009B210(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74C4: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (1009B230) --------------------------------------------------------
int sub_1009B230()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74CA: using guessed type int TSK_pvg_get_id(void);

//----- (1009B250) --------------------------------------------------------
int __cdecl sub_1009B250(int a1, int a2, int a3)
{
  int v3; // esi@1

  SYS_enter_krnl();
  v3 = TSK_pvg_get_mon_data(a1, a2, a3);
  SYS_exit_krnl();
  return v3;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74D0: using guessed type int __cdecl TSK_pvg_get_mon_data(_DWORD, _DWORD, _DWORD);

//----- (1009B280) --------------------------------------------------------
int __cdecl sub_1009B280(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74D6: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (1009B2B0) --------------------------------------------------------
__int16 __cdecl sub_1009B2B0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74DC: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (1009B2D0) --------------------------------------------------------
int sub_1009B2D0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74E2: using guessed type int TSK_pvg_get_timer(void);

//----- (1009B2F0) --------------------------------------------------------
int __cdecl sub_1009B2F0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74E8: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009B320) --------------------------------------------------------
int sub_1009B320()
{
  char v1; // [sp+0h] [bp-84h]@1
  int v2; // [sp+24h] [bp-60h]@1
  int v3; // [sp+34h] [bp-50h]@1

  sub_1009B250(-2, (int)&v1, 0);
  return v3 + 1000 * v2;
}

//----- (1009B380) --------------------------------------------------------
int __cdecl sub_1009B380(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74F4: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009B3B0) --------------------------------------------------------
int __cdecl sub_1009B3B0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A74FA: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (1009B3D0) --------------------------------------------------------
int __cdecl sub_1009B3D0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A7500: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (1009B3F0) --------------------------------------------------------
int __cdecl sub_1009B3F0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A7506: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (1009B420) --------------------------------------------------------
int __cdecl sub_1009B420(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A750C: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (1009B450) --------------------------------------------------------
int __cdecl sub_1009B450(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A7512: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009B480) --------------------------------------------------------
int __cdecl sub_1009B480(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A7518: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (1009B4B0) --------------------------------------------------------
int __cdecl sub_1009B4B0(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A751E: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (1009B4D0) --------------------------------------------------------
int __cdecl sub_1009B4D0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A7524: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (1009B4F0) --------------------------------------------------------
char __cdecl sub_1009B4F0(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_1009B2D0();
  if ( sub_1009B3B0(a1) == 5 )
    goto LABEL_4;
  while ( sub_1009B2D0() < v2 )
  {
    sub_1009B4D0(20);
    if ( sub_1009B3B0(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_1009B3B0(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1009B560) --------------------------------------------------------
int __cdecl sub_1009B560(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_1009B230();
    sub_1009B2F0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A752A: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (1009B5A0) --------------------------------------------------------
int __cdecl sub_1009B5A0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_1009B3D0(a2);
  return result;
}
// 100CB8C0: using guessed type void *tsk_app_hdr_ptr;

//----- (1009B5D0) --------------------------------------------------------
int __cdecl sub_1009B5D0(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_1009B3F0(a1, a2);
  return result;
}
// 100CB8C0: using guessed type void *tsk_app_hdr_ptr;

//----- (1009B5F0) --------------------------------------------------------
int __cdecl sub_1009B5F0(int a1, int a2, int a3)
{
  dword_10645A9C = a1;
  dword_10645A90 = a2;
  dword_10645A94 = a3;
  return gdi_pvg_create_window(&dword_10645A88);
}
// 100A7530: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 10645A88: using guessed type int dword_10645A88;
// 10645A90: using guessed type int dword_10645A90;
// 10645A94: using guessed type int dword_10645A94;
// 10645A9C: using guessed type int dword_10645A9C;

//----- (1009B630) --------------------------------------------------------
int sub_1009B630()
{
  int result; // eax@1

  result = 0;
  dword_10645A9C = 0;
  dword_10645A90 = 0;
  dword_10645A94 = 59;
  dword_10645A88 = 1;
  dword_10645A8C = 0;
  dword_10645A98 = 0;
  return result;
}
// 10645A88: using guessed type int dword_10645A88;
// 10645A8C: using guessed type int dword_10645A8C;
// 10645A90: using guessed type int dword_10645A90;
// 10645A94: using guessed type int dword_10645A94;
// 10645A98: using guessed type int dword_10645A98;
// 10645A9C: using guessed type int dword_10645A9C;

//----- (1009B680) --------------------------------------------------------
int __cdecl sub_1009B680(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10645A88 = a1;
  return result;
}
// 10645A88: using guessed type int dword_10645A88;

//----- (1009B690) --------------------------------------------------------
int __cdecl sub_1009B690(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 100A753C: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009B6E0) --------------------------------------------------------
int __cdecl sub_1009B6E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 100A7542: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009B730) --------------------------------------------------------
int sub_1009B730()
{
  gdi_pvg_init();
  return sub_1009B630();
}
// 100A7548: using guessed type int gdi_pvg_init(void);

//----- (1009B780) --------------------------------------------------------
int __cdecl sub_1009B780(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 100A7566: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009B7E0) --------------------------------------------------------
int __cdecl sub_1009B7E0(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_1014F6B0[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_1014F6B4[2 * v1];
}
// 1014F6B0: using guessed type int dword_1014F6B0[];
// 1014F6B4: using guessed type int dword_1014F6B4[];

//----- (1009B830) --------------------------------------------------------
int __cdecl sub_1009B830(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 100A7578: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009B850) --------------------------------------------------------
char __cdecl sub_1009B850(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1009B830(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10070AD0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (1009B890) --------------------------------------------------------
int __cdecl sub_1009B890(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_1009B830(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (1009B8D0) --------------------------------------------------------
int __cdecl sub_1009B8D0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1009B830(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (1009B900) --------------------------------------------------------
int __cdecl sub_1009B900(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 100A757E: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009B920) --------------------------------------------------------
int __cdecl sub_1009B920(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_1009B900(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_1009C6A0() )
  {
    v4 = sub_1009B7E0(a1);
    if ( v4 != 42066 )
      v3 = sub_1009B900(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 1009C6A0: using guessed type int sub_1009C6A0(void);

//----- (1009B980) --------------------------------------------------------
int __cdecl sub_1009B980(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1009B920(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10070AD0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (1009B9C0) --------------------------------------------------------
char __cdecl sub_1009B9C0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1009B900(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10070AD0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (1009BA00) --------------------------------------------------------
int __cdecl sub_1009BA00(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_1009B830(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_1009B900(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (1009BA60) --------------------------------------------------------
signed int __cdecl sub_1009BA60(unsigned int a1)
{
  signed int result; // eax@4
  int v2; // eax@8
  int v3; // edx@9

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_16;
  if ( (a1 & 3) == 1 )
    return sub_10071840(a1);
  if ( a1 && (a1 & 3) == 2 )
  {
    v2 = 0;
    if ( !dword_10658308 )
      goto LABEL_11;
    while ( 1 )
    {
      v3 = dword_10658310[v2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      if ( ++v2 >= (unsigned int)dword_10658308 )
        goto LABEL_11;
    }
    if ( v2 != -1 )
    {
      sub_1009C6B0(
        v2,
        *(_DWORD *)(dword_10658310[v2] + 12),
        *(_DWORD *)(v3 + 16),
        *(_BYTE *)(v3 + 32),
        *(_WORD *)(v3 + 20),
        *(_DWORD *)(v3 + 4));
      result = sub_1009BA60(a1 & 0xFFFFFFFC);
    }
    else
    {
LABEL_11:
      result = -6;
    }
  }
  else
  {
LABEL_16:
    result = FIL_vfs_close();
  }
  return result;
}
// 100A758A: using guessed type int FIL_vfs_close(void);
// 10658308: using guessed type int dword_10658308;
// 10658310: using guessed type int dword_10658310[];

//----- (1009BAD0) --------------------------------------------------------
int __cdecl sub_1009BAD0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 100A75A2: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009BB40) --------------------------------------------------------
signed int __cdecl sub_1009BB40(unsigned int a1, void *a2, int a3)
{
  unsigned int v3; // eax@4
  signed int result; // eax@4
  int v5; // eax@7

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v3 = sub_10071AF0(a1);
    return sub_10073590(v3, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v5 = sub_1009BD10(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_1009CA50(a1, a2, a3, v5, (unsigned __int64)v5 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 100A75B4: using guessed type int FIL_vfs_read(void);

//----- (1009BB80) --------------------------------------------------------
signed int __cdecl sub_1009BB80(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_100718C0(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_1009CA50(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 100A75BA: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009BC10) --------------------------------------------------------
signed int __cdecl sub_1009BC10(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10071920(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 100A75C6: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009BC60) --------------------------------------------------------
__int64 __cdecl sub_1009BC60(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 100A75CC: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (1009BC90) --------------------------------------------------------
int __cdecl sub_1009BC90(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 100A75D8: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (1009BCC0) --------------------------------------------------------
int __cdecl sub_1009BCC0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 100A75E4: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009BCE0) --------------------------------------------------------
char __cdecl sub_1009BCE0(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_1009BA60(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1009BB30: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1009BD10) --------------------------------------------------------
signed int __cdecl sub_1009BD10(unsigned int a1, int a2, int a3)
{
  return sub_1009BC10(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (1009BD30) --------------------------------------------------------
int __cdecl sub_1009BD30(int a1, int a2, int a3)
{
  return sub_1009BC90(a1, a2, a3);
}

//----- (1009BD50) --------------------------------------------------------
int __cdecl sub_1009BD50(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 1009CBA0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1009BDB0) --------------------------------------------------------
signed int __cdecl sub_1009BDB0(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1009BE30) --------------------------------------------------------
unsigned int __usercall sub_1009BE30@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  unsigned int v3; // eax@5
  char *v4; // edi@9
  char v5; // al@10
  unsigned int v6; // eax@12
  signed int v7; // ebx@15
  const char *v8; // eax@19
  unsigned int result; // eax@47
  unsigned int v10; // [sp+Ch] [bp-98h]@1
  int v11; // [sp+14h] [bp-90h]@29
  char v12; // [sp+1Dh] [bp-87h]@30
  char v13; // [sp+1Fh] [bp-85h]@9
  char v14; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v10 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
  }
  else
  {
    strncpy(&v14, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v4 = &v13;
      do
        v5 = (v4++)[1];
      while ( v5 );
      *(_DWORD *)v4 = 7368052;
    }
    v10 = j_FIL_vfs_open(*a1, 6, 1809);
    v6 = j_FIL_vfs_open(&v14, 14, 1809);
    v2 = v6;
    if ( v6 >= 0xFFFFFFC2 || !v6 )
    {
      sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v7 = sub_1009BD10(v6, 0, 2);
    if ( v7 < 0 )
    {
      sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v8 = a1[2] + 12;
    if ( v7 < (signed int)v8 && sub_1009BD30(v2, (int)v8, (unsigned __int64)(signed int)v8 >> 32) < 0 )
    {
      sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v3 = j_FIL_vfs_mmap(v2, 0, a1[2] + 12, 0);
    v1 = v3;
    if ( v3 < 0xFFFFFFC2 && v3 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v3 + 9) || *(_BYTE *)(v3 + 8) != 56 )
        {
          sub_1009BD50((int)a1, v3 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v3 + 4) = sub_1009B2D0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v10 < 0xFFFFFFC2 && v10 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_1009BB40(v10, &v11, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v11;
          v12 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_1009BCC0(v10, (int)&v11, 12, 0) != 12 )
          {
            sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v14, *a1) )
        sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_1009BA60(v2);
LABEL_42:
  if ( v10 < 0xFFFFFFC2 && v10 )
    sub_1009BA60(v10);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 1009BB30: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1009BC00: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (1009C130) --------------------------------------------------------
int __usercall sub_1009C130@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 1009CBA0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1009C150) --------------------------------------------------------
signed int __cdecl sub_1009C150(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_1009B5D0(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_1009B5A0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_1009C130(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_1009BE30((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_1009B5A0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (1009C220) --------------------------------------------------------
unsigned int __cdecl sub_1009C220(LONG Value)
{
  char v1; // al@1
  unsigned int result; // eax@3
  unsigned int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_1009BE30((const char **)Value);
    v3 = result;
    if ( result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_10070AD0("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_1009C130(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (1009C2B0) --------------------------------------------------------
void __cdecl sub_1009C2B0(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_1009CBB0(a1, a2);
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A75EA: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (1009C2E0) --------------------------------------------------------
int __cdecl sub_1009C2E0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A75F0: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (1009C3C0) --------------------------------------------------------
int __cdecl sub_1009C3C0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A7638: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1009C410) --------------------------------------------------------
int __cdecl sub_1009C410(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 100A74A6: using guessed type int SYS_exit_krnl(void);
// 100A74B2: using guessed type int SYS_enter_krnl(void);
// 100A763E: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1009C480) --------------------------------------------------------
int __cdecl sub_1009C480(int a1)
{
  void *v1; // ecx@0
  void *v2; // eax@1
  int v3; // eax@3

  v2 = (void *)a1;
  if ( !a1 )
    v2 = sub_100705C0(v1);
  a1 = (int)v2;
  v3 = sub_10071590(&a1, 4u, (int)&unk_1014D278, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1014D27C[2 * v3];
}
// 1014D27C: using guessed type int dword_1014D27C[];

//----- (1009C4C0) --------------------------------------------------------
int __cdecl sub_1009C4C0(int a1)
{
  void *v1; // ecx@0
  void *v2; // eax@1
  int v3; // eax@3

  v2 = (void *)a1;
  if ( !a1 )
    v2 = sub_100705C0(v1);
  a1 = (int)v2;
  v3 = sub_10071590(&a1, 4u, (int)&unk_1014D2B0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1014D2B4[2 * v3];
}
// 1014D2B4: using guessed type int dword_1014D2B4[];

//----- (1009C500) --------------------------------------------------------
int __cdecl sub_1009C500(int a1)
{
  void *v1; // ecx@0
  void *v2; // eax@1
  int v3; // eax@3

  v2 = (void *)a1;
  if ( !a1 )
    v2 = sub_100705C0(v1);
  a1 = (int)v2;
  v3 = sub_10071590(&a1, 4u, (int)&unk_1014D2E8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1014D2EC[2 * v3];
}
// 1014D2EC: using guessed type int dword_1014D2EC[];

//----- (1009C540) --------------------------------------------------------
int __cdecl sub_1009C540(int a1)
{
  void *v1; // ecx@0
  void *v2; // eax@1
  int v3; // eax@3

  v2 = (void *)a1;
  if ( !a1 )
    v2 = sub_100705C0(v1);
  a1 = (int)v2;
  v3 = sub_10071590(&a1, 4u, (int)&unk_1014D320, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1014D324[2 * v3];
}
// 1014D324: using guessed type int dword_1014D324[];

//----- (1009C580) --------------------------------------------------------
int __cdecl sub_1009C580(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1009C4C0(a4);
    result = sub_1009B830(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_1009B830(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1009C480(a4);
      result = sub_1009B830(v6, a3, 6);
    }
  }
  return result;
}

//----- (1009C5F0) --------------------------------------------------------
int __cdecl sub_1009C5F0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1009C540(a3);
    result = sub_1009B830(v4, a1, 64);
    if ( result == -7 )
    {
      sub_1009B4D0(100);
      v5 = sub_1009C540(a3);
      result = sub_1009B830(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1009C500(a3);
    result = sub_1009B830(v6, a2, 8);
    if ( result == -7 )
    {
      sub_1009B4D0(100);
      v7 = sub_1009C500(a3);
      result = sub_1009B830(v7, a2, 8);
    }
  }
  return result;
}

//----- (1009C6B0) --------------------------------------------------------
unsigned int __cdecl sub_1009C6B0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_10658310[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_106582C8[a1];
  dword_106582C8[a1] = a3 + v9;
  dword_10658288[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_10658288[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 106582C8: using guessed type int dword_106582C8[];
// 10658310: using guessed type int dword_10658310[];

//----- (1009C860) --------------------------------------------------------
int __usercall sub_1009C860@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_10658310[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_10658310[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 10658310: using guessed type int dword_10658310[];

//----- (1009C910) --------------------------------------------------------
int __cdecl sub_1009C910(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_1009C860(a1);
  v3 = &dword_10658310[a1];
  v4 = sub_1009BB80(
         *(_DWORD *)dword_10658310[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_10658310[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_106582C8[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 106582C8: using guessed type int dword_106582C8[];
// 10658310: using guessed type int dword_10658310[];

//----- (1009C9C0) --------------------------------------------------------
int __usercall sub_1009C9C0@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_10658310[a1];
  v3 = (int *)(dword_106582C8[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_10658310[a1] + 32)) % *(_WORD *)(dword_10658310[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_1009C910(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 106582C8: using guessed type int dword_106582C8[];
// 10658310: using guessed type int dword_10658310[];

//----- (1009CA50) --------------------------------------------------------
int __cdecl sub_1009CA50(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_10658308 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_10658310[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_10658308 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_1009B3F0(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_10658310[v6] + 28);
        v12 = sub_1009C9C0(v6, (unsigned int)v7 & *(_DWORD *)(dword_10658310[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_10658310[v6] + 4) != 138 )
        sub_1009B3D0(*(_DWORD *)(dword_10658310[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_10658310[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_1009B3D0(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 10658308: using guessed type int dword_10658308;
// 10658310: using guessed type int dword_10658310[];

//----- (1009CBB0) --------------------------------------------------------
void __cdecl sub_1009CBB0(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_100704C0(v2) && sub_10070580(v3) != 1 )
    *a2 = 0;
}

//----- (1009CBE0) --------------------------------------------------------
char sub_1009CBE0()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_10079250() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_1068B5AC + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_1068B5AC + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_1068B5AC + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 1068B5AC: using guessed type int dword_1068B5AC;

//----- (1009CC30) --------------------------------------------------------
int __cdecl sub_1009CC30(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (1009CD40) --------------------------------------------------------
unsigned int *__cdecl sub_1009CD40(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int *result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_1009D880(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_1009CE20(v9);
      }
      else
      {
        result = sub_1009D350(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = (unsigned int *)sub_1009D170(v9);
    }
    else
    {
      result = sub_1009D350(v9);
    }
  }
  else
  {
    result = sub_1009D350(v9);
  }
  return result;
}

//----- (1009CE20) --------------------------------------------------------
unsigned int *__cdecl sub_1009CE20(int a1)
{
  unsigned int *result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = (unsigned int *)sub_100A1C30(a1);
  v20 = (int)result;
  if ( result )
  {
    v19 = *(_WORD *)(result[14] + 10);
    v18 = ((unsigned int)*((_WORD *)result + 7) >> 3)
        + *((_WORD *)result + 6) * *(_WORD *)(result[14] + 10)
        + *(_DWORD *)result[14];
    v9 = 8 * (*((_WORD *)result + 7) >> 3) - *((_WORD *)result + 7) + 8;
    v15 = *(_WORD *)(result[13] + 10);
    if ( !(*(_WORD *)(result[13] + 10) << 30) )
    {
      v16 = (unsigned int *)(*(_DWORD *)result[13]
                           + *((_WORD *)result + 4) * *(_WORD *)(result[13] + 10)
                           + 4 * (8 * *((_WORD *)result + 5) >> 5));
      v8 = 32 * (8 * *((_WORD *)result + 5) >> 5) - 8 * *((_WORD *)result + 5) + 32;
      v3 = *((_WORD *)result + 8);
      v6 = *((_WORD *)result + 9);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (unsigned int *)((char *)v16 + v15);
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (1009D170) --------------------------------------------------------
int __cdecl sub_1009D170(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_100A1C30(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (1009D350) --------------------------------------------------------
unsigned int *__cdecl sub_1009D350(int a1)
{
  unsigned int *result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = (unsigned int *)sub_100A1C30(a1);
  v23 = (unsigned int)result;
  if ( result )
  {
    v22 = *(_WORD *)(result[14] + 10);
    v20 = *(_DWORD *)result[14] + *((_WORD *)result + 6) * *(_WORD *)(result[14] + 10);
    result = (unsigned int *)result[14];
    if ( (unsigned int)*((_BYTE *)result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_101502E8[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_101502E8[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = (unsigned int *)*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( (unsigned int)result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_101502E8[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_101502E8[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int *)((char *)v19 + v18);
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (1009D880) --------------------------------------------------------
int __cdecl sub_1009D880(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (1009D8E0) --------------------------------------------------------
_WORD *__cdecl sub_1009D8E0(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (1009D940) --------------------------------------------------------
int __cdecl sub_1009D940(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_1009CC30(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (1009DA30) --------------------------------------------------------
void sub_1009DA30()
{
  ;
}

//----- (1009DA40) --------------------------------------------------------
void sub_1009DA40()
{
  ;
}

//----- (1009DA50) --------------------------------------------------------
int __cdecl sub_1009DA50(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_1009E4A0(a1, a2, a3);
  return result;
}

//----- (1009DA90) --------------------------------------------------------
char __cdecl sub_1009DA90(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_10658351 = a1;
  byte_10658350 = a2;
  return result;
}
// 10658350: using guessed type char byte_10658350;
// 10658351: using guessed type char byte_10658351;

//----- (1009DAB0) --------------------------------------------------------
int __cdecl sub_1009DAB0(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  _DWORD *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = &a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *v15 )
      {
        if ( *v15 == 2 )
          v26 = sub_1009E2F0(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_1009DA50(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_1009F8C0(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_1009F8C0(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_1009F8C0(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_1009F8C0(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_1009E390(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_100A1E00(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_1009CE20(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_100A1E00(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (1009E2F0) --------------------------------------------------------
bool __cdecl sub_1009E2F0(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (1009E390) --------------------------------------------------------
bool __cdecl sub_1009E390(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_10658351 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_10658350;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 10658350: using guessed type char byte_10658350;
// 10658351: using guessed type char byte_10658351;

//----- (1009E4A0) --------------------------------------------------------
int __cdecl sub_1009E4A0(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (1009E590) --------------------------------------------------------
int __cdecl sub_1009E590(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_1009F8C0(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101502F4[0]);
    *(_WORD *)(a1 + 10) = byte_101502F4[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_101502F4[2] + v11 - byte_101502F4[1] + 1;
    sub_100A2380(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101502F4[3]);
    *(_WORD *)(a1 + 8) = byte_101502F4[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_101502F4[5] + v12 - byte_101502F4[4] + 1;
    sub_100A2550(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101502F4[6]);
    *(_WORD *)(a1 + 10) = byte_101502F4[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_101502F4[7] - (byte_101502F4[8] + v11) - 1;
    sub_100A2380(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101502F4[9]);
    *(_WORD *)(a1 + 8) = byte_101502F4[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_101502F4[10] - (byte_101502F4[11] + v12) - 1;
    sub_100A2550(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

//----- (1009E7F0) --------------------------------------------------------
int __cdecl sub_1009E7F0(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_100A2380;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_100A2550;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (1009ED40) --------------------------------------------------------
int __cdecl sub_1009ED40(int a1, signed int a2, int a3, int a4, int a5)
{
  int result; // eax@3
  __int16 v6; // ST14_2@11
  __int16 v7; // ST18_2@11
  __int16 v8; // ST5C_2@11
  int v9; // edx@47
  int v10; // eax@50
  int v11; // ecx@50
  int v12; // ecx@51
  __int16 v13; // [sp+4h] [bp-6Ch]@55
  __int16 v14; // [sp+Ah] [bp-66h]@11
  __int16 v15; // [sp+Eh] [bp-62h]@11
  signed __int16 j; // [sp+10h] [bp-60h]@6
  unsigned __int16 l; // [sp+10h] [bp-60h]@18
  signed __int16 ii; // [sp+10h] [bp-60h]@47
  unsigned __int16 v19; // [sp+14h] [bp-5Ch]@22
  unsigned __int16 v20; // [sp+18h] [bp-58h]@24
  char *v21; // [sp+20h] [bp-50h]@1
  __int16 k; // [sp+28h] [bp-48h]@15
  int v23; // [sp+2Ch] [bp-44h]@47
  int v24; // [sp+30h] [bp-40h]@47
  int v25; // [sp+34h] [bp-3Ch]@47
  int v26; // [sp+38h] [bp-38h]@15
  int v27; // [sp+3Ch] [bp-34h]@4
  int v28; // [sp+40h] [bp-30h]@11
  __int16 v29; // [sp+44h] [bp-2Ch]@13
  signed __int16 v30; // [sp+48h] [bp-28h]@11
  int v31; // [sp+4Ch] [bp-24h]@11
  signed __int16 v32; // [sp+54h] [bp-1Ch]@11
  __int16 v33; // [sp+5Ch] [bp-14h]@57
  signed __int16 i; // [sp+60h] [bp-10h]@4
  unsigned __int16 m; // [sp+60h] [bp-10h]@36
  signed __int16 n; // [sp+60h] [bp-10h]@44
  unsigned __int16 jj; // [sp+60h] [bp-10h]@53
  __int16 v38; // [sp+64h] [bp-Ch]@11
  __int16 v39; // [sp+68h] [bp-8h]@4
  unsigned __int16 v40; // [sp+6Ch] [bp-4h]@17
  int v41; // [sp+84h] [bp+14h]@1

  v21 = (char *)(a5 + (-a5 & 3));
  v41 = a4 - (-a5 & 3) - (((_BYTE)a4 - (-(char)a5 & 3)) & 3);
  if ( a2 >= 2 && 2 * a2 <= v41 )
  {
    v39 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 6);
    v27 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)v21 = 0;
    for ( i = 1; (unsigned __int16)i < a2; ++i )
    {
      for ( j = i;
            j
         && *(_WORD *)(a3 + 4 * *(_WORD *)&v21[2 * (unsigned __int16)j - 2] + 2) > (signed int)*(_WORD *)(a3 + 4 * (unsigned __int16)i + 2);
            --j )
      {
        *(_WORD *)&v21[2 * (unsigned __int16)j] = *(_WORD *)&v21[2 * (unsigned __int16)j - 2];
      }
      *(_WORD *)&v21[2 * (unsigned __int16)j] = i;
    }
    v30 = 0;
    v32 = 0;
    v28 = 2 * a2 + (-2 * a2 & 3);
    v31 = (int)&v21[v28];
    v6 = *(_WORD *)(a1 + 26);
    v7 = *(_WORD *)(a1 + 30);
    v15 = *(_WORD *)(a1 + 28);
    v8 = *(_WORD *)(a1 + 42);
    v14 = *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 40);
    v38 = *(_WORD *)(a3 + 4 * *(_WORD *)v21 + 2);
    if ( v38 < v14 )
      v38 = *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 40);
    v29 = *(_WORD *)(a3 + 4 * *(_WORD *)&v21[2 * a2 - 2] + 2);
    if ( v29 > v15 + v14 )
      v29 = v15 + v14;
    v26 = 0;
    for ( k = v38; k < v29; ++k )
    {
      while ( 1 )
      {
        v40 = *(_WORD *)&v21[2 * v26];
        if ( *(_WORD *)(a3 + 4 * v40 + 2) > k )
          break;
        for ( l = 0; (signed int)l < 2; ++l )
        {
          if ( l )
          {
            if ( v40 == a2 - 1 )
              v19 = 0;
            else
              v19 = v40 + 1;
            v20 = v40;
          }
          else
          {
            if ( v40 )
              v19 = v40 - 1;
            else
              v19 = a2 - 1;
            v20 = v19;
          }
          if ( *(_WORD *)(a3 + 4 * v19 + 2) <= k )
          {
            if ( *(_WORD *)(a3 + 4 * v19 + 2) < k )
            {
              for ( m = 0; m < (signed int)(unsigned __int16)v30 && *(_WORD *)(v31 + 12 * m) != v20; ++m )
                ;
              if ( (unsigned __int16)v30 - m > 0 )
                memcpy_0((void *)(v31 + 12 * m), (const void *)(v31 + 12 * (m + 1)), 12 * ((unsigned __int16)--v30 - m));
            }
          }
          else
          {
            if ( (unsigned __int16)v30 == (unsigned __int16)((v41 - v28) / 0xCu) )
            {
              v32 = -1;
              goto LABEL_63;
            }
            *(_WORD *)(v31 + 12 * (unsigned __int16)v30) = v20;
            *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 4) = ((*(_WORD *)(a3 + 4 * v19)
                                                                - (signed int)*(_WORD *)(a3 + 4 * v40)) << 16)
                                                              / (*(_WORD *)(a3 + 4 * v19 + 2)
                                                               - (signed int)*(_WORD *)(a3 + 4 * v40 + 2));
            *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 8) = (*(_WORD *)(a3 + 4 * v40) << 16)
                                                              + *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 4)
                                                              * (k - *(_WORD *)(a3 + 4 * v40 + 2));
            if ( (unsigned __int16)++v30 > (signed int)(unsigned __int16)v32 )
              v32 = v30;
          }
        }
        ++v26;
      }
      for ( n = 1; (unsigned __int16)n < (signed int)(unsigned __int16)v30; ++n )
      {
        if ( *(_DWORD *)(v31 + 12 * ((unsigned __int16)n - 1) + 8) > *(_DWORD *)(v31 + 12 * (unsigned __int16)n + 8) )
        {
          v9 = v31 + 12 * (unsigned __int16)n;
          v23 = *(_DWORD *)v9;
          v24 = *(_DWORD *)(v9 + 4);
          v25 = *(_DWORD *)(v9 + 8);
          for ( ii = n; ii && *(_DWORD *)(v31 + 12 * ((unsigned __int16)ii - 1) + 8) > v25; --ii )
          {
            v10 = v31 + 12 * ((unsigned __int16)ii - 1);
            v11 = v31 + 12 * (unsigned __int16)ii;
            *(_DWORD *)v11 = *(_DWORD *)v10;
            *(_DWORD *)(v11 + 4) = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v11 + 8) = *(_DWORD *)(v10 + 8);
          }
          v12 = v31 + 12 * (unsigned __int16)ii;
          *(_DWORD *)v12 = v23;
          *(_DWORD *)(v12 + 4) = v24;
          *(_DWORD *)(v12 + 8) = v25;
        }
      }
      for ( jj = 0; jj < (unsigned __int16)v30 - 1; jj += 2 )
      {
        v13 = *(_DWORD *)(v31 + 12 * jj + 8) >> 16;
        if ( *(_WORD *)(v31 + 12 * jj + 8) )
          ++v13;
        v33 = *(_DWORD *)(v31 + 12 * (jj + 1) + 8) >> 16;
        if ( !*(_WORD *)(v31 + 12 * (jj + 1) + 8) )
          --v33;
        if ( v13 <= v33 )
        {
          *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + v13;
          *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + k;
          *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + v33;
          sub_100A22D0(a1);
        }
        *(_DWORD *)(v31 + 12 * jj + 8) += *(_DWORD *)(v31 + 12 * jj + 4);
        *(_DWORD *)(v31 + 12 * (jj + 1) + 8) += *(_DWORD *)(v31 + 12 * (jj + 1) + 4);
      }
    }
LABEL_63:
    *(_WORD *)(a1 + 4) = v39;
    *(_DWORD *)(a1 + 36) = v27;
    if ( (unsigned __int16)v32 == 0xFFFF )
      result = -1;
    else
      result = v31 + 12 * (unsigned __int16)v32 - a5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1009F430) --------------------------------------------------------
int __cdecl sub_1009F430(int a1, signed int a2, int a3, char a4)
{
  int result; // eax@44
  signed __int16 v5; // [sp+0h] [bp-3Ch]@11
  int v6; // [sp+4h] [bp-38h]@27
  int v7; // [sp+4h] [bp-38h]@33
  __int16 v8; // [sp+8h] [bp-34h]@13
  char v9; // [sp+Fh] [bp-2Dh]@2
  char (__cdecl *v10)(int); // [sp+10h] [bp-2Ch]@3
  char *(__cdecl *v11)(int); // [sp+14h] [bp-28h]@6
  __int16 v12; // [sp+18h] [bp-24h]@8
  __int16 v13; // [sp+1Ch] [bp-20h]@13
  signed __int16 v14; // [sp+20h] [bp-1Ch]@13
  signed __int16 v15; // [sp+24h] [bp-18h]@21
  signed int i; // [sp+28h] [bp-14h]@8
  __int16 v17; // [sp+2Ch] [bp-10h]@11
  __int16 v18; // [sp+30h] [bp-Ch]@11
  signed __int16 v19; // [sp+34h] [bp-8h]@24
  __int16 v20; // [sp+38h] [bp-4h]@8

  if ( a2 >= 2 )
  {
    v9 = 0;
    if ( *(_DWORD *)(a1 + 72) )
      v10 = *(char (__cdecl **)(int))(a1 + 72);
    else
      v10 = sub_100A2380;
    if ( *(_DWORD *)(a1 + 76) )
      v11 = *(char *(__cdecl **)(int))(a1 + 76);
    else
      v11 = sub_100A2550;
    v20 = *(_WORD *)(a1 + 42) + *(_WORD *)a3;
    v12 = *(_WORD *)(a1 + 40) + *(_WORD *)(a3 + 2);
    for ( i = 1; i < a2; ++i )
    {
      *(_WORD *)(a1 + 10) = v20;
      *(_WORD *)(a1 + 8) = v12;
      v20 = *(_WORD *)(a1 + 42) + *(_WORD *)(a3 + 4 * i);
      v12 = *(_WORD *)(a1 + 40) + *(_WORD *)(a3 + 4 * i + 2);
      *(_WORD *)(a1 + 14) = v20;
      *(_WORD *)(a1 + 12) = v12;
      v5 = 1;
      v17 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
      v18 = v17;
      if ( v17 < 0 )
      {
        v5 = -1;
        v18 = -v17;
      }
      v14 = 1;
      v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
      v13 = v8;
      if ( v8 < 0 )
      {
        v14 = -1;
        v13 = -v8;
      }
      if ( v8 | v17 )
      {
        if ( *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 10) )
        {
          v9 = 1;
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          *(_WORD *)(a1 + 12) = v8;
          v11(a1);
          *(_WORD *)(a1 + 8) += v8;
        }
        else if ( *(_WORD *)(a1 + 12) == *(_WORD *)(a1 + 8) )
        {
          v9 = 0;
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          *(_WORD *)(a1 + 14) = v17;
          v10(a1);
          *(_WORD *)(a1 + 10) += v17;
        }
        else
        {
          if ( v18 <= 0x3FFF )
            v15 = 2 * v18;
          else
            v15 = 32766;
          if ( v13 <= 0x3FFF )
            v19 = 2 * v13;
          else
            v19 = 32766;
          if ( v18 <= v13 )
          {
            v9 = 1;
            *(_WORD *)(a1 + 16) = 0;
            *(_WORD *)(a1 + 18) = 1;
            v7 = v15 - v13 - (v5 < 0);
            *(_WORD *)(a1 + 12) = 0;
            while ( v13 )
            {
              *(_WORD *)(a1 + 12) += v14;
              if ( v7 >= 0 )
              {
                v11(a1);
                *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
                *(_WORD *)(a1 + 12) = 0;
                *(_WORD *)(a1 + 10) += v5;
                v7 -= v19;
              }
              v7 += v15;
              --v13;
            }
            v11(a1);
            *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
          }
          else
          {
            v9 = 0;
            *(_WORD *)(a1 + 16) = 1;
            *(_WORD *)(a1 + 18) = 0;
            v6 = v19 - v18 - (v14 < 0);
            *(_WORD *)(a1 + 14) = 0;
            while ( v18 )
            {
              *(_WORD *)(a1 + 14) += v5;
              if ( v6 >= 0 )
              {
                v10(a1);
                *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
                *(_WORD *)(a1 + 14) = 0;
                *(_WORD *)(a1 + 8) += v14;
                v6 -= v15;
              }
              v6 += v19;
              --v18;
            }
            v10(a1);
            *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
          }
        }
      }
    }
    if ( a4 & 2 )
    {
      if ( v9 )
      {
        *(_WORD *)(a1 + 12) = 1;
        v11(a1);
      }
      else
      {
        *(_WORD *)(a1 + 14) = 1;
        v10(a1);
      }
    }
    *(_WORD *)(a1 + 46) = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 42);
    result = *(_WORD *)(a1 + 40);
    *(_WORD *)(a1 + 44) = *(_WORD *)(a1 + 8) - result;
  }
  return result;
}

//----- (1009F8C0) --------------------------------------------------------
int __cdecl sub_1009F8C0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_100A1E00(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (1009F9B0) --------------------------------------------------------
char __cdecl sub_1009F9B0(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7)
{
  char result; // al@4
  char v8; // [sp+0h] [bp-17Ch]@55
  char v9; // [sp+4h] [bp-178h]@49
  char v10; // [sp+8h] [bp-174h]@43
  char v11; // [sp+Ch] [bp-170h]@37
  char v12; // [sp+10h] [bp-16Ch]@31
  char v13; // [sp+14h] [bp-168h]@25
  char v14; // [sp+18h] [bp-164h]@19
  char v15; // [sp+1Ch] [bp-160h]@13
  char v16; // [sp+20h] [bp-15Ch]@98
  char v17; // [sp+21h] [bp-15Bh]@98
  __int16 v18; // [sp+22h] [bp-15Ah]@98
  __int16 v19; // [sp+24h] [bp-158h]@98
  __int16 v20; // [sp+26h] [bp-156h]@98
  int v21; // [sp+2Ch] [bp-150h]@98
  char v22; // [sp+30h] [bp-14Ch]@96
  char v23; // [sp+31h] [bp-14Bh]@96
  __int16 v24; // [sp+32h] [bp-14Ah]@96
  __int16 v25; // [sp+34h] [bp-148h]@96
  __int16 v26; // [sp+36h] [bp-146h]@96
  int v27; // [sp+3Ch] [bp-140h]@96
  char v28; // [sp+40h] [bp-13Ch]@94
  char v29; // [sp+41h] [bp-13Bh]@94
  __int16 v30; // [sp+42h] [bp-13Ah]@94
  __int16 v31; // [sp+44h] [bp-138h]@94
  __int16 v32; // [sp+46h] [bp-136h]@94
  int v33; // [sp+4Ch] [bp-130h]@94
  char v34; // [sp+50h] [bp-12Ch]@92
  char v35; // [sp+51h] [bp-12Bh]@92
  __int16 v36; // [sp+52h] [bp-12Ah]@92
  __int16 v37; // [sp+54h] [bp-128h]@92
  __int16 v38; // [sp+56h] [bp-126h]@92
  int v39; // [sp+5Ch] [bp-120h]@92
  char v40; // [sp+60h] [bp-11Ch]@90
  char v41; // [sp+61h] [bp-11Bh]@90
  __int16 v42; // [sp+62h] [bp-11Ah]@90
  __int16 v43; // [sp+64h] [bp-118h]@90
  __int16 v44; // [sp+66h] [bp-116h]@90
  int v45; // [sp+6Ch] [bp-110h]@90
  char v46; // [sp+70h] [bp-10Ch]@88
  char v47; // [sp+71h] [bp-10Bh]@88
  __int16 v48; // [sp+72h] [bp-10Ah]@88
  __int16 v49; // [sp+74h] [bp-108h]@88
  __int16 v50; // [sp+76h] [bp-106h]@88
  int v51; // [sp+7Ch] [bp-100h]@88
  char v52; // [sp+80h] [bp-FCh]@86
  char v53; // [sp+81h] [bp-FBh]@86
  __int16 v54; // [sp+82h] [bp-FAh]@86
  __int16 v55; // [sp+84h] [bp-F8h]@86
  __int16 v56; // [sp+86h] [bp-F6h]@86
  int v57; // [sp+8Ch] [bp-F0h]@86
  char v58; // [sp+90h] [bp-ECh]@84
  char v59; // [sp+91h] [bp-EBh]@84
  __int16 v60; // [sp+92h] [bp-EAh]@84
  __int16 v61; // [sp+94h] [bp-E8h]@84
  __int16 v62; // [sp+96h] [bp-E6h]@84
  int v63; // [sp+9Ch] [bp-E0h]@84
  char v64; // [sp+A0h] [bp-DCh]@79
  char v65; // [sp+A1h] [bp-DBh]@79
  __int16 v66; // [sp+A2h] [bp-DAh]@79
  __int16 v67; // [sp+A4h] [bp-D8h]@79
  __int16 v68; // [sp+A6h] [bp-D6h]@79
  int v69; // [sp+ACh] [bp-D0h]@79
  char v70; // [sp+B0h] [bp-CCh]@77
  char v71; // [sp+B1h] [bp-CBh]@77
  __int16 v72; // [sp+B2h] [bp-CAh]@77
  __int16 v73; // [sp+B4h] [bp-C8h]@77
  __int16 v74; // [sp+B6h] [bp-C6h]@77
  int v75; // [sp+BCh] [bp-C0h]@77
  char v76; // [sp+C0h] [bp-BCh]@75
  char v77; // [sp+C1h] [bp-BBh]@75
  __int16 v78; // [sp+C2h] [bp-BAh]@75
  __int16 v79; // [sp+C4h] [bp-B8h]@75
  __int16 v80; // [sp+C6h] [bp-B6h]@75
  int v81; // [sp+CCh] [bp-B0h]@75
  char v82; // [sp+D0h] [bp-ACh]@73
  char v83; // [sp+D1h] [bp-ABh]@73
  __int16 v84; // [sp+D2h] [bp-AAh]@73
  __int16 v85; // [sp+D4h] [bp-A8h]@73
  __int16 v86; // [sp+D6h] [bp-A6h]@73
  int v87; // [sp+DCh] [bp-A0h]@73
  char v88; // [sp+E0h] [bp-9Ch]@71
  char v89; // [sp+E1h] [bp-9Bh]@71
  __int16 v90; // [sp+E2h] [bp-9Ah]@71
  __int16 v91; // [sp+E4h] [bp-98h]@71
  __int16 v92; // [sp+E6h] [bp-96h]@71
  int v93; // [sp+ECh] [bp-90h]@71
  char v94; // [sp+F0h] [bp-8Ch]@69
  char v95; // [sp+F1h] [bp-8Bh]@69
  __int16 v96; // [sp+F2h] [bp-8Ah]@69
  __int16 v97; // [sp+F4h] [bp-88h]@69
  __int16 v98; // [sp+F6h] [bp-86h]@69
  int v99; // [sp+FCh] [bp-80h]@69
  char v100; // [sp+100h] [bp-7Ch]@67
  char v101; // [sp+101h] [bp-7Bh]@67
  __int16 v102; // [sp+102h] [bp-7Ah]@67
  __int16 v103; // [sp+104h] [bp-78h]@67
  __int16 v104; // [sp+106h] [bp-76h]@67
  int v105; // [sp+10Ch] [bp-70h]@67
  char v106; // [sp+110h] [bp-6Ch]@65
  char v107; // [sp+111h] [bp-6Bh]@65
  __int16 v108; // [sp+112h] [bp-6Ah]@65
  __int16 v109; // [sp+114h] [bp-68h]@65
  __int16 v110; // [sp+116h] [bp-66h]@65
  int v111; // [sp+11Ch] [bp-60h]@65
  __int16 v112; // [sp+120h] [bp-5Ch]@1
  char v113; // [sp+127h] [bp-55h]@64
  __int16 v114; // [sp+128h] [bp-54h]@1
  int v115; // [sp+12Ch] [bp-50h]@61
  __int16 v116; // [sp+130h] [bp-4Ch]@1
  char v117; // [sp+137h] [bp-45h]@57
  __int16 v118; // [sp+138h] [bp-44h]@61
  __int16 v119; // [sp+13Ah] [bp-42h]@61
  __int16 v120; // [sp+13Ch] [bp-40h]@8
  __int16 v121; // [sp+140h] [bp-3Ch]@61
  __int16 v122; // [sp+144h] [bp-38h]@8
  char v123; // [sp+148h] [bp-34h]@9
  char v124; // [sp+149h] [bp-33h]@21
  char v125; // [sp+14Ah] [bp-32h]@33
  char v126; // [sp+14Bh] [bp-31h]@57
  char v127; // [sp+14Ch] [bp-30h]@45
  char v128; // [sp+14Dh] [bp-2Fh]@27
  char v129; // [sp+14Eh] [bp-2Eh]@15
  char v130; // [sp+14Fh] [bp-2Dh]@39
  __int16 v131; // [sp+150h] [bp-2Ch]@9
  __int16 v132; // [sp+154h] [bp-28h]@1
  __int16 v133; // [sp+158h] [bp-24h]@61
  __int16 v134; // [sp+15Ah] [bp-22h]@61
  char v135; // [sp+15Ch] [bp-20h]@59
  char v136; // [sp+15Dh] [bp-1Fh]@67
  char v137; // [sp+15Eh] [bp-1Eh]@71
  char v138; // [sp+15Fh] [bp-1Dh]@79
  char v139; // [sp+160h] [bp-1Ch]@75
  char v140; // [sp+161h] [bp-1Bh]@69
  char v141; // [sp+162h] [bp-1Ah]@65
  char v142; // [sp+163h] [bp-19h]@73
  __int16 v143; // [sp+168h] [bp-14h]@1
  int v144; // [sp+16Ch] [bp-10h]@57
  __int16 v145; // [sp+170h] [bp-Ch]@1
  __int16 v146; // [sp+174h] [bp-8h]@9
  __int16 v147; // [sp+178h] [bp-4h]@9

  v114 = a2;
  v132 = a3;
  v112 = a6;
  v143 = a7;
  v116 = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  v145 = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 46) = a6;
  *(_WORD *)(a1 + 44) = v143;
  v112 += *(_WORD *)(a1 + 42);
  v143 += *(_WORD *)(a1 + 40);
  v114 += *(_WORD *)(a1 + 42);
  v132 += *(_WORD *)(a1 + 40);
  if ( v116 != v112 || v145 != v143 )
  {
    if ( a5 & 1 )
    {
      v122 = v116;
      v116 = v112;
      v112 = v122;
      v120 = v145;
      v145 = v143;
      v143 = v120;
    }
    sub_100A0C00((int)&v123, v116 - v114, v145 - v132, v112 - v114, v143 - v132);
    v146 = (unsigned int)(46341 * a4) >> 16;
    v131 = v146 - 1;
    v147 = v146 + 1;
    if ( v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v147 + v114 < *(_WORD *)(a1 + 26)
      || v131 + v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v132 < *(_WORD *)(a1 + 24) )
    {
      v15 = 0;
    }
    else
    {
      v15 = -1;
    }
    v129 &= v15;
    if ( v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v147 + v114 < *(_WORD *)(a1 + 26)
      || v132 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 - v131 < *(_WORD *)(a1 + 24) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -1;
    }
    v124 &= v14;
    if ( v114 - v147 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 < (signed int)*(_WORD *)(a1 + 26)
      || v131 + v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v132 < *(_WORD *)(a1 + 24) )
    {
      v13 = 0;
    }
    else
    {
      v13 = -1;
    }
    v128 &= v13;
    if ( v114 - v147 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 < (signed int)*(_WORD *)(a1 + 26)
      || v132 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 - v131 < *(_WORD *)(a1 + 24) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -1;
    }
    v125 &= v12;
    if ( v131 + v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v114 < *(_WORD *)(a1 + 26)
      || v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v147 + v132 < *(_WORD *)(a1 + 24) )
    {
      v11 = 0;
    }
    else
    {
      v11 = -1;
    }
    v130 &= v11;
    if ( v114 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 - v131 < *(_WORD *)(a1 + 26)
      || v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v147 + v132 < *(_WORD *)(a1 + 24) )
    {
      v10 = 0;
    }
    else
    {
      v10 = -1;
    }
    v127 &= v10;
    if ( v131 + v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v114 < *(_WORD *)(a1 + 26)
      || v132 - v147 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v9 = 0;
    }
    else
    {
      v9 = -1;
    }
    v123 &= v9;
    if ( v114 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 - v131 < *(_WORD *)(a1 + 26)
      || v132 - v147 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
    v126 &= v8;
    v144 = 0;
    v117 = 0;
    while ( v144 < 8 )
    {
      *(&v135 + v144) = *(_BYTE *)(a1 + 1);
      v117 |= *(&v123 + v144++);
    }
    result = v117;
    if ( v117 )
    {
      v121 = 0;
      v122 = 0;
      v120 = a4;
      v115 = 1 - a4;
      v119 = v116;
      v118 = v145;
      v134 = v112;
      v133 = v143;
      while ( v122 < v120 )
      {
        if ( v115 >= 0 )
        {
          v113 = 0;
          if ( v129 )
          {
            v106 = 6;
            v107 = v129;
            v108 = v120 + v132;
            v109 = v121 + v114;
            v110 = v122 + v114;
            v111 = a5;
            *(_BYTE *)(a1 + 1) = v141;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100A0AF0(a1, (int)&v106, (int)&v118, (int)&v133);
            v141 = *(_BYTE *)(a1 + 1);
          }
          if ( v124 )
          {
            v100 = 1;
            v101 = v124;
            v102 = v132 - v120;
            v103 = v122 + v114;
            v104 = v121 + v114;
            v105 = a5;
            *(_BYTE *)(a1 + 1) = v136;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100A0AF0(a1, (int)&v100, (int)&v118, (int)&v133);
            v136 = *(_BYTE *)(a1 + 1);
          }
          if ( v128 )
          {
            v94 = 5;
            v95 = v128;
            v96 = v120 + v132;
            v97 = v114 - v122;
            v98 = v114 - v121;
            v99 = a5;
            *(_BYTE *)(a1 + 1) = v140;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100A0AF0(a1, (int)&v94, (int)&v118, (int)&v133);
            v140 = *(_BYTE *)(a1 + 1);
          }
          if ( v125 )
          {
            v88 = 2;
            v89 = v125;
            v90 = v132 - v120;
            v91 = v114 - v121;
            v92 = v114 - v122;
            v93 = a5;
            *(_BYTE *)(a1 + 1) = v137;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100A0AF0(a1, (int)&v88, (int)&v118, (int)&v133);
            v137 = *(_BYTE *)(a1 + 1);
          }
          if ( v130 )
          {
            v82 = 7;
            v83 = v130;
            v84 = v120 + v114;
            v85 = v122 + v132;
            v86 = v121 + v132;
            v87 = a5;
            *(_BYTE *)(a1 + 1) = v142;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100A0AF0(a1, (int)&v82, (int)&v118, (int)&v133);
            v142 = *(_BYTE *)(a1 + 1);
          }
          if ( v127 )
          {
            v76 = 4;
            v77 = v127;
            v78 = v114 - v120;
            v79 = v121 + v132;
            v80 = v122 + v132;
            v81 = a5;
            *(_BYTE *)(a1 + 1) = v139;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100A0AF0(a1, (int)&v76, (int)&v118, (int)&v133);
            v139 = *(_BYTE *)(a1 + 1);
          }
          if ( v123 )
          {
            v70 = 0;
            v71 = v123;
            v72 = v120 + v114;
            v73 = v132 - v121;
            v74 = v132 - v122;
            v75 = a5;
            *(_BYTE *)(a1 + 1) = v135;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100A0AF0(a1, (int)&v70, (int)&v118, (int)&v133);
            v135 = *(_BYTE *)(a1 + 1);
          }
          if ( v126 )
          {
            v64 = 3;
            v65 = v126;
            v66 = v114 - v120;
            v67 = v132 - v122;
            v68 = v132 - v121;
            v69 = a5;
            *(_BYTE *)(a1 + 1) = v138;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100A0AF0(a1, (int)&v64, (int)&v118, (int)&v133);
            v138 = *(_BYTE *)(a1 + 1);
          }
          v121 = v122 + 1;
          v115 -= 2 * v120-- - 2;
        }
        v115 += 2 * v122++ + 3;
      }
      result = v120;
      if ( v122 == v120 )
      {
        v113 = 0;
        if ( v129 )
        {
          v58 = 6;
          v59 = v129;
          v60 = v120 + v132;
          v61 = v121 + v114;
          v62 = v122 + v114;
          v63 = a5;
          *(_BYTE *)(a1 + 1) = v141;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100A0AF0(a1, (int)&v58, (int)&v118, (int)&v133);
          v141 = *(_BYTE *)(a1 + 1);
        }
        if ( v124 )
        {
          v52 = 1;
          v53 = v124;
          v54 = v132 - v120;
          v55 = v122 + v114;
          v56 = v121 + v114;
          v57 = a5;
          *(_BYTE *)(a1 + 1) = v136;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100A0AF0(a1, (int)&v52, (int)&v118, (int)&v133);
          v136 = *(_BYTE *)(a1 + 1);
        }
        if ( v128 )
        {
          v46 = 5;
          v47 = v128;
          v48 = v120 + v132;
          v49 = v114 - v122;
          v50 = v114 - v121;
          v51 = a5;
          *(_BYTE *)(a1 + 1) = v140;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100A0AF0(a1, (int)&v46, (int)&v118, (int)&v133);
          v140 = *(_BYTE *)(a1 + 1);
        }
        if ( v125 )
        {
          v40 = 2;
          v41 = v125;
          v42 = v132 - v120;
          v43 = v114 - v121;
          v44 = v114 - v122;
          v45 = a5;
          *(_BYTE *)(a1 + 1) = v137;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100A0AF0(a1, (int)&v40, (int)&v118, (int)&v133);
          v137 = *(_BYTE *)(a1 + 1);
        }
        if ( v130 )
        {
          v34 = 7;
          v35 = v130;
          v36 = v120 + v114;
          v37 = v122 + v132;
          v38 = v121 + v132;
          v39 = a5;
          *(_BYTE *)(a1 + 1) = v142;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100A0AF0(a1, (int)&v34, (int)&v118, (int)&v133);
          v142 = *(_BYTE *)(a1 + 1);
        }
        if ( v127 )
        {
          v28 = 4;
          v29 = v127;
          v30 = v114 - v120;
          v31 = v121 + v132;
          v32 = v122 + v132;
          v33 = a5;
          *(_BYTE *)(a1 + 1) = v139;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100A0AF0(a1, (int)&v28, (int)&v118, (int)&v133);
          v139 = *(_BYTE *)(a1 + 1);
        }
        if ( v123 )
        {
          v22 = 0;
          v23 = v123;
          v24 = v120 + v114;
          v25 = v132 - v121;
          v26 = v132 - v122;
          v27 = a5;
          *(_BYTE *)(a1 + 1) = v135;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100A0AF0(a1, (int)&v22, (int)&v118, (int)&v133);
          v135 = *(_BYTE *)(a1 + 1);
        }
        result = v126;
        if ( v126 )
        {
          v16 = 3;
          v17 = v126;
          v18 = v114 - v120;
          v19 = v132 - v122;
          v20 = v132 - v121;
          v21 = a5;
          *(_BYTE *)(a1 + 1) = v138;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100A0AF0(a1, (int)&v16, (int)&v118, (int)&v133);
          result = a1;
          v138 = *(_BYTE *)(a1 + 1);
        }
      }
    }
  }
  else if ( a5 & 2 )
  {
    result = sub_100A1150(a1, a2, a3, a4, 0);
  }
  else
  {
    result = sub_100A1BD0(a1, a6, a7);
  }
  return result;
}

//----- (100A0AF0) --------------------------------------------------------
char *__cdecl sub_100A0AF0(int a1, int a2, int a3, int a4)
{
  if ( (*(_BYTE *)a2 + 1) & 2 )
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a2 + 10) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)a3;
    *(_WORD *)(a2 + 10) = *(_WORD *)a4;
  }
  return off_10150300[*(_BYTE *)a2](a1, a2);
}
// 10150300: using guessed type int (__cdecl *off_10150300[16])(int, int);

//----- (100A0B60) --------------------------------------------------------
char __cdecl sub_100A0B60(int a1, int a2)
{
  *(_WORD *)(a1 + 8) = *(_WORD *)a2;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a2 + 4) - *(_WORD *)(a2 + 2);
  return sub_100A2380(a1);
}

//----- (100A0BB0) --------------------------------------------------------
char *__cdecl sub_100A0BB0(int a1, int a2)
{
  *(_WORD *)(a1 + 10) = *(_WORD *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 4) - *(_WORD *)(a2 + 2);
  return sub_100A2550(a1);
}

//----- (100A0C00) --------------------------------------------------------
signed int __cdecl sub_100A0C00(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  signed int result; // eax@3
  int v6; // edx@7
  int v7; // eax@11
  char v8; // [sp+5h] [bp-3h]@1
  char i; // [sp+5h] [bp-3h]@2
  unsigned __int8 v10; // [sp+5h] [bp-3h]@3
  bool v11; // [sp+6h] [bp-2h]@7
  char v12; // [sp+7h] [bp-1h]@1

  v8 = sub_100A0D50(a2, a3);
  v12 = sub_100A0D50(a4, a5);
  if ( (unsigned __int8)v8 == (unsigned __int8)v12 )
  {
    switch ( v8 )
    {
      case 0:
      case 7:
        v6 = a5 < a3;
        v11 = a5 > a3;
        break;
      case 1:
      case 2:
        v6 = a4 < a2;
        v11 = a4 > a2;
        break;
      case 3:
      case 4:
        v6 = a5 < a3;
        v11 = a5 < a3;
        break;
      default:
        v6 = a4 < a2;
        v11 = a4 < a2;
        break;
    }
    LOBYTE(v6) = v11;
    BYTE1(v6) = v11;
    v7 = v6 << 16;
    LOWORD(v7) = v6;
    *(_DWORD *)a1 = v7;
    *(_DWORD *)(a1 + 4) = v7;
    result = v11 != 0 ? 10 : 13;
    *(_BYTE *)(a1 + (unsigned __int8)v8) = result;
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + (unsigned __int8)v8) = 5;
    *(_BYTE *)(a1 + (unsigned __int8)v12) = 9;
    for ( i = v8 + 1; ; i = v10 + 1 )
    {
      v10 = i & 7;
      result = v10;
      if ( v10 == (unsigned __int8)v12 )
        break;
      *(_BYTE *)(a1 + v10) = 1;
    }
  }
  return result;
}

//----- (100A0D50) --------------------------------------------------------
char __cdecl sub_100A0D50(__int16 a1, __int16 a2)
{
  char v3; // [sp+1h] [bp-1h]@3

  if ( a1 >= 0 )
  {
    if ( a1 <= 0 )
    {
      v3 = 4 * (a2 >= 0) + 2;
    }
    else if ( a2 > 0 )
    {
      v3 = (a1 >= a2) + 6;
    }
    else
    {
      v3 = a1 <= -a2;
    }
  }
  else if ( a2 >= 0 )
  {
    v3 = (a1 >= -a2) + 4;
  }
  else
  {
    v3 = (a1 <= a2) + 2;
  }
  return v3;
}

//----- (100A0DF0) --------------------------------------------------------
char *__cdecl sub_100A0DF0(int a1, int a2)
{
  __int16 v2; // ST08_2@7
  char *result; // eax@11
  __int16 v4; // ST08_2@20
  int v5; // [sp+4h] [bp-8h]@3
  __int16 v6; // [sp+8h] [bp-4h]@3

  if ( (*(_BYTE *)(a2 + 1) & 3) == 2 )
  {
    if ( *(_WORD *)(a2 + 8) >= (signed int)*(_WORD *)(a2 + 6) )
    {
      v5 = *(_DWORD *)(a2 + 2);
      v6 = *(_WORD *)(a2 + 6);
      if ( *(_WORD *)(a2 + 8) < (signed int)*(_WORD *)(a2 + 4) )
        HIWORD(v5) = *(_WORD *)(a2 + 8);
      --v6;
      if ( *(_WORD *)(a1 + 4) == 4 && *(_DWORD *)(a2 + 12) & 1 )
      {
        v2 = HIWORD(v5);
        HIWORD(v5) = v6;
        v6 = v2;
      }
      off_10150320[*(_BYTE *)a2](a1, (int)&v5);
    }
  }
  else if ( *(_BYTE *)(a2 + 1) & 4 )
  {
    result = (char *)*(_WORD *)(a2 + 6);
    if ( *(_WORD *)(a2 + 8) < (signed int)result )
      return result;
    if ( *(_WORD *)(a2 + 8) < (signed int)*(_WORD *)(a2 + 4) )
      *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 8);
  }
  if ( *(_BYTE *)(a2 + 1) & 8 )
  {
    result = (char *)a2;
    if ( *(_WORD *)(a2 + 10) > (signed int)*(_WORD *)(a2 + 4) )
      return result;
    if ( *(_WORD *)(a2 + 10) > (signed int)*(_WORD *)(a2 + 6) )
      *(_WORD *)(a2 + 6) = *(_WORD *)(a2 + 10);
  }
  --*(_WORD *)(a2 + 6);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = *(_WORD *)(a2 + 6);
  if ( *(_WORD *)(a1 + 4) == 4 )
  {
    if ( *(_DWORD *)(a2 + 12) & 1 )
    {
      v4 = HIWORD(v5);
      HIWORD(v5) = v6;
      v6 = v4;
    }
  }
  return off_10150320[*(_BYTE *)a2](a1, (int)&v5);
}
// 10150320: using guessed type int (__cdecl *off_10150320[8])(int, int);

//----- (100A0FA0) --------------------------------------------------------
char *__cdecl sub_100A0FA0(int a1, int a2)
{
  __int16 v2; // ST08_2@7
  char *result; // eax@11
  __int16 v4; // ST08_2@20
  int v5; // [sp+4h] [bp-8h]@3
  __int16 v6; // [sp+8h] [bp-4h]@3

  if ( (*(_BYTE *)(a2 + 1) & 3) == 2 )
  {
    if ( *(_WORD *)(a2 + 8) <= (signed int)*(_WORD *)(a2 + 6) )
    {
      v5 = *(_DWORD *)(a2 + 2);
      v6 = *(_WORD *)(a2 + 6);
      if ( *(_WORD *)(a2 + 8) > (signed int)*(_WORD *)(a2 + 4) )
        HIWORD(v5) = *(_WORD *)(a2 + 8);
      ++v6;
      if ( *(_WORD *)(a1 + 4) == 4 && *(_DWORD *)(a2 + 12) & 1 )
      {
        v2 = HIWORD(v5);
        HIWORD(v5) = v6;
        v6 = v2;
      }
      off_10150320[*(_BYTE *)a2](a1, (int)&v5);
    }
  }
  else if ( *(_BYTE *)(a2 + 1) & 4 )
  {
    result = (char *)*(_WORD *)(a2 + 6);
    if ( *(_WORD *)(a2 + 8) > (signed int)result )
      return result;
    if ( *(_WORD *)(a2 + 8) > (signed int)*(_WORD *)(a2 + 4) )
      *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 8);
  }
  if ( *(_BYTE *)(a2 + 1) & 8 )
  {
    result = (char *)a2;
    if ( *(_WORD *)(a2 + 10) < (signed int)*(_WORD *)(a2 + 4) )
      return result;
    if ( *(_WORD *)(a2 + 10) < (signed int)*(_WORD *)(a2 + 6) )
      *(_WORD *)(a2 + 6) = *(_WORD *)(a2 + 10);
  }
  ++*(_WORD *)(a2 + 6);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = *(_WORD *)(a2 + 6);
  if ( *(_WORD *)(a1 + 4) == 4 )
  {
    if ( *(_DWORD *)(a2 + 12) & 1 )
    {
      v4 = HIWORD(v5);
      HIWORD(v5) = v6;
      v6 = v4;
    }
  }
  return off_10150320[*(_BYTE *)a2](a1, (int)&v5);
}
// 10150320: using guessed type int (__cdecl *off_10150320[8])(int, int);

//----- (100A1150) --------------------------------------------------------
char __cdecl sub_100A1150(int a1, __int16 a2, __int16 a3, __int16 a4, char a5)
{
  int v5; // ST3C_4@5
  char result; // al@5
  char v7; // [sp+0h] [bp-64h]@52
  char v8; // [sp+4h] [bp-60h]@46
  char v9; // [sp+8h] [bp-5Ch]@40
  char v10; // [sp+Ch] [bp-58h]@34
  char v11; // [sp+10h] [bp-54h]@28
  char v12; // [sp+14h] [bp-50h]@22
  char v13; // [sp+18h] [bp-4Ch]@16
  char v14; // [sp+1Ch] [bp-48h]@10
  __int16 v15; // [sp+24h] [bp-40h]@1
  int v16; // [sp+28h] [bp-3Ch]@58
  __int16 v17; // [sp+2Ch] [bp-38h]@58
  __int16 v18; // [sp+30h] [bp-34h]@58
  __int16 v19; // [sp+34h] [bp-30h]@58
  __int16 v20; // [sp+38h] [bp-2Ch]@6
  __int16 v21; // [sp+3Ch] [bp-28h]@1
  char v22; // [sp+40h] [bp-24h]@56
  char v23; // [sp+41h] [bp-23h]@64
  char v24; // [sp+42h] [bp-22h]@68
  char v25; // [sp+43h] [bp-21h]@76
  char v26; // [sp+44h] [bp-20h]@72
  char v27; // [sp+45h] [bp-1Fh]@66
  char v28; // [sp+46h] [bp-1Eh]@62
  char v29; // [sp+47h] [bp-1Dh]@70
  int v30; // [sp+48h] [bp-1Ch]@54
  __int16 v31; // [sp+4Ch] [bp-18h]@6
  char v32; // [sp+50h] [bp-14h]@48
  char v33; // [sp+51h] [bp-13h]@18
  char v34; // [sp+52h] [bp-12h]@30
  char v35; // [sp+53h] [bp-11h]@54
  char v36; // [sp+54h] [bp-10h]@42
  char v37; // [sp+55h] [bp-Fh]@24
  char v38; // [sp+56h] [bp-Eh]@12
  char v39; // [sp+57h] [bp-Dh]@36
  char v40; // [sp+5Fh] [bp-5h]@54
  __int16 v41; // [sp+60h] [bp-4h]@6

  v15 = *(_WORD *)(a1 + 42) + a2;
  v21 = *(_WORD *)(a1 + 40) + a3;
  if ( a5 & 1 )
    sub_100A35D0(a1, a2, a3, a4);
  if ( *(_WORD *)(a1 + 4) != 4 || (signed int)*(_WORD *)(a1 + 2) <= 1 )
  {
    v31 = 46341 * a4 / 0x10000;
    v20 = v31 - 1;
    v41 = v31 + 1;
    if ( v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v41 + v15 < *(_WORD *)(a1 + 26)
      || v20 + v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v21 < *(_WORD *)(a1 + 24) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -1;
    }
    v38 = v14;
    if ( v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v41 + v15 < *(_WORD *)(a1 + 26)
      || v21 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 - v20 < *(_WORD *)(a1 + 24) )
    {
      v13 = 0;
    }
    else
    {
      v13 = -1;
    }
    v33 = v13;
    if ( v15 - v41 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 < (signed int)*(_WORD *)(a1 + 26)
      || v20 + v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v21 < *(_WORD *)(a1 + 24) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -1;
    }
    v37 = v12;
    if ( v15 - v41 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 < (signed int)*(_WORD *)(a1 + 26)
      || v21 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 - v20 < *(_WORD *)(a1 + 24) )
    {
      v11 = 0;
    }
    else
    {
      v11 = -1;
    }
    v34 = v11;
    if ( v20 + v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v15 < *(_WORD *)(a1 + 26)
      || v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v41 + v21 < *(_WORD *)(a1 + 24) )
    {
      v10 = 0;
    }
    else
    {
      v10 = -1;
    }
    v39 = v10;
    if ( v15 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 - v20 < *(_WORD *)(a1 + 26)
      || v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v41 + v21 < *(_WORD *)(a1 + 24) )
    {
      v9 = 0;
    }
    else
    {
      v9 = -1;
    }
    v36 = v9;
    if ( v20 + v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v15 < *(_WORD *)(a1 + 26)
      || v21 - v41 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
    v32 = v8;
    if ( v15 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 - v20 < *(_WORD *)(a1 + 26)
      || v21 - v41 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v7 = 0;
    }
    else
    {
      v7 = -1;
    }
    result = v7;
    v35 = v7;
    v30 = 0;
    v40 = 0;
    while ( v30 < 8 )
    {
      *(&v22 + v30) = *(_BYTE *)(a1 + 1);
      result = *(&v32 + v30);
      v40 |= result;
      ++v30;
    }
    if ( v40 )
    {
      v18 = 0;
      v19 = 0;
      v17 = a4;
      v16 = 1 - a4;
      while ( v19 < v17 )
      {
        if ( v16 >= 0 )
        {
          *(_WORD *)(a1 + 10) = v18 + v15;
          *(_WORD *)(a1 + 14) = v19 + 1 - v18;
          if ( v38 )
          {
            *(_WORD *)(a1 + 8) = v17 + v21;
            *(_BYTE *)(a1 + 1) = v28;
            sub_100A2380(a1);
            v28 = *(_BYTE *)(a1 + 1);
          }
          if ( v33 )
          {
            *(_WORD *)(a1 + 8) = v21 - v17;
            *(_BYTE *)(a1 + 1) = v23;
            sub_100A2380(a1);
            v23 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 10) = v15 - v18;
          *(_WORD *)(a1 + 14) = v18 - v19 - 1;
          if ( v37 )
          {
            *(_WORD *)(a1 + 8) = v17 + v21;
            *(_BYTE *)(a1 + 1) = v27;
            sub_100A2380(a1);
            v27 = *(_BYTE *)(a1 + 1);
          }
          if ( v34 )
          {
            *(_WORD *)(a1 + 8) = v21 - v17;
            *(_BYTE *)(a1 + 1) = v24;
            sub_100A2380(a1);
            v24 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 8) = v18 + v21;
          *(_WORD *)(a1 + 12) = v19 + 1 - v18;
          if ( v39 )
          {
            *(_WORD *)(a1 + 10) = v17 + v15;
            *(_BYTE *)(a1 + 1) = v29;
            sub_100A2550(a1);
            v29 = *(_BYTE *)(a1 + 1);
          }
          if ( v36 )
          {
            *(_WORD *)(a1 + 10) = v15 - v17;
            *(_BYTE *)(a1 + 1) = v26;
            sub_100A2550(a1);
            v26 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 8) = v21 - v18;
          *(_WORD *)(a1 + 12) = v18 - v19 - 1;
          if ( v32 )
          {
            *(_WORD *)(a1 + 10) = v17 + v15;
            *(_BYTE *)(a1 + 1) = v22;
            sub_100A2550(a1);
            v22 = *(_BYTE *)(a1 + 1);
          }
          if ( v35 )
          {
            *(_WORD *)(a1 + 10) = v15 - v17;
            *(_BYTE *)(a1 + 1) = v25;
            sub_100A2550(a1);
            v25 = *(_BYTE *)(a1 + 1);
          }
          v18 = v19 + 1;
          v16 -= 2 * v17-- - 2;
        }
        v16 += 2 * v19++ + 3;
      }
      result = v17;
      if ( v19 == v17 )
      {
        *(_WORD *)(a1 + 10) = v18 + v15;
        *(_WORD *)(a1 + 14) = v19 + 1 - v18;
        if ( v38 )
        {
          *(_WORD *)(a1 + 8) = v17 + v21;
          *(_BYTE *)(a1 + 1) = v28;
          sub_100A2380(a1);
          v28 = *(_BYTE *)(a1 + 1);
        }
        if ( v33 )
        {
          *(_WORD *)(a1 + 8) = v21 - v17;
          *(_BYTE *)(a1 + 1) = v23;
          sub_100A2380(a1);
          v23 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 10) = v15 - v18;
        *(_WORD *)(a1 + 14) = v18 - v19 - 1;
        if ( v37 )
        {
          *(_WORD *)(a1 + 8) = v17 + v21;
          *(_BYTE *)(a1 + 1) = v27;
          sub_100A2380(a1);
          v27 = *(_BYTE *)(a1 + 1);
        }
        if ( v34 )
        {
          *(_WORD *)(a1 + 8) = v21 - v17;
          *(_BYTE *)(a1 + 1) = v24;
          sub_100A2380(a1);
          v24 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 8) = v18 + v21;
        *(_WORD *)(a1 + 12) = v19 + 1 - v18;
        if ( v39 )
        {
          *(_WORD *)(a1 + 10) = v17 + v15;
          *(_BYTE *)(a1 + 1) = v29;
          sub_100A2550(a1);
          v29 = *(_BYTE *)(a1 + 1);
        }
        if ( v36 )
        {
          *(_WORD *)(a1 + 10) = v15 - v17;
          *(_BYTE *)(a1 + 1) = v26;
          sub_100A2550(a1);
          v26 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 8) = v21 - v18;
        result = a1;
        *(_WORD *)(a1 + 12) = v18 - v19 - 1;
        if ( v32 )
        {
          *(_WORD *)(a1 + 10) = v17 + v15;
          *(_BYTE *)(a1 + 1) = v22;
          sub_100A2550(a1);
          result = *(_BYTE *)(a1 + 1);
          v22 = *(_BYTE *)(a1 + 1);
        }
        if ( v35 )
        {
          *(_WORD *)(a1 + 10) = v15 - v17;
          *(_BYTE *)(a1 + 1) = v25;
          sub_100A2550(a1);
          result = *(_BYTE *)(a1 + 1);
        }
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 44);
    *(_WORD *)(a1 + 46) = a2;
    *(_WORD *)(a1 + 44) = a3 - a4;
    sub_1009F9B0(a1, a2, a3, a4, 1, a2, a4 + a3);
    sub_1009F9B0(a1, a2, a3, a4, 1, a2, a3 - a4);
    result = v5;
    *(_DWORD *)(a1 + 44) = v5;
  }
  return result;
}

//----- (100A1BD0) --------------------------------------------------------
int __cdecl sub_100A1BD0(int a1, __int16 a2, __int16 a3)
{
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 46) + *(_WORD *)(a1 + 42);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 44) + *(_WORD *)(a1 + 40);
  return sub_100A24F0(a1);
}

//----- (100A1C30) --------------------------------------------------------
int __cdecl sub_100A1C30(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100A1E00) --------------------------------------------------------
int __cdecl sub_100A1E00(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  signed int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  signed int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_10150348 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (100A22D0) --------------------------------------------------------
char __cdecl sub_100A22D0(int a1)
{
  int v1; // eax@3
  int v3; // [sp+0h] [bp-30h]@3
  __int16 v4; // [sp+4h] [bp-2Ch]@1
  char v5; // [sp+8h] [bp-28h]@6
  int v6; // [sp+14h] [bp-1Ch]@1

  v6 = *(_WORD *)(a1 + 10);
  v4 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
  if ( v4 < 0 )
  {
    v6 = *(_WORD *)(a1 + 14);
    v4 = -v4;
  }
  v1 = (signed __int16)(v4 + 1);
  v6 = v1 + (v6 << 16);
  v3 = *(_WORD *)(a1 + 6);
  if ( v3 == 1 )
  {
    LOBYTE(v1) = sub_100A26A0(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  else if ( v3 == 3 )
  {
    LOBYTE(v1) = sub_100A2B90(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  return v1;
}

//----- (100A2380) --------------------------------------------------------
char __cdecl sub_100A2380(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_100A2A20(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = (unsigned int)sub_100A3350(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_100A2A20(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_100A2A20(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_100A2B90(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_100A2FC0(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (100A24F0) --------------------------------------------------------
int __cdecl sub_100A24F0(int a1)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  result = a1;
  v2 = *(_WORD *)(a1 + 4);
  if ( *(_WORD *)(a1 + 4) && v2 != 2 )
  {
    if ( v2 == 3 )
      result = sub_100A2CA0(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  else
  {
    result = sub_100A2AA0(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  return result;
}

//----- (100A2550) --------------------------------------------------------
char *__cdecl sub_100A2550(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_100A2B10(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_100A2D90(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_100A3100(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_100A2B10(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_100A3490(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (100A26A0) --------------------------------------------------------
unsigned int __cdecl sub_100A26A0(int a1, signed int a2, int a3, int a4)
{
  unsigned int result; // eax@1

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  result = sub_100A2760(a1, a4);
  if ( *(_DWORD *)a4 )
  {
    *(_DWORD *)(a4 + 32) = (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) >> (*(_BYTE *)(a4 + 12) & 0x1F)) | (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) << (32 - (*(_BYTE *)(a4 + 12) & 0x1F)));
    *(_DWORD *)(a4 + 36) = 1;
    result = sub_100A2880(a1, a4);
  }
  return result;
}

//----- (100A2760) --------------------------------------------------------
int __cdecl sub_100A2760(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (100A2880) --------------------------------------------------------
unsigned int __cdecl sub_100A2880(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (100A2A20) --------------------------------------------------------
int __cdecl sub_100A2A20(int a1, int a2, int a3)
{
  return sub_100A1E00(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (100A2AA0) --------------------------------------------------------
int __cdecl sub_100A2AA0(int a1, int a2, int a3)
{
  return sub_100A1E00(
           a1,
           (a2 << 16) + *(_WORD *)(a1 + 34) - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           (a3 << 16) + *(_WORD *)(a1 + 32) - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (100A2B10) --------------------------------------------------------
int __cdecl sub_100A2B10(int a1, int a2, int a3)
{
  return sub_100A1E00(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (100A2B90) --------------------------------------------------------
char __cdecl sub_100A2B90(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_100A2CA0(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_100A2760(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_10150348 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_10150348 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (100A2CA0) --------------------------------------------------------
int __cdecl sub_100A2CA0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (100A2D90) --------------------------------------------------------
int __cdecl sub_100A2D90(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_100A2E90(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (100A2E90) --------------------------------------------------------
int __cdecl sub_100A2E90(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100A2FC0) --------------------------------------------------------
char *__cdecl sub_100A2FC0(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_100A2760(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_100A2880(a1, (int)v11);
  }
  return result;
}

//----- (100A3100) --------------------------------------------------------
char *__cdecl sub_100A3100(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_100A2E90(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (100A3350) --------------------------------------------------------
int *__cdecl sub_100A3350(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int *result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_100A2FC0(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_100A2B90(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int *)((char *)v10 + (v8 >> 8));
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (100A3490) --------------------------------------------------------
int *__cdecl sub_100A3490(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int *result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_100A3100(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_100A2D90(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int *)((char *)v9 + (v8 >> 8));
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (100A35D0) --------------------------------------------------------
int __cdecl sub_100A35D0(int a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax@5
  int v5; // [sp+0h] [bp-18h]@6
  __int16 v6; // [sp+4h] [bp-14h]@6
  int v7; // [sp+8h] [bp-10h]@1
  __int16 v8; // [sp+Ch] [bp-Ch]@6
  __int16 v9; // [sp+10h] [bp-8h]@1
  __int16 v10; // [sp+14h] [bp-4h]@1

  v7 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
  v10 = *(_WORD *)(a1 + 42) + a2;
  v9 = *(_WORD *)(a1 + 40) + a3;
  if ( v10 - a4 < *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
    && a4 + v10 >= *(_WORD *)(a1 + 26)
    && v9 - a4 < *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
    && a4 + v9 >= *(_WORD *)(a1 + 24) )
  {
    v8 = 0;
    v6 = a4;
    v5 = 1 - a4;
    while ( v8 < v6 )
    {
      if ( v5 >= 0 )
      {
        *(_WORD *)(a1 + 10) = v8 + v10;
        *(_WORD *)(a1 + 8) = v6 + v9;
        *(_WORD *)(a1 + 14) = v10 - v8;
        sub_100A22D0(a1);
        *(_WORD *)(a1 + 8) = v9 - v6;
        sub_100A22D0(a1);
        v5 -= 2 * v6-- - 2;
      }
      *(_WORD *)(a1 + 10) = v6 + v10;
      *(_WORD *)(a1 + 8) = v8 + v9;
      *(_WORD *)(a1 + 14) = v10 - v6;
      sub_100A22D0(a1);
      *(_WORD *)(a1 + 8) = v9 - v8;
      sub_100A22D0(a1);
      v5 += 2 * v8++ + 3;
    }
    result = v8;
    if ( v8 == v6 )
    {
      *(_WORD *)(a1 + 10) = v6 + v10;
      *(_WORD *)(a1 + 8) = v8 + v9;
      *(_WORD *)(a1 + 14) = v10 - v6;
      sub_100A22D0(a1);
      *(_WORD *)(a1 + 8) = v9 - v8;
      LOBYTE(result) = sub_100A22D0(a1);
    }
    *(_DWORD *)(a1 + 36) = v7;
  }
  else
  {
    result = v7;
    *(_DWORD *)(a1 + 36) = v7;
  }
  return result;
}

//----- (100A3830) --------------------------------------------------------
int __thiscall sub_100A3830(void *this)
{
  char *v1; // ecx@1
  int result; // eax@1

  v1 = (char *)this + 96;
  result = 0;
  if ( *(char **)v1 != v1 )
    result = *(_DWORD *)v1 - 104;
  return result;
}

//----- (100A3840) --------------------------------------------------------
void __fastcall sub_100A3840(int a1, int a2)
{
  void (__cdecl *v2)(int, int); // eax@2

  if ( a1 )
  {
    v2 = *(void (__cdecl **)(int, int))(a1 + 48);
    if ( v2 )
      v2(a1, a2);
  }
}

//----- (100A3860) --------------------------------------------------------
int __fastcall sub_100A3860(const char *a1, const char *a2)
{
  int result; // eax@1

  result = 1;
  if ( a2 )
  {
    if ( a1 )
      result = strcmp(a2, a1);
  }
  return result;
}

//----- (100A38A0) --------------------------------------------------------
unsigned int __usercall sub_100A38A0@<eax>(const char *a1@<eax>)
{
  unsigned int result; // eax@2

  if ( a1 )
    result = strlen(a1);
  else
    result = 0;
  return result;
}

//----- (100A38C0) --------------------------------------------------------
int __cdecl sub_100A38C0(int a1, int a2)
{
  int result; // eax@1
  _DWORD *v3; // edx@1

  *(_DWORD *)(a2 + 92) = a1;
  result = a2 + 104;
  v3 = *(_DWORD **)(a1 + 100);
  *(_DWORD *)(a1 + 100) = a2 + 104;
  *(_DWORD *)result = a1 + 96;
  *(_DWORD *)(result + 4) = v3;
  *v3 = a2 + 104;
  return result;
}

//----- (100A38E0) --------------------------------------------------------
int sub_100A38E0(int arg0, char *arg4, ...)
{
  int v2; // eax@1
  size_t v3; // ebx@1
  signed int v4; // esi@4
  _DWORD *v5; // eax@4
  int result; // eax@7
  int (__cdecl *v7)(int, size_t); // eax@11
  void *v8; // eax@12
  char v9; // [sp+Ch] [bp-84h]@1
  char v10; // [sp+8Bh] [bp-5h]@3
  va_list va; // [sp+9Ch] [bp+Ch]@1

  va_start(va, arg4);
  v2 = _vsnprintf(&v9, 0x80u, arg4, va);
  v3 = v2;
  if ( v2 < 0 || (unsigned int)v2 >= 0x80 )
  {
    v3 = 127;
    v10 = 0;
  }
  v4 = 0;
  v5 = (_DWORD *)(arg0 + 72);
  while ( *v5 )
  {
    ++v4;
    ++v5;
    if ( v4 >= 5 )
      return -27;
  }
  if ( v4 < 5 )
  {
    if ( arg0 && (v7 = *(int (__cdecl **)(int, size_t))(arg0 + 52)) != 0 )
      v8 = (void *)v7(arg0, v3 + 1);
    else
      v8 = 0;
    *(_DWORD *)(arg0 + 4 * v4 + 72) = v8;
    if ( v8 )
    {
      memcpy(v8, &v9, v3);
      *(_BYTE *)(v3 + *(_DWORD *)(arg0 + 4 * v4 + 72)) = 0;
      result = 0;
    }
    else
    {
      result = -26;
    }
  }
  else
  {
    result = -27;
  }
  return result;
}

//----- (100A3A00) --------------------------------------------------------
void *__cdecl sub_100A3A00(int a1, int a2)
{
  void *result; // eax@1
  void *v3; // ebx@1

  result = (void *)(*(int (__cdecl **)(_DWORD, signed int))(a1 + 24))(0, 116);
  v3 = result;
  if ( result )
  {
    memset(result, 0, 0x74u);
    *((_DWORD *)v3 + 3) = a2 | 2;
    qmemcpy((char *)v3 + 28, (const void *)a1, 0x2Cu);
    *((_DWORD *)v3 + 25) = (char *)v3 + 96;
    *((_DWORD *)v3 + 24) = (char *)v3 + 96;
    *((_DWORD *)v3 + 27) = (char *)v3 + 104;
    *((_DWORD *)v3 + 26) = (char *)v3 + 104;
    *((_DWORD *)v3 + 23) = v3;
    result = v3;
  }
  return result;
}

//----- (100A3A60) --------------------------------------------------------
signed int __cdecl sub_100A3A60(void *a1)
{
  _DWORD *v1; // eax@1
  int v2; // ecx@5
  int v3; // edx@5
  signed int result; // eax@9

  v1 = a1;
  if ( a1 )
  {
    while ( !(*((_BYTE *)v1 + 12) & 2) )
    {
      if ( v1 == a1 )
      {
        v1 = (_DWORD *)sub_100A3830(a1);
      }
      else
      {
        v2 = v1[26];
        v3 = 0;
        if ( v2 != v1[23] + 96 )
          v3 = v2 - 104;
        v1 = (_DWORD *)v3;
      }
      if ( !v1 )
        goto LABEL_9;
    }
    result = 1;
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (100A3AB0) --------------------------------------------------------
signed int __cdecl sub_100A3AB0(int a1, char a2, __int32 *a3)
{
  int v3; // eax@1
  int v4; // esi@1
  _BYTE *v5; // eax@2
  signed int result; // eax@4

  v3 = sub_100A46E0(a2, 0, *(_DWORD *)(a1 + 40));
  v4 = v3;
  if ( v3 && (v5 = *(_BYTE **)(v3 + 8)) != 0 && isdigit(*v5) )
  {
    *a3 = j__atol(*(const char **)(v4 + 8));
    result = 0;
  }
  else
  {
    result = -31;
  }
  return result;
}

//----- (100A3B10) --------------------------------------------------------
int __cdecl sub_100A3B10(int a1)
{
  int result; // eax@1

  result = a1;
  ++*(_DWORD *)(result + 12);
  return result;
}

//----- (100A3B20) --------------------------------------------------------
signed int __cdecl sub_100A3B20(int a1)
{
  int v1; // eax@2
  bool v2; // zf@3
  signed int result; // eax@3

  if ( !a1 || (v1 = *(_DWORD *)(a1 + 32)) == 0 || (v2 = sub_100A4670(*(_DWORD *)(v1 + 4), a1) == 0, result = 1, v2) )
    result = 0;
  return result;
}

//----- (100A3B50) --------------------------------------------------------
int __cdecl sub_100A3B50(int a1, void *a2, size_t a3)
{
  int v3; // ecx@1
  const char *v4; // ebx@2
  unsigned int v5; // esi@3
  int result; // eax@5
  int (__cdecl *v7)(int, size_t); // eax@8

  v3 = *(_DWORD *)(a1 + 32);
  if ( a3 )
  {
    v4 = *(const char **)(a1 + 8);
    if ( v4 )
    {
      v5 = strlen(v4);
      if ( v3 && *(_DWORD *)(v3 + 52) )
        result = (*(int (__cdecl **)(int, const char *, unsigned int))(v3 + 56))(v3, v4, v5 + a3 + 1);
      else
        result = 0;
    }
    else
    {
      if ( v3 && (v7 = *(int (__cdecl **)(int, size_t))(v3 + 52)) != 0 )
        result = v7(v3, a3 + 1);
      else
        result = 0;
      v5 = 0;
    }
    *(_DWORD *)(a1 + 8) = result;
    if ( result )
    {
      memcpy((void *)(v5 + result), a2, a3);
      *(_BYTE *)(a3 + v5 + *(_DWORD *)(a1 + 8)) = 0;
      result = *(_DWORD *)(a1 + 8);
    }
  }
  else
  {
    result = *(_DWORD *)(a1 + 8);
  }
  return result;
}

//----- (100A3BF0) --------------------------------------------------------
int __cdecl sub_100A3BF0(int a1, void *a2)
{
  void *v2; // edi@3
  unsigned int v3; // ebx@5
  int (__cdecl *v4)(int, unsigned int); // eax@7
  void *v5; // eax@8
  int result; // eax@11

  if ( a1 && a2 )
  {
    v2 = *(void **)(a1 + 16);
    if ( v2 != a2 && sub_100A3860((const char *)a2, *(const char **)(a1 + 16)) )
    {
      v3 = sub_100A38A0((const char *)a2);
      if ( v2 )
        sub_100A3840(a1, (int)v2);
      v4 = *(int (__cdecl **)(int, unsigned int))(a1 + 52);
      if ( v4 )
        v5 = (void *)v4(a1, v3 + 1);
      else
        v5 = 0;
      *(_DWORD *)(a1 + 16) = v5;
      if ( v5 )
      {
        memcpy(v5, a2, v3 + 1);
        *(_BYTE *)(v3 + *(_DWORD *)(a1 + 16)) = 0;
        *(_DWORD *)(a1 + 12) |= 0xAu;
        result = 0;
      }
      else
      {
        result = -26;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100A3C90) --------------------------------------------------------
void __usercall sub_100A3C90(int a1@<edx>, int a2@<esi>)
{
  void (__cdecl *v2)(int, _DWORD); // eax@4

  if ( *(_BYTE *)(a2 + 1) & 2 && *(_DWORD *)(a2 + 4) )
  {
    if ( a1 )
    {
      v2 = *(void (__cdecl **)(int, _DWORD))(a1 + 48);
      if ( v2 )
        v2(a1, *(_DWORD *)(a2 + 4));
    }
    *(_DWORD *)(a2 + 4) = 0;
  }
}

//----- (100A3CC0) --------------------------------------------------------
int __thiscall sub_100A3CC0(int this)
{
  int v1; // edx@1
  int v2; // edx@2
  int v3; // eax@3
  int v4; // eax@7
  _DWORD *v5; // eax@11
  int v6; // eax@13
  int v7; // edx@16
  int result; // eax@16
  _DWORD *v9; // esi@16

  v1 = *(_DWORD *)(this + 24);
  if ( v1 )
  {
    if ( this == *(_DWORD *)(v1 + 28) )
    {
      v5 = (_DWORD *)(this + 16);
      if ( (_DWORD *)*v5 == v5 )
      {
        *(_DWORD *)(v1 + 28) = 0;
      }
      else
      {
        v6 = *v5 - 16;
        if ( v6 == this )
          v6 = 0;
        *(_DWORD *)(v1 + 28) = v6;
      }
    }
  }
  else
  {
    v2 = *(_DWORD *)(this + 32);
    if ( *(_DWORD *)v2 == this )
    {
      v3 = *(_DWORD *)(this + 16) - 16;
      if ( v3 == this )
        v3 = 0;
      *(_DWORD *)v2 = v3;
    }
    else if ( *(_DWORD *)(v2 + 4) == this )
    {
      v4 = *(_DWORD *)(this + 16) - 16;
      if ( v4 == this )
        v4 = 0;
      *(_DWORD *)(v2 + 4) = v4;
    }
  }
  v7 = *(_DWORD *)(this + 16);
  result = this + 16;
  v9 = *(_DWORD **)(this + 20);
  *(_DWORD *)(v7 + 4) = v9;
  *v9 = v7;
  *(_DWORD *)result = result;
  *(_DWORD *)(result + 4) = result;
  *(_DWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 36) = 0;
  return result;
}

//----- (100A3D40) --------------------------------------------------------
void __cdecl sub_100A3D40(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // eax@3
  int v4; // edx@4
  int v5; // eax@4
  _DWORD *v6; // esi@4

  if ( a1 && a2 )
  {
    sub_100A3CC0(a2);
    v3 = *(_DWORD *)(a1 + 28);
    if ( v3 )
    {
      v4 = v3 + 16;
      v5 = v2 + 16;
      v6 = *(_DWORD **)(v4 + 4);
      *(_DWORD *)(v4 + 4) = v2 + 16;
      *(_DWORD *)(v5 + 4) = v6;
      *(_DWORD *)v5 = v4;
      *v6 = v2 + 16;
      *(_DWORD *)(v2 + 24) = a1;
      *(_BYTE *)(v2 + 36) = *(_BYTE *)(a1 + 36) + 1;
    }
    else
    {
      *(_DWORD *)(a1 + 28) = v2;
      *(_DWORD *)(v2 + 24) = a1;
      *(_BYTE *)(v2 + 36) = *(_BYTE *)(a1 + 36) + 1;
    }
  }
}

//----- (100A3D90) --------------------------------------------------------
int __cdecl sub_100A3D90(int a1, int a2)
{
  void (__cdecl *v2)(int, _DWORD); // eax@3
  int v3; // eax@6
  _DWORD *v4; // ecx@8
  int result; // eax@11
  _DWORD *v6; // ecx@11

  if ( *(_DWORD *)(a2 + 8) )
  {
    if ( a1 )
    {
      v2 = *(void (__cdecl **)(int, _DWORD))(a1 + 48);
      if ( v2 )
        v2(a1, *(_DWORD *)(a2 + 8));
    }
    *(_DWORD *)(a2 + 8) = 0;
  }
  v3 = *(_DWORD *)(a2 + 24);
  if ( v3 && *(_DWORD *)(v3 + 40) == a2 )
  {
    v4 = (_DWORD *)(a2 + 16);
    if ( (_DWORD *)*v4 == v4 )
      *(_DWORD *)(v3 + 40) = 0;
    else
      *(_DWORD *)(v3 + 40) = *v4 - 16;
  }
  sub_100A3C90(a1, a2);
  result = *(_DWORD *)(a2 + 16);
  v6 = *(_DWORD **)(a2 + 20);
  *(_DWORD *)(result + 4) = v6;
  *v6 = result;
  if ( a1 )
  {
    result = *(_DWORD *)(a1 + 48);
    if ( result )
      result = ((int (__cdecl *)(int, int))result)(a1, a2);
  }
  return result;
}

//----- (100A3E10) --------------------------------------------------------
int __cdecl sub_100A3E10(int a1)
{
  int v1; // ecx@1
  int v2; // edx@1
  int result; // eax@1
  int v4; // edx@3
  _DWORD *v5; // ecx@3

  sub_100A3CC0(a1);
  v2 = *(_DWORD *)(v1 + 32);
  result = *(_DWORD *)(v2 + 4);
  if ( result )
  {
    v4 = result + 16;
    result = v1 + 16;
    v5 = *(_DWORD **)(v4 + 4);
    *(_DWORD *)(v4 + 4) = result;
    *(_DWORD *)result = v4;
    *(_DWORD *)(result + 4) = v5;
    *v5 = result;
  }
  else
  {
    *(_DWORD *)(v2 + 4) = v1;
  }
  return result;
}

//----- (100A3E40) --------------------------------------------------------
int __cdecl sub_100A3E40(int a1, int a2, char a3, int a4, void *a5)
{
  char v5; // bl@1
  int (__cdecl *v6)(int, signed int); // eax@2
  int v7; // esi@3
  int v8; // edi@6
  const char *v9; // eax@9
  unsigned int v10; // ecx@9
  size_t v11; // ebx@11
  int (__cdecl *v12)(int, unsigned int); // eax@12
  void *v13; // edi@13
  void *v14; // edx@18
  size_t v15; // ebx@19
  int (__cdecl *v16)(int, size_t); // eax@20
  int v17; // eax@21
  void *v18; // edi@21
  int v19; // eax@27
  _DWORD *v20; // ecx@28
  int v21; // eax@28
  int v22; // edx@28
  int result; // eax@28
  void (__cdecl *v24)(int, int); // eax@30

  v5 = a3;
  if ( a1 && (v6 = *(int (__cdecl **)(int, signed int))(a1 + 52)) != 0 )
    v7 = v6(a1, a3 != 2 ? 48 : 28);
  else
    v7 = 0;
  if ( !v7 )
    return v7;
  memset((void *)v7, 0, a3 != 2 ? 48 : 28);
  v8 = a2;
  *(_DWORD *)(v7 + 16) = v7 + 16;
  *(_DWORD *)(v7 + 20) = v7 + 16;
  *(_DWORD *)(v7 + 24) = a2;
  *(_BYTE *)v7 = a3;
  if ( a3 != 2 )
    *(_DWORD *)(v7 + 28) = 0;
  *(_BYTE *)(v7 + 2) = *(_BYTE *)a4;
  if ( *(_DWORD *)(a4 + 4) )
  {
    *(_BYTE *)(v7 + 1) |= 2u;
    v9 = *(const char **)(a4 + 4);
    v10 = 0;
    if ( v9 )
      v10 = strlen(v9);
    v11 = v10 + 1;
    if ( a1 && (v12 = *(int (__cdecl **)(int, unsigned int))(a1 + 52)) != 0 )
      v13 = (void *)v12(a1, v10 + 1);
    else
      v13 = 0;
    *(_DWORD *)(v7 + 4) = v13;
    if ( !v13 )
      goto LABEL_29;
    memcpy(v13, *(const void **)(a4 + 4), v11);
    *((char *)v13 + v11 - 1) = 0;
    v5 = a3;
    v8 = a2;
  }
  else
  {
    *(_DWORD *)(v7 + 4) = sub_100A6120(*(_BYTE *)a4);
  }
  v14 = a5;
  if ( !a5 )
    goto LABEL_25;
  v15 = strlen((const char *)a5) + 1;
  if ( a1 && (v16 = *(int (__cdecl **)(int, size_t))(a1 + 52)) != 0 )
  {
    v17 = v16(a1, v15);
    v14 = a5;
    v18 = (void *)v17;
  }
  else
  {
    v18 = 0;
  }
  *(_DWORD *)(v7 + 8) = v18;
  if ( v18 )
  {
    memcpy(v18, v14, v15);
    *((char *)v18 + v15 - 1) = 0;
    v5 = a3;
    v8 = a2;
LABEL_25:
    if ( v8 )
    {
      if ( v5 == 2 )
      {
        v19 = *(_DWORD *)(v8 + 40);
        if ( v19 )
        {
          v20 = *(_DWORD **)(v19 + 20);
          v21 = v19 + 16;
          v22 = v7 + 16;
          *(_DWORD *)(v21 + 4) = v7 + 16;
          *(_DWORD *)v22 = v21;
          result = v7;
          *(_DWORD *)(v22 + 4) = v20;
          *v20 = v7 + 16;
        }
        else
        {
          *(_DWORD *)(v8 + 40) = v7;
          result = v7;
        }
        return result;
      }
      sub_100A3D40(v8, v7);
    }
    return v7;
  }
LABEL_29:
  if ( a1 )
  {
    v24 = *(void (__cdecl **)(int, int))(a1 + 48);
    if ( v24 )
      v24(a1, v7);
  }
  return 0;
}

//----- (100A3FE0) --------------------------------------------------------
int __cdecl sub_100A3FE0(int a1, int a2, void *a3)
{
  int result; // eax@1
  int v4; // ebp@2
  int v5; // eax@5
  int v6; // edi@5
  void (__cdecl *v7)(int, _DWORD); // eax@8
  size_t v8; // esi@12
  int (__cdecl *v9)(int, size_t); // eax@14
  void *v10; // eax@15

  result = 0;
  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 32);
    if ( v4 )
    {
      if ( *(_BYTE *)a2 != 68 || *(_DWORD *)(a2 + 4) )
      {
        v5 = sub_100A44F0(a2, 0, *(_DWORD *)(a1 + 40));
        v6 = v5;
        if ( v5 )
        {
          if ( *(_DWORD *)(v5 + 8) )
          {
            if ( v4 )
            {
              v7 = *(void (__cdecl **)(int, _DWORD))(v4 + 48);
              if ( v7 )
                v7(v4, *(_DWORD *)(v6 + 8));
            }
            *(_DWORD *)(v6 + 8) = 0;
          }
          if ( a3 )
          {
            v8 = strlen((const char *)a3);
            if ( v8 )
            {
              if ( v4 && (v9 = *(int (__cdecl **)(int, size_t))(v4 + 52)) != 0 )
                v10 = (void *)v9(v4, v8 + 1);
              else
                v10 = 0;
              *(_DWORD *)(v6 + 8) = v10;
              if ( !v10 )
                return 0;
              memcpy(v10, a3, v8);
              *(_BYTE *)(v8 + *(_DWORD *)(v6 + 8)) = 0;
            }
          }
          result = v6;
        }
        else
        {
          result = sub_100A3E40(*(_DWORD *)(a1 + 32), a1, 2, a2, a3);
        }
      }
    }
  }
  return result;
}

//----- (100A40C0) --------------------------------------------------------
int __cdecl sub_100A40C0(int a1, int a2, int a3, char a4, int a5, void *a6)
{
  int result; // eax@1
  int v7; // ecx@2
  _DWORD *v8; // esi@5
  int v9; // edx@5
  int v10; // ecx@5

  result = sub_100A3E40(a1, a3, a4, a5, a6);
  if ( result )
  {
    *(_DWORD *)(result + 32) = a1;
    v7 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 )
    {
      if ( !a3 )
      {
        v8 = *(_DWORD **)(v7 + 20);
        v9 = v7 + 16;
        v10 = result + 16;
        *(_DWORD *)(v9 + 4) = result + 16;
        *(_DWORD *)v10 = v9;
        *(_DWORD *)(v10 + 4) = v8;
        *v8 = result + 16;
      }
    }
    else
    {
      *(_DWORD *)a2 = result;
    }
  }
  return result;
}

//----- (100A4120) --------------------------------------------------------
int __cdecl sub_100A4120(int a1, int a2, char a3, int a4, void *a5)
{
  int v6; // [sp+0h] [bp-8h]@1

  sub_100A6140(a4, (int)&v6);
  return sub_100A40C0(a1, a1, a2, a3, (int)&v6, a5);
}

//----- (100A4160) --------------------------------------------------------
int (__cdecl *__cdecl sub_100A4160(void *a1))(int, void *)
{
  int v1; // edi@1
  int (__cdecl *result)(int, void *); // eax@3
  bool v3; // zf@6
  int *v4; // ebx@8
  int v5; // ecx@10
  void (__cdecl *v6)(int, int); // eax@12

  v1 = *((_DWORD *)a1 + 8);
  if ( !*((_DWORD *)a1 + 3) || sub_100A3B20((int)a1) )
  {
    while ( *((_DWORD *)a1 + 7) )
      sub_100A4160((void *)(*(_DWORD *)(*((_DWORD *)a1 + 7) + 16) - 16));
    sub_100A3CC0((int)a1);
    v3 = *((_DWORD *)a1 + 10) == 0;
    *((_DWORD *)a1 + 4) = 0;
    if ( !v3 )
    {
      do
        sub_100A3D90(v1, *((_DWORD *)a1 + 10));
      while ( *((_DWORD *)a1 + 10) );
    }
    v4 = (int *)((char *)a1 + 44);
    if ( *((_DWORD *)a1 + 11) )
    {
      do
        sub_100A5010(v1, (int *)a1 + 11, *v4);
      while ( *v4 );
    }
    sub_100A3C90(v1, (int)a1);
    v5 = *((_DWORD *)a1 + 2);
    if ( v5 )
    {
      if ( v1 )
      {
        v6 = *(void (__cdecl **)(int, int))(v1 + 48);
        if ( v6 )
          v6(v1, v5);
      }
      *((_DWORD *)a1 + 2) = 0;
    }
    result = (int (__cdecl *)(int, void *))memset(a1, 204, 0x30u);
    if ( v1 )
    {
      result = *(int (__cdecl **)(int, void *))(v1 + 48);
      if ( result )
        result = (int (__cdecl *)(int, void *))result(v1, a1);
    }
  }
  else
  {
    result = (int (__cdecl *)(int, void *))sub_100A3E10((int)a1);
  }
  return result;
}

//----- (100A4240) --------------------------------------------------------
void __cdecl sub_100A4240(void *a1)
{
  bool v1; // zf@1

  v1 = (*((_DWORD *)a1 + 3))-- == 1;
  if ( v1 )
  {
    if ( sub_100A3B20((int)a1) )
      sub_100A4160(a1);
  }
}

//----- (100A4270) --------------------------------------------------------
int (__cdecl *__usercall sub_100A4270@<eax>(int a1@<esi>, int a2))(int, int)
{
  int (__cdecl *result)(int, int); // eax@5
  int *v3; // edi@7
  signed int v4; // ebx@7
  void (__cdecl *v5)(int, _DWORD); // eax@15
  int v6; // eax@17
  _DWORD *v7; // ecx@17
  int v8; // eax@17
  _DWORD *v9; // ecx@17
  int v10; // [sp+0h] [bp-4h]@0

  sub_100A62E0(v10);
  if ( *(_DWORD *)a1 )
  {
    sub_100A4160(*(void **)a1);
    *(_DWORD *)a1 = 0;
  }
  if ( *(_DWORD *)(a1 + 4) )
  {
    sub_100A4160(*(void **)(a1 + 4));
    *(_DWORD *)(a1 + 4) = 0;
  }
  result = *(int (__cdecl **)(int, int))(a1 + 24);
  if ( result )
  {
    result = (int (__cdecl *)(int, int))sub_100A5730(a1, *(_DWORD *)(a1 + 24));
    *(_DWORD *)(a1 + 24) = 0;
  }
  v3 = (int *)(a1 + 72);
  v4 = 5;
  do
  {
    if ( *v3 )
    {
      result = *(int (__cdecl **)(int, int))(a1 + 48);
      if ( result )
        result = (int (__cdecl *)(int, int))result(a1, *v3);
      *v3 = 0;
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  if ( !a2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
    {
      v5 = *(void (__cdecl **)(int, _DWORD))(a1 + 48);
      if ( v5 )
        v5(a1, *(_DWORD *)(a1 + 16));
    }
    v6 = *(_DWORD *)(a1 + 104);
    v7 = *(_DWORD **)(a1 + 108);
    *(_DWORD *)(v6 + 4) = v7;
    *v7 = v6;
    v8 = *(_DWORD *)(a1 + 96);
    v9 = *(_DWORD **)(a1 + 100);
    *(_DWORD *)(v8 + 4) = v9;
    *v9 = v8;
    result = *(int (__cdecl **)(int, int))(a1 + 48);
    *(_DWORD *)(a1 + 104) = 0;
    if ( result )
      result = (int (__cdecl *)(int, int))result(a1, a1);
  }
  return result;
}

//----- (100A4340) --------------------------------------------------------
int __cdecl sub_100A4340(int a1, int a2, void *a3)
{
  int v4; // [sp+0h] [bp-8h]@1

  sub_100A6290((const char *)a2, (int)&v4);
  return sub_100A3FE0(a1, (int)&v4, a3);
}

//----- (100A4370) --------------------------------------------------------
int __cdecl sub_100A4370(int a1, int a2, void *a3)
{
  int v4; // [sp+0h] [bp-8h]@1

  sub_100A6140(a2, (int)&v4);
  return sub_100A3FE0(a1, (int)&v4, a3);
}

//----- (100A43A0) --------------------------------------------------------
int __cdecl sub_100A43A0(int a1, int a2, char a3, int a4, void *a5)
{
  int v6; // [sp+0h] [bp-8h]@1

  sub_100A6290((const char *)a4, (int)&v6);
  return sub_100A40C0(a1, a1, a2, a3, (int)&v6, a5);
}

//----- (100A43E0) --------------------------------------------------------
void __cdecl sub_100A43E0(int a1)
{
  _DWORD *v1; // ecx@2
  int v2; // eax@2
  signed int i; // edi@4

  if ( a1 )
  {
    v1 = (_DWORD *)(a1 + 96);
    v2 = 0;
    if ( (_DWORD *)*v1 != v1 )
      v2 = *v1 - 104;
    for ( i = 1024; v2; v2 = sub_100A3830((void *)a1) )
    {
      if ( !--i )
        break;
      sub_100A43E0(v2);
    }
    sub_100A4270(a1, 0);
  }
}

//----- (100A4430) --------------------------------------------------------
int __usercall sub_100A4430@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  _DWORD *v2; // ecx@1
  int v3; // eax@1
  signed int i; // edi@3

  v1 = a1;
  v2 = (_DWORD *)(a1 + 96);
  v3 = 0;
  if ( (_DWORD *)*v2 != v2 )
    v3 = *v2 - 104;
  for ( i = 1024; v3; v3 = sub_100A3830((void *)v1) )
  {
    if ( !--i )
      break;
    sub_100A43E0(v3);
  }
  sub_100A4270(v1, 1);
  return sub_100A48F0(v1, *(void **)(v1 + 16), 256);
}

//----- (100A4490) --------------------------------------------------------
void __cdecl sub_100A4490(void *a1)
{
  _BYTE *v1; // esi@1
  int v2; // eax@6
  int v3; // ecx@6

  v1 = a1;
  if ( a1 )
  {
    do
    {
      if ( v1[12] & 8 )
        sub_100A4430((int)v1);
      sub_100A6300((int)v1);
      if ( v1 == a1 )
      {
        v1 = (_BYTE *)sub_100A3830(a1);
      }
      else
      {
        v2 = *((_DWORD *)v1 + 26);
        v3 = 0;
        if ( v2 != *((_DWORD *)v1 + 23) + 96 )
          v3 = v2 - 104;
        v1 = (_BYTE *)v3;
      }
    }
    while ( v1 );
  }
}

//----- (100A44F0) --------------------------------------------------------
int __cdecl sub_100A44F0(int a1, const char *a2, int a3)
{
  int v3; // esi@1
  const char *v4; // edx@4
  const char *v5; // ecx@4
  const char *v6; // ecx@9
  int v7; // eax@11
  int result; // eax@14

  v3 = a3;
  if ( a3 )
  {
    do
    {
      if ( *(_BYTE *)a1 == *(_BYTE *)(v3 + 2) )
      {
        if ( *(_BYTE *)a1 != 68
          || (v4 = *(const char **)(a1 + 4), v5 = *(const char **)(v3 + 4), v4 == v5)
          || v4 && v5 && !strcmp(v5, v4) )
        {
          if ( !a2 )
            break;
          v6 = *(const char **)(v3 + 8);
          if ( v6 )
          {
            if ( !strcmp(v6, a2) )
              break;
          }
        }
      }
      v7 = *(_DWORD *)(v3 + 16) - 16;
      if ( v7 == a3 )
        v7 = 0;
      v3 = v7;
    }
    while ( v7 );
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100A45C0) --------------------------------------------------------
int __cdecl sub_100A45C0(char a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@2

  result = a2;
  if ( a2 )
  {
    v4 = a3;
    do
    {
      if ( a1 == *(_BYTE *)(result + 2) && --v4 < 0 )
        break;
      result = *(_DWORD *)(result + 16) - 16;
      if ( result == a2 )
        result = 0;
    }
    while ( result );
  }
  return result;
}

//----- (100A45F0) --------------------------------------------------------
int __cdecl sub_100A45F0(int a1, int a2)
{
  _DWORD *v2; // ecx@1
  int result; // eax@1
  int i; // esi@3
  int v5; // edx@5
  int v6; // ecx@5

  v2 = (_DWORD *)(a1 + 96);
  result = 0;
  if ( (_DWORD *)*v2 != v2 )
    result = *v2 - 104;
  for ( i = 0; i < a2; result = v6 )
  {
    if ( !result )
      break;
    v5 = *(_DWORD *)(result + 104);
    v6 = 0;
    if ( v5 != *(_DWORD *)(result + 92) + 96 )
      v6 = v5 - 104;
    ++i;
  }
  return result;
}

//----- (100A4640) --------------------------------------------------------
int __cdecl sub_100A4640(int a1, char a2)
{
  int v2; // ecx@1
  int result; // eax@2

  v2 = a1;
  do
  {
    result = *(_DWORD *)(v2 + 16) - 16;
    if ( result == *(_DWORD *)(*(_DWORD *)(v2 + 24) + 28) )
      result = 0;
    v2 = result;
  }
  while ( result && *(_BYTE *)(result + 2) != a2 );
  return result;
}

//----- (100A4670) --------------------------------------------------------
signed int __cdecl sub_100A4670(int a1, int a2)
{
  signed int result; // eax@1
  int v3; // ecx@1

  result = 0;
  v3 = a1;
  if ( a1 )
  {
    while ( v3 != a2 )
    {
      v3 = *(_DWORD *)(v3 + 16) - 16;
      if ( v3 == a1 )
        v3 = 0;
      if ( !v3 )
        return result;
    }
    result = 1;
  }
  return result;
}

//----- (100A46A0) --------------------------------------------------------
int __usercall sub_100A46A0@<eax>(int result@<eax>, int (__cdecl *a2)(int, int)@<ebx>, int *a3@<edi>, int a4)
{
  int i; // esi@1
  int v5; // eax@3
  int v6; // ecx@3

  for ( i = result; result; i = result )
  {
    result = a2(a4, i);
    *a3 = result;
    if ( result )
      break;
    v5 = *(_DWORD *)(i + 16);
    v6 = *(_DWORD *)(v5 + 8);
    result = v5 - 16;
    if ( result == *(_DWORD *)(v6 + 40) )
      result = 0;
  }
  return result;
}

//----- (100A46E0) --------------------------------------------------------
int __cdecl sub_100A46E0(char a1, const char *a2, int a3)
{
  char v4; // [sp+0h] [bp-8h]@1

  sub_100A6140(a1, (int)&v4);
  return sub_100A44F0((int)&v4, a2, a3);
}

//----- (100A4710) --------------------------------------------------------
int __cdecl sub_100A4710(char a1, int a2)
{
  return sub_100A45C0(a1, a2, 0);
}

//----- (100A4730) --------------------------------------------------------
int __cdecl sub_100A4730(int a1, int a2, int (__cdecl *a3)(int, int), int *a4, int *a5)
{
  int result; // eax@1
  int i; // esi@5

  ++*a4;
  result = a3(a1, a2);
  *a5 = result;
  if ( !result )
  {
    result = *a4;
    if ( *a4 <= 100 )
    {
      if ( *(_DWORD *)(a2 + 40) )
      {
        *a4 = result + 1;
        result = sub_100A46A0(*(_DWORD *)(a2 + 40), a3, a5, a1);
        --*a4;
      }
      for ( i = *(_DWORD *)(a2 + 28); !*a5; i = result )
      {
        if ( !i || *a4 >= 100 )
          break;
        sub_100A4730(a1, i, a3, a4, a5);
        result = *(_DWORD *)(i + 16) - 16;
        if ( result == *(_DWORD *)(*(_DWORD *)(i + 24) + 28) )
          result = 0;
      }
      --*a4;
    }
  }
  return result;
}

//----- (100A47D0) --------------------------------------------------------
signed int __cdecl sub_100A47D0(int a1, int a2)
{
  signed int result; // eax@3

  if ( *(_BYTE *)a2 == 2 )
  {
    result = 0;
  }
  else if ( sub_100A46E0(*(_BYTE *)a1, *(const char **)(a1 + 4), *(_DWORD *)(a2 + 40)) )
  {
    *(_DWORD *)(a1 + 8) = a2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100A4810) --------------------------------------------------------
int __cdecl sub_100A4810(int a1, int a2, int (__cdecl *a3)(int, int))
{
  int v3; // edi@1
  int result; // eax@1
  int (__cdecl *v5)(int, int); // ebx@2
  int v6; // esi@2
  int v7; // eax@6
  int v8; // [sp+4h] [bp-4h]@1

  v3 = a2;
  result = 0;
  v8 = 0;
  if ( a2 )
  {
    v5 = a3;
    a2 = 0;
    sub_100A4730(a1, v3, a3, &a2, &v8);
    v6 = *(_DWORD *)(v3 + 16) - 16;
    if ( v6 == v3 )
      v6 = 0;
    for ( result = v8; !v8; result = v8 )
    {
      if ( !v6 )
        break;
      v8 = v5(a1, v3);
      sub_100A4730(a1, v6, v5, &a2, &v8);
      v7 = *(_DWORD *)(v6 + 16) - 16;
      if ( v7 == v3 )
        v7 = 0;
      v6 = v7;
    }
  }
  return result;
}

//----- (100A48A0) --------------------------------------------------------
int __cdecl sub_100A48A0(char a1, int a2, int a3)
{
  char v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = 0;
  sub_100A4810((int)&v4, a3, sub_100A47D0);
  return v6;
}

//----- (100A48F0) --------------------------------------------------------
int __cdecl sub_100A48F0(int a1, void *a2, int a3)
{
  int v3; // esi@1
  int result; // eax@1
  unsigned int v5; // eax@3
  int v6; // edi@3
  int (__cdecl *v7)(int, signed int); // eax@6
  int v8; // eax@7
  int v9; // eax@9
  void (__cdecl *v10)(int, int); // eax@10
  int (__cdecl *v11)(int, int); // ecx@12
  int v12; // ebx@13
  void (__cdecl *v13)(int, int); // eax@15
  int v14; // eax@18
  signed int v15; // edi@18
  int v16; // eax@18
  int v17; // ST0C_4@23
  int v18; // eax@23
  void (__cdecl *v19)(int, int); // eax@24
  void (__cdecl *v20)(int, int); // eax@26
  int v21; // [sp+10h] [bp-24h]@18
  int v22; // [sp+14h] [bp-20h]@1
  int v23; // [sp+18h] [bp-1Ch]@1
  int v24; // [sp+1Ch] [bp-18h]@1
  int v25; // [sp+20h] [bp-14h]@6
  int v26; // [sp+24h] [bp-10h]@6
  int (__cdecl **v27)(int, void *, size_t); // [sp+28h] [bp-Ch]@6
  int v28; // [sp+2Ch] [bp-8h]@6
  int v29; // [sp+30h] [bp-4h]@6
  int v30; // [sp+38h] [bp+4h]@9

  v22 = 0;
  v3 = a1;
  v23 = -1;
  v24 = -1;
  *(_DWORD *)(a1 + 8) = &v22;
  result = sub_100A3BF0(a1, a2);
  if ( result )
  {
    *(_DWORD *)(a1 + 8) = 0;
    return result;
  }
  *(_DWORD *)(a1 + 12) &= 0xFFFFFFF7;
  v5 = sub_100A5F80(a1);
  v6 = v5;
  if ( v5 >= 0xFFFFFFC2 || !v5 )
  {
    sub_100A38E0(a1, "could not open file %s\n", a2);
    result = v6;
    *(_DWORD *)(a1 + 8) = 0;
    return result;
  }
  v25 = 0;
  v29 = 0;
  v27 = 0;
  v28 = 0;
  v26 = 1966110;
  v7 = *(int (__cdecl **)(int, signed int))(a1 + 52);
  v25 = a1;
  LOWORD(v29) = 1270;
  if ( v7 )
    v8 = v7(a1, 1270);
  else
    v8 = 0;
  v28 = v8;
  v27 = &off_10150748;
  v9 = sub_100A67B0((int)&v25);
  v30 = v9;
  if ( !v9 )
  {
    v10 = *(void (__cdecl **)(int, int))(v3 + 48);
    if ( v10 )
      v10(v3, v28);
LABEL_17:
    sub_100A5F60(v3);
    return -26;
  }
  v11 = *(int (__cdecl **)(int, int))(v3 + 52);
  if ( !v11 )
  {
LABEL_15:
    sub_100A6880(v9);
    v13 = *(void (__cdecl **)(int, int))(v3 + 48);
    if ( v13 )
      v13(v3, v28);
    goto LABEL_17;
  }
  v12 = v11(v3, a3);
  if ( !v12 )
  {
    v9 = v30;
    goto LABEL_15;
  }
  while ( 1 )
  {
    v14 = sub_100A5FA0(v3);
    v15 = v14;
    v16 = v14 < a3;
    v21 = v16;
    if ( v15 >= 0 )
      break;
LABEL_21:
    if ( v16 )
      goto LABEL_24;
  }
  if ( !sub_100A6FB0(v30, v12, v15, v16) )
  {
    v16 = v21;
    goto LABEL_21;
  }
  v17 = *(_DWORD *)(v3 + 16);
  v18 = sub_100A6320(v30);
  sub_100A38E0(v3, "error \"%s\" while parsing file %s\n", v18, v17);
  v15 = -15;
LABEL_24:
  sub_100A6880(v30);
  v19 = *(void (__cdecl **)(int, int))(v3 + 48);
  if ( v19 )
    v19(v3, v12);
  v20 = *(void (__cdecl **)(int, int))(v3 + 48);
  if ( v20 )
    v20(v3, v28);
  *(_DWORD *)(v3 + 8) = 0;
  if ( v15 > 0 )
    v15 = 0;
  sub_100A5F60(v3);
  if ( !v15 )
    v15 = sub_100A5F20((int *)v3);
  return v15;
}
// 10150748: using guessed type int (__cdecl *off_10150748)(int, void *, size_t);

//----- (100A4B00) --------------------------------------------------------
int __cdecl sub_100A4B00(int a1, void *a2, size_t a3)
{
  int result; // eax@1
  int v4; // ebx@1
  void *v5; // edi@4
  size_t v6; // esi@4
  int v7; // eax@6

  result = *(_DWORD *)a1;
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 8);
  if ( *(_DWORD *)(v4 + 8) < 0 )
  {
    if ( !(*(_BYTE *)(result + 12) & 1) || *(_DWORD *)(*(_DWORD *)v4 + 8) )
    {
      v6 = a3;
      v5 = a2;
    }
    else
    {
      v5 = a2;
      v6 = a3;
      if ( isspace(*(_BYTE *)a2) )
      {
        while ( v6 )
        {
          v7 = *((_BYTE *)v5 + 1);
          v5 = (char *)v5 + 1;
          --v6;
          if ( !isspace(v7) )
            return sub_100A3B50(*(_DWORD *)v4, v5, v6);
        }
      }
    }
    result = sub_100A3B50(*(_DWORD *)v4, v5, v6);
  }
  return result;
}

//----- (100A4B80) --------------------------------------------------------
int __cdecl sub_100A4B80(int *a1, const char *a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // edx@1
  int result; // eax@1
  int v7; // edi@7
  char *v8; // eax@9
  char v9; // cl@10
  int v10; // ebx@11
  int v11; // edx@11
  _BYTE *v12; // edi@11
  int v13; // ebp@11
  int v14; // eax@13
  void (__cdecl *v15)(int, _DWORD); // eax@16
  int v16; // [sp+Ch] [bp-4h]@1
  int v17; // [sp+14h] [bp+4h]@1

  v2 = *a1;
  v3 = *(_DWORD *)(*a1 + 8);
  v4 = *(_DWORD *)v3;
  v5 = *(_DWORD *)(*(_DWORD *)v3 + 24);
  result = *(_DWORD *)(v3 + 8);
  --*(_DWORD *)(v3 + 4);
  v16 = v5;
  v17 = v2;
  if ( result < 0 )
    goto LABEL_26;
  if ( result == *(_DWORD *)(v3 + 4) )
  {
    *(_DWORD *)(v3 + 8) = -1;
    sub_100A4160((void *)v4);
    result = v16;
    *(_DWORD *)v3 = v16;
    return result;
  }
  if ( result < 0 )
  {
LABEL_26:
    if ( *(_BYTE *)(v4 + 2) != 68 )
      sub_100A6260(a2);
    v7 = *(_DWORD *)(*(_DWORD *)v3 + 8);
    if ( *(_BYTE *)(v2 + 12) & 1 )
    {
      if ( v7 )
      {
        v8 = *(char **)(*(_DWORD *)v3 + 8);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = (int)&v8[-v7 - 1];
        v11 = *(_BYTE *)(v7 + v10 - 1);
        v12 = (_BYTE *)(v7 + v10 - 1);
        v13 = 0;
        if ( isspace(v11) )
        {
          do
          {
            if ( v13 >= v10 )
              break;
            *v12 = 0;
            v14 = *(v12-- - 1);
            ++v13;
          }
          while ( isspace(v14) );
          if ( v13 )
          {
            if ( v13 < v10 )
            {
              if ( *(_DWORD *)(v17 + 52) )
                (*(void (__cdecl **)(int, _DWORD, int))(v17 + 56))(v17, *(_DWORD *)(*(_DWORD *)v3 + 8), v10 - v13 + 1);
            }
            else
            {
              v15 = *(void (__cdecl **)(int, _DWORD))(v17 + 48);
              if ( v15 )
                v15(v17, *(_DWORD *)(*(_DWORD *)v3 + 8));
              *(_DWORD *)(*(_DWORD *)v3 + 8) = 0;
            }
          }
        }
      }
    }
    if ( *(_BYTE *)(*(_DWORD *)v3 + 2) == 49 )
      sub_100A62C0(v17);
    result = v16;
    *(_DWORD *)v3 = v16;
  }
  return result;
}

//----- (100A4CB0) --------------------------------------------------------
signed int __usercall sub_100A4CB0@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@1
  int v3; // eax@2
  int v4; // esi@2
  unsigned int v5; // eax@3
  void *v6; // ebx@8
  int v7; // ST18_4@10
  int v8; // ST18_4@11
  int v9; // eax@13
  _DWORD *v10; // ecx@16
  int v11; // esi@16
  signed int result; // eax@16
  int v13; // ecx@19
  int v14; // eax@19
  int v15; // ebp@19
  int v16; // ebx@19
  int i; // [sp+Ch] [bp-88h]@1
  int v18; // [sp+Ch] [bp-88h]@19
  char v19; // [sp+10h] [bp-84h]@3
  char v20; // [sp+8Fh] [bp-5h]@5

  v2 = sub_100A4710(22, *(_DWORD *)(a2 + 28));
  for ( i = v2; v2; v2 = sub_100A4710(22, v9) )
  {
    v3 = sub_100A46E0(56, 0, *(_DWORD *)(v2 + 40));
    v4 = v3;
    if ( v3 )
    {
      sub_100A5FC0(a1, *(char **)(v3 + 8), &v19, 0x80u);
      v5 = sub_100A5F80(a1);
      if ( v5 >= 0xFFFFFFC2 || !v5 )
      {
        strncpy(&v19, *(const char **)(v4 + 8), 0x80u);
        v20 = 0;
        v5 = sub_100A5F80(a1);
      }
      if ( v5 < 0xFFFFFFC2 && v5 )
      {
        sub_100A5F60(a1);
        v6 = sub_100A3A00(a1 + 28, *(_DWORD *)(a1 + 12));
        if ( v6 )
        {
          sub_100A3BF0((int)v6, &v19);
          sub_100A38C0(a1, (int)v6);
        }
        else
        {
          v7 = *(_DWORD *)(v4 + 8);
          nullsub_4();
        }
      }
      else
      {
        v8 = *(_DWORD *)(v4 + 8);
        nullsub_4();
      }
    }
    else
    {
      nullsub_4();
    }
    v9 = *(_DWORD *)(v2 + 16) - 16;
    if ( v9 == i )
      v9 = 0;
  }
  v10 = (_DWORD *)(a1 + 96);
  v11 = 0;
  result = -15;
  if ( (_DWORD *)*v10 != v10 )
    v11 = *v10 - 104;
  if ( v11 )
  {
    do
    {
      v13 = sub_100A48F0(v11, *(void **)(v11 + 16), 256);
      v14 = *(_DWORD *)(v11 + 104);
      v15 = 0;
      v18 = v13;
      v16 = v11;
      if ( v14 != *(_DWORD *)(v11 + 92) + 96 )
        v15 = v14 - 104;
      v11 = v15;
      if ( v13 )
      {
        sub_100A38E0(a1, "unable to read frame %s\n", *(_DWORD *)(v16 + 16));
        sub_100A43E0(v16);
        v13 = v18;
      }
    }
    while ( v15 );
    result = v13;
  }
  return result;
}

//----- (100A4E70) --------------------------------------------------------
int *__cdecl sub_100A4E70(int *a1, int a2, int a3, int a4)
{
  int *result; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@5
  int i; // esi@8
  int v9; // [sp+10h] [bp-8h]@9

  result = a1;
  v5 = *a1;
  v6 = *(_DWORD *)(*a1 + 8);
  ++*(_DWORD *)(v6 + 4);
  if ( *(_DWORD *)(v6 + 8) < 0 )
  {
    result = (int *)sub_100A43A0(v5, *(_DWORD *)v6, 1, a2, 0);
    *(_DWORD *)v6 = result;
    if ( ~(unsigned __int8)(*(_DWORD *)(v5 + 12) >> 2) & 1 && *((_BYTE *)result + 2) == 68 )
    {
      result = (int *)nullsub_4();
      *(_DWORD *)(v6 + 8) = *(_DWORD *)(v6 + 4) - 1;
    }
    else
    {
      v7 = result[6];
      if ( v7 )
        *((_BYTE *)result + 36) = *(_BYTE *)(v7 + 36) + 1;
      else
        *((_BYTE *)result + 36) = 0;
      for ( i = 0; i < a4; ++i )
      {
        result = (int *)sub_100A6290(*(const char **)(a3 + 8 * i), (int)&v9);
        if ( !(~(unsigned __int8)(*(_DWORD *)(v5 + 12) >> 2) & 1) || (_BYTE)v9 != 68 )
          result = (int *)sub_100A3FE0(*(_DWORD *)v6, (int)&v9, *(void **)(a3 + 8 * i + 4));
      }
    }
  }
  return result;
}

//----- (100A4F40) --------------------------------------------------------
signed int __cdecl sub_100A4F40(int *a1)
{
  int v1; // eax@1
  int v2; // eax@2
  int v3; // eax@3
  signed int result; // eax@4

  v1 = sub_100A4710(29, *a1);
  if ( v1 && (v2 = *(_DWORD *)(v1 + 28)) != 0 && (v3 = sub_100A4710(23, v2)) != 0 )
    result = sub_100A4CB0((int)a1, v3);
  else
    result = 0;
  return result;
}

//----- (100A4F90) --------------------------------------------------------
int __cdecl sub_100A4F90(int a1, char a2, const char *a3)
{
  int v3; // esi@1
  const char *v4; // edx@3
  int v5; // eax@7

  v3 = a1;
  if ( a1 )
  {
    do
    {
      if ( *(_BYTE *)v3 == a2 )
      {
        v4 = *(const char **)(v3 + 4);
        if ( a3 == v4 || a3 && v4 && !strcmp(a3, v4) )
          break;
      }
      v5 = *(_DWORD *)(v3 + 12) - 12;
      if ( v5 == a1 )
        v5 = 0;
      v3 = v5;
    }
    while ( v5 );
  }
  return v3;
}

//----- (100A5010) --------------------------------------------------------
int __cdecl sub_100A5010(int a1, int *a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@2
  int v5; // ecx@5
  _DWORD *v6; // edx@5
  int (__cdecl *v7)(int, int); // edx@6

  result = a3;
  if ( *a2 == a3 )
  {
    v4 = *(_DWORD *)(a3 + 8) - 8;
    if ( v4 == a3 )
      v4 = 0;
    *a2 = v4;
  }
  v5 = *(_DWORD *)(a3 + 8);
  v6 = *(_DWORD **)(a3 + 12);
  *(_DWORD *)(v5 + 4) = v6;
  *v6 = v5;
  if ( a1 )
  {
    v7 = *(int (__cdecl **)(int, int))(a1 + 48);
    if ( v7 )
      result = v7(a1, a3);
  }
  return result;
}

//----- (100A5050) --------------------------------------------------------
void __fastcall sub_100A5050(_DWORD *a1, int a2)
{
  int v2; // ecx@4
  int v3; // eax@4
  int *v4; // edx@4

  if ( a2 )
  {
    if ( *a1 )
    {
      v2 = *a1 + 8;
      v3 = a2 + 8;
      v4 = *(int **)(v2 + 4);
      *(_DWORD *)(v2 + 4) = v3;
      *(_DWORD *)v3 = v2;
      *(_DWORD *)(v3 + 4) = v4;
      *v4 = v3;
    }
    else
    {
      *a1 = a2;
    }
  }
}

//----- (100A5080) --------------------------------------------------------
signed int __usercall sub_100A5080@<eax>(_BYTE *a1@<edi>, int *a2@<esi>, int a3)
{
  int v3; // eax@2
  signed int result; // eax@7

  if ( a1 )
  {
    v3 = *a2;
    if ( *a2 )
    {
      while ( *(_BYTE *)v3 != *a1 )
      {
        v3 = *(_DWORD *)(v3 + 8) - 8;
        if ( v3 == *a2 )
          v3 = 0;
        if ( !v3 )
        {
          sub_100A5050(a2, (int)a1);
          return 0;
        }
      }
      sub_100A5010(a3, a2, v3);
    }
    sub_100A5050(a2, (int)a1);
    result = 0;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100A50E0) --------------------------------------------------------
int __fastcall sub_100A50E0(int a1, int a2)
{
  int result; // eax@1
  int v3; // ecx@3
  _DWORD *v4; // edx@3

  result = *(_DWORD *)(a1 + 24);
  if ( result )
  {
    v3 = result + 12;
    result = a2 + 12;
    v4 = *(_DWORD **)(v3 + 4);
    *(_DWORD *)(v3 + 4) = result;
    *(_DWORD *)result = v3;
    *(_DWORD *)(result + 4) = v4;
    *v4 = result;
  }
  else
  {
    *(_DWORD *)(a1 + 24) = a2;
  }
  return result;
}

//----- (100A5100) --------------------------------------------------------
char __cdecl sub_100A5100(_DWORD *a1, unsigned int a2)
{
  int v2; // eax@1
  char *v3; // edx@2
  int v4; // ecx@2
  char *v5; // ecx@3
  char v6; // bl@4
  _DWORD *v7; // esi@7
  unsigned int v8; // ecx@7
  int v9; // edi@11
  int v10; // ecx@12
  _BYTE *v11; // edx@12
  _BYTE *v12; // esi@12
  int v13; // ecx@14
  _BYTE *v14; // edx@14
  _BYTE *v15; // esi@14
  _BYTE *v16; // edx@16
  _BYTE *v17; // esi@16
  signed int v18; // ecx@18

  v2 = 0;
  while ( 1 )
  {
    v3 = off_101508F4[2 * v2];
    v4 = 0;
    if ( v3 )
    {
      v5 = off_101508F4[2 * v2];
      do
        v6 = *v5++;
      while ( v6 );
      v4 = v5 - (v3 + 1);
    }
    if ( v4 != a2 )
      goto LABEL_22;
    v7 = a1;
    v8 = a2;
    if ( a2 < 4 )
    {
LABEL_10:
      if ( !v8 )
        goto LABEL_20;
    }
    else
    {
      while ( *v7 == *(_DWORD *)v3 )
      {
        v8 -= 4;
        v3 += 4;
        ++v7;
        if ( v8 < 4 )
          goto LABEL_10;
      }
    }
    v9 = *(_BYTE *)v7 - (unsigned __int8)*v3;
    if ( *(_BYTE *)v7 == (unsigned __int8)*v3 )
    {
      v10 = v8 - 1;
      v11 = v3 + 1;
      v12 = (char *)v7 + 1;
      if ( !v10
        || (v9 = *v12 - *v11, *v12 == *v11)
        && ((v13 = v10 - 1, v14 = v11 + 1, v15 = v12 + 1, !v13)
         || (v9 = *v15 - *v14, *v15 == *v14)
         && ((v16 = v14 + 1, v17 = v15 + 1, v13 == 1) || (v9 = *v17 - *v16, *v17 == *v16))) )
      {
LABEL_20:
        v18 = 0;
        goto LABEL_21;
      }
    }
    v18 = 1;
    if ( v9 <= 0 )
      v18 = -1;
LABEL_21:
    if ( !v18 )
      return byte_101508F0[8 * v2];
LABEL_22:
    if ( (unsigned int)++v2 >= 1 )
      return 1;
  }
}
// 101508F4: using guessed type char *off_101508F4[2];

//----- (100A51E0) --------------------------------------------------------
int __cdecl sub_100A51E0(int a1, unsigned __int8 a2, _BYTE *a3, unsigned int a4)
{
  signed int (__cdecl *v4)(int, _BYTE *, unsigned int, int); // eax@2
  int v5; // ebx@3
  _BYTE *v6; // edx@4
  int v7; // ecx@5
  char *v8; // ecx@6
  char v9; // al@7
  _BYTE *v10; // esi@10
  unsigned int v11; // ecx@10
  int v12; // edi@14
  int v13; // ecx@15
  _BYTE *v14; // edx@15
  _BYTE *v15; // esi@15
  int v16; // ecx@17
  _BYTE *v17; // edx@17
  _BYTE *v18; // esi@17
  _BYTE *v19; // edx@19
  _BYTE *v20; // esi@19
  signed int v21; // eax@21
  int (__cdecl *v22)(int, signed int); // eax@33
  int result; // eax@34
  signed int v24; // [sp+10h] [bp-Ch]@1
  int v25; // [sp+14h] [bp-8h]@1
  int v26; // [sp+18h] [bp-4h]@3

  v24 = 0;
  LOBYTE(v25) = 9;
  if ( a2 > 4u )
    goto LABEL_30;
  v4 = (signed int (__cdecl *)(int, _BYTE *, unsigned int, int))*(&off_10150980 + 3 * a2);
  if ( v4 )
  {
    v24 = v4(a1, a3, a4, (int)&v25);
    goto LABEL_30;
  }
  v26 = *a3;
  v5 = 0;
  while ( 1 )
  {
    v6 = (_BYTE *)off_101508AC[2 * v5];
    if ( v26 != *v6 )
      goto LABEL_25;
    v7 = 0;
    if ( v6 )
    {
      v8 = (char *)off_101508AC[2 * v5];
      do
        v9 = *v8++;
      while ( v9 );
      v7 = v8 - (v6 + 1);
    }
    if ( v7 != a4 )
      goto LABEL_25;
    v10 = a3;
    v11 = a4;
    if ( a4 < 4 )
    {
LABEL_13:
      if ( !v11 )
        goto LABEL_23;
    }
    else
    {
      while ( *(_DWORD *)v10 == *(_DWORD *)v6 )
      {
        v11 -= 4;
        v6 += 4;
        v10 += 4;
        if ( v11 < 4 )
          goto LABEL_13;
      }
    }
    v12 = *v10 - *v6;
    if ( *v10 == *v6 )
    {
      v13 = v11 - 1;
      v14 = v6 + 1;
      v15 = v10 + 1;
      if ( !v13
        || (v12 = *v15 - *v14, *v15 == *v14)
        && ((v16 = v13 - 1, v17 = v14 + 1, v18 = v15 + 1, !v16)
         || (v12 = *v18 - *v17, *v18 == *v17)
         && ((v19 = v17 + 1, v20 = v18 + 1, v16 == 1) || (v12 = *v20 - *v19, *v20 == *v19))) )
      {
LABEL_23:
        v21 = 0;
        goto LABEL_24;
      }
    }
    v21 = 1;
    if ( v12 <= 0 )
      v21 = -1;
LABEL_24:
    if ( !v21 )
      break;
LABEL_25:
    if ( (unsigned int)++v5 >= 9 )
    {
      v24 = -15;
      goto LABEL_30;
    }
  }
  LOBYTE(v25) = byte_101508A8[8 * v5];
  if ( (_BYTE)v25 == 9 )
    v24 = -15;
LABEL_30:
  if ( a2 >= 5u || v24 )
  {
    nullsub_5(a3);
    result = 0;
  }
  else
  {
    if ( a1 && (v22 = *(int (__cdecl **)(int, signed int))(a1 + 52)) != 0 )
      result = v22(a1, 16);
    else
      result = 0;
    if ( result )
    {
      *(_BYTE *)result = a2;
      *(_DWORD *)(result + 2) = v25;
      *(_DWORD *)(result + 8) = result + 8;
      *(_DWORD *)(result + 12) = result + 8;
    }
  }
  return result;
}
// 100A4F80: using guessed type int __cdecl nullsub_5(_DWORD);
// 10150980: using guessed type int (__cdecl *off_10150980)(int, char, int, int);

//----- (100A5390) --------------------------------------------------------
signed int __cdecl sub_100A5390(int a1, _BYTE *a2, unsigned int a3, int a4)
{
  int v4; // ebp@1
  int v5; // ebx@1
  char *v6; // ecx@2
  int v7; // eax@3
  char *v8; // eax@4
  char v9; // dl@5
  _BYTE *v10; // edx@8
  unsigned int v11; // eax@8
  int v12; // esi@12
  int v13; // eax@13
  _BYTE *v14; // ecx@13
  _BYTE *v15; // edx@13
  int v16; // eax@15
  _BYTE *v17; // ecx@15
  _BYTE *v18; // edx@15
  _BYTE *v19; // ecx@17
  _BYTE *v20; // edx@17
  signed int v21; // eax@19
  signed int result; // eax@27
  int v23; // [sp+10h] [bp-4h]@1

  v4 = a4;
  v23 = *a2;
  *(_DWORD *)a4 = 0;
  v5 = 0;
  while ( 1 )
  {
    v6 = (&off_101508F8)[8 * v5];
    if ( v23 != (unsigned __int8)*v6 )
      goto LABEL_23;
    v7 = 0;
    if ( v6 )
    {
      v8 = (&off_101508F8)[8 * v5];
      do
        v9 = *v8++;
      while ( v9 );
      v7 = v8 - (v6 + 1);
    }
    if ( v7 != a3 )
      goto LABEL_23;
    v10 = a2;
    v11 = a3;
    if ( a3 < 4 )
    {
LABEL_11:
      if ( !v11 )
        goto LABEL_21;
    }
    else
    {
      while ( *(_DWORD *)v10 == *(_DWORD *)v6 )
      {
        v11 -= 4;
        v6 += 4;
        v10 += 4;
        if ( v11 < 4 )
          goto LABEL_11;
      }
    }
    v12 = *v10 - (unsigned __int8)*v6;
    if ( *v10 == (unsigned __int8)*v6 )
    {
      v13 = v11 - 1;
      v14 = v6 + 1;
      v15 = v10 + 1;
      if ( !v13
        || (v12 = *v15 - *v14, *v15 == *v14)
        && ((v16 = v13 - 1, v17 = v14 + 1, v18 = v15 + 1, !v16)
         || (v12 = *v18 - *v17, *v18 == *v17)
         && ((v19 = v17 + 1, v20 = v18 + 1, v16 == 1) || (v12 = *v20 - *v19, *v20 == *v19))) )
      {
LABEL_21:
        v21 = 0;
        goto LABEL_22;
      }
    }
    v21 = 1;
    if ( v12 <= 0 )
      v21 = -1;
LABEL_22:
    v4 = a4;
    if ( !v21 )
      break;
LABEL_23:
    if ( (unsigned int)++v5 >= 0x10 )
      goto LABEL_26;
  }
  *(_BYTE *)(a4 + 2) = byte_101508FC[8 * v5];
  *(_BYTE *)(a4 + 1) = byte_101508FD[8 * v5];
  *(_BYTE *)a4 = byte_101508FE[8 * v5];
  *(_BYTE *)(a4 + 3) = 1;
LABEL_26:
  if ( *(_BYTE *)(v4 + 3) )
  {
    result = 0;
  }
  else
  {
    sub_100A38E0(a1, "unknown css color %s\n", a2);
    result = -15;
  }
  return result;
}
// 101508F8: using guessed type char *off_101508F8;

//----- (100A54D0) --------------------------------------------------------
int __cdecl sub_100A54D0(int a1, char *a2, int a3, int a4)
{
  char *v4; // edi@1
  int v5; // ecx@2
  char v6; // al@6

  *(_DWORD *)a4 = 0;
  v4 = a2;
  if ( !isdigit((unsigned __int8)*a2) )
    goto LABEL_11;
  do
    v5 = (unsigned __int8)(v4++)[1];
  while ( isdigit(v5) );
  if ( v4 != a2 )
    *(_WORD *)a4 = j__atol(a2);
  else
LABEL_11:
    *(_WORD *)a4 = 0;
  v6 = sub_100A5100(v4, a3 + a2 - v4);
  *(_BYTE *)(a4 + 2) = v6;
  if ( v6 == 1 )
    *(_BYTE *)(a4 + 2) = 0;
  return 0;
}

//----- (100A5540) --------------------------------------------------------
signed int __cdecl sub_100A5540(int a1, unsigned __int8 a2, char *a3)
{
  _BYTE *v3; // eax@3
  signed int result; // eax@3

  if ( a1 && a3 )
  {
    v3 = (_BYTE *)sub_100A51E0(*(_DWORD *)(a1 + 32), a2, a3, strlen(a3));
    result = sub_100A5080(v3, (int *)(a1 + 44), *(_DWORD *)(a1 + 32));
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100A5590) --------------------------------------------------------
void __cdecl sub_100A5590(int a1, int a2)
{
  int v2; // eax@2
  int *v3; // esi@2
  void (__cdecl *v4)(int, _DWORD); // eax@6
  int v5; // eax@8
  _DWORD *v6; // ecx@8
  void (__cdecl *v7)(int, int); // eax@9

  if ( a2 )
  {
    v2 = *(_DWORD *)(a2 + 8);
    v3 = (int *)(a2 + 8);
    if ( v2 )
    {
      do
      {
        sub_100A5010(a1, (int *)(a2 + 8), v2);
        v2 = *v3;
      }
      while ( *v3 );
    }
    if ( *(_DWORD *)(a2 + 4) )
    {
      if ( a1 )
      {
        v4 = *(void (__cdecl **)(int, _DWORD))(a1 + 48);
        if ( v4 )
          v4(a1, *(_DWORD *)(a2 + 4));
      }
    }
    v5 = *(_DWORD *)(a2 + 12);
    v6 = *(_DWORD **)(a2 + 16);
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    if ( a1 )
    {
      v7 = *(void (__cdecl **)(int, int))(a1 + 48);
      if ( v7 )
        v7(a1, a2);
    }
  }
}

//----- (100A5600) --------------------------------------------------------
int __usercall sub_100A5600@<eax>(unsigned int a1@<ebx>, int a2, _BYTE *a3, _BYTE *a4, unsigned int a5)
{
  unsigned int v5; // edi@1
  char *v6; // ecx@2
  int v7; // eax@3
  char *v8; // eax@4
  char v9; // dl@5
  _BYTE *v10; // edx@8
  unsigned int v11; // eax@8
  int v12; // esi@12
  int v13; // eax@13
  _BYTE *v14; // ecx@13
  _BYTE *v15; // edx@13
  int v16; // eax@15
  _BYTE *v17; // ecx@15
  _BYTE *v18; // edx@15
  _BYTE *v19; // ecx@17
  _BYTE *v20; // edx@17
  signed int v21; // eax@19
  int v23; // [sp+Ch] [bp-8h]@1

  v23 = 0;
  v5 = 0;
  while ( 1 )
  {
    v6 = (&off_1015097C)[v5];
    if ( *a3 != (unsigned __int8)*v6 )
      goto LABEL_23;
    v7 = 0;
    if ( v6 )
    {
      v8 = (&off_1015097C)[v5];
      do
        v9 = *v8++;
      while ( v9 );
      v7 = v8 - (v6 + 1);
    }
    if ( v7 != a1 )
      goto LABEL_23;
    v10 = a3;
    v11 = a1;
    if ( a1 < 4 )
    {
LABEL_11:
      if ( !v11 )
        goto LABEL_21;
    }
    else
    {
      while ( *(_DWORD *)v10 == *(_DWORD *)v6 )
      {
        v11 -= 4;
        v6 += 4;
        v10 += 4;
        if ( v11 < 4 )
          goto LABEL_11;
      }
    }
    v12 = *v10 - (unsigned __int8)*v6;
    if ( *v10 == (unsigned __int8)*v6 )
    {
      v13 = v11 - 1;
      v14 = v6 + 1;
      v15 = v10 + 1;
      if ( !v13
        || (v12 = *v15 - *v14, *v15 == *v14)
        && ((v16 = v13 - 1, v17 = v14 + 1, v18 = v15 + 1, !v16)
         || (v12 = *v18 - *v17, *v18 == *v17)
         && ((v19 = v17 + 1, v20 = v18 + 1, v16 == 1) || (v12 = *v20 - *v19, *v20 == *v19))) )
      {
LABEL_21:
        v21 = 0;
        goto LABEL_22;
      }
    }
    v21 = 1;
    if ( v12 <= 0 )
      v21 = -1;
LABEL_22:
    if ( !v21 )
      break;
LABEL_23:
    ++v23;
    v5 += 12;
    if ( v5 >= 0x3C )
      goto LABEL_26;
  }
  if ( (unsigned __int8)byte_10150978[12 * v23] >= 5u )
  {
LABEL_26:
    nullsub_5(a3);
    return 0;
  }
  return sub_100A51E0(a2, byte_10150978[12 * v23], a4, a5);
}
// 100A4F80: using guessed type int __cdecl nullsub_5(_DWORD);
// 1015097C: using guessed type char *off_1015097C;

//----- (100A5730) --------------------------------------------------------
int __cdecl sub_100A5730(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@2

  result = a2;
  if ( a2 )
  {
    do
    {
      v3 = *(_DWORD *)(result + 12) - 12;
      if ( v3 == result )
        v3 = 0;
      sub_100A5590(a1, result);
      result = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (100A5760) --------------------------------------------------------
int __cdecl sub_100A5760(int a1, int a2, _BYTE *a3)
{
  _BYTE *v3; // esi@1
  int v4; // ecx@2
  _BYTE *v5; // ebx@3
  int v6; // eax@4
  int result; // eax@6
  int (__cdecl *v8)(int, signed int); // eax@8
  int v9; // eax@9
  int v10; // ebp@9
  int v11; // edx@12
  _BYTE *v12; // ebx@14
  int (__cdecl *v13)(int, int); // eax@19
  int v14; // edi@19
  void *v15; // eax@20
  unsigned __int8 v16; // al@25
  _BYTE *v17; // esi@28
  int v18; // eax@31
  char v19; // al@32
  _BYTE *v20; // edi@33
  signed int v21; // ebx@38
  int v22; // edx@46
  int v23; // eax@47
  char v24; // al@48
  _BYTE *j; // ebp@48
  signed int v26; // edi@53
  char v27; // al@58
  int v28; // eax@61
  int v29; // [sp+14h] [bp-8h]@9
  _BYTE *i; // [sp+18h] [bp-4h]@33

  v3 = a3;
  if ( isspace(*a3) )
  {
    do
      v4 = (v3++)[1];
    while ( isspace(v4) );
  }
  v5 = v3;
  if ( isalnum(*v3) )
  {
    do
      v6 = (v3++)[1];
    while ( isalnum(v6) );
  }
  if ( v3 == v5 )
  {
    sub_100A38E0(a1, "css rule should start with alphanum, %s\n", a3);
    return v3 - v5 - 15;
  }
  if ( !a1 )
    return -26;
  v8 = *(int (__cdecl **)(int, signed int))(a1 + 52);
  if ( !v8 )
    return -26;
  v9 = v8(a1, 20);
  v10 = v9;
  v29 = v9;
  if ( !v9 )
    return -26;
  *(_DWORD *)v9 = 0;
  *(_DWORD *)(v9 + 4) = 0;
  *(_DWORD *)(v9 + 8) = 0;
  *(_DWORD *)(v9 + 12) = 0;
  *(_DWORD *)(v9 + 12) = v9 + 12;
  *(_DWORD *)(v9 + 16) = v9 + 12;
  *(_BYTE *)v9 = sub_100A6160(v5, v3 - v5);
  if ( *v3 == 46 )
  {
    v11 = (v3++)[1];
    if ( !isalpha(v11) )
    {
      sub_100A38E0(a1, "css class should start with alpha, %s\n", a3);
LABEL_66:
      sub_100A5590(a1, v10);
      return -15;
    }
    v12 = v3;
    while ( isalnum(*v3) || *v3 == 45 || *v3 == 95 )
      ++v3;
    v13 = *(int (__cdecl **)(int, int))(a1 + 52);
    v14 = v3 - v12;
    if ( v13 )
      v15 = (void *)v13(a1, v14 + 1);
    else
      v15 = 0;
    *(_DWORD *)(v10 + 4) = v15;
    if ( !v15 )
    {
      sub_100A5590(a1, v10);
      return -26;
    }
    memcpy(v15, v12, v3 - v12);
    *(_BYTE *)(v14 + *(_DWORD *)(v10 + 4)) = 0;
  }
  v16 = *v3;
  if ( *v3 != 123 )
  {
    while ( isspace(v16) )
    {
      v16 = (v3++)[1];
      if ( v16 == 123 )
        goto LABEL_28;
    }
    sub_100A38E0(a1, "should only be spaces between element and {, %s\n", a3);
    if ( *v3 != 123 )
    {
      sub_100A38E0(a1, "css rule missing {, %s\n", a3);
      goto LABEL_66;
    }
  }
LABEL_28:
  v17 = v3 + 1;
  while ( *v17 )
  {
    if ( isspace(*v17) )
    {
      do
        v18 = (v17++)[1];
      while ( isspace(v18) );
    }
    v19 = *v17;
    if ( *v17 == 125 )
      goto LABEL_67;
    v20 = v17;
    for ( i = v17; v19 != 58; v19 = (v17++)[1] )
    {
      if ( v19 == 59 )
        break;
      if ( v19 == 125 )
        break;
      if ( !v19 )
        break;
    }
    v21 = v17 - v20;
    if ( v17 - v20 <= 0 )
      goto LABEL_41;
    while ( isspace(v20[v21 - 1]) )
    {
      if ( --v21 <= 0 )
        goto LABEL_41;
    }
    if ( v21 <= 0 || *v17 != 58 )
    {
LABEL_41:
      sub_100A38E0(a1, "invalid css property, %s\n", a3);
      goto LABEL_66;
    }
    v22 = (v17++)[1];
    if ( isspace(v22) )
    {
      do
        v23 = (v17++)[1];
      while ( isspace(v23) );
    }
    v24 = *v17;
    for ( j = v17; v24 != 58; v24 = (v17++)[1] )
    {
      if ( v24 == 59 )
        break;
      if ( v24 == 125 )
        break;
      if ( !v24 )
        break;
    }
    v26 = v17 - j;
    if ( v17 - j <= 0 )
      goto LABEL_56;
    while ( isspace(j[v26 - 1]) )
    {
      if ( --v26 <= 0 )
        goto LABEL_56;
    }
    if ( v26 <= 0 || (v27 = *v17, *v17 != 59) && v27 != 125 && v27 != 32 )
    {
LABEL_56:
      nullsub_5(a3);
      v10 = v29;
      goto LABEL_66;
    }
    v28 = sub_100A5600(v21, a1, i, j, v26);
    sub_100A5050((_DWORD *)(v29 + 8), v28);
    if ( *v17 == 59 )
      ++v17;
    v10 = v29;
  }
  if ( *v17 != 125 )
  {
    nullsub_5(a3);
    goto LABEL_66;
  }
LABEL_67:
  if ( *(_DWORD *)(v10 + 8) )
  {
    sub_100A50E0(a1, v10);
    result = 0;
  }
  else
  {
    sub_100A6120(*(_BYTE *)v10);
    nullsub_5(*(_DWORD *)(v10 + 4));
    sub_100A5590(a1, v10);
    result = 0;
  }
  return result;
}
// 100A4F80: using guessed type int __cdecl nullsub_5(_DWORD);

//----- (100A5B30) --------------------------------------------------------
signed int __cdecl sub_100A5B30(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int (__cdecl *v4)(int, signed int); // eax@2
  int v5; // esi@3
  int (__cdecl *v6)(int, signed int); // eax@4
  void (__cdecl *v7)(int, int); // eax@6
  _BYTE *v9; // esi@9
  int v10; // ebp@9
  int v11; // edx@14
  int v12; // eax@15
  int v13; // ebx@25
  void (__cdecl *v14)(int, _BYTE *); // eax@41
  void (__cdecl *v15)(int, _BYTE *); // eax@43
  int v16; // ebp@46
  unsigned int v17; // [sp+Ch] [bp-14h]@9
  signed int v18; // [sp+10h] [bp-10h]@9
  int v19; // [sp+14h] [bp-Ch]@9
  _BYTE *v20; // [sp+18h] [bp-8h]@5
  _BYTE *v21; // [sp+1Ch] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( !a1 )
    return -26;
  v4 = *(int (__cdecl **)(int, signed int))(a1 + 52);
  if ( !v4 )
    return -26;
  v5 = v4(a1, 128);
  v21 = (_BYTE *)v5;
  if ( !v5 )
    return -26;
  v6 = *(int (__cdecl **)(int, signed int))(a1 + 52);
  if ( !v6 || (v20 = (_BYTE *)v6(a1, 129)) == 0 )
  {
    v7 = *(void (__cdecl **)(int, int))(a1 + 48);
    if ( v7 )
      v7(a1, v5);
    return -26;
  }
  v9 = (_BYTE *)a1;
  v10 = 0;
  v18 = 0;
  v19 = 1;
  v17 = 2;
  do
  {
    if ( v3 <= 0 )
    {
      v9 = v21;
      v19 = sub_100A5FA0(v2);
      v3 = v19;
      continue;
    }
    if ( v17 & 2 )
    {
      if ( isspace(*v9) )
      {
        do
        {
          v11 = v3--;
          if ( v11 <= 0 )
            break;
          v12 = (v9++)[1];
        }
        while ( isspace(v12) );
      }
      if ( v3 <= 0 )
        continue;
      v17 &= 0xFFFFFFFD;
    }
    if ( !(v17 & 1) )
    {
      v13 = *v9;
      if ( v13 == 42 )
      {
        if ( v10 == 47 )
        {
          v17 |= 1u;
          goto LABEL_37;
        }
      }
      else
      {
        if ( *v9 == 123 )
        {
          v17 |= 6u;
          v20[v18++] = 123;
          goto LABEL_37;
        }
        if ( *v9 != 125 )
        {
          if ( !isalnum(*v9) && v13 != 46 && v13 != 45 && v13 != 95 && v13 != 58 && v13 != 59 )
          {
            if ( v13 == 47 )
              goto LABEL_37;
            nullsub_5(v13);
            goto LABEL_36;
          }
          do
          {
            v20[v18] = v13;
            v13 = (v9++)[1];
            v16 = v18++ + 1;
            --v3;
          }
          while ( (isalnum(v13) || v13 == 46 || v13 == 45 || v13 == 95 || v13 == 58 || v13 == 59) && v3 && v16 < 128 );
          ++v3;
          --v9;
          v17 |= 2u;
LABEL_37:
          if ( v18 >= 128 )
          {
            nullsub_5(v20);
            v19 = -15;
          }
          goto LABEL_39;
        }
        v20[v18] = 125;
        if ( v17 & 4 )
        {
          v20[v18 + 1] = 0;
          sub_100A5760(a1, a2, v20);
          v18 = 0;
          v17 = 2;
LABEL_39:
          --v3;
          v10 = v13;
          v2 = a1;
          ++v9;
          continue;
        }
        sub_100A6070(a1, (int)"found } with no {, %s\n", (char)v21);
      }
LABEL_36:
      v19 = -15;
      goto LABEL_37;
    }
    do
    {
      if ( v10 == 42 && *v9 == 47 )
        goto LABEL_24;
      v10 = *v9;
      --v3;
      ++v9;
    }
    while ( v3 > 0 );
    if ( v10 == 42 && *v9 == 47 )
    {
LABEL_24:
      v10 = *v9++;
      --v3;
      v17 = v17 & 0xFFFFFFFE | 2;
    }
  }
  while ( v19 > 0 );
  v14 = *(void (__cdecl **)(int, _BYTE *))(v2 + 48);
  if ( v14 )
    v14(v2, v21);
  v15 = *(void (__cdecl **)(int, _BYTE *))(v2 + 48);
  if ( v15 )
    v15(v2, v20);
  return v19;
}
// 100A4F80: using guessed type int __cdecl nullsub_5(_DWORD);

//----- (100A5E30) --------------------------------------------------------
signed int __cdecl sub_100A5E30(int a1, int a2)
{
  int v2; // ebx@3
  unsigned int v3; // eax@6
  unsigned int v4; // esi@6
  int v5; // ST0C_4@8
  signed int v6; // ebx@11
  signed int result; // eax@11

  if ( *(_BYTE *)a2 != 1 || *(_BYTE *)(a2 + 2) != 35 )
  {
    result = 0;
  }
  else
  {
    v2 = sub_100A46E0(26, 0, *(_DWORD *)(a2 + 40));
    if ( v2
      && sub_100A46E0(47, "stylesheet", *(_DWORD *)(a2 + 40))
      && sub_100A46E0(64, "text/css", *(_DWORD *)(a2 + 40)) )
    {
      v3 = sub_100A6090(a1, *(char **)(v2 + 8), 1);
      v4 = v3;
      if ( v3 >= 0xFFFFFFC2 || !v3 )
      {
        v5 = *(_DWORD *)(v2 + 8);
        v4 = sub_100A5F80(a1);
      }
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        v6 = sub_100A5B30(a1, a2);
        sub_100A5F60(a1);
        result = v6;
      }
      else
      {
        sub_100A38E0(a1, "unable to open external css %s\n", *(_DWORD *)(v2 + 8));
        result = -15;
      }
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (100A5F20) --------------------------------------------------------
int __cdecl sub_100A5F20(int *a1)
{
  return sub_100A4810((int)a1, *a1, sub_100A5E30);
}

//----- (100A5F40) --------------------------------------------------------
unsigned int __usercall sub_100A5F40@<eax>(const char *a1@<eax>)
{
  unsigned int result; // eax@2

  if ( a1 )
    result = strlen(a1);
  else
    result = 0;
  return result;
}

//----- (100A5F60) --------------------------------------------------------
void __cdecl sub_100A5F60(int a1)
{
  void (*v1)(void); // eax@2

  if ( a1 )
  {
    v1 = *(void (**)(void))(a1 + 28);
    if ( v1 )
      v1();
  }
}

//----- (100A5F80) --------------------------------------------------------
int __cdecl sub_100A5F80(int a1)
{
  int (*v1)(void); // eax@2
  int result; // eax@3

  if ( a1 && (v1 = *(int (**)(void))(a1 + 32)) != 0 )
    result = v1();
  else
    result = 0;
  return result;
}

//----- (100A5FA0) --------------------------------------------------------
int __cdecl sub_100A5FA0(int a1)
{
  int (*v1)(void); // eax@2
  int result; // eax@3

  if ( a1 && (v1 = *(int (**)(void))(a1 + 40)) != 0 )
    result = v1();
  else
    result = -15;
  return result;
}

//----- (100A5FC0) --------------------------------------------------------
int __cdecl sub_100A5FC0(int a1, char *a2, char *a3, size_t a4)
{
  const char *v4; // eax@4
  signed int v5; // eax@8
  char v6; // cl@9
  int result; // eax@13

  if ( a3 )
    *a3 = 0;
  if ( a1 && (v4 = *(const char **)(a1 + 16)) != 0 && a2 && a3 && (signed int)a4 > 0 )
  {
    strncpy(a3, v4, a4);
    a3[a4 - 1] = 0;
    v5 = sub_100A5F40(a3);
    if ( v5 >= (signed int)(a4 - 1) )
      goto LABEL_18;
    while ( 1 )
    {
      v6 = a3[v5 - 1];
      if ( v6 == 47 || v6 == 92 )
        break;
      --v5;
    }
    a3[v5] = 0;
    strncat(a3, a2, a4 - v5);
    a3[a4 - 1] = 0;
    if ( (signed int)sub_100A5F40(a3) < (signed int)(a4 - 1) )
    {
      result = 0;
    }
    else
    {
LABEL_18:
      *a3 = 0;
      result = -26;
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100A6070) --------------------------------------------------------
void __cdecl sub_100A6070(int a1, int a2, char a3)
{
  void (__cdecl *v3)(int, int, char *); // eax@2

  if ( a1 )
  {
    v3 = *(void (__cdecl **)(int, int, char *))(a1 + 44);
    if ( v3 )
      v3(a1, a2, &a3);
  }
}

//----- (100A6090) --------------------------------------------------------
int __cdecl sub_100A6090(int a1, char *a2, int a3)
{
  int result; // eax@3
  char v4; // [sp+4h] [bp-84h]@3

  if ( a1 && *(_DWORD *)(a1 + 32) )
  {
    sub_100A5FC0(a1, a2, &v4, 0x80u);
    result = (*(int (__cdecl **)(int, char *, int))(a1 + 32))(a1, &v4, a3);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100A6120) --------------------------------------------------------
char *__cdecl sub_100A6120(unsigned __int8 a1)
{
  unsigned __int8 v1; // al@1

  v1 = a1;
  if ( a1 > 0x44u )
    v1 = 68;
  return (char *)off_10150E30[3 * v1];
}

//----- (100A6140) --------------------------------------------------------
int __cdecl sub_100A6140(char a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_BYTE *)a2 = a1;
  *(_DWORD *)(a2 + 4) = 0;
  return result;
}

//----- (100A6160) --------------------------------------------------------
char __cdecl sub_100A6160(_BYTE *a1, unsigned int a2)
{
  _BYTE *v2; // esi@1
  unsigned int v3; // ebp@2
  _DWORD *v4; // ebx@4
  _DWORD *v5; // edx@6
  unsigned int v6; // ecx@6
  int v7; // eax@10
  int v8; // edi@10
  int v9; // ecx@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  int v12; // eax@12
  int v13; // ecx@13
  _BYTE *v14; // edx@13
  _BYTE *v15; // esi@13
  int v16; // eax@14
  _BYTE *v17; // edx@15
  _BYTE *v18; // esi@15
  signed int v19; // ecx@17
  char v21; // [sp+10h] [bp-8h]@4
  _BYTE *v22; // [sp+14h] [bp-4h]@2

  v2 = a1;
  if ( a1 )
  {
    v3 = a2;
    v22 = (_BYTE *)*a1;
  }
  else
  {
    v22 = a1;
    v3 = 0;
  }
  v21 = 0;
  v4 = off_10150E30;
  while ( 1 )
  {
    if ( v3 != v4[1] )
      goto LABEL_22;
    v5 = (_DWORD *)*v4;
    v6 = v3;
    if ( v3 < 4 )
    {
LABEL_9:
      if ( !v6 )
        goto LABEL_19;
    }
    else
    {
      while ( *(_DWORD *)v2 == *v5 )
      {
        v6 -= 4;
        ++v5;
        v2 += 4;
        if ( v6 < 4 )
          goto LABEL_9;
      }
    }
    v7 = *(_BYTE *)v5;
    v8 = *v2 - v7;
    if ( *v2 == v7 )
    {
      v9 = v6 - 1;
      v10 = (char *)v5 + 1;
      v11 = v2 + 1;
      if ( !v9
        || (v12 = *v10, v8 = *v11 - v12, *v11 == v12)
        && ((v13 = v9 - 1, v14 = v10 + 1, v15 = v11 + 1, !v13)
         || (v16 = *v14, v8 = *v15 - v16, *v15 == v16)
         && ((v17 = v14 + 1, v18 = v15 + 1, v13 == 1) || (v8 = *v18 - *v17, *v18 == *v17))) )
      {
LABEL_19:
        v19 = 0;
        goto LABEL_20;
      }
    }
    v19 = 1;
    if ( v8 <= 0 )
      v19 = -1;
LABEL_20:
    if ( !v19 )
      return v21;
    v2 = a1;
LABEL_22:
    if ( (signed int)v22 >= *(_BYTE *)*v4 )
    {
      ++v21;
      v4 += 3;
      if ( (signed int)v4 <= (signed int)&off_10151154 )
        continue;
    }
    return 68;
  }
}
// 10151154: using guessed type char *off_10151154;

//----- (100A6260) --------------------------------------------------------
char __cdecl sub_100A6260(const char *a1)
{
  unsigned int v1; // eax@1

  v1 = 0;
  if ( a1 )
    v1 = strlen(a1);
  return sub_100A6160(a1, v1);
}

//----- (100A6290) --------------------------------------------------------
int __cdecl sub_100A6290(const char *a1, int a2)
{
  int result; // eax@1

  LOBYTE(result) = sub_100A6260(a1);
  *(_BYTE *)a2 = result;
  *(_DWORD *)(a2 + 4) = (_BYTE)result != 68 ? 0 : (unsigned int)a1;
  return result;
}

//----- (100A62C0) --------------------------------------------------------
int __cdecl sub_100A62C0(int a1)
{
  int (*v1)(void); // eax@2
  int result; // eax@3

  if ( a1 && (v1 = *(int (**)(void))(a1 + 68)) != 0 )
    result = v1();
  else
    result = 0;
  return result;
}

//----- (100A62E0) --------------------------------------------------------
int __cdecl sub_100A62E0(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_DWORD *)(a1 + 68) )
    result = (*(int (**)(void))(a1 + 60))();
  return result;
}

//----- (100A6300) --------------------------------------------------------
void __cdecl sub_100A6300(int a1)
{
  void (*v1)(void); // eax@2

  if ( a1 )
  {
    v1 = *(void (**)(void))(a1 + 64);
    if ( v1 )
      v1();
  }
}

//----- (100A6320) --------------------------------------------------------
int __cdecl sub_100A6320(int a1)
{
  return *(_DWORD *)(a1 + 12) + 13;
}

//----- (100A6330) --------------------------------------------------------
_BYTE *__cdecl sub_100A6330(int a1)
{
  int v1; // esi@1
  int v2; // eax@3
  int v3; // ebp@3
  unsigned __int16 v4; // bx@3
  void *v5; // edi@3
  _BYTE *result; // eax@3
  int v7; // [sp+8h] [bp+4h]@3

  v1 = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      v2 = *(_DWORD *)(a1 + 12);
      v3 = *(_DWORD *)(v2 + 104);
      v4 = *(_WORD *)(v2 + 8);
      v5 = *(void **)(v2 + 4);
      v7 = *(_DWORD *)(v2 + 96);
      memset(v5, 0, v4);
      memset(*(void **)(v1 + 12), 0, 0x7Cu);
      *(_DWORD *)(*(_DWORD *)(v1 + 12) + 96) = v7;
      *(_DWORD *)(*(_DWORD *)(v1 + 12) + 104) = v3;
      *(_DWORD *)(*(_DWORD *)(v1 + 12) + 4) = v5;
      *(_WORD *)(*(_DWORD *)(v1 + 12) + 8) = v4;
      *(_WORD *)(*(_DWORD *)(v1 + 12) + 10) = v4;
      result = *(_BYTE **)(v1 + 12);
      *result = 4;
    }
  }
  return result;
}

//----- (100A63B0) --------------------------------------------------------
int sub_100A63B0(int arg0, char *arg4, ...)
{
  int v2; // esi@1
  int result; // eax@1
  va_list va; // [sp+10h] [bp+Ch]@1

  va_start(va, arg4);
  v2 = *(_DWORD *)(arg0 + 12);
  result = v2 + 13;
  if ( !*(_BYTE *)(v2 + 13) )
  {
    result = _vsnprintf((char *)(v2 + 13), 0x50u, arg4, va);
    if ( result < 0 || result == 80 )
      *(_BYTE *)(v2 + 92) = 0;
    if ( *(_BYTE *)v2 )
    {
      *(_BYTE *)(v2 + 1) |= 2u;
      *(_BYTE *)v2 = 0;
    }
  }
  return result;
}

//----- (100A6400) --------------------------------------------------------
void *__cdecl sub_100A6400(int a1)
{
  int v1; // esi@1
  _BYTE *v2; // ebp@1
  int v3; // edi@1
  void *result; // eax@2
  int v5; // ebx@5

  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(_BYTE **)(v1 + 116);
  v3 = *(_DWORD *)(v1 + 120);
  if ( *(_BYTE *)(v1 + 1) & 2 )
  {
    memset(*(void **)(v1 + 4), 0, *(_WORD *)(v1 + 10));
    result = 0;
    *(_BYTE *)(v1 + 1) &= 0xFDu;
  }
  else
  {
    result = (void *)strlen(*(const char **)(v1 + 4));
  }
  if ( v3 <= 0 )
  {
LABEL_10:
    --v3;
LABEL_11:
    *(_DWORD *)(v1 + 120) = v3;
    *(_DWORD *)(v1 + 116) = v2;
    return result;
  }
  while ( 1 )
  {
    v5 = *v2;
    --v3;
    ++v2;
    if ( v5 == 60 )
      break;
    if ( (signed int)result >= *(_WORD *)(v1 + 10) )
    {
      if ( *(_DWORD *)(v1 + 100) )
      {
        (**(void (__cdecl ***)(int, _DWORD, void *))(a1 + 8))(a1, *(_DWORD *)(v1 + 4), result);
        memset(*(void **)(v1 + 4), 0, *(_WORD *)(v1 + 10));
        result = 0;
      }
    }
    *((_BYTE *)result + *(_DWORD *)(v1 + 4)) = v5;
    result = (char *)result + 1;
    if ( v3 <= 0 )
      goto LABEL_10;
  }
  if ( *(_BYTE *)v1 )
  {
    *(_BYTE *)(v1 + 1) |= 2u;
    *(_BYTE *)v1 = 3;
  }
  if ( (signed int)result <= 0 || !*(_DWORD *)(v1 + 100) )
    goto LABEL_11;
  (**(void (__cdecl ***)(int, _DWORD, void *))(a1 + 8))(a1, *(_DWORD *)(v1 + 4), result);
  result = memset(*(void **)(v1 + 4), 0, *(_WORD *)(v1 + 10));
  *(_DWORD *)(v1 + 120) = v3;
  *(_DWORD *)(v1 + 116) = v2;
  return result;
}

//----- (100A6500) --------------------------------------------------------
signed int __usercall sub_100A6500@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // edx@2

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(v1 + 108) = 0;
  result = 0;
  if ( *(_WORD *)(a1 + 4) )
  {
    do
    {
      v3 = *(_DWORD *)(v1 + 104) + 8 * result;
      *(_DWORD *)v3 = 0;
      *(_DWORD *)(v3 + 4) = 0;
      ++result;
    }
    while ( result < *(_WORD *)(a1 + 4) );
  }
  return result;
}

//----- (100A6530) --------------------------------------------------------
_BYTE *__usercall sub_100A6530@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  _BYTE *v2; // ebp@1
  int v3; // esi@1
  _BYTE *result; // eax@2
  int v5; // ecx@5
  bool v6; // zf@5

  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(_BYTE **)(v1 + 116);
  v3 = *(_DWORD *)(v1 + 120);
  if ( *(_BYTE *)(v1 + 1) & 2 )
  {
    memset(*(void **)(v1 + 4), 0, *(_WORD *)(v1 + 10));
    result = 0;
    *(_BYTE *)(v1 + 1) &= 0xFDu;
  }
  else
  {
    result = (_BYTE *)strlen(*(const char **)(v1 + 4));
  }
  if ( v3 <= 0 )
  {
LABEL_9:
    *(_DWORD *)(v1 + 120) = v3 - 1;
    *(_DWORD *)(v1 + 116) = v2;
    return result;
  }
  while ( 1 )
  {
    v5 = *v2;
    --v3;
    ++v2;
    v6 = result == (_BYTE *)2;
    if ( (signed int)result < 2 )
    {
      if ( v5 == 45 )
      {
        (result++)[*(_DWORD *)(v1 + 4)] = 45;
        goto LABEL_8;
      }
      v6 = result == (_BYTE *)2;
    }
    if ( v6 && v5 == 62 )
      break;
    result = 0;
    **(_BYTE **)(v1 + 4) = 0;
    if ( v3 <= 0 )
      goto LABEL_9;
    while ( *v2 != 45 )
    {
      --v3;
      ++v2;
      if ( v3 <= 0 )
      {
        *(_DWORD *)(v1 + 120) = v3 - 1;
        *(_DWORD *)(v1 + 116) = v2;
        return result;
      }
    }
LABEL_8:
    if ( v3 <= 0 )
      goto LABEL_9;
  }
  if ( *(_BYTE *)v1 )
  {
    *(_BYTE *)(v1 + 1) |= 2u;
    *(_BYTE *)v1 = 4;
  }
  result = *(_BYTE **)(v1 + 4);
  *result = 0;
  *(_DWORD *)(v1 + 120) = v3;
  *(_DWORD *)(v1 + 116) = v2;
  return result;
}

//----- (100A65F0) --------------------------------------------------------
char __usercall sub_100A65F0@<al>(int a1@<eax>, _BYTE *a2@<ecx>)
{
  _BYTE *v2; // ebx@1
  int v3; // edi@1
  int v4; // esi@3
  int v5; // edi@6
  _BYTE *v6; // ebx@7
  int v7; // esi@8
  char result; // al@15

  v2 = a2;
  v3 = a1;
  if ( !a2 )
    goto LABEL_21;
  if ( !a1 )
    goto LABEL_21;
  v4 = *a2;
  if ( !isalpha(v4) && v4 != 95 && v4 != 58 )
    goto LABEL_21;
  v5 = v3 - 1;
  if ( v5 <= 0 )
    goto LABEL_22;
  v6 = v2 + 1;
  while ( 1 )
  {
    v7 = *v6;
    if ( !isalpha(v7) && v7 != 95 && v7 != 58 && !isdigit(v7) && v7 != 45 && v7 != 46 )
      break;
    --v5;
    ++v6;
    if ( v5 <= 0 )
      return 1;
  }
  if ( v5 <= 0 )
LABEL_22:
    result = 1;
  else
LABEL_21:
    result = 0;
  return result;
}

//----- (100A6680) --------------------------------------------------------
int __usercall sub_100A6680@<eax>(int a1@<eax>, int a2)
{
  int v2; // ecx@1
  char **v3; // esi@1
  char *v4; // eax@1
  char v5; // dl@2
  int result; // eax@3

  v2 = *(_DWORD *)(a1 + 12);
  v3 = (char **)(*(_DWORD *)(v2 + 96) + 4 * a2);
  v4 = *v3;
  do
    v5 = *v4++;
  while ( v5 );
  result = v4 - (*v3 + 1) + 1;
  *(_WORD *)(v2 + 10) += result;
  *v3 = 0;
  --*(_DWORD *)(v2 + 100);
  return result;
}

//----- (100A66C0) --------------------------------------------------------
int __fastcall sub_100A66C0(int a1, int a2)
{
  int result; // eax@1
  int v3; // ecx@1

  result = *(_DWORD *)(a2 + 12);
  v3 = *(_DWORD *)(result + 100) - 1;
  if ( v3 >= 0 )
    result = (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a2 + 8) + 8))(
               a2,
               *(_DWORD *)(*(_DWORD *)(result + 96) + 4 * v3),
               *(_DWORD *)(result + 104),
               *(_DWORD *)(result + 108));
  return result;
}

//----- (100A66F0) --------------------------------------------------------
void *__usercall sub_100A66F0@<eax>(int a1@<eax>, size_t a2@<ebx>, void *a3)
{
  int v3; // edi@1
  void *result; // eax@2
  unsigned __int16 v5; // ax@3
  void *v6; // esi@3

  v3 = *(_DWORD *)(a1 + 12);
  if ( (signed int)(a2 + 1) <= *(_WORD *)(v3 + 10) )
  {
    v5 = *(_WORD *)(v3 + 10) - a2 - 1;
    v6 = (void *)(*(_DWORD *)(v3 + 4) + v5);
    *(_WORD *)(v3 + 10) = v5;
    memcpy_0(v6, a3, a2);
    *((_BYTE *)v6 + a2) = 0;
    ++*(_DWORD *)(v3 + 100);
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100A6740) --------------------------------------------------------
int __usercall sub_100A6740@<eax>(int result@<eax>)
{
  int v1; // esi@1
  _BYTE *v2; // ebp@1
  int v3; // edi@1
  bool v4; // zf@8

  v1 = *(_DWORD *)(result + 12);
  v2 = *(_BYTE **)(v1 + 116);
  v3 = *(_DWORD *)(v1 + 120);
  if ( *(_BYTE *)(v1 + 1) & 2 )
  {
    result = sub_100A6680(result, *(_DWORD *)(v1 + 100) - 1);
    *(_BYTE *)(v1 + 1) &= 0xFDu;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      result = *v2;
      --v3;
      ++v2;
      if ( result == 62 )
        break;
      if ( !v3 )
        goto LABEL_6;
    }
    v4 = *(_BYTE *)v1 == 0;
    *(_DWORD *)(v1 + 112) = 0;
    *(_DWORD *)(v1 + 116) = v2;
    *(_DWORD *)(v1 + 120) = v3;
    if ( !v4 )
    {
      *(_BYTE *)(v1 + 1) |= 2u;
      *(_BYTE *)v1 = 4;
    }
  }
  else
  {
LABEL_6:
    *(_DWORD *)(v1 + 116) = v2;
    *(_DWORD *)(v1 + 120) = v3 - 1;
  }
  return result;
}

//----- (100A67B0) --------------------------------------------------------
int __cdecl sub_100A67B0(int a1)
{
  int v1; // ebx@1
  size_t v2; // ebp@1
  int v3; // esi@5
  int v4; // ebx@5
  int v5; // eax@5
  int v6; // edx@5
  int v7; // ecx@5
  int v8; // eax@5
  int result; // eax@6

  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(_WORD *)(a1 + 16);
  if ( v1 && !(v1 & 3) && *(_WORD *)(a1 + 6) && v2 >= 0xB4 )
  {
    memset((void *)v1, 0, v2);
    v3 = v1;
    *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 6) = *(_WORD *)(a1 + 6);
    v4 = v1 + 16;
    *(_DWORD *)(v3 + 12) = v4;
    v4 += 124;
    *(_DWORD *)(*(_DWORD *)(v3 + 12) + 96) = v4;
    v5 = *(_WORD *)(v3 + 6);
    v6 = v4 + 4 * v5;
    *(_DWORD *)(*(_DWORD *)(v3 + 12) + 104) = v6;
    v7 = 8 * *(_WORD *)(v3 + 4);
    v8 = v2 + 4 * (-35 - v5) - v7;
    *(_DWORD *)(*(_DWORD *)(v3 + 12) + 4) = v6 + v7;
    *(_WORD *)(*(_DWORD *)(v3 + 12) + 8) = v8;
    *(_WORD *)(*(_DWORD *)(v3 + 12) + 10) = v8;
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)v3 = *(_DWORD *)a1;
    if ( v8 >= 20 )
    {
      sub_100A6330(v3);
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100A6880) --------------------------------------------------------
int __cdecl sub_100A6880(int a1)
{
  int result; // eax@2

  if ( a1 )
  {
    sub_100A6500(a1);
    result = 0;
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  return result;
}

//----- (100A68A0) --------------------------------------------------------
int __usercall sub_100A68A0@<eax>(int a1@<edi>)
{
  int result; // eax@1
  int v2; // esi@1

  result = *(_DWORD *)(a1 + 12);
  v2 = *(_DWORD *)(result + 100) - 1;
  if ( v2 >= 0 )
  {
    (*(void (__cdecl **)(int, _DWORD))(*(_DWORD *)(a1 + 8) + 4))(a1, *(_DWORD *)(*(_DWORD *)(result + 96) + 4 * v2));
    result = sub_100A6680(a1, v2);
  }
  return result;
}

//----- (100A68D0) --------------------------------------------------------
char __cdecl sub_100A68D0(int a1)
{
  int v1; // ebx@1
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int j; // edi@1
  int v5; // eax@2
  int v6; // ecx@2
  _BYTE *v7; // ebp@3
  _BYTE *v8; // esi@12
  signed int v9; // eax@25
  char v10; // al@33
  int v12; // [sp+10h] [bp-Ch]@1
  signed int i; // [sp+10h] [bp-Ch]@12
  _BYTE *v14; // [sp+14h] [bp-8h]@1
  int v15; // [sp+18h] [bp-4h]@12

  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(_BYTE **)(v1 + 116);
  v3 = 0;
  j = *(_DWORD *)(v1 + 120);
  v12 = 0;
  v14 = *(_BYTE **)(v1 + 116);
  if ( *(_BYTE *)(v1 + 1) & 2 )
  {
    sub_100A6500(a1);
    LOBYTE(v5) = (unsigned int)memset(*(void **)(v1 + 4), 0, *(_WORD *)(v1 + 10));
    v2 = v14;
    *(_BYTE *)(v1 + 1) &= 0xFDu;
  }
  else
  {
    v7 = *(_BYTE **)(v1 + 4);
    v6 = (int)(v7 + 1);
    do
      LOBYTE(v5) = *v7++;
    while ( (_BYTE)v5 );
    v3 = (int)&v7[-v6];
  }
  if ( j )
  {
    while ( 1 )
    {
      v5 = *v2;
      --j;
      ++v2;
      v12 = v5;
      if ( v5 == 62 )
        break;
      v5 = *(_DWORD *)(v1 + 4);
      if ( v3 >= *(_WORD *)(v1 + 10) )
      {
        *(_BYTE *)(*(_WORD *)(v1 + 10) + v5 - 1) = 0;
        LOBYTE(v5) = sub_100A63B0(a1, "not enough memory for attributes %s\n", *(_DWORD *)(v1 + 4));
        break;
      }
      LOBYTE(v6) = v12;
      *(_BYTE *)(v5 + v3++) = v12;
      if ( !j )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    --j;
  }
  *(_DWORD *)(v1 + 116) = v2;
  *(_DWORD *)(v1 + 120) = j;
  if ( v12 == 62 )
  {
    v8 = *(_BYTE **)(v1 + 4);
    v5 = 0;
    v15 = v3;
    for ( i = 0; v3 > 0; ++i )
    {
      switch ( v5 )
      {
        case 0:
        case 2:
        case 4:
          for ( ; v3 > 0; ++v8 )
          {
            if ( !isspace(*v8) )
              break;
            --v3;
          }
          goto LABEL_45;
        case 1:
          for ( j = 0; v3 > 0; ++j )
          {
            if ( isspace(v8[j]) )
              break;
            if ( v8[j] == 61 )
              break;
            --v3;
          }
          if ( !sub_100A65F0(j, v8) )
          {
            sub_100A63B0(a1, "invalid attribute name %s\n", v8);
            v3 = -1;
            j = 0;
          }
          v9 = *(_DWORD *)(v1 + 108);
          if ( v9 >= *(_WORD *)(a1 + 4) )
          {
            sub_100A63B0(a1, "too many attributes %s\n", *(_DWORD *)(v1 + 4));
            v3 = -1;
            v14 = &unk_100C4192;
            goto LABEL_49;
          }
          v6 = *(_DWORD *)(v1 + 104);
          v14 = v8;
          *(_DWORD *)(v6 + 8 * v9) = v8;
          v8 += j;
          goto LABEL_46;
        case 3:
          if ( v3 <= 0 || *v8 != 61 )
          {
            sub_100A63B0(a1, "expected = after attribute %s\n", v14);
            v3 = -1;
          }
          v6 = (int)v14;
          ++v8;
          v14[j] = 0;
          --v3;
          goto LABEL_49;
        case 5:
          if ( v3 <= 0 || (v10 = *v8, *v8 != 34) && v10 != 39 )
          {
            sub_100A63B0(a1, "expected \" or ' after attribute %s\n", *(_DWORD *)(v1 + 4));
            ++v8;
            v3 = -2;
          }
          else
          {
            ++v8;
            *(_BYTE *)(v1 + 12) = v10;
            --v3;
          }
          goto LABEL_49;
        case 6:
          j = 0;
          if ( v3 <= 0 )
            goto LABEL_40;
          break;
        default:
          sub_100A63B0(a1, "unexpected condition parsing attributes %s\n", *(_DWORD *)(v1 + 4));
          v3 = -1;
LABEL_45:
          if ( i <= 1 )
            goto LABEL_46;
          goto LABEL_49;
      }
      while ( 1 )
      {
        --v3;
        if ( v8[j] == *(_BYTE *)(v1 + 12) )
          break;
        ++j;
        if ( v3 <= 0 )
        {
LABEL_40:
          --v3;
          break;
        }
      }
      if ( j )
      {
        v6 = *(_DWORD *)(v1 + 108);
        *(_DWORD *)(*(_DWORD *)(v1 + 104) + 8 * v6 + 4) = v8;
        v8[j] = 0;
      }
      ++*(_DWORD *)(v1 + 108);
      v8 += j + 1;
      i = -1;
LABEL_46:
      if ( v3 == 1 && *v8 == 47 )
        v3 = 0;
LABEL_49:
      v5 = i + 1;
    }
    if ( *(_BYTE *)v1 )
    {
      *(_BYTE *)(v1 + 1) |= 2u;
      *(_BYTE *)v1 = 4;
      sub_100A66C0(v6, a1);
      LOBYTE(v5) = v15;
      if ( v15 )
      {
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 4) + v15 - 1) == 47 )
          LOBYTE(v5) = sub_100A68A0(a1);
      }
    }
  }
  return v5;
}

//----- (100A6BC0) --------------------------------------------------------
_BYTE *__cdecl sub_100A6BC0(int a1)
{
  int v1; // esi@1
  int v2; // ebx@1
  signed int v3; // edi@2
  int v4; // ebx@5
  const char *v5; // eax@13
  _BYTE *result; // eax@17
  int v7; // ebp@21
  const char *v8; // ebp@27
  unsigned int v9; // ecx@28
  _DWORD *v10; // eax@28
  const char *v11; // edx@28
  int v12; // edi@32
  int v13; // ecx@33
  _BYTE *v14; // edx@33
  _BYTE *v15; // eax@33
  int v16; // ecx@35
  _BYTE *v17; // edx@35
  _BYTE *v18; // eax@35
  _BYTE *v19; // edx@37
  _BYTE *v20; // eax@37
  signed int v21; // eax@39
  const char **v22; // eax@51
  char v23; // al@55
  int v24; // [sp+10h] [bp-8h]@1
  _BYTE *v25; // [sp+14h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(_DWORD *)(v1 + 120);
  v25 = *(_BYTE **)(v1 + 116);
  v24 = *(_DWORD *)(v1 + 120);
  if ( *(_BYTE *)(v1 + 1) & 2 )
  {
    memset(*(void **)(v1 + 4), 0, *(_WORD *)(v1 + 10));
    v3 = 0;
    *(_BYTE *)(v1 + 1) &= 0xFDu;
  }
  else
  {
    v3 = strlen(*(const char **)(v1 + 4));
  }
  if ( !v2 )
  {
LABEL_16:
    --v24;
    goto LABEL_17;
  }
  while ( 1 )
  {
    v4 = *v25;
    --v24;
    ++v25;
    if ( isspace(v4) )
    {
      if ( !v3 || **(_BYTE **)(v1 + 4) != 47 )
        break;
    }
    if ( v4 == 62 || v4 == 47 && v3 > 0 )
      break;
    if ( v3 >= *(_WORD *)(v1 + 10) )
    {
      sub_100A63B0(a1, "element name too long %s\n", *(_DWORD *)(v1 + 4));
      result = v25;
      *(_DWORD *)(v1 + 116) = v25;
      *(_DWORD *)(v1 + 120) = v24;
      return result;
    }
    *(_BYTE *)(v3++ + *(_DWORD *)(v1 + 4)) = v4;
    if ( v3 == 3 )
    {
      v5 = *(const char **)(v1 + 4);
      if ( *v5 == 33 && !strncmp(v5, "!--", 3u) )
      {
        if ( !*(_BYTE *)v1 )
          goto LABEL_17;
        result = v25;
        *(_BYTE *)(v1 + 1) |= 2u;
        *(_BYTE *)v1 = 1;
        *(_DWORD *)(v1 + 116) = v25;
        *(_DWORD *)(v1 + 120) = v24;
        return result;
      }
    }
    if ( !v24 )
      goto LABEL_16;
  }
  v7 = *(_DWORD *)(v1 + 100);
  if ( v3 <= 1 || **(_BYTE **)(v1 + 4) != 47 )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 96) + 4 * v7) = sub_100A66F0(a1, v3, *(void **)(v1 + 4));
    if ( !*(_DWORD *)(*(_DWORD *)(v1 + 96) + 4 * v7) )
      sub_100A63B0(a1, "out of memory while pushing element name %s\n", *(_DWORD *)(v1 + 4));
    if ( !v3 )
    {
      sub_100A63B0(a1, "expected nonwhitespace after '<' %s\n", v25 - 1);
      result = v25;
      *(_DWORD *)(v1 + 116) = v25;
      *(_DWORD *)(v1 + 120) = v24;
      return result;
    }
    v22 = (const char **)(*(_DWORD *)(v1 + 96) + 4 * v7);
    if ( *v22 && sub_100A65F0(strlen(*v22), *v22) )
    {
      ++v24;
      --v25;
      if ( *(_BYTE *)v1 )
      {
        result = v25;
        *(_BYTE *)(v1 + 1) |= 2u;
        *(_BYTE *)v1 = 2;
        *(_DWORD *)(v1 + 116) = v25;
        *(_DWORD *)(v1 + 120) = v24;
        return result;
      }
    }
    else
    {
      v23 = **(_BYTE **)(v1 + 4);
      if ( v23 != 33 && v23 != 63 )
      {
        sub_100A63B0(a1, "invalid element name %s\n", *(_DWORD *)(*(_DWORD *)(v1 + 96) + 4 * v7));
        result = v25;
        *(_DWORD *)(v1 + 116) = v25;
        *(_DWORD *)(v1 + 120) = v24;
        return result;
      }
      if ( *(_BYTE *)v1 )
      {
        result = v25;
        *(_BYTE *)(v1 + 1) |= 2u;
        *(_BYTE *)v1 = 5;
        *(_DWORD *)(v1 + 116) = v25;
        *(_DWORD *)(v1 + 120) = v24;
        return result;
      }
    }
LABEL_17:
    result = v25;
    *(_DWORD *)(v1 + 116) = v25;
    *(_DWORD *)(v1 + 120) = v24;
    return result;
  }
  if ( v7 <= 0 )
  {
    sub_100A63B0(a1, "wrong closing element %s\n", *(_DWORD *)(v1 + 4));
    result = v25;
    *(_DWORD *)(v1 + 116) = v25;
    *(_DWORD *)(v1 + 120) = v24;
    return result;
  }
  while ( v3 > 0 && isspace(*(_BYTE *)(*(_DWORD *)(v1 + 4) + v3 - 1)) )
    --v3;
  v8 = *(const char **)(*(_DWORD *)(v1 + 96) + 4 * v7 - 4);
  if ( strlen(v8) != v3 - 1 )
  {
LABEL_45:
    sub_100A63B0(a1, "wrong closing element %s expected %s\n", *(_DWORD *)(v1 + 4), v8);
    result = v25;
    *(_DWORD *)(v1 + 116) = v25;
    *(_DWORD *)(v1 + 120) = v24;
    return result;
  }
  v9 = v3 - 1;
  v10 = (_DWORD *)(*(_DWORD *)(v1 + 4) + 1);
  v11 = v8;
  if ( (unsigned int)(v3 - 1) < 4 )
  {
LABEL_31:
    if ( !v9 )
    {
LABEL_41:
      v21 = 0;
      goto LABEL_42;
    }
  }
  else
  {
    while ( *v10 == *(_DWORD *)v11 )
    {
      v9 -= 4;
      v11 += 4;
      ++v10;
      if ( v9 < 4 )
        goto LABEL_31;
    }
  }
  v12 = *(_BYTE *)v10 - *v11;
  if ( *(_BYTE *)v10 == *v11 )
  {
    v13 = v9 - 1;
    v14 = v11 + 1;
    v15 = (char *)v10 + 1;
    if ( !v13 )
      goto LABEL_41;
    v12 = *v15 - *v14;
    if ( *v15 == *v14 )
    {
      v16 = v13 - 1;
      v17 = v14 + 1;
      v18 = v15 + 1;
      if ( !v16 )
        goto LABEL_41;
      v12 = *v18 - *v17;
      if ( *v18 == *v17 )
      {
        v19 = v17 + 1;
        v20 = v18 + 1;
        if ( v16 == 1 )
          goto LABEL_41;
        v12 = *v20 - *v19;
        if ( *v20 == *v19 )
          goto LABEL_41;
      }
    }
  }
  v21 = 1;
  if ( v12 <= 0 )
    v21 = -1;
LABEL_42:
  if ( v21 )
    goto LABEL_45;
  sub_100A68A0(a1);
  if ( !*(_BYTE *)v1 )
    goto LABEL_17;
  result = v25;
  *(_BYTE *)(v1 + 1) |= 2u;
  *(_BYTE *)v1 = 4;
  *(_DWORD *)(v1 + 116) = v25;
  *(_DWORD *)(v1 + 120) = v24;
  return result;
}

//----- (100A6FB0) --------------------------------------------------------
signed int __cdecl sub_100A6FB0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1
  signed int result; // eax@13

  v4 = *(_DWORD *)(a1 + 12);
  if ( a4 )
    *(_BYTE *)(v4 + 1) |= 1u;
  *(_DWORD *)(v4 + 116) = a2;
  *(_DWORD *)(v4 + 120) = a3;
  while ( *(_DWORD *)(v4 + 120) > 0 )
  {
    switch ( *(_BYTE *)v4 )
    {
      case 2:
        sub_100A68D0(a1);
        break;
      case 3:
        sub_100A6BC0(a1);
        break;
      case 4:
        sub_100A6400(a1);
        break;
      case 1:
        sub_100A6530(a1);
        break;
      case 5:
        sub_100A6740(a1);
        break;
      case 0:
        *(_DWORD *)(v4 + 120) = 0;
        break;
      default:
        *(_BYTE *)v4 = 0;
        break;
    }
  }
  result = 0;
  if ( !*(_BYTE *)v4 || a4 && (*(_BYTE *)v4 != 4 || *(_DWORD *)(v4 + 100)) )
    result = 1;
  return result;
}

//----- (100A7070) --------------------------------------------------------
unsigned int __cdecl sub_100A7070(unsigned __int8 a1, unsigned int a2)
{
  return dword_10151670[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 10151670: using guessed type int dword_10151670[];

//----- (100A7090) --------------------------------------------------------
unsigned int __cdecl sub_100A7090(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_10151670[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_10151670[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_10151670[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_10151670[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_10151670[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_10151670[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_10151670[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_10151670[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_10151670[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_10151670[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 10151670: using guessed type int dword_10151670[];

//----- (100A71C0) --------------------------------------------------------
double __cdecl sub_100A71C0(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (100A7220) --------------------------------------------------------
double __cdecl sub_100A7220(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (100A72A0) --------------------------------------------------------
void __cdecl sub_100A72A0(double a1)
{
  sub_100A71C0(a1, 3.1415926535898);
}

//----- (100A72C0) --------------------------------------------------------
double __cdecl sub_100A72C0(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_100A7220(a1, 3.1415927);
  return result;
}

//----- (100A7300) --------------------------------------------------------
int __cdecl sub_100A7300(double a1)
{
  int result; // eax@2

  if ( a1 >= 0.0 )
    result = (signed int)(a1 + 0.5);
  else
    result = (signed int)(a1 - 0.5);
  return result;
}

//----- (100A7330) --------------------------------------------------------
int __cdecl sub_100A7330(signed int a1, signed int a2)
{
  int result; // eax@2
  signed int v3; // [sp+4h] [bp-4h]@4

  if ( a2 > 0 )
  {
    if ( a1 >= 0 )
      v3 = a2;
    else
      v3 = -a2;
    result = a2 * (signed int)(((double)v3 * 0.5 + (double)a1) / (double)a2);
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100A7380) --------------------------------------------------------
double __cdecl sub_100A7380(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100A73F0) --------------------------------------------------------
int __cdecl sub_100A73F0(float a1)
{
  int result; // eax@2

  if ( a1 <= 0.0 )
  {
    if ( a1 >= 0.0 )
      result = 0;
    else
      result = -1;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100A7420) --------------------------------------------------------
double __cdecl sub_100A7420(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_100A72C0(v4);
    }
    result = v3;
  }
  return result;
}

//----- (100AA9F8) --------------------------------------------------------
int __cdecl sub_100AA9F8(int a1, int a2, char a3)
{
  return vscan_fn(sub_100B49FA, a2, 0, &a3);
}
// 100AA990: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100AC0E6) --------------------------------------------------------
int __cdecl sub_100AC0E6(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno_0(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_100AF844() + 8 && (void **)v2 != sub_100AF844() + 16 || !sub_100B7746((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_10163CC8;
      else
        v9 = (_BYTE *)(dword_1068C620[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_100B7626((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_100B7626((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 100B7702: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100ACC7B) --------------------------------------------------------
int __cdecl sub_100ACC7B(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10658694 = a1;
  return result;
}
// 10658694: using guessed type int dword_10658694;

//----- (100AE330) --------------------------------------------------------
signed int __cdecl sub_100AE330(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_106586F0 )
  {
    *a1 = dword_106586F0;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106586F0: using guessed type int dword_106586F0;

//----- (100AE367) --------------------------------------------------------
signed int __cdecl sub_100AE367(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_106586F0 )
  {
    *a1 = dword_106586FC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106586F0: using guessed type int dword_106586F0;
// 106586FC: using guessed type int dword_106586FC;

//----- (100AE988) --------------------------------------------------------
void sub_100AE988()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_1068C620;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_1068C720 );
}
// 1068C620: using guessed type int dword_1068C620[];
// 1068C720: using guessed type int dword_1068C720;

//----- (100AEE35) --------------------------------------------------------
int (*sub_100AEE35())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_1015F960;
  v1 = (int (**)(void))&unk_1015F960;
  if ( &unk_1015F960 < &unk_1015F960 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_1015F960 );
  }
  return result;
}

//----- (100AEE59) --------------------------------------------------------
void __cdecl sub_100AEE59()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_1015F968;
  if ( &unk_1015F968 < &unk_1015F968 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_1015F968 );
  }
}

//----- (100AF6A9) --------------------------------------------------------
int sub_100AF6A9()
{
  return flsall(1);
}
// 100AF57C: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (100AF844) --------------------------------------------------------
void **sub_100AF844()
{
  return &off_10163D98;
}
// 10163D98: using guessed type void *off_10163D98;

//----- (100AF84A) --------------------------------------------------------
signed int sub_100AF84A()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_1068C600;
  if ( !dword_1068C600 )
  {
    v0 = 512;
LABEL_5:
    dword_1068C600 = v0;
    goto LABEL_6;
  }
  if ( dword_1068C600 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_1068B5EC = v1;
  if ( v1 || (dword_1068C600 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_1068B5EC = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_10163D98;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&byte_10164018 )
        break;
      v1 = dword_1068B5EC;
    }
    v5 = 0;
    v6 = &unk_10163DA8;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_1068C620[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_10163E08 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 100AE651: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 10163D98: using guessed type void *off_10163D98;
// 10164018: using guessed type char byte_10164018;
// 1068C600: using guessed type int dword_1068C600;
// 1068C620: using guessed type int dword_1068C620[];

//----- (100AFB25) --------------------------------------------------------
int sub_100AFB25()
{
  return _decode_pointer(dword_10658854);
}
// 100AD84B: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10658854: using guessed type int dword_10658854;

//----- (100AFCE2) --------------------------------------------------------
int __cdecl sub_100AFCE2(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_10658860 )
  {
    v3 = LoadLibraryW(L"USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxW");
    if ( !v5 )
      return 0;
    dword_10658860 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_10658864 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_10658868 = _encode_pointer(v7);
    if ( sub_100AE330(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationW");
      dword_10658870 = _encode_pointer(v8);
      if ( dword_10658870 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_1065886C = _encode_pointer(v9);
      }
    }
  }
  if ( dword_1065886C == v23
    || dword_10658870 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_1065886C),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_10658870),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_10658864 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_10658864);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_10658868 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_10658868);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_100AE367(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_10658860);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 100ACC85: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AD7D4: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 100AD842: using guessed type int _encoded_null(void);
// 100AD84B: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10658860: using guessed type int dword_10658860;
// 10658864: using guessed type int dword_10658864;
// 10658868: using guessed type int dword_10658868;
// 1065886C: using guessed type int dword_1065886C;
// 10658870: using guessed type int dword_10658870;

//----- (100B16B4) --------------------------------------------------------
#error "100B16B9: positive sp value has been found (funcsize=0)"

//----- (100B16BF) --------------------------------------------------------
#error "100B16C4: positive sp value has been found (funcsize=0)"

//----- (100B16CA) --------------------------------------------------------
#error "100B16CF: positive sp value has been found (funcsize=0)"

//----- (100B16D0) --------------------------------------------------------
#error "100B16D5: positive sp value has been found (funcsize=0)"

//----- (100B16D6) --------------------------------------------------------
#error "100B16DB: positive sp value has been found (funcsize=0)"

//----- (100B16DC) --------------------------------------------------------
#error "100B16E1: positive sp value has been found (funcsize=0)"

//----- (100B16E2) --------------------------------------------------------
#error "100B16FD: positive sp value has been found (funcsize=0)"

//----- (100B1703) --------------------------------------------------------
#error "100B1718: positive sp value has been found (funcsize=0)"

//----- (100B171E) --------------------------------------------------------
#error "100B1739: positive sp value has been found (funcsize=0)"

//----- (100B173A) --------------------------------------------------------
#error "100B1749: positive sp value has been found (funcsize=0)"

//----- (100B174A) --------------------------------------------------------
#error "100B175D: positive sp value has been found (funcsize=0)"

//----- (100B175E) --------------------------------------------------------
#error "100B176D: positive sp value has been found (funcsize=0)"

//----- (100B176E) --------------------------------------------------------
#error "100B178D: positive sp value has been found (funcsize=0)"

//----- (100B1793) --------------------------------------------------------
#error "100B17AC: positive sp value has been found (funcsize=0)"

//----- (100B17B2) --------------------------------------------------------
#error "100B17D1: positive sp value has been found (funcsize=0)"

//----- (100B17D2) --------------------------------------------------------
#error "100B17E5: positive sp value has been found (funcsize=0)"

//----- (100B17E6) --------------------------------------------------------
#error "100B17FD: positive sp value has been found (funcsize=0)"

//----- (100B17FE) --------------------------------------------------------
#error "100B1811: positive sp value has been found (funcsize=0)"

//----- (100B1812) --------------------------------------------------------
#error "100B1831: positive sp value has been found (funcsize=0)"

//----- (100B1837) --------------------------------------------------------
#error "100B1850: positive sp value has been found (funcsize=0)"

//----- (100B1856) --------------------------------------------------------
#error "100B1875: positive sp value has been found (funcsize=0)"

//----- (100B1876) --------------------------------------------------------
#error "100B1889: positive sp value has been found (funcsize=0)"

//----- (100B188A) --------------------------------------------------------
#error "100B18A1: positive sp value has been found (funcsize=0)"

//----- (100B18A2) --------------------------------------------------------
#error "100B18B5: positive sp value has been found (funcsize=0)"

//----- (100B18B6) --------------------------------------------------------
#error "100B18D5: positive sp value has been found (funcsize=0)"

//----- (100B18DB) --------------------------------------------------------
#error "100B18F4: positive sp value has been found (funcsize=0)"

//----- (100B18FA) --------------------------------------------------------
#error "100B1919: positive sp value has been found (funcsize=0)"

//----- (100B191A) --------------------------------------------------------
#error "100B192D: positive sp value has been found (funcsize=0)"

//----- (100B192E) --------------------------------------------------------
#error "100B1945: positive sp value has been found (funcsize=0)"

//----- (100B1946) --------------------------------------------------------
#error "100B1959: positive sp value has been found (funcsize=0)"

//----- (100B195A) --------------------------------------------------------
#error "100B1979: positive sp value has been found (funcsize=0)"

//----- (100B197F) --------------------------------------------------------
#error "100B1998: positive sp value has been found (funcsize=0)"

//----- (100B199E) --------------------------------------------------------
#error "100B19BD: positive sp value has been found (funcsize=0)"

//----- (100B19BE) --------------------------------------------------------
#error "100B19D1: positive sp value has been found (funcsize=0)"

//----- (100B19D2) --------------------------------------------------------
#error "100B19E9: positive sp value has been found (funcsize=0)"

//----- (100B19EA) --------------------------------------------------------
#error "100B19FD: positive sp value has been found (funcsize=0)"

//----- (100B19FE) --------------------------------------------------------
#error "100B1A1D: positive sp value has been found (funcsize=0)"

//----- (100B1A23) --------------------------------------------------------
#error "100B1A3C: positive sp value has been found (funcsize=0)"

//----- (100B1A42) --------------------------------------------------------
#error "100B1A61: positive sp value has been found (funcsize=0)"

//----- (100B1A62) --------------------------------------------------------
#error "100B1A75: positive sp value has been found (funcsize=0)"

//----- (100B1A76) --------------------------------------------------------
#error "100B1A8D: positive sp value has been found (funcsize=0)"

//----- (100B1A8E) --------------------------------------------------------
#error "100B1AA1: positive sp value has been found (funcsize=0)"

//----- (100B1AA2) --------------------------------------------------------
#error "100B1AC1: positive sp value has been found (funcsize=0)"

//----- (100B1AC7) --------------------------------------------------------
#error "100B1AE0: positive sp value has been found (funcsize=0)"

//----- (100B1AE6) --------------------------------------------------------
#error "100B1B05: positive sp value has been found (funcsize=0)"

//----- (100B1B06) --------------------------------------------------------
#error "100B1B19: positive sp value has been found (funcsize=0)"

//----- (100B1B1A) --------------------------------------------------------
#error "100B1B31: positive sp value has been found (funcsize=0)"

//----- (100B1B32) --------------------------------------------------------
#error "100B1B45: positive sp value has been found (funcsize=0)"

//----- (100B49FA) --------------------------------------------------------
int __cdecl sub_100B49FA(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno_0(a1) == -1 || _fileno_0(a1) == -2 )
  {
    v7 = &unk_10163CC8;
  }
  else
  {
    v6 = &dword_1068C620[_fileno_0(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno_0(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno_0(a1) == -1 || _fileno_0(a1) == -2 ? (v9 = &unk_10163CC8) : (v8 = &dword_1068C620[_fileno_0(a1) >> 5],
                                                                             v9 = (_BYTE *)(*v8
                                                                                          + ((_fileno_0(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_100BBE92(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_100BBE92(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_100BBE92(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_100BBE92(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_100BBE92(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_1016368C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_100BBE92(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_100BBE92(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_100BBE92(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_100BBE92(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AD84B: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 100B49BF: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 100B49D5: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 1016368C: using guessed type int (*off_1016368C[3])();
// 1068C620: using guessed type int dword_1068C620[];
// 100B49FA: using guessed type char var_24[11];

//----- (100B6965) --------------------------------------------------------
void sub_100B6965()
{
  dword_1068B5E4 = 0;
}
// 1068B5E4: using guessed type int dword_1068B5E4;

//----- (100B6A1D) --------------------------------------------------------
int sub_100B6A1D()
{
  dword_1068C738 = _get_sse2_info();
  return 0;
}
// 100B69BD: using guessed type int _get_sse2_info(void);
// 1068C738: using guessed type int dword_1068C738;

//----- (100B6A2A) --------------------------------------------------------
int __cdecl sub_100B6A2A(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_100BB122((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 100B42AB: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100B6AD0) --------------------------------------------------------
int __cdecl sub_100B6AD0(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_100BB664((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 100B42AB: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100B6E68) --------------------------------------------------------
signed int __cdecl sub_100B6E68(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_100BCAB5(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_1068C620[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 100AAF91: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100B7004) --------------------------------------------------------
_WORD *__cdecl sub_100B7004(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  char v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_1068C620[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_1068C620[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_100B6E68(a1, 0, 0, 2u);
  if ( sub_100B7746(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 100AAF91: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100ADA67: using guessed type int _getptd(void);
// 1068C620: using guessed type int dword_1068C620[];
// 100B7004: using guessed type CHAR var_410[688];

//----- (100B7626) --------------------------------------------------------
_WORD *__cdecl sub_100B7626(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_1068C620[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_100B7004(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_100BCBC6(a1);
  return v6;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100BCB26: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100B7746) --------------------------------------------------------
int __cdecl sub_100B7746(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_1068C620[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100B8725) --------------------------------------------------------
int __cdecl sub_100B8725(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10658CF0 = a1;
  return result;
}
// 10658CF0: using guessed type int dword_10658CF0;

//----- (100B872F) --------------------------------------------------------
int __cdecl sub_100B872F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10658CFC = a1;
  return result;
}
// 10658CFC: using guessed type int dword_10658CFC;

//----- (100B8739) --------------------------------------------------------
int __cdecl sub_100B8739(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10658D00 = a1;
  return result;
}
// 10658D00: using guessed type int dword_10658D00;

//----- (100B8818) --------------------------------------------------------
int __cdecl sub_100B8818(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10658D04 = a1;
  return result;
}
// 10658D04: using guessed type int dword_10658D04;

//----- (100BA3BD) --------------------------------------------------------
int __cdecl sub_100BA3BD(FILE *a1, int a2, int a3)
{
  int result; // eax@2
  int *v4; // edi@7
  _BYTE *v5; // eax@7
  int *v6; // edi@12
  _BYTE *v7; // eax@12
  int v8; // edi@17
  int v9; // [sp+10h] [bp-1Ch]@1

  v9 = 0;
  if ( a1 == 0 || a2 == 0 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  else
  {
    _lock_file(a1);
    if ( !(a1->_flag & 0x40) )
    {
      if ( _fileno_0(a1) == -1 || _fileno_0(a1) == -2 )
      {
        v5 = &unk_10163CC8;
      }
      else
      {
        v4 = &dword_1068C620[_fileno_0(a1) >> 5];
        v5 = (_BYTE *)(*v4 + ((_fileno_0(a1) & 0x1F) << 6));
      }
      if ( v5[36] & 0x7F
        || (_fileno_0(a1) == -1 || _fileno_0(a1) == -2 ? (v7 = &unk_10163CC8) : (v6 = &dword_1068C620[_fileno_0(a1) >> 5],
                                                                                 v7 = (_BYTE *)(*v6
                                                                                              + ((_fileno_0(a1) & 0x1F) << 6))),
            v7[36] & 0x80) )
      {
        *_errno() = 22;
        _invalid_parameter(0, 0, 0, 0, 0);
        v9 = -1;
      }
    }
    if ( !v9 )
    {
      v8 = _stbuf(a1);
      v9 = _output_l((int)a1, a2, 0, (int)&a3);
      _ftbuf(v8, a1);
    }
    _unlock_file(a1);
    result = v9;
  }
  return result;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AF91B: using guessed type _DWORD __cdecl _lock_file(_DWORD);
// 100AF985: using guessed type _DWORD __cdecl _unlock_file(_DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100BA50C) --------------------------------------------------------
int __cdecl sub_100BA50C(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_10658D14 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_10658D14 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_10658D18 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_10658D1C = _encode_pointer(v7);
    if ( sub_100AE330(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_10658D24 = _encode_pointer(v8);
      if ( dword_10658D24 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_10658D20 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_10658D20 == v23
    || dword_10658D24 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_10658D20),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_10658D24),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_10658D18 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_10658D18);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_10658D1C != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_10658D1C);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_100AE367(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_10658D14);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 100ACC85: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AD7D4: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 100AD842: using guessed type int _encoded_null(void);
// 100AD84B: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10658D14: using guessed type int dword_10658D14;
// 10658D18: using guessed type int dword_10658D18;
// 10658D1C: using guessed type int dword_10658D1C;
// 10658D20: using guessed type int dword_10658D20;
// 10658D24: using guessed type int dword_10658D24;

//----- (100BA802) --------------------------------------------------------
int sub_100BA802()
{
  return 0;
}

//----- (100BB122) --------------------------------------------------------
signed int __cdecl sub_100BB122(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_101646C8 - 1;
    v64 = v3;
    v65 = dword_101646C8 / 32;
    v9 = dword_101646C8 % 32;
    v10 = (int *)(&v60 + dword_101646C8 / 32);
    v66 = 31 - dword_101646C8 % 32;
    if ( (1 << (31 - dword_101646C8 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_101646C4 - dword_101646C8 )
    {
      if ( v3 > dword_101646C4 )
      {
        if ( v3 < dword_101646C0 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_101646D4 + v3;
          v50 = dword_101646CC / 32;
          v51 = dword_101646CC % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_101646CC % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_101646CC / 32;
          v44 = dword_101646CC % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_101646CC % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_101646D4 + dword_101646C0;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_101646C4 - v64) / 32;
      v62 = v59;
      v18 = (dword_101646C4 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_101646C8 - 1;
      v25 = dword_101646C8 / 32;
      v65 = dword_101646C8 / 32;
      v26 = (int *)(&v60 + dword_101646C8 / 32);
      v64 = 31 - dword_101646C8 % 32;
      if ( (1 << (31 - dword_101646C8 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_101646C8 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_101646CC + 1) / 32;
      v37 = (dword_101646CC + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_101646CC));
  if ( dword_101646D0 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_101646D0 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 101646C0: using guessed type int dword_101646C0;
// 101646C4: using guessed type int dword_101646C4;
// 101646C8: using guessed type int dword_101646C8;
// 101646CC: using guessed type int dword_101646CC;
// 101646D0: using guessed type int dword_101646D0;
// 101646D4: using guessed type int dword_101646D4;

//----- (100BB664) --------------------------------------------------------
signed int __cdecl sub_100BB664(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_101646E0 - 1;
    v64 = v3;
    v65 = dword_101646E0 / 32;
    v9 = dword_101646E0 % 32;
    v10 = (int *)(&v60 + dword_101646E0 / 32);
    v66 = 31 - dword_101646E0 % 32;
    if ( (1 << (31 - dword_101646E0 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_101646DC - dword_101646E0 )
    {
      if ( v3 > dword_101646DC )
      {
        if ( v3 < dword_101646D8 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_101646EC + v3;
          v50 = dword_101646E4 / 32;
          v51 = dword_101646E4 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_101646E4 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_101646E4 / 32;
          v44 = dword_101646E4 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_101646E4 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_101646EC + dword_101646D8;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_101646DC - v64) / 32;
      v62 = v59;
      v18 = (dword_101646DC - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_101646E0 - 1;
      v25 = dword_101646E0 / 32;
      v65 = dword_101646E0 / 32;
      v26 = (int *)(&v60 + dword_101646E0 / 32);
      v64 = 31 - dword_101646E0 % 32;
      if ( (1 << (31 - dword_101646E0 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_101646E0 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_101646E4 + 1) / 32;
      v37 = (dword_101646E4 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_101646E4));
  if ( dword_101646E8 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_101646E8 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 101646D8: using guessed type int dword_101646D8;
// 101646DC: using guessed type int dword_101646DC;
// 101646E0: using guessed type int dword_101646E0;
// 101646E4: using guessed type int dword_101646E4;
// 101646E8: using guessed type int dword_101646E8;
// 101646EC: using guessed type int dword_101646EC;

//----- (100BBD72) --------------------------------------------------------
int __cdecl sub_100BBD72(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno_0(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno_0(a1) == -1 || _fileno_0(a1) == -2 )
    {
      v8 = &unk_10163CC8;
    }
    else
    {
      v7 = &dword_1068C620[_fileno_0(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno_0(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100B7702: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100BBE92) --------------------------------------------------------
int __cdecl sub_100BBE92(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno_0(a2) == -1 || _fileno_0(a2) == -2 )
    {
      v3 = &unk_10163CC8;
    }
    else
    {
      v2 = &dword_1068C620[_fileno_0(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno_0(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno_0(a2) == -1 || _fileno_0(a2) == -2 ? (v5 = &unk_10163CC8) : (v4 = &dword_1068C620[_fileno_0(a2) >> 5],
                                                                               v5 = (_BYTE *)(*v4
                                                                                            + ((_fileno_0(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100B7702: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100BCA34) --------------------------------------------------------
signed int __cdecl sub_100BCA34(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_1068C620[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_1065836C == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 1065836C: using guessed type int dword_1065836C;
// 1068C620: using guessed type int dword_1068C620[];

//----- (100BCAB5) --------------------------------------------------------
signed int __cdecl sub_100BCAB5(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_1068C620[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 100ACD81: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100BCBC6) --------------------------------------------------------
void __cdecl sub_100BCBC6(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_1068C620[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 1068C620: using guessed type int dword_1068C620[];

//----- (100BCE87) --------------------------------------------------------
wchar_t __cdecl sub_100BCE87(wchar_t WCh, FILE *a2)
{
  int *v2; // ebx@4
  _BYTE *v3; // eax@4
  int *v4; // ebx@9
  _BYTE *v5; // eax@9
  bool v6; // sf@12
  int v7; // eax@13
  wchar_t result; // ax@16
  int v9; // eax@18
  int *v10; // ebx@24
  _BYTE *v11; // eax@24
  int v12; // ebx@28
  int v13; // eax@30
  int SizeConverted; // [sp+Ch] [bp-10h]@27
  char MbCh[8]; // [sp+10h] [bp-Ch]@27

  if ( a2->_flag & 0x40 )
    goto LABEL_40;
  if ( _fileno_0(a2) == -1 || _fileno_0(a2) == -2 )
  {
    v3 = &unk_10163CC8;
  }
  else
  {
    v2 = &dword_1068C620[_fileno_0(a2) >> 5];
    v3 = (_BYTE *)(*v2 + ((_fileno_0(a2) & 0x1F) << 6));
  }
  if ( (v3[36] & 0x7F) == 2 )
    goto LABEL_40;
  if ( _fileno_0(a2) == -1 || _fileno_0(a2) == -2 )
  {
    v5 = &unk_10163CC8;
  }
  else
  {
    v4 = &dword_1068C620[_fileno_0(a2) >> 5];
    v5 = (_BYTE *)(*v4 + ((_fileno_0(a2) & 0x1F) << 6));
  }
  if ( (v5[36] & 0x7F) == 1 )
  {
    v6 = a2->_cnt-- - 1 < 0;
    if ( v6 )
    {
      v7 = sub_100AC0E6((char)WCh, a2);
    }
    else
    {
      *a2->_ptr = WCh;
      v7 = *a2->_ptr++;
    }
    if ( v7 != -1 )
    {
      v6 = a2->_cnt-- - 1 < 0;
      if ( v6 )
      {
        v9 = sub_100AC0E6(SHIBYTE(WCh), a2);
      }
      else
      {
        *a2->_ptr = HIBYTE(WCh);
        v9 = *a2->_ptr++;
      }
      if ( v9 != -1 )
        return WCh;
    }
    return -1;
  }
  if ( _fileno_0(a2) == -1 || _fileno_0(a2) == -2 )
  {
    v11 = &unk_10163CC8;
  }
  else
  {
    v10 = &dword_1068C620[_fileno_0(a2) >> 5];
    v11 = (_BYTE *)(*v10 + ((_fileno_0(a2) & 0x1F) << 6));
  }
  if ( !(v11[4] & 0x80) )
  {
LABEL_40:
    v6 = a2->_cnt - 2 < 0;
    a2->_cnt -= 2;
    if ( v6 )
    {
      result = sub_100BDD61(WCh, a2);
    }
    else
    {
      result = WCh;
      *(_WORD *)a2->_ptr = WCh;
      a2->_ptr += 2;
    }
  }
  else
  {
    if ( wctomb_s(&SizeConverted, MbCh, 5u, WCh) )
      return -1;
    v12 = 0;
    if ( SizeConverted > 0 )
    {
      do
      {
        v6 = a2->_cnt-- - 1 < 0;
        if ( v6 )
        {
          v13 = sub_100AC0E6(MbCh[v12], a2);
        }
        else
        {
          *a2->_ptr = MbCh[v12];
          v13 = *a2->_ptr++;
        }
        if ( v13 == -1 )
          return -1;
      }
      while ( ++v12 < SizeConverted );
    }
    result = WCh;
  }
  return result;
}
// 1068C620: using guessed type int dword_1068C620[];
// 100BCE87: using guessed type char MbCh[8];

//----- (100BDD61) --------------------------------------------------------
int __cdecl sub_100BDD61(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  int v5; // eax@10
  unsigned int v6; // eax@10
  int v7; // eax@16
  char *v8; // edi@16
  signed __int32 v9; // edi@16
  _BYTE *v10; // eax@21
  __int64 v11; // rax@24
  unsigned __int16 v12; // bx@25
  int v13; // [sp+4h] [bp-4h]@10
  int v14; // [sp+14h] [bp+Ch]@1

  v2 = a2;
  v14 = _fileno_0(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return 0xFFFF;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return 0xFFFF;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag;
  v2->_cnt = 0;
  v13 = 0;
  v6 = v5 & 0xFFFFFFEF | 2;
  v2->_flag = v6;
  if ( !(v6 & 0x10C) && ((void **)v2 != sub_100AF844() + 8 && (void **)v2 != sub_100AF844() + 16 || !sub_100B7746(v14)) )
    _getbuf(v2);
  if ( v2->_flag & 0x108 )
  {
    v7 = (int)v2->_base;
    v8 = v2->_ptr;
    v2->_ptr = (char *)(v7 + 2);
    v9 = (signed __int32)&v8[-v7];
    v2->_cnt = v2->_bufsiz - 2;
    if ( v9 <= 0 )
    {
      if ( v14 == -1 || v14 == -2 )
        v10 = &unk_10163CC8;
      else
        v10 = (_BYTE *)(dword_1068C620[v14 >> 5] + ((v14 & 0x1F) << 6));
      if ( v10[4] & 0x20 )
      {
        v11 = _lseeki64(v14, 0i64, 2);
        if ( (HIDWORD(v11) & (unsigned int)v11) == -1 )
          goto LABEL_28;
      }
    }
    else
    {
      v13 = (int)sub_100B7626(v14, v7, v9);
    }
    v12 = a1;
    *(_WORD *)v2->_base = a1;
  }
  else
  {
    v9 = 2;
    v12 = a1;
    LOWORD(v13) = a1;
    v13 = (int)sub_100B7626(v14, (int)&v13, 2u);
  }
  if ( v13 != v9 )
  {
LABEL_28:
    v2->_flag |= 0x20u;
    return 0xFFFF;
  }
  return v12;
}
// 100B7702: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1068C620: using guessed type int dword_1068C620[];

//----- (100BDED1) --------------------------------------------------------
signed int __cdecl sub_100BDED1(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_100BCAB5(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_1068C620[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_1068C620[0] + 68) & 1)
    && (v1 = sub_100BCAB5(2), sub_100BCAB5(1) == v1)
    || (v2 = (void *)sub_100BCAB5(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_100BCA34(a1);
  *(_BYTE *)(dword_1068C620[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100AAF91: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1068C620: using guessed type int dword_1068C620[];

#error "There were 52 decompilation failure(s) on 2615 function(s)"
